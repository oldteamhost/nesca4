#ifndef _HC_NET_SDK_H_
#define _HC_NET_SDK_H_

#ifndef _WINDOWS_
    #if (defined(_WIN32) || defined(_WIN64))
        #include <winsock2.h>
        #include <windows.h>    
    #endif
#endif

#if defined(_WIN64)
    #define OS_WINDOWS64    1
#endif

#if defined(__LP64__)
    #define OS_POSIX64    1 
#endif


#ifndef __PLAYRECT_defined
#define __PLAYRECT_defined
typedef struct __PLAYRECT
{
    int x;
    int y;
    int uWidth;
    int uHeight;
}PLAYRECT;
#endif

#if (defined(_WIN32)) //windows
#define NET_DVR_API  extern "C" __declspec(dllimport)
typedef  unsigned __int64   UINT64;
typedef  signed   __int64   INT64;
#elif defined(__linux__) || defined(__APPLE__) //linux
#define  BOOL  int
typedef  unsigned int       DWORD;
typedef  unsigned short     WORD;
typedef  unsigned short     USHORT;
typedef  short              SHORT;
typedef  int                LONG;
typedef  unsigned char      BYTE;
typedef  unsigned int       UINT;
typedef  void*              LPVOID;
typedef  void*              HANDLE;
typedef  unsigned int*      LPDWORD; 
typedef  unsigned long long UINT64;
typedef  signed long long   INT64;

#ifndef TRUE
#define TRUE  1
#endif
#ifndef FALSE
#define FALSE 0
#endif
#ifndef NULL
#define NULL 0
#endif

#define __stdcall 
#define CALLBACK  

#define NET_DVR_API extern "C"
typedef unsigned int   COLORKEY;
typedef unsigned int   COLORREF;

#ifndef __HWND_defined
#define __HWND_defined
#if defined(__APPLE__) || defined(ANDROID)
typedef void* HWND;
#elif defined(__linux__)
typedef unsigned int HWND;
#else
typedef void* HWND;
#endif
#endif

#ifndef __HDC_defined
#define __HDC_defined
#if defined(__linux__)
typedef struct __DC
{
    void*   surface;        //SDL Surface
    HWND    hWnd;           //HDC window handle
}DC;
typedef DC* HDC;
#else
typedef void* HDC;
#endif
#endif

typedef struct tagInitInfo
{
    int uWidth; 
    int uHeight; 
}INITINFO; 
#endif

//Macro definition 
#define MAX_NAMELEN                 16      //DVR's local Username
#define MAX_RIGHT                   32      //Authority permitted by Device (1- 12 for local authority,  13- 32 for remote authority) 
#define NAME_LEN                    32      //Username length
#define MIN_PASSWD_LEN              8       //min password length
#define PASSWD_LEN                  16      //Password length
#define STREAM_PASSWD_LEN           12      //stream password length
#define MAX_PASSWD_LEN_EX           64      //Password length 64 bit
#define GUID_LEN                    16      //GUID length
#define DEV_TYPE_NAME_LEN           24      //Device name length
#define SERIALNO_LEN                48      //SN length
#define MACADDR_LEN                 6       //Length of MAC address
#define MAC_ADDRESS_NUM             48      //MAC Address num
#define MAX_SENCE_NUM               16      //scene Num
#define RULE_REGION_MAX             128     //Rule Region num
#define MAX_ETHERNET                2       //Configurable Ethernet of device
#define MAX_NETWORK_CARD            4       //Configurable Network card of device
#define MAX_NETWORK_CARD_EX         12      //Configurable Extension Network card of device
#define PATHNAME_LEN                128     //length of path name
#define MAX_PRESET_V13              16      //Preset number
#define  MAX_TEST_COMMAND_NUM       32 
#define MAX_NUMBER_LEN              32      //number length
#define MAX_NAME_LEN                128     //device name length
#define MAX_INDEX_LED               8       //LED Index 2013-11-19
#define    MAX_CUSTOM_DIR           64      //Custom Dir Max Length
#define URL_LEN_V40                 256     //max URL Length
#define CLOUD_NAME_LEN              48      //Cloud storage server username length
#define CLOUD_PASSWD_LEN            48      //Cloud storage server Password length
#define MAX_SENSORNAME_LEN          64      //Sensor Name Len
#define MAX_SENSORCHAN_LEN          32      //Sensor Channel Len
#define MAX_DESCRIPTION_LEN         32      //Description Len
#define MAX_DEVNAME_LEN_EX          64      //Device Name Len
#define NET_SDK_MAX_FILE_PATH       256     //File path len 
#define MAX_TMEVOICE_LEN            64      //TME Voice Len
#define ISO_8601_LEN                32      //ISO 8601 time Length
#define MODULE_INFO_LEN             32 
#define VERSION_INFO_LEN            32

#define MAX_NUM_INPUT_BOARD         512     //the maximum number of input board
#define  MAX_SHIPSDETE_REGION_NUM    8      // Ship detection area maximum number list

#define MAX_RES_NUM_ONE_VS_INPUT_CHAN 8
#define MAX_VS_INPUT_CHAN_NUM        16

#define NET_SDK_MAX_FDID_LEN         256    //face lib id length
#define NET_SDK_MAX_PICID_LEN        256    //face picture id len
#define NET_SDK_FDPIC_CUSTOM_INFO_LEN 96    //face lib custom info len
#define NET_DVR_MAX_FACE_ANALYSIS_NUM 32    //max face analysis num
#define NET_DVR_MAX_FACE_SEARCH_NUM   5     //manx face search number
#define NET_SDK_SECRETKEY_LEN        128    //config file secret key len
#define NET_SDK_CUSTOM_LEN           512    //Maximum length of custom information
#define NET_SDK_CHECK_CODE_LEN       128    //Check length
#define RELATIVE_CHANNEL_LEN          2     //num of relative channels associated with alarm
#define NET_SDK_MAX_CALLEDTARGET_NAME 32    //called target name
#define NET_SDK_MAX_HBDID_LEN        256    //human lib id length
//led controler
#define  MAX_LEN_TEXT_CONTENT        128
#define  MAX_NUM_INPUT_SOURCE_TEXT    32
#define  MAX_NUM_OUTPUT_CHANNEL      512

#define MAX_LEN_OSD_CONTENT  256
#define MAX_NUM_OSD_ONE_SUBWND  8
#define MAX_NUM_SPLIT_WND  64
#define MAX_NUM_OSD 8

//2013-11-19
#define MAX_DEVNAME_LEN               32     //Device Name
#define MAX_LED_INFO                 256     //The screen font display information
#define MAX_TIME_LEN                  32     //Time Max Len
#define MAX_CARD_LEN                  24     //Card Max Len
#define MAX_OPERATORNAME_LEN          32     //OperatorName Max Len

#define THERMOMETRY_ALARMRULE_NUM   40      //Thermometry Alarm rule Number
#define MAX_THERMOMETRY_REGION_NUM  40      //Thermometry Region Num
#define MAX_THERMOMETRY_DIFFCOMPARISON_NUM  40 //Thermometry Temperature difference Num
#define MAX_SHIPS_NUM               20      //Ships Num
#define MAX_SHIPIMAGE_NUM           6       //Ships capture images num
#define KEY_WORD_NUM                3       //key word number
#define KEY_WORD_LEN               128      //key word length
#define ASYN_LOGIN_SUCC                1        
#define ASYN_LOGIN_FAILED            0    

#define NET_SDK_MAX_VERIFICATION_CODE_LEN  32        //verification Code Max Len
#define NET_SDK_MAX_OPERATE_CODE_LEN  64        //operate code max len
#define MAX_TIMESEGMENT_V30            8       //Maximum number of time segments in 9000 DVR's guard schedule
#define MAX_TIMESEGMENT                4       //Maximum number of time segments in 8000 DVR's guard schedule
#define MAX_SHELTERNUM                4       //Maximum number of mask areas in 8000 DVR
#define MAX_DAYS                    7       //The number of days in a week
#define MAX_ACCESSORY_CARD         256      //The maximum length parts board information 
#define PHONENUMBER_LEN                32      //Maximum length of PPPOE number
#define MAX_ICR_NUM                 8       //ITC Maximum ICR Preset Point number
#define MAX_VEHICLEFLOW_INFO                       24       //ITC maximum vehicleflow info number
#define MAX_SHELTERNUM                4       //Maximum number of mask areas in 8000 DVR
#define MAX_DAYS                    7       //The number of days in a week
#define PHONENUMBER_LEN                32      //Maximum length of PPPOE number
#define CARD_READER_DESCRIPTION    32       //card reader description
#define MAX_FACE_NUM                2       //max face num
#define MAX_DOOR_CODE_LEN               8 //room code length
#define MAX_LOCK_CODE_LEN               8 //lock code length

#define MAX_DISKNUM_V30                33        //Maximum disk number in 9000 DVR,  including 16 internal SATA disks,  1 eSTAT disk and 16 NFS disks

#define NET_SDK_MAX_NET_USER_NUM        64    //net user

#define NET_SDK_DISK_LOCATION_LEN  16      //Hard disk location length 
#define NET_SDK_SUPPLIER_NAME_LEN  32      //Supplier name length 
#define NET_SDK_DISK_MODEL_LEN     64      //Drive model length 
#define NET_SDK_MAX_DISK_VOLUME    33      //The largest hard disk volume number 
#define NET_SDK_DISK_VOLUME_LEN    36      //Hard disk volume name length

#define MAX_DISKNUM                    16      //Maximum disk number in 8000 DVR
#define MAX_DISKNUM_V10                8       //used in 1.2 or earlier version

#define MAX_WINDOW_V30                32      //9000 maximum number of local display windows
#define MAX_WINDOW_V40                64      //Netra 2.3.1 extern
#define MAX_WINDOW                    16      //8000 maximum number of local display windows
#define MAX_VGA_V30                    4       //9000 maximum number of VGA
#define MAX_VGA                        1       //8000 maximum number of VGA

#define MAX_USERNUM_V30                32      //Maximum number of 9000 DVR users
#define MAX_USERNUM                    16      //Maximum number of 8000 DVR users
#define MAX_EXCEPTIONNUM_V30        32      //Maximum number of exceptions handled by 9000 DVR
#define MAX_EXCEPTIONNUM            16      //Maximum number of exceptions handled by 8000 DVR
#define MAX_LINK                    6       //Maximum number of video connections to 8000's single channel
#define MAX_ITC_EXCEPTIONOUT        32      //Maximun number of ITC exception Out
#define MAX_SCREEN_DISPLAY_LEN        512        //Screen characters in length 

#define MAX_DECPOOLNUM                4       //Maximum loop decoding number supported by each decoding channel of single channel decoder
#define MAX_DECNUM                    4       //Maximum decoding channel number of single channel decoder (only has one channel,  others are reserved) 
#define MAX_TRANSPARENTNUM            2       //Maximum number of Transparent channel in single channel decoder
#define MAX_CYCLE_CHAN                16      //Maximum number of loop channels in single channel decoder
#define MAX_CYCLE_CHAN_V30          64      //Maximum number of loop channels in single channel decoder (extend) 
#define MAX_DIRNAME_LENGTH            80      //Maximum number of directory name
#define MAX_WINDOWS                    16      //Maximum number of windows

#define MAX_STRINGNUM_V30            8        //Maximum number of OSD lines in 9000 DVR
#define MAX_STRINGNUM                4       //Maximum number of OSD lines in 8000 DVR
#define MAX_STRINGNUM_EX            8       //8000 customized extensions
#define MAX_AUXOUT_V30                16      //9000 maximum number of AUX output ports
#define MAX_AUXOUT                    4       //8000 maximum number of AUX output ports
#define MAX_HD_GROUP                16      //9000 maximum number of hard disk groups
#define MAX_HD_GROUP_V40            32      // maximum number of hard disk groups (256NVR)
#define MAX_NFS_DISK                8       //8000 maximum number of NFS disks

#define IW_ESSID_MAX_SIZE            32      //SSID length of WIFI
#define IW_ENCODING_TOKEN_MAX        32      //Maximum bytes of WIFI security Key
#define MAX_SERIAL_NUM                64        //Maximum number of Transparent channel
#define MAX_DDNS_NUMS                10      //Maximum number of DDNS in 9000
#define MAX_DOMAIN_NAME                64        //Maximum Domain Name length
#define MAX_EMAIL_ADDR_LEN            48        //Maximum Email Address length
#define MAX_EMAIL_PWD_LEN            32      //Maximum Email password length
#define MAX_SLAVECAMERA_NUM         8       //Maximum SlaveCamera Number
#define MAX_CALIB_NUM               6       //Maximum Calib Num 
#define MAX_CALIB_NUM_EX            20      //Maximum Calib Num Express   
#define MAX_LEDDISPLAYINFO_LEN      1024    //Maximum LedDisplayInfo Len
#define MAX_PEOPLE_DETECTION_NUM    8       //Maximum People Detection Region Number

#define MAXPROGRESS                    100     //Maximum percent while playing back
#define MAX_SERIALNUM                2       //Serial Port supported by 8000 DVR,  1- 232,  2- 485
#define CARDNUM_LEN                    20      //Card number length
#define PATIENTID_LEN              64
#define CARDNUM_LEN_OUT                32      //Card number length for outer
#define MAX_VIDEOOUT_V30            4       //9000 DVR analog video output number. 
#define MAX_VIDEOOUT                2       //8000 DVR analog video output number

#define MAX_PRESET_V30                256        // 9000 Preset number of PTZ  
#define MAX_TRACK_V30                256        // 9000 Track number of PTZ   
#define MAX_CRUISE_V30                256        // 9000 Cruise number of PTZ  
#define MAX_PRESET                    128        // 8000 Preset number of PTZ  
#define MAX_TRACK                    128        // 8000 Track number of PTZ   
#define MAX_CRUISE                    128        // 8000 Cruise number of PTZ  

#define MAX_PRESET_V40                300        /* PTZ Max Support Preset Num */
#define MAX_CRUISE_POINT_NUM        128     /* Max Support Cruise Point Num */
#define MAX_CRUISEPOINT_NUM_V50     256     //Max Support Cruise Point V50 Num 

#define CRUISE_MAX_PRESET_NUMS        32         // Maximum number of Cruise points in one Cruise 
#define MAX_FACE_PIC_NUM            30      //Face Pictrue Num
#define LOCKGATE_TIME_NUM           4       //Lock Gate Num

#define MAX_SERIAL_PORT             8       // Maximum number of RS232 supported by 9000 DVR
#define MAX_PREVIEW_MODE            8       // Maximum number of display layout mode;  single windows/4 windows/9 windows/16 windows/... 
#define MAX_MATRIXOUT               16      // Maximum number of analog matrix output 
#define LOG_INFO_LEN                11840   // Additional information of Log 
#define DESC_LEN                    16      // String length of PTZ description 
#define PTZ_PROTOCOL_NUM            200     // Maximum number of PTZ protocols in 9000 DVR 
#define IPC_PROTOCOL_NUM            50      // Maximum number of ipc protocols in 9000 DVR 

#define MAX_AUDIO                    1       //Number of talk channels in 8000 DVR
#define MAX_AUDIO_V30                2       //Number of talk channels in 9000 DVR
#define MAX_CHANNUM                    16      //Maximum number of video/audio channels in 8000 DVR
#define MAX_ALARMIN                    16      //Maximum number of alarm input channels in 8000 DVR
#define MAX_ALARMOUT                4       //Maximum number of alarm output channels in 8000 DVR
//9000 IP Camera
#define MAX_ANALOG_CHANNUM          32      //32 analog channels in total
#define MAX_ANALOG_ALARMOUT         32      //32 analog alarm output channels intotal
#define MAX_ANALOG_ALARMIN          32      //32 analog alarm input channels intotal
#define MAX_IP_DEVICE               32      //9000 DVR can connect 32 IP devices
#define MAX_IP_DEVICE_V40           64      //Maximum number of IP devices that can be added, the value is 64, including IVMS-2000
#define MAX_IP_CHANNEL              32      //9000 DVR can connect 32 IP channels
#define MAX_IP_ALARMIN              128     //Maximum number of alarm input channels that can be added
#define MAX_IP_ALARMOUT             64      //Maximum number of alarm output channels that can be added
#define MAX_IP_ALARMIN_V40          4096    //Maximum number of alarm input channels that can be added
#define MAX_IP_ALARMOUT_V40         4096    //Maximum number of alarm output channels that can be added

#define MAX_RECORD_FILE_NUM         20        //max file number for back , cd write or delete

//SDK_V31 ATM
#define MAX_ACTION_TYPE                12        //Maximum action number of the transactions added  
#define MAX_ATM_PROTOCOL_NUM        256     //Maximum protocol number of each input sort
#define ATM_CUSTOM_PROTO            1025    //user- defined protocol
#define ATM_PROTOCOL_SORT           4       //number of ATM protocol segment 
#define ATM_DESC_LEN                32      //Length of the ATM description string
// SDK_V31 ATM

/*Maximum channels number including analog channels and IP channels */
#define MAX_IPV6_LEN                  64      //MAX IPv6 Address Len
#define MAX_EVENTID_LEN             64      //MAX EventID Len

#define INVALID_VALUE_UINT32         0xffffffff   // Invalid Value
#define MAX_CHANNUM_V40             512
#define MAX_MULTI_AREA_NUM          24

#define MAX_SINGLE_FTPPICNAME_LEN       20 //The largest single FTP channel names 
#define MAX_CAMNAME_LEN                 32 //The channel name 
#define MAX_FTPNAME_NUM                 12 //Number of TFP name 


#define COURSE_NAME_LEN                32    
#define INSTRUCTOR_NAME_LEN            16    
#define COURSE_DESCRIPTION_LEN        256    
#define MAX_TIMESEGMENT_V40            16

#define MAX_MIX_CHAN_NUM        16        //max mixed channel number
#define MAX_LINE_IN_CHAN_NUM    16        //max line in channel number
#define MAX_MIC_CHAN_NUM        16        //max mic channel number
#define INQUEST_CASE_NO_LEN        64        //inquest case number length
#define INQUEST_CASE_NAME_LEN    64        //inquest case name length
#define CUSTOM_INFO_LEN            64        //custom information length
#define INQUEST_CASE_LEN        64        //inquest case information length

#define MAX_FILE_ID_LEN         128
#define MAX_PIC_NAME_LEN        128 //picture name len

#define MAX_CHANNUM_V30                ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL )   //64
#define MAX_ALARMOUT_V40             (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ALARMOUT_V30               ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT ) //96
#define MAX_ALARMIN_V30                ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN )   //160
#define MAX_ALARMIN_V40             (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ANALOG_ALARM_WITH_VOLT_LIMIT    16 //max analog alarm num with limited volt
#define NET_SDK_VERSION_LIST_LEN    64 //Algorithm library version Max

#define MAX_ROIDETECT_NUM           8
#define MAX_LANERECT_NUM            5       //Max Lane rect num
#define MAX_FORTIFY_NUM                10      //Max number of channels to be fortified
#define MAX_INTERVAL_NUM            4       //Max number of interval
#define MAX_CHJC_NUM                3       //Max number of chars short for province of car
#define MAX_VL_NUM                    5       //Max number of virtual lines
#define MAX_DRIVECHAN_NUM            16      //max number of drive channels
#define MAX_COIL_NUM                3       //max number of coils
#define MAX_SIGNALLIGHT_NUM            6       //max number of signal lights
#define LEN_16                        16
#define LEN_32                        32
#define LEN_64                        64
#define LEN_31                        31
#define	MAX_LINKAGE_CHAN_NUM          16  //max alarm linkage NVR channel number
#define MAX_CABINET_COUNT           8       //max number of cabinets
#define MAX_ID_LEN                  48
#define MAX_PARKNO_LEN              16
#define MAX_ALARMREASON_LEN         32 
#define MAX_UPGRADE_INFO_LEN        48
#define MAX_CUSTOMDIR_LEN           32      //max Lenth of custom Dir   
#define MAX_LED_INFO_LEN            512     //LED Info Len
#define MAX_VOICE_INFO_LEN          128     //Voice Info Len
#define MAX_LITLE_INFO_LEN          64      //Litle Info Len
#define MAX_CUSTOM_INFO_LEN         64      //Custom Info Len
#define MAX_PHONE_NUM_LEN           16      //Phone Num Len
#define MAX_APP_SERIALNUM_LEN       32      //App Serial Num Len

#define AUDIOTALKTYPE_G722            0
#define AUDIOTALKTYPE_G711_MU        1
#define AUDIOTALKTYPE_G711_A        2
#define AUDIOTALKTYPE_MP2L2         5
#define AUDIOTALKTYPE_G726            6
#define AUDIOTALKTYPE_AAC            7
#define AUDIOTALKTYPE_PCM             8
#define AUDIOTALKTYPE_G722C       9

//packet type
#define FILE_HEAD            0 //file head
#define VIDEO_I_FRAME        1 //video I frame
#define VIDEO_B_FRAME        2 //video B frame
#define VIDEO_P_FRAME        3 //video P frame
#define AUDIO_PACKET        10 //audio packet
#define PRIVT_PACKET        11 //private packet
//E frame
#define HIK_H264_E_FRAME    (1 << 6)



#define MAX_TRANSPARENT_CHAN_NUM    4        //max transparent channels for every serial channel
#define MAX_TRANSPARENT_ACCESS_NUM  4        //max host access number for every lisening port 

//ITS
#define MAX_PARKING_STATUS            8        //Park State: 0-no Car,1-Car,2-Press Line (highest priority), 3-Special Park Spaces 
#define MAX_PARKING_NUM                4        //A channel 4 largest parking Spaces (from left to right an array of 0 ~ 3) 

#define MAX_ITS_SCENE_NUM          16       //max ITS scene num
#define MAX_SCENE_TIMESEG_NUM      16       //max scene time segment num
#define MAX_IVMS_IP_CHANNEL        128      //max ip channels
#define DEVICE_ID_LEN              48       //device id len
#define MONITORSITE_ID_LEN         48       //monitor site id len
#define MAX_AUXAREA_NUM            16       //max auxiliary area num
#define MAX_SLAVE_CHANNEL_NUM      16       //max slave channel num
#define MAX_DEVDESC_LEN            64       //Device description information Len
#define MAX_SECRETKEY_LEN          512      //Secret Key Len
#define MAX_INDEX_CODE_LEN         64       //Index Code Len
#define MAX_ILLEGAL_LEN            64       //Illegal Len
#define ILLEGAL_LEN            32       //Illegal Len
#define CODE_LEN        64  //Authorization code
#define ALIAS_LEN       32  //Alias,read only
#define MAX_TRUCK_AXLE_NUM          10      //max truck axle
#define MAX_CATEGORY_LEN            8       //Max Category Len
#define SERIAL_NO_LEN               16      //Parking Serial NO length
//IPC
#define MAX_SCH_TASKS_NUM 10

#define MAX_SERVERID_LEN            64 //Max Server ID Len 
#define MAX_SERVERDOMAIN_LEN        128 //Max Server Domain Name Len 
#define MAX_AUTHENTICATEID_LEN      64 //Max Authenticate ID Len 
#define MAX_AUTHENTICATEPASSWD_LEN  32 //Max Authenticate Passwd Len 
#define MAX_SERVERNAME_LEN          64 //???????? 
#define MAX_COMPRESSIONID_LEN       64 //??ID?????
#define MAX_SIPSERVER_ADDRESS_LEN   128 //SIP??????????IP??
#define MAX_PlATE_NO_LEN         32   //Max Plate Number Len 2013-09-27
#define UPNP_PORT_NUM            12      //upnp port Number
#define MAX_NOTICE_NUMBER_LEN       32   //max notice number len
#define MAX_NOTICE_THEME_LEN        64   //max notice theme len
#define MAX_NOTICE_DETAIL_LEN       1024 //max notice detal len
#define MAX_NOTICE_PIC_NUM          6    //max notice pic num
#define MAX_DEV_NUMBER_LEN          32   //Max Device ID Len

#define HOLIDAY_GROUP_NAME_LEN          32  //holiday group name len
#define MAX_HOLIDAY_PLAN_NUM            16  //holiday max plan number
#define TEMPLATE_NAME_LEN               32  //plan template name len 
#define MAX_HOLIDAY_GROUP_NUM           16   //plan template max group number
#define DOOR_NAME_LEN                   32  //door name len 
#define STRESS_PASSWORD_LEN             8   //stress password len
#define SUPER_PASSWORD_LEN              8   //super password len
#define GROUP_NAME_LEN                  32  //group name len 
#define GROUP_COMBINATION_NUM           8   //group combination number 
#define MULTI_CARD_GROUP_NUM            4   //multi card group number 
#define ACS_CARD_NO_LEN                 32  //access card No. len
#define NET_SDK_EMPLOYEE_NO_LEN         32  //employee No. len
#define NET_SDK_UUID_LEN                36  //UUID len
#define NET_SDK_EHOME_KEY_LEN           32  //EHome Key Len
#define CARD_PASSWORD_LEN               8   // card password len 
#define MAX_DOOR_NUM                    32  //max door number
#define MAX_CARD_RIGHT_PLAN_NUM         4   //max card right plan number
#define MAX_GROUP_NUM_128               128 //The largest number of grou
#define MAX_CARD_READER_NUM             64  //max card reader number 
#define MAX_SNEAK_PATH_NODE             8   //max sneak path node number
#define MAX_MULTI_DOOR_INTERLOCK_GROUP  8   //max multi door interlock group 
#define MAX_INTER_LOCK_DOOR_NUM         8   //max inter lock door number
#define MAX_CASE_SENSOR_NUM             8   //max case sensor number
#define MAX_DOOR_NUM_256                256 //max door num
#define MAX_READER_ROUTE_NUM            16  //max reader route num
#define MAX_FINGER_PRINT_NUM            10  //max finger print num
#define MAX_CARD_READER_NUM_512            512 //max card reader num
#define NET_SDK_MULTI_CARD_GROUP_NUM_20     20   //multi card group num

#define ERROR_MSG_LEN                      32 

#define PER_RING_PORT_NUM                2   //the port number of the ring
#define SENSORNAME_LEN                  32  //Sensor Name Len
#define MAX_SENSORDESCR_LEN             64  //Sensor Description Len
#define MAX_DNS_SERVER_NUM              2   //DNS Server Num
#define SENSORUNIT_LEN                  32 //max unit word length

#define WEP_KEY_MAX_SIZE                32 //WEP Key Max Size
#define WEP_KEY_MAX_NUM                 4  //WEP Key Max Num
#define WPA_KEY_MAX_SIZE                64 //WPA Key Max Size

#define MAX_IDCODE_LEN                  128 //firmware code length
#define MAX_VERSIIN_LEN                 64  //max version length
#define MAX_IDCODE_NUM                  32  //max firmware code number
#define SDK_LEN_2048                    2048
#define SDK_MAX_IP_LEN 48

#define RECT_POINT_NUM                    4

#define MAX_PUBLIC_KEY_LEN 512 
#define CHIP_SERIALNO_LEN 32 
#define ENCRYPT_DEV_ID_LEN        20
#define MAX_SEARCH_ID_LEN               36
#define TERMINAL_NAME_LEN               64
#define MAX_URL_LEN                     512
#define REGISTER_NAME_LEN               64 

//optical fiber
#define MAX_PORT_NUM            64  //maximum port number
#define MAX_SINGLE_CARD_PORT_NO 4   //maximum port number of single card
#define MAX_FUNC_CARD_NUM       32  //maximum function card number
#define MAX_FC_CARD_NUM         33  //maximum card number
#define MAX_REMARKS_LEN         128 //port remarks length
#define NET_DEV_NAME_LEN        64  //The length of the device name 
#define NET_DEV_TYPE_NAME_LEN  64  //Device type name length
//LED
#define MAX_OUTPUT_PORT_NUM                32    //maximum output port number
#define MAX_SINGLE_PORT_RECVCARD_NUM    64    //maximum receive card number of single port
#define MAX_GAMMA_X_VALUE                256    //maximum x value number of GAMMA table

#define ABNORMAL_INFO_NUM               4   //abnormal info num

#define PLAYLIST_NAME_LEN                64            //play list name length
#define PLAYLIST_ITEM_NUM                64            //play item nummber

//NVR
#define NET_SDK_MAX_LOGIN_PASSWORD_LEN           128 //login password len
#define NET_SDK_MAX_ANSWER_LEN                   256 //security answer length
#define NET_SDK_MAX_QUESTION_LIST_LEN            32//security question list length
#define NET_SDK_MAX_THERMOMETRYALGNAME           128//Thermometry Algorithm library length
#define NET_SDK_MAX_SHIPSALGNAME                128//Ships Algorithm library length
#define NET_SDK_MAX_FIRESALGNAME                 128//Fire Algorithm library length

#define MAX_PASSPORT_NUM_LEN          16     //max passport number len
#define MAX_PASSPORT_INFO_LEN         128    //max generic info len
#define MAX_PASSPORT_NAME_LEN         64     //max name len
#define MAX_PASSPORT_MONITOR_LEN      1024   //max monitor info len
#define MAX_NATIONALITY_LEN           16     //max nationality len
#define MAX_PASSPORT_TYPE_LEN         4      //max type len

#define  MAX_SCREEN_AREA_NUM  128  //maximum number of screen area
#define  LOCK_NAME_LEN                   32 

//[add]by zengxiaole 2017-09-27 DS-19D2000-S v2.0
#define MAX_FIRE_ALARM_ZONE         12           //max fire alarm host zone
#define MAX_FIRE_ALARM_POINT_ZONE   32           //max fire alarm host point

/*******************Global Error Code**********************/
#define NET_DVR_NOERROR 					0	//No Error
#define NET_DVR_PASSWORD_ERROR 				1	//Username or Password error
#define NET_DVR_NOENOUGHPRI 				2	//Don't have enough authority 
#define NET_DVR_NOINIT 						3	//have not Initialized
#define NET_DVR_CHANNEL_ERROR 				4	//Channel number error
#define NET_DVR_OVER_MAXLINK 				5	//Number of clients connecting to DVR beyonds the Maximum
#define NET_DVR_VERSIONNOMATCH				6	//Version is not matched
#define NET_DVR_NETWORK_FAIL_CONNECT		7	//Connect to server failed
#define NET_DVR_NETWORK_SEND_ERROR			8	//Send data to server failed
#define NET_DVR_NETWORK_RECV_ERROR			9	//Receive data from server failed
#define NET_DVR_NETWORK_RECV_TIMEOUT		10	//Receive data from server timeout
#define NET_DVR_NETWORK_ERRORDATA			11	//Transferred data has error
#define NET_DVR_ORDER_ERROR					12	//Wrong Sequence of invoking API
#define NET_DVR_OPERNOPERMIT				13	//No such authority. 
#define NET_DVR_COMMANDTIMEOUT				14	//Execute command timeout
#define NET_DVR_ERRORSERIALPORT				15	//Serial port number error
#define NET_DVR_ERRORALARMPORT				16	//Alarm port error
#define NET_DVR_PARAMETER_ERROR 			17  //Parameters error
#define NET_DVR_CHAN_EXCEPTION				18	//Server channel in error status
#define NET_DVR_NODISK						19	//No hard disk
#define NET_DVR_ERRORDISKNUM				20	//Hard disk number error
#define NET_DVR_DISK_FULL					21	//Server's hard disk is full
#define NET_DVR_DISK_ERROR					22	//Server's hard disk error
#define NET_DVR_NOSUPPORT					23	//Server doesn't support
#define NET_DVR_BUSY						24	//Server is busy
#define NET_DVR_MODIFY_FAIL					25	//Server modification failed
#define NET_DVR_PASSWORD_FORMAT_ERROR		26	//Input format of Password error
#define NET_DVR_DISK_FORMATING				27	//Hard disk is formating,  cannot execute.  
#define NET_DVR_DVRNORESOURCE				28	//DVR don't have enough resource
#define	NET_DVR_DVROPRATEFAILED				29  //DVR Operation failed
#define NET_DVR_OPENHOSTSOUND_FAIL 			30  //Open PC audio failed
#define NET_DVR_DVRVOICEOPENED 				31  //Server's talk channel is occupied 
#define	NET_DVR_TIMEINPUTERROR				32  //Time input is not correct
#define	NET_DVR_NOSPECFILE					33  //Can't playback the file that does not exist in Server
#define NET_DVR_CREATEFILE_ERROR			34	//Create file error
#define	NET_DVR_FILEOPENFAIL				35  //Open file error
#define	NET_DVR_OPERNOTFINISH				36  //The previous operation is not finished yet
#define	NET_DVR_GETPLAYTIMEFAIL				37  //Get current playing time error
#define	NET_DVR_PLAYFAIL					38  //Playback error
#define NET_DVR_FILEFORMAT_ERROR			39  //Wrong file format
#define NET_DVR_DIR_ERROR					40	//Wrong directory 
#define NET_DVR_ALLOC_RESOURCE_ERROR		41  //Assign resource error
#define NET_DVR_AUDIO_MODE_ERROR			42	//Audio card mode error
#define NET_DVR_NOENOUGH_BUF				43	//Buffer is too small
#define NET_DVR_CREATESOCKET_ERROR		 	44	//Create SOCKET error
#define NET_DVR_SETSOCKET_ERROR				45	//Setup SOCKET error
#define NET_DVR_MAX_NUM						46	//Reach the maximum number
#define NET_DVR_USERNOTEXIST				47	//User does not exist
#define NET_DVR_WRITEFLASHERROR				48  //Write to FLASH error
#define NET_DVR_UPGRADEFAIL					49  //DVR update failed 
#define NET_DVR_CARDHAVEINIT				50  //Decoding Card has been initialized already
#define NET_DVR_PLAYERFAILED				51	//Invoke API of player library error
#define NET_DVR_MAX_USERNUM					52  //Reach the maximum number of DVR Users
#define NET_DVR_GETLOCALIPANDMACFAIL		53  //Failed to get Client software's IP or MAC address
#define NET_DVR_NOENCODEING					54	//No encoding on this channel
#define NET_DVR_IPMISMATCH					55	//IP address is not matched
#define NET_DVR_MACMISMATCH					56	//MAC address is not matched
#define NET_DVR_UPGRADELANGMISMATCH			57	//Update file has wrong language
#define NET_DVR_MAX_PLAYERPORT				58	//Reach the maximum player number
#define NET_DVR_NOSPACEBACKUP				59	//There is no enough space on the backup device
#define NET_DVR_NODEVICEBACKUP				60	//Failed to find the specified backup device 
#define NET_DVR_PICTURE_BITS_ERROR			61	//Image has wrong color bit,  24 color only
#define NET_DVR_PICTURE_DIMENSION_ERROR		62	//Image size exceeds the maximum value;  smaller than 128*256
#define NET_DVR_PICTURE_SIZ_ERROR			63	//Image file exceeds the maximum size;  smaller than 100K
#define NET_DVR_LOADPLAYERSDKFAILED			64	//Failed to load the player SDK from current directory
#define NET_DVR_LOADPLAYERSDKPROC_ERROR		65	//Failed to find the API's entry in player SDK
#define NET_DVR_LOADDSSDKFAILED				66	//Failed to load the DSsdk from current directory
#define NET_DVR_LOADDSSDKPROC_ERROR		    67	//Failed to find the API's entry in DSsDK
#define NET_DVR_DSSDK_ERROR					68	//Failed to involve the API of DSsDK.dll
#define NET_DVR_VOICEMONOPOLIZE				69	//Audio card has been occupied exclusively
#define NET_DVR_JOINMULTICASTFAILED			70	//Join to multicast group error
#define NET_DVR_CREATEDIR_ERROR				71	//Failed to create log directory
#define NET_DVR_BINDSOCKET_ERROR			72	//Failed to bind socked error. 
#define NET_DVR_SOCKETCLOSE_ERROR			73	//socket is disconnected,  that caused by network disconnected or unreachable destination mostly
#define NET_DVR_USERID_ISUSING			    74	//User ID is using when logout
#define NET_DVR_SOCKETLISTEN_ERROR			75	//Socket listen error
#define NET_DVR_PROGRAM_EXCEPTION			76	//Application error
#define NET_DVR_WRITEFILE_FAILED			77	//Failed to write file
#define NET_DVR_FORMAT_READONLY				78  //Forbidden to format read only disk
#define NET_DVR_WITHSAMEUSERNAME		    79  //Same user name already exists.
#define NET_DVR_DEVICETYPE_ERROR            80  //Device Model is not matched when import parameters
#define NET_DVR_LANGUAGE_ERROR              81  //Audio is not matched when import parameters
#define NET_DVR_PARAVERSION_ERROR           82  //Software version is not matched when import parameters
#define NET_DVR_IPCHAN_NOTALIVE             83  //IP Channels is off line when
#define NET_DVR_RTSP_SDK_ERROR                84    //Failed to load IPC communication library
#define NET_DVR_CONVERT_SDK_ERROR            85    //Failed to load stream format convertion library
#define NET_DVR_IPC_COUNT_OVERFLOW            86  //ip count overflow
#define NET_DVR_MAX_ADD_NUM                 87  //add label or other operation reach the maximum number
#define NET_DVR_PARAMMODE_ERROR             88  //Param Mode Error
//2009- 01- 04 
#define NET_DVR_CODESPITTER_OFFLINE            89  //Videoplat: CodeSpitter is Offline
#define NET_DVR_BACKUP_COPYING                90  //Device is backuping
//2010-01-16
#define NET_DVR_CHAN_NOTSUPPORT             91  //Channel doesn't support

#define NET_DVR_CALLINEINVALID              92  // The height line location is too concentrated, or the length line is not inclined enough 
#define NET_DVR_CALCANCELCONFLICT           93  // Cancel calibration conflict, if the rule and overall actual size filter have been set
#define NET_DVR_CALPOINTOUTRANGE            94     // Calibration point exceeds the range 
#define NET_DVR_FILTERRECTINVALID           95  // The size filter does not meet the requirement
#define NET_DVR_DDNS_DEVOFFLINE             96  // Device hasn't registered to ddns
#define NET_DVR_DDNS_INTER_ERROR            97  // DDNS inter error
#define NET_DVR_FUNCTION_NOT_SUPPORT_OS     98  //This function don't support this OS.
#define NET_DVR_DEC_CHAN_REBIND             99  //Decode channel can not bind two or more display channel
#define NET_DVR_INTERCOM_SDK_ERROR          100 //Failed to load the Intercom SDK from current directory
#define NET_DVR_NO_CURRENT_UPDATEFILE       101 //NO Current UpdateFile
#define NET_DVR_USER_NOT_SUCC_LOGIN         102  //user is not login yet
#define NET_DVR_USE_LOG_SWITCH_FILE            103  //it is using log switch file
#define NET_DVR_POOL_PORT_EXHAUST            104  //Port pool is exhaust
#define    NET_DVR_PACKET_TYPE_NOT_SUPPORT        105    //The stream packet type is error

#define NET_DVR_IPPARA_IPID_ERROR           106  //IPID when IP access configuration is incorrect

#define NET_DVR_LOAD_HCPREVIEW_SDK_ERROR           107  //Load Preview COM Failed
#define NET_DVR_LOAD_HCVOICETALK_SDK_ERROR         108  //Load Voice talk COM Failed
#define NET_DVR_LOAD_HCALARM_SDK_ERROR             109  //Load Alarm COM Failed
#define NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR          110  //Load Play back COM Failed
#define NET_DVR_LOAD_HCDISPLAY_SDK_ERROR           111  //Load Display COM Failed
#define NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR          112  //Load Industry COM Failed
#define NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR     113  //Load General config mgr COM Failed
#define NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR        114  //Load device core config COM Failed
#define NET_DVR_LOAD_HCNETUTILS_SDK_ERROR          115  //Load HCNetUtils Failed

#define NET_DVR_CORE_VER_MISMATCH                  121   //There is a mismatch between the component and core version 
#define NET_DVR_CORE_VER_MISMATCH_HCPREVIEW        122   //There is a mismatch  between Live view component and core version.
#define NET_DVR_CORE_VER_MISMATCH_HCVOICETALK      123   //There is a mismatch  between voice component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCALARM          124   //There is a mismatch  between alarm component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK       125   //There is a mismatch  between playback component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCDISPLAY        126   //There is a mismatch  between display component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY       127   //There is a mismatch  between industrial application component and core version
#define NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR  128   //There is a mismatch  between General configuration management component and the core version

#define NET_DVR_COM_VER_MISMATCH_HCPREVIEW         136   //There is a mismatch  between Live view component and HCNetSDK version.
#define NET_DVR_COM_VER_MISMATCH_HCVOICETALK       137   //There is a mismatch  between voice component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCALARM           138   //here is a mismatch  between alarm component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCPLAYBACK        139   //There is a mismatch  between playback component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCDISPLAY         140   //There is a mismatch  between display component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCINDUSTRY        141   //There is a mismatch  between industrial application component and HCNetSDK version
#define NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR   142   //There is a mismatch  between General configuration management component and the HCNetSDK version

#define NET_ERR_CONFIG_FILE_IMPORT_FAILED          145  //import config file failed
#define NET_ERR_CONFIG_FILE_EXPORT_FAILED          146  //export config file failed
#define NET_DVR_CERTIFICATE_FILE_ERROR      147  //certificate error.
#define NET_DVR_LOAD_SSL_LIB_ERROR          148  //load lib ssl failed (maybe lib version unmatched)
#define NET_DVR_SSL_VERSION_NOT_MATCH       149  //lib ssl version unmatched

#define NET_DVR_ALIAS_DUPLICATE                150    // Alias is duplicate  //2011-08-31 the configuration of new ddns accessing device by alias or serial number

#define    NET_DVR_INVALID_COMMUNICATION        151    //Invalid Communication
#define    NET_DVR_USERNAME_NOT_EXIST            152    //UserName is not exist
#define    NET_DVR_USER_LOCKED                    153 //UserName Locked
#define NET_DVR_INVALID_USERID              154 //Invalid User ID
#define NET_DVR_LOW_LOGIN_VERSION           155 //Low Login Version
#define NET_DVR_LOAD_LIBEAY32_DLL_ERROR     156 //load libeay32.dll failed
#define NET_DVR_LOAD_SSLEAY32_DLL_ERROR     157 //load ssleay32.dll failed
#define NET_ERR_LOAD_LIBICONV                       158 //load libiconv2 failed
#define NET_ERR_SSL_CONNECT_FAILED        159 //SSL connect failed
#define NET_ERR_MCAST_ADDRESS_ERROR      160 //Multicast's address is error
#define NET_ERR_LOAD_ZLIB                   161
#define NET_ERR_OPENSSL_NO_INIT             162 

#define NET_DVR_SERVER_NOT_EXIST         164 //can not find the server
#define NET_DVR_TEST_SERVER_FAIL_CONNECT            165    //fail connect with test server
#define NET_DVR_NAS_SERVER_INVALID_DIR                166    //NAS server mount fail,invalid directory
#define NET_DVR_NAS_SERVER_NOENOUGH_PRI                167    //NAS server mount fail,no authority
#define NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS            168    //sever not configure DNS.
#define    NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY        169    //Email server not configure gateway
#define    NET_DVR_TEST_SERVER_PASSWORD_ERROR            170    //the password of the test server is error
#define    NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP    171    //device connect exception with smtp server
#define    NET_DVR_FTP_SERVER_FAIL_CREATE_DIR            172    //FTP server create directory fail
#define    NET_DVR_FTP_SERVER_NO_WRITE_PIR                173    //FTP server not have write authority
#define    NET_DVR_IP_CONFLICT                            174    //IP conflict
#define NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE      175  //No free space for the storage pool
#define NET_DVR_STORAGEPOOL_INVALID                 176  //The storage pool of the cloud server is invalid, no configured storage pool or the storage pool ID is incorrect.
#define NET_DVR_EFFECTIVENESS_REBOOT                177  //Effectiveness Reboot
#define NET_ERR_ANR_ARMING_EXIST                    178  //ANR arming is already established.
#define NET_ERR_UPLOADLINK_EXIST                    179  //Upload Link is already established.
#define NET_ERR_INCORRECT_FILE_FORMAT               180  //Incorrect file format                     
#define NET_ERR_INCORRECT_FILE_CONTENT              181  //Incorrect file content
#define NET_ERR_MAX_HRUDP_LINK                       182               //HRUDP limit the number of connections over equipment 
#define NET_SDK_ERR_ACCESSKEY_SECRETKEY    183   // access or secret key is error
#define NET_SDK_ERR_CREATE_PORT_MULTIPLEX    184 //create port-multiplexing fail
#define NET_DVR_NONBLOCKING_CAPTURE_NOTSUPPORT   185 //nonblocking capture picture not support
#define NET_SDK_ERR_FUNCTION_INVALID   186  //already open asyncronous function,this function has been invalid
#define NET_SDK_ERR_MAX_PORT_MULTIPLEX     187   //alread reach to the max num of port-multiplexing
#define NET_DVR_INVALID_LINK                   188  //invalid link or link has not been created
#define NET_DVR_ISAPI_NOT_SUPPORT              189  //interface not support ISAPI
// RAID error code
#define RAID_ERROR_INDEX                    200
#define NET_DVR_NAME_NOT_ONLY               (RAID_ERROR_INDEX + 0)  // Existing name
#define NET_DVR_OVER_MAX_ARRAY              (RAID_ERROR_INDEX + 1 ) // Number of arrays has reached its limit
#define NET_DVR_OVER_MAX_VD                 (RAID_ERROR_INDEX + 2 ) // Number of virtual disks  has reached its limit
#define NET_DVR_VD_SLOT_EXCEED              (RAID_ERROR_INDEX + 3 ) // Virtual disk slot is full
#define NET_DVR_PD_STATUS_INVALID           (RAID_ERROR_INDEX + 4 ) // Physical disk for rebuilding array is with error status
#define NET_DVR_PD_BE_DEDICATE_SPARE        (RAID_ERROR_INDEX + 5 ) // Physical disk for rebuilding array is specified as spare drive
#define NET_DVR_PD_NOT_FREE                 (RAID_ERROR_INDEX + 6 ) // Physical disk for rebuilding array is not idle
#define NET_DVR_CANNOT_MIG2NEWMODE          (RAID_ERROR_INDEX + 7 ) // Unable to migrate from the current array type to the new array type
#define NET_DVR_MIG_PAUSE                   (RAID_ERROR_INDEX + 8 ) // The migration operation has been paused
#define NET_DVR_MIG_CANCEL                  (RAID_ERROR_INDEX + 9 ) // The migration operation has been canceled
#define NET_DVR_EXIST_VD                    (RAID_ERROR_INDEX + 10) // Operation failed! Please delete the virtual disk existed in the array first
#define NET_DVR_TARGET_IN_LD_FUNCTIONAL     (RAID_ERROR_INDEX + 11) // Target physical disk is part of the virtual disk and is functional
#define NET_DVR_HD_IS_ASSIGNED_ALREADY      (RAID_ERROR_INDEX + 12) // Specified physical disk is assigned to a virtual disk
#define NET_DVR_INVALID_HD_COUNT            (RAID_ERROR_INDEX + 13) // Number of physical disks doesn't fit the specified RAID level
#define NET_DVR_LD_IS_FUNCTIONAL            (RAID_ERROR_INDEX + 14) // Specified virtual disk is functional
#define NET_DVR_BGA_RUNNING                 (RAID_ERROR_INDEX + 15) // BGA is running
#define NET_DVR_LD_NO_ATAPI                 (RAID_ERROR_INDEX + 16) // Can not create virtual disk with ATAPI drive
#define NET_DVR_MIGRATION_NOT_NEED          (RAID_ERROR_INDEX + 17) // Migration is not necessary
#define NET_DVR_HD_TYPE_MISMATCH            (RAID_ERROR_INDEX + 18) // Physical disks are not of the same type
#define NET_DVR_NO_LD_IN_DG                 (RAID_ERROR_INDEX + 19) // No virtual disk exist on the specified array
#define NET_DVR_NO_ROOM_FOR_SPARE           (RAID_ERROR_INDEX + 20) // Disk space is too small to be assigned as spare drive
#define NET_DVR_SPARE_IS_IN_MULTI_DG        (RAID_ERROR_INDEX + 21) // Disk is already assigned as a spare drive for an array
#define NET_DVR_DG_HAS_MISSING_PD           (RAID_ERROR_INDEX + 22) // Disk is missing from an array
// x86 64bit nvr 2012-02-04
#define NET_DVR_NAME_EMPTY                    (RAID_ERROR_INDEX + 23) /*Name is empty*/
#define NET_DVR_INPUT_PARAM                    (RAID_ERROR_INDEX + 24) /*Input param is wrong*/
#define NET_DVR_PD_NOT_AVAILABLE            (RAID_ERROR_INDEX + 25) /*Physics disk is not available*/
#define NET_DVR_ARRAY_NOT_AVAILABLE            (RAID_ERROR_INDEX + 26) /*Array is not available*/
#define NET_DVR_PD_COUNT                    (RAID_ERROR_INDEX + 27) /*Physics disk number is wrong*/
#define NET_DVR_VD_SMALL                    (RAID_ERROR_INDEX + 28) /*Virtual disk is small*/
#define NET_DVR_NO_EXIST                    (RAID_ERROR_INDEX + 29) /*Raid No exist*/
#define NET_DVR_NOT_SUPPORT                    (RAID_ERROR_INDEX + 30) /*Operation not support*/
#define NET_DVR_NOT_FUNCTIONAL                 (RAID_ERROR_INDEX + 31) /*Raid is not functional*/
#define NET_DVR_DEV_NODE_NOT_FOUND            (RAID_ERROR_INDEX + 32) /*Virtual disk device node is no exist*/
#define NET_DVR_SLOT_EXCEED                    (RAID_ERROR_INDEX + 33) /*Slot is exceed*/ 
#define NET_DVR_NO_VD_IN_ARRAY                (RAID_ERROR_INDEX + 34) /*Virtual disk is not exist in array*/
#define NET_DVR_VD_SLOT_INVALID                (RAID_ERROR_INDEX + 35) /*Virtual disk slot is invalid*/
#define NET_DVR_PD_NO_ENOUGH_SPACE            (RAID_ERROR_INDEX + 36) /*Physics disk is no enough space*/
#define NET_DVR_ARRAY_NONFUNCTION            (RAID_ERROR_INDEX + 37) /*Only functional raid can move*/
#define NET_DVR_ARRAY_NO_ENOUGH_SPACE        (RAID_ERROR_INDEX + 38) /*Array is no enough space*/
#define NET_DVR_STOPPING_SCANNING_ARRAY        (RAID_ERROR_INDEX + 39) /*Pull disk or scan array is processing*/
#define NET_DVR_NOT_SUPPORT_16T             (RAID_ERROR_INDEX + 40) /*Not support 16T*/
#define NET_DVR_ARRAY_FORMATING             (RAID_ERROR_INDEX + 41) /*Array formating*/ 
#define NET_DVR_QUICK_SETUP_PD_COUNT        (RAID_ERROR_INDEX + 42) /*at least three idle wheel cfg*/ 

#define    NET_DVR_ERROR_DEVICE_NOT_ACTIVATED    250//device not activated
#define  NET_DVR_ERROR_RISK_PASSWORD          251 //risk password
#define    NET_DVR_ERROR_DEVICE_HAS_ACTIVATED    252//device has activated already

// Intelligence error code  
#define VCA_ERROR_INDEX                     300 // VCA error index
#define NET_DVR_ID_ERROR                    (VCA_ERROR_INDEX + 0)   // Configuration ID is illegal.
#define NET_DVR_POLYGON_ERROR               (VCA_ERROR_INDEX + 1)   // Polygon does not match requirement.
#define NET_DVR_RULE_PARAM_ERROR            (VCA_ERROR_INDEX + 2)   // Rule parameter is illegal.
#define NET_DVR_RULE_CFG_CONFLICT           (VCA_ERROR_INDEX + 3)   // Configuration conflict.
#define NET_DVR_CALIBRATE_NOT_READY         (VCA_ERROR_INDEX + 4)   // Calibration not ready.
#define NET_DVR_CAMERA_DATA_ERROR           (VCA_ERROR_INDEX + 5)   // Camera parameter is illegal.
#define NET_DVR_CALIBRATE_DATA_UNFIT        (VCA_ERROR_INDEX + 6)    // Not tilt enough, not fit to calibrate.
#define NET_DVR_CALIBRATE_DATA_CONFLICT    (VCA_ERROR_INDEX + 7)    // Calibration error.
#define NET_DVR_CALIBRATE_CALC_FAIL         (VCA_ERROR_INDEX + 8)    // Failed to calculate camera calibration parameter.
#define    NET_DVR_CALIBRATE_LINE_OUT_RECT        (VCA_ERROR_INDEX + 9)    // The input calibrating line exceeds the external rectangle sample.
#define NET_DVR_ENTER_RULE_NOT_READY        (VCA_ERROR_INDEX + 10)  // Enter rule not ready.
#define NET_DVR_AID_RULE_NO_INCLUDE_LANE    (VCA_ERROR_INDEX + 11)    // It does not include lane in the traffic event rule (especial for traffic jam or driving against the traffic).
#define NET_DVR_LANE_NOT_READY                (VCA_ERROR_INDEX + 12)    // Lane not ready.
#define NET_DVR_RULE_INCLUDE_TWO_WAY        (VCA_ERROR_INDEX + 13)    // There are two different directions in event rule.
#define NET_DVR_LANE_TPS_RULE_CONFLICT      (VCA_ERROR_INDEX + 14)  // The lane conflicts with the data rule.
#define NET_DVR_NOT_SUPPORT_EVENT_TYPE      (VCA_ERROR_INDEX + 15)  // Event type is not support.
#define NET_DVR_LANE_NO_WAY                 (VCA_ERROR_INDEX + 16)  // Lane has not direction.
#define NET_DVR_SIZE_FILTER_ERROR           (VCA_ERROR_INDEX + 17)  // Size filter is error.
#define NET_DVR_LIB_FFL_NO_FACE             (VCA_ERROR_INDEX + 18)  // Picture of feature point location has not face.
#define NET_DVR_LIB_FFL_IMG_TOO_SMALL       (VCA_ERROR_INDEX + 19)  // Picture of feature point location is too small.
#define NET_DVR_LIB_FD_IMG_NO_FACE          (VCA_ERROR_INDEX + 20)  // Picture of single detect has not face.
#define NET_DVR_LIB_FACE_TOO_SMALL          (VCA_ERROR_INDEX + 21)  // Face is too small when modeling.
#define NET_DVR_LIB_FACE_QUALITY_TOO_BAD    (VCA_ERROR_INDEX + 22)  // Face quality is too bad when modeling.
#define NET_DVR_KEY_PARAM_ERR               (VCA_ERROR_INDEX + 23)  //Key parameter is error.
#define NET_DVR_CALIBRATE_DATA_ERR          (VCA_ERROR_INDEX + 24)  //Calibrate data is error.
#define NET_DVR_CALIBRATE_DISABLE_FAIL      (VCA_ERROR_INDEX + 25)  //Disable calibrate has failed.
#define NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE   (VCA_ERROR_INDEX + 26)  //Filter scale is out range.
#define NET_DVR_LIB_FD_REGION_TOO_LARGE     (VCA_ERROR_INDEX + 27)  //Region is too big.
#define NET_DVR_TRIAL_OVERDUE               (VCA_ERROR_INDEX + 28) //Trial overdue.
#define NET_DVR_CONFIG_FILE_CONFLICT        (VCA_ERROR_INDEX + 29) //Config file conflict.

#define NET_DVR_FR_FPL_FAIL                 (VCA_ERROR_INDEX + 30)   //Feature points location is error in face recognition
#define NET_DVR_FR_IQA_FAIL                 (VCA_ERROR_INDEX + 31)   //Image quality assessment is error in face recognition
#define NET_DVR_FR_FEM_FAIL                 (VCA_ERROR_INDEX + 32)   //Feature extract & match error in face recognition
#define NET_DVR_FPL_DT_CONF_TOO_LOW         (VCA_ERROR_INDEX + 33)   //Detection confidence is too low in feature points location
#define NET_DVR_FPL_CONF_TOO_LOW            (VCA_ERROR_INDEX + 34)   //Confidence is too low in feature points location
#define NET_DVR_E_DATA_SIZE                 (VCA_ERROR_INDEX + 35)  //Size of model data error
#define NET_DVR_FR_MODEL_VERSION_ERR        (VCA_ERROR_INDEX + 36)  //Model version is error
#define NET_DVR_FR_FD_FAIL                  (VCA_ERROR_INDEX + 37)  //Face detection error in face recognition
#define NET_DVR_FA_NORMALIZE_ERR            (VCA_ERROR_INDEX + 38)  //Face attribute normalize error

#define NET_DVR_DOG_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 39)  //Pustream and softdog are mismatched
#define NET_DVR_DEV_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 40)  //Pustream device version is error
#define NET_DVR_PUSTREAM_ALREADY_EXISTS     (VCA_ERROR_INDEX + 41)  //The pustream has existence
#define NET_DVR_SEARCH_CONNECT_FAILED       (VCA_ERROR_INDEX + 42)  //Failed to connect face retrieval device
#define NET_DVR_INSUFFICIENT_DISK_SPACE     (VCA_ERROR_INDEX + 43)  //Storage space is insufficient
#define NET_DVR_DATABASE_CONNECTION_FAILED  (VCA_ERROR_INDEX + 44)  //Failed to connect database
#define NET_DVR_DATABASE_ADM_PW_ERROR       (VCA_ERROR_INDEX + 45)  //Username or password is error for database
#define NET_DVR_DECODE_YUV                  (VCA_ERROR_INDEX + 46)  //Failed to decode image
#define NET_DVR_IMAGE_RESOLUTION_ERROR      (VCA_ERROR_INDEX + 47)  //Image resolution is unreasonable
#define NET_DVR_CHAN_WORKMODE_ERROR         (VCA_ERROR_INDEX + 48)  //Channel workmode error

#define NET_DVR_RTSP_ERROR_NOENOUGHPRI              401  // no authoration: when server return 401,RTSP return it.
#define NET_DVR_RTSP_ERROR_ALLOC_RESOURCE           402  // fail to alloc resource
#define NET_DVR_RTSP_ERROR_PARAMETER                403  // parameter error.
#define NET_DVR_RTSP_ERROR_NO_URL                   404  // can't find the url. when server return 404,RTSP return it.
#define NET_DVR_RTSP_ERROR_FORCE_STOP               406  // user force to stop.
#define NET_DVR_RTSP_GETPORTFAILED                  407  // rtsp get port failed

#define NET_DVR_RTSP_DESCRIBERROR                   410  // rtsp describe communicate error
#define NET_DVR_RTSP_DESCRIBESENDTIMEOUT            411  // Sending signal "DECRIBE" is timeout
#define NET_DVR_RTSP_DESCRIBESENDERROR                412  // Failed to send signal "DECRIBE"
#define NET_DVR_RTSP_DESCRIBERECVTIMEOUT            413  // Receiving signal "DECRIBE" is timeout
#define NET_DVR_RTSP_DESCRIBERECVDATALOST            414  // Receiving data of signal "DECRIBE" error
#define NET_DVR_RTSP_DESCRIBERECVERROR                415  // Failed to receive signal "DECRIBE"
#define NET_DVR_RTSP_DESCRIBESERVERERR                416  // Signal "DECRIBE" server returns the error

#define NET_DVR_RTSP_SETUPERROR                        420  // rtsp setup communicate error
#define NET_DVR_RTSP_SETUPSENDTIMEOUT                421  // Sending signal "SETUP" is timeout
#define NET_DVR_RTSP_SETUPSENDERROR                    422  // Sending signal "SETUP" error
#define NET_DVR_RTSP_SETUPRECVTIMEOUT                423  // Receiving signal "SETUP" is timeout
#define NET_DVR_RTSP_SETUPRECVDATALOST                424  // Receiving data of signal "SETUP" error
#define NET_DVR_RTSP_SETUPRECVERROR                    425  // Failed to receive signal "SETUP"
#define NET_DVR_RTSP_OVER_MAX_CHAN                    426  // It exceeds the max connection number, or no enough resource. when server return 453,RTSP return it.
#define NET_DVR_RTSP_SETUPSERVERERR                    427  // Signal "SETUP" server returns the error

#define NET_DVR_RTSP_PLAYERROR                        430  // rtsp play communicate error
#define NET_DVR_RTSP_PLAYSENDTIMEOUT                431  // Sending signal "PLAY" is timeout
#define NET_DVR_RTSP_PLAYSENDERROR                    432  // Sending signal "PLAY" error
#define NET_DVR_RTSP_PLAYRECVTIMEOUT                433  // Receiving signal "PLAY" is timeout
#define NET_DVR_RTSP_PLAYRECVDATALOST                434  // Receiving data of signal "PLAY" error
#define NET_DVR_RTSP_PLAYRECVERROR                    435  // Failed to receive signal "PLAY"
#define NET_DVR_RTSP_PLAYSERVERERR                    436  // Signal "PLAY" server returns the error

#define NET_DVR_RTSP_TEARDOWNERROR                    440  // rtsp teardown communicate error
#define NET_DVR_RTSP_TEARDOWNSENDTIMEOUT            441  // Sending signal "TEARDOWN" is timeout
#define NET_DVR_RTSP_TEARDOWNSENDERROR                442  // Sending signal "TEARDOWN" error
#define NET_DVR_RTSP_TEARDOWNRECVTIMEOUT            443  // Receiving signal "TEARDOWN" is timeout
#define NET_DVR_RTSP_TEARDOWNRECVDATALOST            444  // Receiving data of signal "TEARDOWN" error
#define NET_DVR_RTSP_TEARDOWNRECVERROR                445  // Failed to receive signal "TEARDOWN"
#define NET_DVR_RTSP_TEARDOWNSERVERERR                446  // Signal "TEARDOWN" server returns the error

#define NET_PLAYM4_NOERROR                            500     // No error
#define    NET_PLAYM4_PARA_OVER                        501     // Input parameter is invalid; 
#define NET_PLAYM4_ORDER_ERROR                        502     // The order of the function to be called is error.
#define    NET_PLAYM4_TIMER_ERROR                        503     // Create multimedia clock failed; 
#define NET_PLAYM4_DEC_VIDEO_ERROR                    504     // Decode video data failed.
#define NET_PLAYM4_DEC_AUDIO_ERROR                    505     // Decode audio data failed.
#define    NET_PLAYM4_ALLOC_MEMORY_ERROR                506     // Allocate memory failed.
#define NET_PLAYM4_OPEN_FILE_ERROR                    507     // Open the file failed.
#define NET_PLAYM4_CREATE_OBJ_ERROR                    508     // Create thread or event failed
#define NET_PLAYM4_CREATE_DDRAW_ERROR                509     // Create DirectDraw object failed.
#define NET_PLAYM4_CREATE_OFFSCREEN_ERROR            510     // Failed when creating off- screen surface.
#define NET_PLAYM4_BUF_OVER                            511     // Buffer is overflow
#define NET_PLAYM4_CREATE_SOUND_ERROR                512     // Failed when creating audio device.    
#define    NET_PLAYM4_SET_VOLUME_ERROR                    513     // Set volume failed
#define NET_PLAYM4_SUPPORT_FILE_ONLY                514     // The function only support play file.
#define NET_PLAYM4_SUPPORT_STREAM_ONLY                515     // The function only support play stream.
#define NET_PLAYM4_SYS_NOT_SUPPORT                    516     // System not support.
#define NET_PLAYM4_FILEHEADER_UNKNOWN                517     // No file header.
#define NET_PLAYM4_VERSION_INCORRECT                518     // The version of decoder and encoder is not adapted.  
#define NET_PALYM4_INIT_DECODER_ERROR                519     // Initialize decoder failed.
#define NET_PLAYM4_CHECK_FILE_ERROR                    520     // The file data is unknown.
#define NET_PLAYM4_INIT_TIMER_ERROR                    521     // Initialize multimedia clock failed.
#define    NET_PLAYM4_BLT_ERROR                        522     // BLT failed.
#define NET_PLAYM4_UPDATE_ERROR                        523     // Update failed.
#define NET_PLAYM4_OPEN_FILE_ERROR_MULTI            524  // Open file error,  stream type is multi
#define NET_PLAYM4_OPEN_FILE_ERROR_VIDEO            525  // Open file error,  stream type is video
#define NET_PLAYM4_JPEG_COMPRESS_ERROR                526  // JPEG compress error
#define NET_PLAYM4_EXTRACT_NOT_SUPPORT                527     // Don't support the version of this file.
#define NET_PLAYM4_EXTRACT_DATA_ERROR                528     // Extract video data failed.

//convert error
#define  NET_CONVERT_ERROR_NOT_SUPPORT          581  //convert not support

//audio intercom error
#define  NET_AUDIOINTERCOM_OK                   600
#define  NET_AUDIOINTECOM_ERR_NOTSUPORT         601 //not support
#define  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY      602 //alloc memery error
#define  NET_AUDIOINTECOM_ERR_PARAMETER            603 //param error
#define  NET_AUDIOINTECOM_ERR_CALL_ORDER        604 //call order error
#define  NET_AUDIOINTECOM_ERR_FIND_DEVICE       605 //can not find device error
#define  NET_AUDIOINTECOM_ERR_OPEN_DEVICE       606 // open device error
#define  NET_AUDIOINTECOM_ERR_NO_CONTEXT        607 // no context error
#define  NET_AUDIOINTECOM_ERR_NO_WAVFILE        608 //no Wav file error
#define  NET_AUDIOINTECOM_ERR_INVALID_TYPE      609 // invalid type error
#define  NET_AUDIOINTECOM_ERR_ENCODE_FAIL       610 //encode fail error
#define  NET_AUDIOINTECOM_ERR_DECODE_FAIL       611 //decode fail error
#define  NET_AUDIOINTECOM_ERR_NO_PLAYBACK       612 //play back error
#define  NET_AUDIOINTECOM_ERR_DENOISE_FAIL      613 //denoise fail error
#define  NET_AUDIOINTECOM_ERR_UNKOWN            619 //unKown Error

#define NET_QOS_OK                                    700                        // No error
#define NET_QOS_ERROR                                (NET_QOS_OK - 1)        // Qos error
#define NET_QOS_ERR_INVALID_ARGUMENTS                (NET_QOS_OK - 2)        // Invalid arguments 
#define NET_QOS_ERR_SESSION_NOT_FOUND                (NET_QOS_OK - 3)        // Session net found
#define NET_QOS_ERR_LIB_NOT_INITIALIZED                (NET_QOS_OK - 4)        // Lib not initialized
#define NET_QOS_ERR_OUTOFMEM                        (NET_QOS_OK - 5)        // Out of memory
#define NET_QOS_ERR_PACKET_UNKNOW                    (NET_QOS_OK - 10)        // Packet unknown
#define NET_QOS_ERR_PACKET_VERSION                    (NET_QOS_OK - 11)        // Packet version error
#define NET_QOS_ERR_PACKET_LENGTH                    (NET_QOS_OK - 12)        // Packet length error
#define NET_QOS_ERR_PACKET_TOO_BIG                    (NET_QOS_OK - 13)        // Packet too big
#define NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH    (NET_QOS_OK - 20)        // Schedule parameters invalid bandwidth
#define NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION        (NET_QOS_OK - 21)        // Schedule parameters bad fraction
#define NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL (NET_QOS_OK - 22)        // Schedule parameters bad minimum interval

#define NET_ERROR_TRUNK_LINE                         711    //sub system has been used as trunk line
#define NET_ERROR_MIXED_JOINT                         712    //mixed jointing is not allowed
#define NET_ERROR_DISPLAY_SWITCH                     713    //can not switch display channel
#define NET_ERROR_USED_BY_BIG_SCREEN                 714    //decode resource had been used by big screen
#define NET_ERROR_USE_OTHER_DEC_RESOURCE             715    //can not use other sub systems' decode resource
#define NET_ERROR_DISP_MODE_SWITCH                     716    //display mode is switching
#define NET_ERROR_SCENE_USING                         717    //scene is using
#define NET_ERR_NO_ENOUGH_DEC_RESOURCE               718    //no enough decode resource
#define NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE         719    //no enough free show resource
#define NET_ERR_NO_ENOUGH_VIDEO_MEMORY               720    //no enough video memory
#define NET_ERR_MAX_VIDEO_NUM                        721    //reach max video number
#define NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL       722    //window can not cover free show window and normal window
#define NET_ERR_FREE_SHOW_WIN_SPLIT                  723    //free show window can not split
#define NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW          724    //the window can not free show
#define NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT    725    //transparent window not support split
#define NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT    726    //split window not support transparent
#define NET_ERR_MAX_LOGO_NUM                         727    //reach max logo number
#define NET_ERR_MAX_WIN_LOOP_NUM                     728    //reach max window loop number
#define NET_ERR_VIRTUAL_LED_VERTICAL_CROSS           729    //virtual LED can not cross screen vertically
#define NET_ERR_MAX_VIRTUAL_LED_HEIGHT               730    //virtual LED height overlimit
#define NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER        731    //illegal character in virtual LED
#define NET_ERR_BASEMAP_NOT_EXIST                    732    //base map is not existed
#define NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED          733    //LED screen does not support virtual LED
#define NET_ERR_LED_RESOLUTION_NOT_SUPPORT           734    //LED resolution not support
#define NET_ERR_PLAN_OVERDUE                         735    //plan is overdue, can not be called
#define NET_ERR_PROCESSER_MAX_SCREEN_BLK             736    //the number of screen which a single processor across reach limit
#define NET_ERR_WND_SIZE_TOO_SMALL                   737    //the size of window is too small
#define NET_ERR_WND_SPLIT_NOT_SUPPORT_ROAM           738    //split window is not supported roam
#define NET_ERR_OUTPUT_ONE_BOARD_ONE_WALL            739    //outputs of one board is not supported binded to walls 
#define NET_ERR_WND_CANNOT_LCD_AND_LED_OUTPUT        740    //window can not cross LCD and LED output
#define NET_ERR_MAX_OSD_NUM                          741    //the number of OSD is limited

#define NET_SDK_CANCEL_WND_TOPKEEP_ATTR_FIRST       751 //cancel set-top maintaining of window top attributes before set-bottom operation
#define NET_SDK_ERR_LED_SCREEN_CHECKING             752 //checking LED screen
#define NET_SDK_ERR_NOT_SUPPORT_SINGLE_RESOLUTION   753 //LCD/LED output not support single resolution configuration when binded
#define NET_SDK_ERR_LED_RESOLUTION_MISMATCHED       754 //the LED output resolution is mismatched with other LED output resolution

#define NET_SDK_ERR_MAX_VIRTUAL_LED_WIDTH           755 //virtual led max width
#define NET_SDK_ERR_MAX_VIRTUAL_LED_IN_SCREEN       756 //virtual max in screen
#define NET_SDK_ERR_MAX_VIRTUAL_LED_IN_WALL         757 //virtual max in wall
#define NET_SDK_ERR_VIRTUAL_LED_OVERLAP             758 //virtual overlap
#define NET_SDK_ERR_VIRTUAL_LED_TYPE                759 //virtual type error
#define NET_SDK_ERR_VIRTUAL_LED_COLOUR              760 //virtual color error
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_DIRECTION      761 //virtual move direction error
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_MODE           762 //virtual mode mode error
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_SPEED          763 //virtual move speed error
#define NET_SDK_ERR_VIRTUAL_LED_DISP_MODE           764 //virtual display mode error
#define NET_SDK_ERR_VIRTUAL_LED_NO                  765 //virtual led no error
#define NET_SDK_ERR_VIRTUAL_LED_PARA                766 //virtual param error
#define NET_SDK_ERR_BASEMAP_POSITION                767 //basemap position error
#define NET_SDK_ERR_BASEMAP_PICTURE_LEN             768 //basemap picture lenth error
#define NET_SDK_ERR_BASEMAP_PICTURE_RESOLUTION      769 //basemap picture resolution error
#define NET_SDK_ERR_BASEMAP_PICTURE_FORMAT          770 //basemap picture  format error
#define NET_SDK_ERR_MAX_VIRTUAL_LED_NUM             771 //maximum number of virtual LED is limited
#define NET_SDK_ERR_MAX_TIME_VIRTUAL_LED_IN_WALL    772 //the number of time LED of one wall is limited

#define NET_ERR_TERMINAL_BUSY                         780    //terminal busy, it is in the meeting

#define NET_ERR_DATA_RETURNED_ILLEGAL                 790   //the data returned from device is illegal 
#define NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR         791    //Equipment other resource-intensive function, cause the function could not be opened 

#define    NET_DVR_ERR_IMPORT_EMPTY_FILE           792    //Import empty file
#define    NET_DVR_ERR_IMPORT_TOO_LARGE_FILE       793    //Import too large file        
#define    NET_DVR_ERR_BAD_IPV4_ADDRESS            794    //Invalid ipv4 address
#define    NET_DVR_ERR_BAD_NET_MASK                795    //Invalid net mask address
#define    NET_DVR_ERR_INVALID_NET_GATE_ADDRESS    796    //Invalid net gate address          
#define    NET_DVR_ERR_BAD_DNS                     797    //Invalid DNS
#define    NET_DVR_ERR_ILLEGAL_PASSWORD            798    //The password have not included user name

#define NET_DVR_DEV_NET_OVERFLOW                     800    // Over the ability of the device network
#define NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK   801    // Can't lock because the file being recording.
#define NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK       802    // Can't format little disk.

//N+1
#define NET_SDK_ERR_REMOTE_DISCONNECT                803 //Remote disconnect
#define NET_SDK_ERR_RD_ADD_RD                        804 //Redaunt device can't add redaunt device
#define NET_SDK_ERR_BACKUP_DISK_EXCEPT                805 //Backup disk exception
#define NET_SDK_ERR_RD_LIMIT                        806 //Redaunt device is up to limit
#define NET_SDK_ERR_ADDED_RD_IS_WD                    807 //Added redaunt device is work device
#define NET_SDK_ERR_ADD_ORDER_WRONG                    808 //Added order is wrong
#define NET_SDK_ERR_WD_ADD_WD                        809 //Work device can't add work device
#define NET_SDK_ERR_WD_SERVICE_EXCETP                810 //Work device cvr service exception
#define NET_SDK_ERR_RD_SERVICE_EXCETP                811 //Redaunt device cvr service exception
#define NET_SDK_ERR_ADDED_WD_IS_RD                    812 //Added work device is redaunt device
#define NET_SDK_ERR_PERFORMANCE_LIMIT                813 //Perormance limit
#define NET_SDK_ERR_ADDED_DEVICE_EXIST                814 //Added device exist

//Inquest
#define NET_SDK_ERR_INQUEST_RESUMING                815 //Inquest resuming
#define NET_SDK_ERR_RECORD_BACKUPING                816 //Record backuping
#define NET_SDK_ERR_DISK_PLAYING                    817 //Disk playing
#define NET_SDK_ERR_INQUEST_STARTED                    818 //Inquest started
#define NET_SDK_ERR_LOCAL_OPERATING                    819 //Local operating
#define NET_SDK_ERR_INQUEST_NOT_START                820 //Inquest not start
//netra3.1.0             
#define NET_SDK_ERR_CHAN_AUDIO_BIND                 821 //chan bind aduio error or no bind
//netra3.1.2 
#define NET_DVR_N_PLUS_ONE_MODE                     822 //Current equipment is N +1 mode
#define NET_DVR_CLOUD_STORAGE_OPENED                823 //Cloud storage mode is open

#define NET_DVR_ERR_OPER_NOT_ALLOWED                824   //N+0 status,not allowed
#define NET_DVR_ERR_NEED_RELOCATE                    825   //need relocate

//trial host error
#define NET_SDK_ERR_IR_PORT_ERROR                   830 //ir port error
#define NET_SDK_ERR_IR_CMD_ERROR                    831 //ir cmd error
#define NET_SDK_ERR_NOT_INQUESTING                  832 //Device in non-trial condition
#define NET_SDK_ERR_INQUEST_NOT_PAUSED              833 //Device in non-pause condition
#define NET_DVR_CHECK_PASSWORD_MISTAKE_ERROR        834 //Check the password mistake 
#define NET_DVR_CHECK_PASSWORD_NULL_ERROR           835 //Check the password can't null
#define NET_DVR_UNABLE_CALIB_ERROR                  836  //Unable to calibrate currently
#define NET_DVR_PLEASE_CALIB_ERROR                  837//Please finish the calibration first
#define NET_DVR_ERR_PANORAMIC_CAL_EMPTY             838 //No panorama image for PanoVu camera calibration in flash.
#define NET_DVR_ERR_CALIB_FAIL_PLEASEAGAIN          839 //(Calibration failed. Please calibrate again.)
#define NET_DVR_ERR_DETECTION_LINE                  840 //(Please set detection line again. The detection line should be within the red count area.)
#define NET_DVR_ERR_TURN_OFF_IMAGE_PARA             841 //Please turn off the image parameters switch first.
#define NET_DVR_EXCEED_FACE_IMAGES_ERROR            843  //exceed face images error
#define NET_DVR_ANALYSIS_FACE_IMAGES_ERROR          844  //analysis face images error
#define NET_ERR_ALARM_INPUT_OCCUPIED   845  //Alarm Input No. A<-1 is used to trigger vehicle capture.
#define NET_DVR_FACELIB_DATABASE_ERROR              846  //face lib error
#define NET_DVR_FACELIB_DATA_ERROR                  847  //face lib data error
#define NET_DVR_FACE_DATA_ID_ERROR                  848  //face pid error
#define NET_DVR_FACELIB_ID_ERROR                    849  //face lib id error
#define NET_DVR_EXCEED_FACE_LIBARY_ERROR            850  //exceed face lib error
#define NET_DVR_PIC_ANALYSIS_NO_TARGET_ERROR           851  
#define NET_DVR_SUBPIC_ANALYSIS_MODELING_ERROR         852 
#define NET_DVR_PIC_ANALYSIS_NO_RESOURCE_ERROR         853 
#define NET_DVR_ANALYSIS_ENGINES_NO_RESOURCE_ERROR                 854
#define NET_DVR_ANALYSIS_ENGINES_USAGE_EXCEED_ERROR                855
#define NET_DVR_EXCEED_HUMANMISINFO_FILTER_ENABLED_ERROR           856 
#define NET_DVR_NAME_ERROR                                         857  //name error
#define NET_DVR_NAME_EXIST_ERROR                                   858  //name exist error
#define NET_DVR_FACELIB_PIC_IMPORTING_ERROR                        859  //face lib picture importing
#define NET_DVR_ERR_CALIB_POSITION                 860 //Calibration position beyond camera motion range
#define NET_DVR_ERR_DELETE                         861 //Unable to delete
#define NET_DVR_ERR_SCENE_ID                       862 //Invalid scene ID
#define NET_DVR_ERR_CALIBING                       863 //In calibration
#define NET_DVR_PIC_FORMAT_ERROR                                   864  //picture format error
#define NET_DVR_PIC_RESOLUTION_INVALID_ERROR                       865  //picture resolution invalid error
#define NET_DVR_PIC_SIZE_EXCEED_ERROR                              866  //picture size exceed
#define NET_DVR_PIC_ANALYSIS_TARGRT_NUM_EXCEED_ERROR               867  //picture target num exceed
#define NET_DVR_ANALYSIS_ENGINES_LOADING_ERROR                     868//engine loading error
#define NET_DVR_ANALYSIS_ENGINES_ABNORMA_ERROR                     869//engine abnorma
#define NET_DVR_ANALYSIS_ENGINES_FACELIB_IMPORTING                 870//analysis engine is import face library 
#define NET_DVR_NO_DATA_FOR_MODELING_ERROR         871  //no data for modeling
#define NET_DVR_FACE_DATA_MODELING_ERROR           872 //face data modeling
#define NET_ERR_FACELIBDATA_OVERLIMIT              873  //facelib data over limit
#define NET_DVR_ANALYSIS_ENGINES_ASSOCIATED_CHANNEL  874//analysis engine has been associated channel 
#define NET_DVR_ERR_CUSTOMID_LEN                   875 //CustomID Len Error
#define NET_DVR_ERR_CUSTOMFACELIBID_REPEAT         876 //CustomFaceLibID Repeat
#define NET_DVR_ERR_CUSTOMHUMANID_REPEAT           877 //CustomHumanID Repeat
#define NET_DVR_ERR_URL_DOWNLOAD_FAIL              878 //url Download Fail
#define NET_DVR_ERR_URL_DOWNLOAD_NOTSTART          879 //url Download Not Start

#define NET_DVR_CFG_FILE_SECRETKEY_ERROR         880  //config file secret key error
#define NET_DVR_WDR_NOTDISABLE_ERROR             881  //Please disable WDR function of all camera channels.
#define NET_DVR_HLC_NOTDISABLE_ERROR             882  //Please disable HLC fucntion of all camera channels.

#define NET_DVR_THERMOMETRY_REGION_OVERSTEP_ERROR         883  //thermometry region overstep error

#define NET_DVR_ERR_MODELING_DEVICEINTERNAL      884 //Modeling failed. Device internal error
#define NET_DVR_ERR_MODELING_FACE                885 //Modeling failed. Face modeling error
#define NET_DVR_ERR_MODELING_FACEGRADING         886 //Modeling failed. Face grading error
#define NET_DVR_ERR_MODELING_FACEGFEATURE        887 //Modeling failed. Facial feature points extracting error
#define NET_DVR_ERR_MODELING_FACEGANALYZING      888 //Modeling failed. Feature analyzing error

#define NET_DVR_ERR_STREAM_LIMIT                 889 //Streaming performance reaches its limit. Please reduce simultaneous live view channels.
#define NET_DVR_ERR_STREAM_DESCRIPTION           890 //Input description for the stream.
#define NET_DVR_ERR_STREAM_DELETE                891 //Stream in use can not be deleted.
#define NET_DVR_ERR_CUSTOMSTREAM_NAME            892 //Custom stream name is empty or invalid
#define NET_DVR_ERR_CUSTOMSTREAM_NOTEXISTED      893 //The stream is not existed

#define NET_DVR_ERR_TOO_SHORT_CALIBRATING_TIME     894 //calibrate time is too short
#define NET_DVR_ERR_AUTO_CALIBRATE_FAILED     895 //auto calibrate failed
#define NET_DVR_ERR_VERIFICATION_FAILED     896 //verification failed

#define NET_DVR_NO_TEMP_SENSOR_ERROR         897  // 
#define NET_DVR_PUPIL_DISTANCE_OVERSIZE_ERROR         898  // 
#define NET_DVR_ERR_UNOPENED_FACE_SNAP           899 //

#define NET_ERR_CUT_INPUTSTREAM_OVERLIMIT           900 //cut input stream signal overlimit
#define NET_ERR_WINCHAN_IDX                             901    // Window index error
#define NET_ERR_WIN_LAYER                             902    // Window Layer    error
#define NET_ERR_WIN_BLK_NUM                             903    // Window Block error
#define NET_ERR_OUTPUT_RESOLUTION                     904    // Output resolution error
#define NET_ERR_LAYOUT                                 905    // Layout Index error
#define NET_ERR_INPUT_RESOLUTION                     906    // Input  resolution error

#define NET_ERR_SUBDEVICE_OFFLINE                     907    // device is off-line
#define NET_ERR_NO_DECODE_CHAN                         908    // no decode channel for use
#define NET_ERR_MAX_WINDOW_ABILITY                     909    // no enough resource for openning window 
#define NET_ERR_ORDER_ERROR                             910    // order error

#define NET_ERR_PLAYING_PLAN                        911    //plan is running
#define NET_ERR_DECODER_USED                        912    //decoder is using
#define    NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW            913    // data is overflow on the output board
#define    NET_ERR_SAME_USER_NAME                        914    // the same user name
#define    NET_ERR_INVALID_USER_NAME                    915    // invalid user name
#define    NET_ERR_MATRIX_USING                        916    // the matrix is using
#define    NET_ERR_DIFFERENT_CHAN_TYPE                    917    // the channel type is different
#define    NET_ERR_INPUT_CHAN_BINDED                    918    // input channel is binded the other matrix channel
#define    NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW            919    // output channels that are using is over max
#define    NET_ERR_MAX_SIGNAL_NUM                        920    // signal number is overflow
#define NET_ERR_INPUT_CHAN_USING                    921    // input channel(signal)is using
#define NET_ERR_MANAGER_LOGON                         922    //manager logon ,operate failed
#define NET_ERR_USERALREADY_LOGON                     923    //the user already logon,operate failed
#define NET_ERR_LAYOUT_INIT                         924    //plan is init,operate failed
#define    NET_ERR_BASEMAP_SIZE_NOT_MATCH                925    //the size of basemap is not match
#define NET_ERR_WINDOW_OPERATING                    926    // the window is executing another action, the operate failed
#define NET_ERR_SIGNAL_UPLIMIT                        927 // there are too many windows base on this signal.
#define NET_ERR_SIGNAL_MAX_ENLARGE_TIMES            928 // can not enlarge signal to the specified times 
#define NET_ERR_ONE_SIGNAL_MULTI_CROSS              929 // one signal can not cross screen two times
#define NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN           930 // ultra HD signal can not on window two times
#define  NET_ERR_MAX_VIRTUAL_LED_WIDTH              931 //The width of Virtual LED is larger than limit value
#define  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN           932 //The character number of virtual LED is larger than limit value
#define     NET_ERR_SINGLE_OUTPUTPARAM_CONFIG            933//not support single output parameter configure
#define  NET_ERR_MULTI_WIN_BE_COVER                 934// multi windows be cover
#define  NET_ERR_WIN_NOT_EXIST                        935//window  does not exist
#define  NET_ERR_WIN_MAX_SIGNALSOURCE                936// the signal source number of the window is over the limit
#define  NET_ERR_MULTI_WIN_MOVE                        937// move the multi window
#define  NET_ERR_MULTI_WIN_YPBPR_SDI                938 // the YPBPR and SDI signal source  doesn't support 9/16 split
#define  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE            939  //difference type input board mix
#define  NET_ERR_SPLIT_WIN_CROSS                    940  //split the cross window
#define  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN            941  //split the not full screen window
#define  NET_ERR_SPLIT_WIN_MANY_WIN                    942  //split the window that only has single output
#define  NET_ERR_WINDOW_SIZE_OVERLIMIT              943   //window size over limit
#define  NET_ERR_INPUTSTREAM_ALREADY_JOINT           944    //input signal is already in joint 
#define  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT          945    //joint input signal number overlimit

#define  NET_ERR_LED_RESOLUTION                        946  //LED resolution greater than output resolution
#define  NET_ERR_JOINT_SCALE_OVERLIMIT              947  //joint scale overlimit
#define  NET_ERR_INPUTSTREAM_ALREADY_DECODE            948  //input signal is already decoding
#define  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE     949  //input signal does not support picture capture
#define  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN            950  //the signal can not show in multi split window

#define NET_ERR_MAX_WIN_OVERLAP                     951    //reach max allowed window overlap number
#define NET_ERR_STREAMID_CHAN_BOTH_VALID            952 //stream ID and channel cannot be valid both
#define NET_ERR_NO_ZERO_CHAN                        953 //device does not have zero channel
#define NEED_RECONNECT                                955 //need reconnect
#define NET_ERR_NO_STREAM_ID                        956 //stream ID does not exist
#define NET_DVR_TRANS_NOT_START                        957 //transcoding has not started
#define NET_ERR_MAXNUM_STREAM_ID                    958 //reach max stream ID number
#define NET_ERR_WORKMODE_MISMATCH                    959 //work mode mismatch
#define NET_ERR_MODE_IS_USING                        960 //already work in the selected mode
#define NET_ERR_DEV_PROGRESSING                        961 //device is progressing
#define NET_ERR_PASSIVE_TRANSCODING                    962 //passive transcoding
#define NET_ERR_RING_NOT_CONFIGURE                   964 //ring net not configed

#define NET_ERR_CLOSE_WINDOW_FIRST                    971  //when switching full frame rate show must close the window of the wall 
#define NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT        972  //input source of VGA/DVI/DP/HDMI/HDBase_T does not support 9/16 under full frame rate show
#define NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK   973  //reach max link number of one signal preview echo
#define NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION  974  //only a split screen window  support child window amplification 
#define NET_DVR_ERR_WINDOW_SIZE_PLACE  975  //Wrong window position. 
#define NET_DVR_ERR_RGIONAL_RESTRICTIONS  976  //Screen distance exceeds the limit.
#define NET_ERR_WNDZOOM_NOT_SUPPORT  977  //single window does not support child window full screen
#define NET_ERR_LED_SCREEN_SIZE  978  //LED  screen width or height is not correct
#define NET_ERR_OPEN_WIN_IN_ERROR_AREA  979  //open a window in the illegal area, the area can not include LED screen and LCD screen
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE  980  //tile pattern does not support roaming
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER  981  //tile pattern does not support layer covering 
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT  982  //tile pattern does not support split screen
#define NET_DVR_LED_WINDOWS_ALREADY_CLOSED  983  //the resolution of LED area output changes, the device has already closed all LED windows in this area
#define NET_DVR_ERR_CLOSE_WINDOWS  984  //Operation failed. Close the window first.
#define NET_DVR_ERR_MATRIX_LOOP_ABILITY            985 //Beyond the cycle decoding capacity.
#define NET_DVR_ERR_MATRIX_LOOP_TIME           986 //Invalid cycle decoding time.
#define NET_DVR_ERR_LINKED_OUT_ABILITY           987 //No more linked camera can be added.
#define NET_ERR_REACH_SCENE_MAX_NUM         988 //scene to upper limit 
#define NET_ERR_SCENE_MEM_NOT_ENOUGH        989 //insufficient memory to new scene
#define NET_ERR_RESOLUTION_NOT_SUPPORT_ODD_VOUT     990     //odd video output channel not support the resolution
#define NET_ERR_RESOLUTION_NOT_SUPPORT_EVEN_VOUT    991     //even video output channel not support the resolution

#define NET_DVR_CANCEL_WND_OPENKEEP_ATTR_FIRST    992     //open keep window can be closed only when it's open keep attribute is canceled
#define NET_SDK_LED_MODE_NOT_SUPPORT_SPLIT        993     //LED mode does not support window split screen
#define NET_ERR_VOICETALK_ONLY_SUPPORT_ONE_TALK   994     //only support one voice talk
#define NET_ERR_WND_POSITION_ADJUSTED             995     //the window position is adjusted by the device, and the application needs to get the location of the window again
#define NET_SDK_ERR_STARTTIME_CANNOT_LESSTHAN_CURTIME   996     //start time can not be less than the current time
#define NET_SDK_ERR_NEED_ADJUST_PLAN            997     //the scene has been associated with the plan, please delete the scene from the plan first
#define NET_ERR_UnitConfig_Failed     998 //When "Enable Unit Unification"is checked,the configuration errors of units configured under temperature measurement and units returned under system settings are different

//ability analyze error
#define XML_ABILITY_NOTSUPPORT                      1000  //not support
#define        XML_ANALYZE_NOENOUGH_BUF                1001        //no enough buf
#define        XML_ANALYZE_FIND_LOCALXML_ERROR            1002        //can not find local xml
#define        XML_ANALYZE_LOAD_LOCALXML_ERROR            1003        //local local xml error
#define        XML_NANLYZE_DVR_DATA_FORMAT_ERROR        1004        //device ability data format error
#define        XML_ANALYZE_TYPE_ERROR                    1005        //ability type error
#define        XML_ANALYZE_XML_NODE_ERROR                1006        //XML ability node format error
#define XML_INPUT_PARAM_ERROR                       1007  //input parameter error

#define NET_DVR_ERR_RETURNED_XML_DATA  1008  //XML data error returned from device

// transport and display error
#define NET_ERR_LEDAREA_EXIST_WINDOW        1051 //lead era exist window
#define NET_ERR_AUDIO_EXIST                 1052 //output exist audio
#define NET_ERR_MATERIAL_NAME_EXIST                1053 //material name already exist
#define NET_ERR_MATERIAL_APPROVE_STATE             1054 //material approve state error
#define NET_ERR_DATAHD_SIGNAL_FORMAT               1055 //already used hd do not support signal format

#define NET_ERR_SCENE_SWITCHING                    1056 //scene is switch
#define NER_ERR_DATA_TRANSFER                      1057 //device is transfering 
#define NET_ERR_DATA_RESTORE                       1058 //device is restoring
#define NET_ERR_CHECK_NOT_ENABLE                   1059  //check not enable
#define NET_ERR_AREA_OFFLINE                       1060  //area offline 
#define NET_ERR_SCREEN_TYPE                        1061 //screen Type not match
#define NET_ERR_MIN_OPERATE_UNIT                   1062 //min operate unit not match
#define NET_ERR_MAINHD_NOT_BACKUP                  1063 //main board not backup
#define NET_ERR_ONE_BACKUP_HD                      1064 //at least one normal hd
#define NET_ERR_CONNECT_SUB_SYSTEM_ABNORMAL     1065  //connect sub system abnormal
#define NET_ERR_SERIAL_PORT_VEST             1066     //serial port vest error
#define NET_ERR_BLOCKLIST_FULL        1067           //allow list full
#define NET_ERR_NOT_MATCH_SOURCE    1068         //source signal type not match
#define NET_ERR_CLOCK_VIRTUAL_LED_FULL    1069        //the virtual LED of clock full
#define NET_ERR_MAX_WIN_SIGNAL_LOOP_NUM   1070      //the window loop signals full
#define NET_ERR_RESOLUTION_NO_MATCH_FRAME 1071   //resolution not match current frame
#define NET_ERR_NOT_UPDATE_LOW_VERSION    1072   //not support update to low version firmware
#define NET_ERR_NO_CUSTOM_TO_UPDATE       1073   //no custom firmware can not update
#define NET_ERR_CHAN_RESOLUTION_NOT_SUPPORT_SPLIT  1074   //this output channel not support split screen
#define NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_SPLIT  1075    //super high definition not support split screen by 9/16
#define NET_ERR_MIRROR_IMAGE_BY_VIDEO_WALL         1076    //the mirror image error about video wall
#define NET_ERR_MAX_OSD_FONT_SIZE                  1077    //the byte of OSD spillover
#define NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_VIDEO_SET  1078  //high definition not support set video parameter
#define NET_ERR_TILE_MODE_NOT_SUPPORT_JOINT        1079  //tile mode not support joint
#define NET_ERR_ADD_AUDIO_MATRIX_FAILED         1080  //create audio matrix failed
#define NET_ERR_ONE_VIRTUAL_LED_AREA_BIND_ONE_AUDIO_AREA   1081  //one virtual LED area bind one audio area
#define NET_ERR_NAT_NOT_MODIFY_SERVER_NETWORK_PARAM   1082  //NAT mode cannot modify server network parameters
#define NET_ERR_ORIGINAL_CHECH_DATA_ERROR       1083     //Original data to check is wrong
#define NET_ERR_INPUT_BOARD_SPLICED_IN_DIFFERENT_NETWORKAREAS        1084  //inputBoards In Different NetworkAreas Cannot BeSpliced
#define NET_ERR_SPLICINGSOURCE_ONWALL_IN_DIFFERENT_NETWORKAREAS        1085  //Splicing Source Of Different NetworkAreas Cannot Be On The Wall
#define NET_ERR_ONWALL_OUTPUTBOARD_MODIFY_NETWORKAREAS   1086  //Output Boards That Are Bound To The TVWall Cannot Modify The NetworkArea
#define NET_ERR_LAN_AND_WAN_CANNOT_SAME_NET_SEGMENT   1087     //the LAN IP and the WAN IP cannot use the same network segment
#define NET_ERR_USERNAME_REPETITIVE        1088  //username repetitive
#define NET_ERR_ASSOCIATED_SAMEWALL_IN_DIFFERENT_NETWORKAREAS   1089  //Outputs of different data network areas cannot be associated with the same video wall
#define NET_ERR_BASEMAP_ROAM_IN_LED_AREA   1090     //LED area does not allow base map roaming
#define NET_ERR_VIRTUAL_LED_NOT_SUPPORT_4K_OUTPUT   1091    //Virtual LED not support display on 4K output
#define NET_ERR_BASEMAP_NOT_SUPPORT_4K_OUTPUT   1092    //Base map not support display on 4K output
#define NET_ERR_MIN_BLOCK_IN_VIRTUAL_LED_AND_OUTPUT   1093   //Min block in virtual LED and output
#define NET_ERR_485FIlE_VERSION_INVALID               1094   //485 file version invalid
#define NET_ERR_485FIlE_CHECK_ERROR               1095   //485 file check error
#define NET_ERR_485FIlE_ABNORMAL_SIZE               1096   //485 file abnormal size
#define NET_ERR_MODIFY_SUBBOARD_NETCFG_IN_NAT         1097   //can not modify subBoard net cfg in NAT
#define NET_ERR_OSD_CONTENT_WITH_ILLEGAL_CHARACTERS   1098   //OSD content contains illegal characters
#define NET_ERR_NON_SLAVE_DEVICE_INSERT_SYNC_LINE     1099   //Non-slave devices are prohibited from inserting sync lines
//Civil Error Code(1100~1200)

#define NET_ERR_PLT_USERID                          1100 //Verification platform Userid Error
#define NET_ERR_TRANS_CHAN_START                    1101 //Operation failed because of the transparent channel is open.
#define NET_ERR_DEV_UPGRADING                        1102 //Device Upgrading 
#define NET_ERR_MISMATCH_UPGRADE_PACK_TYPE          1103 //Upgrade Pack Type Mismatch
#define NET_ERR_DEV_FORMATTING                      1104 //Device Formatting
#define NET_ERR_MISMATCH_UPGRADE_PACK_VERSION       1105 //Upgrade Pack Version Mismatch
#define NET_ERR_PT_LOCKED                           1106 //PT locked

#define NET_DVR_LOGO_OVERLAY_WITHOUT_UPLOAD_PIC     1110 //logo overlay failed,without Upload Picture success
#define NET_DVR_ERR_ILLEGAL_VERIFICATION_CODE        1111 //illegal verification Code 
#define NET_DVR_ERR_LACK_VERIFICATION_CODE            1112 //lack verification Code
#define NET_DVR_ERR_FORBIDDEN_IP                    1113 //This IP address has been banned, do not allow the configuration (IP address filtering device support) 
#define NET_DVR_ERR_UNLOCKPTZ                       1114 //Invalid operation,Lock PTZ first before you save the settings.
#define NET_DVR_ERR_COUNTAREA_LARGE                 1116 //Invalid count area. The size of the count area exceeds the upper limit.
#define NET_DVR_ERR_LABEL_ID_EXCEED                 1117//label id exceed error
#define NET_DVR_ERR_LABEL_TYPE                      1118//label type error
#define NET_DVR_ERR_LABEL_FULL                      1119//label full error
#define NET_DVR_ERR_LABEL_DISABLED                  1120//label disabled error
#define NET_DVR_ERR_DOME_PT_TRANS_TO_DOME_XY        1121//dome PT translate to dome XY error
#define NET_DVR_ERR_DOME_PT_TRANS_TO_PANORAMA_XY    1122//dome PT translate to panorama XY error
#define NET_DVR_ERR_PANORAMA_XY_TRANS_TO_DOME_PT    1123//panorama XY translate to dome PT error
#define NET_DVR_ERR_SCENE_DUR_TIME_LESS_THAN_INTERV_TIME 1124//secene duration time less than interval time
#define NET_DVR_ERR_HTTP_BKN_EXCEED_ONE            1125//http broken only support one link
#define NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_WEBSOCKETS_FIRST    1126//Deleting failed. Turn off HTTPS, Enhanced SDK Service and Websockets on Network Service page first
#define NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_FIRST    1127//Deleting failed. Turn off HTTPS and Enhanced SDK Service on Network Service page first.
#define NET_DVR_ERR_PTZ_OCCUPIED_PRIORITY          1128// High priority PTZ control permission user operation
#define NET_DVR_ERR_INCORRECT_VIDEOAUDIO_ID        1129// Incorrect video channel ID or audio output channel
#define NET_DVR_ERR_REPETITIONTIME_OVER_MAXIMUM          1130// The  repetition Time is no more than maximum
#define NET_DVR_ERR_FORMATTING_FAILED                 1131// Formatting failed. Please try again.
#define NET_DVR_ERR_ENCRYPTED_FORMATTING_FAILED       1132// Encrypted formatting failed. Please try again.
#define NET_DVR_ERR_WRONG_PASSWORD                    1133// Wrong password. Please try again.
#define NET_DVR_ERR_EXPOSURE_SYNC                     1134// Exposure is synchronized, RGB configuration is forbidden. 



//2012-10-16 Error of alarmhost (1200~1300)
#define NET_ERR_SEARCHING_MODULE                    1201 // It is searching external modules
#define NET_ERR_REGISTERING_MODULE                  1202 // It is registering external modules
#define NET_ERR_GETTING_ZONES                        1203 // It is getting zone config parameters
#define NET_ERR_GETTING_TRIGGERS                    1204 // It is getting trigger config parameters
#define NET_ERR_ARMED_STATUS                        1205 // Armed status
#define    NET_ERR_PROGRAM_MODE_STATUS                    1206 // Program status
#define    NET_ERR_WALK_TEST_MODE_STATUS                1207 // Walk test status
#define    NET_ERR_BYPASS_STATUS                        1208 // Bypass status
#define NET_ERR_DISABLED_MODULE_STATUS                1209 // Function disabled
#define    NET_ERR_NOT_SUPPORT_OPERATE_ZONE            1210 // Not support operate zone
#define NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR            1211 // Not support mod module address
#define NET_ERR_UNREGISTERED_MODULE                    1212 // External is not registered
#define NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF        1213 // Public subsystem can not associate itself
#define NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM        1214 // It is exceeds associate numbers
#define NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM    1215 // The subsystem is associate by the public subsystem
#define    NET_ERR_ZONE_FAULT_STATUS                    1216 // Zone is fault status
#define  NET_ERR_SAME_EVENT_TYPE                    1217 // There is same event type in "Event cause alarm out on" and "Event cause alarm out off"    
#define NET_ERR_ZONE_ALARM_STATUS                    1218 // zone is alarm status    
#define NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT            1219 // expansion bus short circuit    
#define NET_ERR_PWD_CONFLICT                        1220  //password conflict
#define NET_ERR_PWD_CONFLICT                        1220  //password conflict
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_ZONE     1221
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_PU       1222
#define NET_ERR_DETECTOR_DISCONNECT                 1223
#define NET_ERR_CALL_BUSY                           1224    //device is on the phone call
#define NET_DVR_ERR_ZONE_TAMPER_STAUS                1225    //zone is in tamper status
#define NET_DVR_ERR_WIRELESS_DEV_REGISTER             1226    //Wireless device has be registered by other panel
#define NET_DVR_ERR_WIRELESS_DEV_ADDED                1227   //Wireless device has be added
#define NET_DVR_ERR_WIRELESS_DEV_OFFLINE              1228  //Wireless device is offline
#define NET_DVR_ERR_WIRELESS_DEV_TAMPER_STATUS         1229  //Wireless device is in temper status
#define NET_DVR_ERR_GPRS_PHONE_CONFLICT    1230   
#define NET_ERR_INIT_PASSWORD_NOT_MODIFY           1231    //the initial password has not been modified, other operations cannot be performed
#define NET_ERR_USER_DISABLED           1232    //user disabled
#define NET_ERR_DEVICE_DEBUGGING           1233    //the device is debugging
#define NET_ERR_GET_ALL_RETURN_OVER                    1300  //get all the returns number overrun 
#define NET_ERR_RESOURCE_USING                      1301  //information resources are in use and cannot be modified
#define NET_ERR_FILE_SIZE_OVERLIMIT                    1302  //the size of file is overlimit
//information publish server error code
#define NET_ERR_MATERIAL_NAME                       1303  //the name of the material illegal
#define NET_ERR_MATERIAL_NAME_LEN                   1304  //material name length is illegal
#define NET_ERR_MATERIAL_REMARK                     1305  //the remarks of the material is illegal
#define NET_ERR_MATERIAL_REMARK_LEN                 1306  //material remarks length is illegal
#define NET_ERR_MATERIAL_SHARE_PROPERTY             1307  //material shared property is illegal
#define NET_ERR_UNSUPPORT_MATERIAL_TYPE             1308  //material type is not supported
#define NET_ERR_MATERIAL_NOT_EXIST                  1309  //material does not exist
#define NET_ERR_READ_FROM_DISK                      1310  //failed to read material from the hard disk file
#define NET_ERR_WRITE_TO_DISK                       1311  //write material files to the hard drive failure
#define NET_ERR_WRITE_DATA_BASE                     1312  //write material database failure
#define NET_ERR_NO_APPROVED_NOT_EXPORT              1313  //not approved content can not export
#define NET_ERR_MATERIAL_EXCEPTION                  1314  //material exception
#define NET_ERR_NO_MISINFO                          1315  //no misinfo
#define NET_ERR_LAN_NOT_SUP_DHCP_CLIENT_CONFIGURATION   1316     //LAN does not support DHCP client configuration in routing mode
#define NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT       1317    //The resolution of each output port on the TV wall is inconsistent
#define NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT_UNBIND_OPTPORT_FIRST   1318    //The resolution of each output port on the TV wall is inconsistent. Please unbind the output port first.
#define NET_ERR_FOUR_K_OUTPUT_RESOLUTION_UNSUPPORT_NINE_TO_SIXTEEN_SPLIT_SCREEN    1319    //4K output resolution does not support 9/16 split screen
#define NET_ERR_SIGNAL_SOURCE_UNSUPPORT_CUSTOM_RESOLUTION  1320  //Signal source does not support this custom resolution
#define NET_ERR_DVI_UNSUPPORT_FOURK_OUTPUT_RESOLUTION      1321   //DVI does not support 4K output resolution
#define NET_ERR_BNC_UNSUPPORT_SOURCE_CROPPING              1322   //BNC does not support source cropping 
#define NET_ERR_OUTPUT_NOT_SUPPORT_VIDEOWALL_RESOLUTION      1323    //Output does not support videowall resolution

//screen interactive error code 
#define    NET_ERR_MAX_SCREEN_CTRL_NUM                    1351  //the number of control connections to screen is limited
#define    NET_ERR_FILE_NOT_EXIST                        1352  //the file is not exist
#define NET_ERR_THUMBNAIL_NOT_EXIST                    1353  //the thumbnail is not exist
#define NET_ERR_DEV_OPEN_FILE_FAIL                    1354  //the device failed to open the file
#define NET_ERR_SERVER_READ_FILE_FAIL                1355  //the screen server failed to read the file
#define NET_ERR_FILE_SIZE                            1356  //file size error
#define    NET_ERR_FILE_NAME                            1357  //file name error, file name is empty or illegal

#define NET_ERR_BROADCAST_BUSY                     1358     //device is on broadcasting
//2012-12-20 ITC ERROR(1400-1499)
#define NET_DVR_ERR_LANENUM_EXCEED                  1400  //Lane number exceed
#define NET_DVR_ERR_PRAREA_EXCEED                   1401  //Area exceed
#define NET_DVR_ERR_LIGHT_PARAM                     1402  //Light parameter error
#define NET_DVR_ERR_LANE_LINE_INVALID               1403  //Lane line invalid
#define NET_DVR_ERR_STOP_LINE_INVALID               1404  //Stop line invalid
#define NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID        1405  //Left or right line invalid
#define NET_DVR_ERR_LANE_NO_REPEAT                  1406  //Lane NO. repeat
#define NET_DVR_ERR_PRAREA_INVALID                  1407  //Area invalid
#define NET_DVR_ERR_LIGHT_NUM_EXCEED                1408  //Light number exceed
#define NET_DVR_ERR_SUBLIGHT_NUM_INVALID            1409  //Sublight number invalid
#define NET_DVR_ERR_LIGHT_AREASIZE_INVALID          1410  //Light area size invalid
#define NET_DVR_ERR_LIGHT_COLOR_INVALID             1411  //Light color invalid
#define NET_DVR_ERR_LIGHT_DIRECTION_INVALID         1412  //Light direction invalid    
#define NET_DVR_ERR_LACK_IOABLITY                    1413  //IO ablity invalid 

#define NET_DVR_ERR_FTP_PORT                        1414  //FTP port error
#define NET_DVR_ERR_FTP_CATALOGUE                   1415  //FTP catalogue error
#define NET_DVR_ERR_FTP_UPLOAD_TYPE                    1416  //FTP upload type error
#define NET_DVR_ERR_FLASH_PARAM_WRITE                1417  //Setting param flash write error
#define NET_DVR_ERR_FLASH_PARAM_READ                1418  //Getting param flash read error
#define NET_DVR_ERR_PICNAME_DELIMITER                1419  //Pic name delimiter error
#define NET_DVR_ERR_PICNAME_ITEM                    1420  //Pic name item error
#define NET_DVR_ERR_PLATE_RECOGNIZE_TYPE            1421  //Plate recognize type error
#define NET_DVR_ERR_CAPTURE_TIMES                    1422  //Capture times error
#define NET_DVR_ERR_LOOP_DISTANCE                    1423  //Loop distance error
#define NET_DVR_ERR_LOOP_INPUT_STATUS                1424  //Loop input status error
#define NET_DVR_ERR_RELATE_IO_CONFLICT                1425  //Related IO conflict
#define NET_DVR_ERR_INTERVAL_TIME                    1426  //Interval time error
#define NET_DVR_ERR_SIGN_SPEED                        1427  //Sign speed error
#define NET_DVR_ERR_PIC_FLIP                        1428  //Flip is used
#define NET_DVR_ERR_RELATE_LANE_NUMBER                1429  //Related lane number error
#define NET_DVR_ERR_TRIGGER_MODE                    1430  //Trigger mode error
#define NET_DVR_ERR_DELAY_TIME                        1431  //Delay time error
#define NET_DVR_ERR_EXCEED_RS485_COUNT                1432  //Exceed RS485 count
#define NET_DVR_ERR_RADAR_TYPE                        1433  //Radar type error
#define NET_DVR_ERR_RADAR_ANGLE                        1434  //Radar angle error
#define NET_DVR_ERR_RADAR_SPEED_VALID_TIME            1435  //Radar speed valid time error
#define NET_DVR_ERR_RADAR_LINE_CORRECT                1436  //Radar line correct error
#define NET_DVR_ERR_RADAR_CONST_CORRECT                1437  //Radar const correct error
#define NET_DVR_ERR_RECORD_PARAM                    1438  //Record param error
#define NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION        1439  //Light number and other param error
#define NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION            1440  //Light number and detection region error
#define NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM                1441  //Plate recognize Province param error

#define NET_DVR_ERR_SPEED_TIMEOUT                 1442    //IO Speed TimeOut Param error
#define NET_DVR_ERR_NTP_TIMEZONE                  1443    //NTP TimeZone Param error
#define NET_DVR_ERR_NTP_INTERVAL_TIME             1444    //NTP Interval Time error
#define NET_DVR_ERR_NETWORK_CARD_NUM              1445    //Network Card Num error
#define NET_DVR_ERR_DEFAULT_ROUTE                 1446    //Default Route error
#define NET_DVR_ERR_BONDING_WORK_MODE             1447    //Banding Work Mode error
#define NET_DVR_ERR_SLAVE_CARD                    1448    //Slave Card error
#define NET_DVR_ERR_PRIMARY_CARD                  1449    //Primary Card error
#define NET_DVR_ERR_DHCP_PPOE_WORK                1450    //DHCP and PPOE not Meanwhile start
#define NET_DVR_ERR_NET_INTERFACE                 1451    //Net Interface invalid
#define NET_DVR_ERR_MTU                           1452    //MTU Param invalid
#define NET_DVR_ERR_NETMASK                       1453    //Netmask address invalid
#define NET_DVR_ERR_IP_INVALID                    1454    //IP address invalid
#define NET_DVR_ERR_MULTICAST_IP_INVALID          1455    //Multicast IP address invalid
#define NET_DVR_ERR_GATEWAY_INVALID               1456    //Gateway address invalid
#define NET_DVR_ERR_DNS_INVALID                   1457    //DNS Param invalid
#define NET_DVR_ERR_ALARMHOST_IP_INVALID          1458    //AlarmHost IP invalid
#define NET_DVR_ERR_IP_CONFLICT                   1459    //IP address Conflict
#define NET_DVR_ERR_NETWORK_SEGMENT               1460    //IP not support Multi Network segment
#define NET_DVR_ERR_NETPORT                       1461    //NetPort param error
#define NET_DVR_ERR_PPPOE_NOSUPPORT               1462  //Unsupport Pppoe 
#define NET_DVR_ERR_DOMAINNAME_NOSUPPORT          1463  //Not Support Domain
#define NET_DVR_ERR_NO_SPEED                      1464  //Speed Not Enabled 
#define NET_DVR_ERR_IOSTATUS_INVALID              1465  //IO Status invalidIO
#define NET_DVR_ERR_BURST_INTERVAL_INVALID        1466  //Burst Interval invalid    
#define NET_DVR_ERR_RESERVE_MODE                  1467  //Reserve Mode invalid
#define NET_DVR_ERR_LANE_NO                       1468  //Lane No error
#define NET_DVR_ERR_COIL_AREA_TYPE                1469  //Coil Area Type error
#define NET_DVR_ERR_TRIGGER_AREA_PARAM            1470  //Trigger Area Param error
#define NET_DVR_ERR_SPEED_LIMIT_PARAM             1471  //Speed Limit Param error
#define NET_DVR_ERR_LANE_PROTOCOL_TYPE            1472  //Lane Protocol Type error
#define NET_DVR_ERR_INTERVAL_TYPE                 1473  //Capture Interval Type error
#define NET_DVR_ERR_INTERVAL_DISTANCE             1474  //Capture Interval Distance error
#define NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE       1475  //Rs485 Associate DevType error
#define NET_DVR_ERR_RS485_ASSOCIATE_LANENO        1476  //Rs485 Associate LaneNo error
#define NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485   1477  //LaneNo Associate MulitRs485 error
#define NET_DVR_ERR_LIGHT_DETECTION_REGION        1478  //Light Detection Region error
#define NET_DVR_ERR_DN2D_NOSUPPORT            1479  //Not Support Capture Frame 2D Noise Reduction
#define NET_DVR_ERR_IRISMODE_NOSUPPORT        1480  //Not Support IRIS Mode
#define NET_DVR_ERR_WB_NOSUPPORT              1481  //Not Support White Balance Mode
#define NET_DVR_ERR_IO_EFFECTIVENESS          1482  //IO Effectiveness invalid
#define NET_DVR_ERR_LIGHTNO_MAX               1483  //Access Detector Lights Red / Yellow Overrun
#define NET_DVR_ERR_LIGHTNO_CONFLICT          1484  //Access Detector Lights Red / Yellow Conflict     
#define NET_DVR_ERR_CANCEL_LINE                1485  //Trigger straight line error
#define NET_DVR_ERR_STOP_LINE               1486  //Subject line area stop line error
#define NET_DVR_ERR_RUSH_REDLIGHT_LINE      1487  //Red light trigger lines error
#define NET_DVR_ERR_IOOUTNO_MAX             1488  //IO output port number of cross-border
#define NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX    1489  //IO output port ahead of time overrun
#define NET_DVR_ERR_IOOUTNO_IOWORKTIME      1490  //IO output effective duration overrun
#define NET_DVR_ERR_IOOUTNO_FREQMULTI       1491  //IO Output No Freqmulti error
#define NET_DVR_ERR_IOOUTNO_DUTYRATE        1492  //IO Output No Dutyrate error
#define NET_DVR_ERR_VIDEO_WITH_EXPOSURE     1493  //To exposure flash onset, work does not support video
#define NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET   1494  //Plate flash brightness is automatically enabled only under license onset luminance compensation mode

#define NET_DVR_ERR_RECOGNIZE_TYPE_PARAM            1495 //Identify the types of illegal license plate recognition parameters (such as cars, car, back, forward, vehicle logo recognition etc.)
#define NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM      1496 //Brand identification card recognition area configuration parameter illegal judgment error
#define NET_DVR_ERR_PORT_CONFLICT                   1497 //Port Conflict
#define NET_DVR_ERR_LOOP_IP                         1498 //IP cannot be the loopback address
#define NET_DVR_ERR_DRIVELINE_SENSITIVE             1499 //Driveline sensitivity error.


#define NET_ERR_VQD_TIME_CONFLICT                    1500 //VQD Diagnostic period conflicts
#define NET_ERR_VQD_PLAN_NO_EXIST                    1501 //VQD Diagnostic plan does not exist
#define NET_ERR_VQD_CHAN_NO_EXIST                    1502 //VQD Monitoring point does not exist
#define NET_ERR_VQD_CHAN_MAX                        1503 //VQD Have reached the maximum number of plans
#define NET_ERR_VQD_TASK_MAX                        1504 //VQD Have reached the maximum number of Task

#define NET_SDK_GET_INPUTSTREAMCFG                  1551  //get input signal list
#define NET_SDK_AUDIO_SWITCH_CONTROL                1552 //sub win audio switch control
#define NET_SDK_GET_VIDEOWALLDISPLAYNO              1553 //get video wall display no
#define NET_SDK_GET_ALLSUBSYSTEM_BASIC_INFO         1554//get all system basic info
#define NET_SDK_SET_ALLSUBSYSTEM_BASIC_INFO         1555 //set all system basic info
#define NET_SDK_GET_AUDIO_INFO                      1556//get all audio info
#define NET_SDK_GET_MATRIX_STATUS_V50               1557 // get matrix status _V50
#define NET_SDK_DELETE_MONITOR_INFO                 1558
#define NET_SDK_DELETE_CAMERA_INFO                  1559


//ITC new Err Code(1600~1900)
#define NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES        1600 //Capture times exceed 2 in flash mode.
#define NET_DVR_ERR_REDAR_TYPE_CONFLICT             1601 //Radar type conflict.
#define NET_DVR_ERR_LICENSE_PLATE_NULL              1602 //License Plate is Null
#define NET_DVR_ERR_WRITE_DATABASE                  1603 //Write Database Error
#define NET_DVR_ERR_LICENSE_EFFECTIVE_TIME          1604 //License Plate Effective Time Error 
#define NET_DVR_ERR_PRERECORDED_STARTTIME_LONG      1605 //The pre recorded start time is greater than the number of illegal capture
#define NET_DVR_ERR_TRIGGER_RULE_LINE               1606 //Trigger rule line error
#define NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL 1607 //Left and right trigger line is not vertical
#define NET_DVR_ERR_FLASH_LAMP_MODE                 1608 //Flash lamp mode error
#define NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM            1609 //Illegal capture number error
#define NET_DVR_ERR_ILLEGAL_DETECTION_TYPE          1610 //Illegal detection type error
#define NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH   1611 //Positive back to trigger line height error
#define NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS    1612 //Mixed mode only supports capture type all targets

#define NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED  1613//Car sign speed Greaterthan limit Speed
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED  1614//Big Car sign speed Greaterthan limit Speed
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED  1615//Big Car sign speed Greaterthan car sign Speed
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED  1616//Big Car limit speed Greaterthan car limit Speed
#define NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT  1617//Big Car low speed limit Greaterthan car low speed limit
#define NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1618//Car limit speed Greaterthan car exception high speed
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1619//Big car limit speed Greaterthan car exception high speed
#define NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE  1620//Stopping more than straight lines trigger lines
#define NET_DVR_ERR_YELLOWLIGHTTIME_INVALID        1621//yellowlighttime setting error
#define NET_DVR_ERR_TRIGGERLINE1_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE2 1622//Trigger line 1 for Not Yield to Pedestrian detection cannot exceed trigger line 2
#define NET_DVR_ERR_TRIGGERLINE2_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE1 1623// Trigger line 2  for Not Yield to Pedestrian detection cannot exceed trigger line 1

//ACS Err Code
#define NET_ERR_TIME_OVERLAP                        1900 //time segment overlap
#define NET_ERR_HOLIDAY_PLAN_OVERLAP                1901 //holiday plan overlap
#define NET_ERR_CARDNO_NOT_SORT                     1902 //not sort card No.
#define NET_ERR_CARDNO_NOT_EXIST                    1903 //card No. inexist
#define NET_ERR_ILLEGAL_CARDNO                      1904 //card No. illegal
#define NET_ERR_ZONE_ALARM                          1905 //zone be arming
#define NET_ERR_ZONE_OPERATION_NOT_SUPPORT          1906 //zone don't support this operate
#define NET_ERR_INTERLOCK_ANTI_CONFLICT             1907 //interlock and anti conflict
#define NET_ERR_DEVICE_CARD_FULL                    1908 //card full(max 100 thousand)
#define NET_ERR_HOLIDAY_GROUP_DOWNLOAD              1909 //holiday group download error
#define NET_ERR_LOCAL_CONTROL_OFF                    1910 //local control off
#define NET_ERR_LOCAL_CONTROL_DISADD                1911 //local control disadd
#define NET_ERR_LOCAL_CONTROL_HASADD                1912 //local control hasadd
#define NET_ERR_LOCAL_CONTROL_DOORNO_CONFLICT        1913 //local control doorNO conflict
#define NET_ERR_LOCAL_CONTROL_COMMUNICATION_FAIL    1914 //local control communication fail
#define NET_ERR_OPERAND_INEXISTENCE                  1915 //operand inexistence
#define NET_ERR_LOCAL_CONTROL_OVER_LIMIT              1916 //local control over limit
#define NET_ERR_DOOR_OVER_LIMIT                         1917 //door over limit
#define NET_ERR_ALARM_OVER_LIMIT                         1918 //alarm over limit
#define NET_ERR_LOCAL_CONTROL_ADDRESS_INCONFORMITY_TYPE      1919 //local control address inconformity type
#define NET_ERR_NOT_SUPPORT_ONE_MORE_CARD           1920 //device not support one more card
#define NET_ERR_DELETE_NO_EXISTENCE_FACE            1921 //delete no existence face
#define NET_ERR_DOOR_SPECIAL_PASSWORD_REPEAT        1922 //door special password repeat
#define NET_ERR_AUTH_CODE_REPEAT                    1923 //auth code repeat
#define NET_ERR_DEPLOY_EXCEED_MAX                   1924 //deploy exceed max
#define NET_ERR_NOT_SUPPORT_DEL_FP_BY_ID            1925 //not support delete finger print by ID
#define NET_ERR_TIME_RANGE                          1926 //time range error
#define NET_ERR_CAPTURE_TIMEOUT                     1927 //capture timeout
#define NET_ERR_LOW_SCORE                           1928 //capture low score
#define NET_ERR_OFFLINE_CAPTURING                   1929 //busy no response

//VIS Error Code                                    
#define NET_DVR_ERR_OUTDOOR_COMMUNICATION            1950 //communication the door machine  abnormality
#define NET_DVR_ERR_ROOMNO_UNDEFINED                1951 //not configured  room No.
#define NET_DVR_ERR_NO_CALLING            1952 //no calling
#define NET_DVR_ERR_RINGING                1953 //rining
#define NET_DVR_ERR_IS_CALLING_NOW        1954 //calling
#define NET_DVR_ERR_NO_CALLING                        1952 //no call 
#define NET_DVR_ERR_RINGING                            1953 //ring the bell 
#define NET_DVR_ERR_IS_CALLING_NOW                    1954 //is calling now 
#define NET_DVR_ERR_LOCK_PASSWORD_WRONG             1955//Intelligent lock password mistake 
#define NET_DVR_ERR_CONTROL_LOCK_FAILURE            1956//Switch lock failure     
#define NET_DVR_ERR_CONTROL_LOCK_OVERTIME           1957//Switch lock timeout     
#define NET_DVR_ERR_LOCK_DEVICE_BUSY                1958//Intelligent lock device is busy 
#define NET_DVR_ERR_UNOPEN_REMOTE_LOCK_FUNCTION     1959//Remote lock function is not open 



#define NET_DVR_ERR_FILE_NOT_COMPLETE               2100     // File not complete
#define NET_DVR_ERR_IPC_EXIST                       2101    //IPC is exist
#define NET_DVR_ERR_ADD_IPC                         2102    //The channle has alread be added
#define NET_DVR_ERR_OUT_OF_RES                      2103    //Band is limited
#define NET_DVR_ERR_CONFLICT_TO_LOCALIP             2104    //IP address is conflict
#define NET_DVR_ERR_IP_SET                          2105    //IP address is illegal
#define NET_DVR_ERR_PORT_SET                        2106    //port is illeagl

#define NET_ERR_WAN_NOTSUPPORT                      2107     //not in the same WLAN/ not support securityquestion config or export GUID
#define NET_ERR_MUTEX_FUNCTION                      2108     //mutex function error
#define NET_ERR_QUESTION_CONFIGNUM                  2109     //security question amount error
#define NET_ERR_FACECHAN_NORESOURCE                 2110     //Face intelligent channel resource has run out 
#define NET_ERR_DATA_CALLBACK                       2111     //Data is callback
#define NET_ERR_ATM_VCA_CHAN_IS_RELATED             2112     //ATM vca channel is related 
#define NET_ERR_ATM_VCA_CHAN_IS_OVERLAPED           2113     //ATM vca channel is overlaped
#define NET_ERR_FACE_CHAN_UNOVERLAP_EACH_OTHER      2114     //Face channel can't overlap each other
#define NET_ERR_ACHIEVE_MAX_CHANNLE_LIMIT           2115     //Achieve max channel limit
#define NET_DVR_SMD_ENCODING_NORESOURSE             2116    //SMD insufficient encoding resources
#define NET_DVR_SMD_DECODING_NORESOURSE             2117    //SMD insufficient decoding resources
#define NET_DVR_FACELIB_DATA_PROCESSING             2118    //Facelib data is being processed
#define NET_DVR_ERR_LARGE_TIME_DIFFRENCE            2119    //Too large time difference between device and server
#define NET_DVR_NO_SUPPORT_WITH_PLAYBACK            2120    //Open the playback,this function is not supported
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_SMD         2121    //The channel has opened SMD,this function is not supported
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_FD          2122    //The channel has opened Face snap,this function is not supported
#define NET_DVR_ILLEGAL_PHONE_NUMBER                2123    //Illegal phone number
#define NET_DVR_ILLEGAL_CERITIFICATE_NUMBER         2124    //Illegal ceritificate number
#define NET_DVR_ERR_CHANNEL_RESOLUTION_NO_SUPPORT   2125   //Channel resolution is not supported
#define NET_DVR_ERR_CHANNEL_COMPRESSION_NO_SUPPORT  2126   //Channel compression is not supported
#define NET_DVR_ERR_CLUSTER_DEVICE_TOO_LESS                 2127  
#define NET_DVR_ERR_CLUSTER_DEL_DEVICE_CM_PLAYLOAD          2128  
#define NET_DVR_ERR_CLUSTER_DEVNUM_OVER_UPPER_LIMIT         2129  
#define NET_DVR_ERR_CLUSTER_DEVICE_TYPE_INCONFORMITY        2130  
#define NET_DVR_ERR_CLUSTER_DEVICE_VERSION_INCONFORMITY     2131  
#define NET_DVR_ERR_CLUSTER_IP_CONFLICT                     2132  
#define NET_DVR_ERR_CLUSTER_IP_INVALID                      2133  
#define NET_DVR_ERR_CLUSTER_PORT_CONFLICT                   2134  
#define NET_DVR_ERR_CLUSTER_PORT_INVALID                    2135  
#define NET_DVR_ERR_CLUSTER_USERNAEM_OR_PASSWORD_INVALID    2136  
#define NET_DVR_ERR_CLUSTER_DEVICE_ALREADY_EXIST            2137 
#define NET_DVR_ERR_CLUSTER_DEVICE_NOT_EXIST                2138  
#define NET_DVR_ERR_CLUSTER_NON_CLUSTER_MODE                2139  
#define NET_DVR_ERR_CLUSTER_IP_NOT_SAME_LAN                 2140  

#define NET_DVR_ERR_CAPTURE_PACKAGE_FAILED                  2141  //Capture package failed
#define NET_DVR_ERR_CAPTURE_PACKAGE_PROCESSING              2142  //Capture package processing
#define NET_DVR_ERR_SAFETY_HELMET_NO_RESOURCE               2143  //Safety helmet has insufficient detection resources
#define NET_DVR_NO_SUPPORT_WITH_ABSTRACT                    2144  //Open the abstract,this function is not supported
#define NET_DVR_ERR_TAPE_LIB_NEED_STOP_ARCHIVE              2145  //The tape library needs to stop archiving
#define NET_DVR_INSUFFICIENT_DEEP_LEARNING_RESOURCES        2146  //Deep learning resources exceed limits
#define NET_DVR_ERR_IDENTITY_KEY                            2147  //Identity key error
#define NET_DVR_MISSING_IDENTITY_KEY                        2148  //Identity key is missing
#define NET_DVR_NO_SUPPORT_WITH_PERSON_DENSITY_DETECT       2149  //Open the person density detect,this function is not supported
#define NET_DVR_IPC_RESOLUTION_OVERFLOW                     2150  //IPC resolution overflow
#define NET_DVR_IPC_BITRATE_OVERFLOW                        2151  //IPC bitrate overflow
#define NET_DVR_ERR_INVALID_TASKID                          2152  //Invalid taskid
#define NET_DVR_PANEL_MODE_NOT_CONFIG                       2153  //No configuration panel mode.
#define NET_DVR_NO_HUMAN_ENGINES_RESOURCE                   2154  //No human engines resource
#define NET_DVR_ERR_TASK_NUMBER_OVERFLOW                    2155  //Task number overflow
#define NET_DVR_ERR_COLLISION_TIME_OVERFLOW                 2156  //Collision time overflow
#define NET_DVR_ERR_CAPTURE_PACKAGE_NO_USB                  2157  //No usb when capture package
#define NET_DVR_ERR_NO_SET_SECURITY_EMAIL                   2158  //The security email is not set
#define NET_DVR_ERR_EVENT_NOTSUPPORT                        2159  //The event is not support
#define NET_DVR_ERR_PASSWORD_FORMAT                         2160  //The password format is wrong
#define NET_DVR_ACCESS_FRONT_DEVICE_PARAM_FAILURE           2161  //The device access front device param failure
#define NET_DVR_ACCESS_FRONT_DEVICE_STREAM_FAILURE          2162  //The device access front device stream failure
#define NET_DVR_ERR_USERNAME_FORMAT                         2163  //The username format is wrong
#define NET_DVR_ERR_UNOPENED_HIGH_RESOLUTION_MODE           2164  //High resolution mode is not open
#define NET_DVR_ERR_TOO_SMALL_QUATO                         2165  //Quota setting is too small
#define NET_DVR_ERR_EMAIL_FORMAT                            2166  //The email format is wrong
#define NET_DVR_ERR_SECURITY_CODE_FORMAT                    2167  //The security code format is wrong
#define NET_DVR_PD_SPACE_TOO_SMALL                          2168  //The array hard disk is too small
#define NET_DVR_PD_NUM_TOO_BIG                              2169  //The total number of array hard disks exceeds one half of the total number
#define NET_DVR_ERR_USB_IS_FULL                             2170  //USB is full
#define NET_DVR_EXCEED_MAX_SMD_TYPE                         2171  //The maximum type of SMD event is reached
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_BEHAVIOR            2172  //The channel is open for behavior analysis and does not support this function
#define NET_DVR_NO_BEHAVIOR_ENGINES_RESOURCE                2173  //Behavioral analysis resources are insufficient
#define NET_DVR_NO_RETENTION_ENGINES_RESOURCE               2174  //Personnel detention resources are insufficient
#define NET_DVR_NO_LEAVE_POSITION_ENGINES_RESOURCE          2175  //Leave position resources are insufficient
#define NET_DVR_NO_PEOPLE_NUM_CHANGE_ENGINES_RESOURCE       2176  //People number change resources are insufficient
#define NET_DVR_PANEL_MODE_NUM_OVER_LIMIT                   2177  //Exceeding the maximum number of panel mode
#define NET_DVR_SURROUND_MODE_NUM_OVER_LIMIT                2178  //Exceeding the maximum number of environmental mode
#define NET_DVR_FACE_MODE_NUM_OVER_LIMIT                    2179  //Exceeding the maximum number of face mode
#define NET_DVR_SAFETYCABIN_MODE_NUM_OVER_LIMIT             2180  //Exceeding the maximum number of safetycabin mode
#define NET_DVR_DETECT_REGION_RANGE_INVALID                 2181  //The detection area is illegal
#define NET_DVR_CHANNEL_CAPTURE_PICTURE_FAILURE             2182  //Channel capture failed
#define NET_DVR_VCACHAN_IS_NORESOURCE                       2183  //Smart channel resources run out
#define NET_DVR_IPC_NUM_REACHES_LIMIT                       2184  // The number of IPC channels reaches the upper limit
#define NET_DVR_IOT_NUM_REACHES_LIMIT                       2185  // The number of IOT channels reaches the upper limit
#define NET_DVR_IOT_CHANNEL_DEVICE_EXIST                    2186  //The current IOT channel has added devices
#define NET_DVR_IOT_CHANNEL_DEVICE_NOT_EXIST                2187  //There is no device in the current IOT channel
#define NET_DVR_INVALID_IOT_PROTOCOL_TYPE                   2188  //Illegal IOT protocol type
#define NET_DVR_INVALID_EZVIZ_SECRET_KEY                    2189  //Invalid ezviz secret key
#define NET_DVR_DUPLICATE_IOT_DEVICE                        2190  //Duplicate IOT devices
#define NET_DVR_SADP_MODIFY_FALIURE                         2191  //SADP modification failed
#define NET_DVR_IPC_NETWORK_ABNORMAL                        2192  //IPC network anomaly
#define NET_DVR_IPC_PASSWORD_ERROR                          2193  //IPC user name and password error
#define NET_DVR_ERROR_IPC_TYPE                              2194  //Wrong type of IPC
#define NET_DVR_ERROR_IPC_LIST_NOT_EMPTY                    2195  //The list of added IPC is not empty
#define NET_DVR_ERROR_IPC_LIST_NOT_MATCH_PAIRING            2196  //The IPC list does not match the pairing
#define NET_DVR_ERROR_IPC_BAD_LANGUAGE                      2197  //The IPC language does not match the device
#define NET_DVR_ERROR_IPC_IS_LOCKING                        2198  //The IPC is locking
#define NET_DVR_ERROR_IPC_NOT_ACTIVATED                     2199  //The IPC is not activated
#define NET_DVR_FIELD_CODING_NOT_SUPPORT                    2200  //Field coding is not supported
#define NET_DVR_ERROR_H323_NOT_SUPPORT_H265                 2201  //H323 video conference does not support H265 stream
#define NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_P       2202  //Under P mode, the exposure time is too large
#define NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_N       2203  //Under N mode, the exposure time is too large
#define NET_DVR_ERROR_PING_PROCESSING                       2204  //Ping is processing
#define NET_DVR_ERROR_PING_NOT_START                        2205  //Ping has not started
#define NET_DVR_ERROR_NEED_DOUBLE_VERIFICATION              2206  //Need double verification
#define NET_DVR_NO_DOUBLE_VERIFICATION_USER                 2207  //No double verification user
#define NET_DVR_CHANNEL_OFFLINE                             2208  //The channel is offline
#define NET_DVR_TIMESPAN_NUM_OVER_LIMIT                     2209  //Time periods exceeded the maximum number of supported
#define NET_DVR_CHANNEL_NUM_OVER_LIMIT                      2210  //The number of channels exceeds the maximum number of supported channels
#define NET_DVR_NO_SEARCH_ID_RESOURCE                       2211  //The searchID resources for the paging query are insufficient
#define NET_DVR_ERROR_ONEKEY_EXPORT                         2212  //Export is underway, please try again later
#define NET_DVR_NO_CITY_MANAGEMENT_ENGINES_RESOURCE         2213  //City management algorithm engine resources are insufficient
#define NET_DVR_NO_SITUATION_ANALYSIS_ENGINES_RESOURCE      2214  //Situation analysis engine resources are insufficient
#define NET_DVR_INTELLIGENT_ANALYSIS_IPC_CANNT_DELETE       2215  //Intelligent analysing ipc can not delete 
#define NET_DVR_NOSUPPORT_RESET_PASSWORD                    2216  //NVR does not support resetting passwords to IPC
#define NET_DVR_ERROR_IPC_NEED_ON_LAN                       2217  //IPC needs to be on LAN
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_SAFETY_HELMET       2218  //The channel has opened safety helmet,this function is not supported
#define NET_DVR_ERROR_GET_RESETPASSWORDTYPE_IS_ABNORMAL     2219  /*Reset password type exception for IPC*/
#define NET_DVR_ERROR_IPC_NOSUPPORT_RESET_PASSWORD          2220  /* Reset passwords are not supported by IPC*/
#define NET_DVR_ERROR_IP_IS_NOT_ONLY_ONE                    2221 /*The IPC IP is not unique*/
#define NET_DVR_NO_SUPPORT_WITH_SMD_OR_SCD                  2222  //Open the SMD/SCD,this function is not supported
#define NET_DVR_NO_SUPPORT_WITH_FD                          2223  //Open the FD,this function is not supported
#define NET_DVR_NO_FD_ENGINES_RESOURCE                      2224  //FD resources are insufficient
#define NET_DVR_ERROR_ONEKEY_REMOVE                         2225  //Remove is underway, please try again later
#define NET_DVR_FACE_PIP_BACKGROUND_CHANNEL_OVERFLOW        2226  //Face pip background channel overflow
#define NET_DVR_MICIN_CHANNEL_OCCUPIED                      2227  //Micin channel occupied
#define NET_DVR_IPC_CHANNEL_IS_IN_PIP                       2228  // ipc chan is in Pip, delete  IPC  invalid

#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_FACE_CONTRAST       2229  //The channel is open for face contrast and does not support this function

#define NET_DVR_INVALID_RECHARGE_CARD                       2230 //invalid recharge card
#define NET_DVR_CLOUD_PLATFORM_SERVER_EXCEPTION             2231 //cloud platform server exception
#define NET_DVR_OPERATION_FAILURE_WITHOUT_LOGIN             2232 //operation failure without login
#define NET_DVR_INVALID_ASSOCIATED_SERIAL_NUMBER            2233 //invalid associated serial number
#define NET_DVR_CLOUD_PLATFORM_ACCOUNT_NOT_EXIST            2234 //cloud platform account not exist
#define NET_DVR_DEVICE_SERIAL_NUMBER_REGISTERED             2235 //device serial number registered
#define NET_DVR_CONFERENCE_ROOM_NOT_EXIST                   2236 //conference room not exist
#define NET_DVR_NEED_DISABLED_ANALOG_CHANNEL                2237//need disabled analog channel
#define NET_DVR_STUDENT_ROLL_CALL_FAILURE                   2238//student roll call failure
#define NET_DVR_SUB_DEVICE_NOT_ENABLE_INDIVIDUAL_BEHAVIOR   2239//sub device not enable individual behavior
#define NET_DVR_SUB_DEVICE_CHANNEL_CONTROL_FAILED           2240//sub device channel control failed
#define NET_DVR_DEVICE_NOT_IN_CONFERENCE                    2241//device not in conference
#define NET_DVR_ALREADY_EXIST_CONFERENCE                    2242//already exist conference
#define NET_DVR_NO_SUPPORT_WITH_VIDEO_CONFERENCE            2243//no support with video conference
#define NET_DVR_START_INTERACTION_FAILURE                   2244//start interaction failure
#define NET_DVR_ASK_QUESTION_STARTED                        2245//ask question started
#define NET_DVR_ASK_QUESTION_CLOSED                         2246//ask question closed
#define NET_DVR_UNABLE_OPERATE_BY_HOST                      2247//unable operate by host
#define NET_DVR_REPEATED_ASK_QUESTION                       2248//repeated ask question
#define NET_DVR_SWITCH_TIMEDIFF_LESS_LIMIT                  2249/*Switch time difference less limit the value (10 minutes)*/
#define NET_DVR_CHANNEL_DEVICE_EXIST                        2250  //The current channel has added devices
#define NET_DVR_CHANNEL_DEVICE_NOT_EXIST                    2251  //There is no device in the current channel
#define NET_DVR_ERROR_ADJUSTING_RESOLUTION                  2252  //Disable target cropping before adjusting resolution
#define NET_DVR_SSD_FILE_SYSTEM_IS_UPGRADING                2253  //SSD file system is upgrading
#define NET_DVR_SSD_FILE_SYSTEM_IS_FORMAT                   2254  //SSD file system is format
#define NET_DVR_CHANNEL_IS_CONNECTING                       2255  //The current channel is connecting

#define NET_DVR_CHANNEL_STREAM_TYPE_NOT_SUPPORT             2257  //The current channel stream type is not supported
#define NET_DVR_CHANNEL_USERNAME_NOT_EXIST                  2258  //The current channel user name does not exist
#define NET_DVR_CHANNEL_ACCESS_PARAM_FAILURE                2259  //The current channel access parameter failed
#define NET_DVR_CHANNEL_GET_STREAM_FAILURE                  2260  //The current channel get stream failed
#define NET_DVR_CHANNEL_RISK_PASSWORD                       2261  //The current channel password is the risk password

#define NET_DVR_NO_SUPPORT_DELETE_STRANGER_LIB              2262  //Deleting stranger libraries is not supported
#define NET_DVR_NO_SUPPORT_CREATE_STRANGER_LIB              2263  //Creating stranger libraries is not supported

#define NET_DVR_NETWORK_PORT_CONFLICT                       2264  //network port conflict
#define NET_DVR_TRANSCODE_NO_RESOURCES                      2265  //Insufficient transcoding resources
#define NET_DVR_SSD_FILE_SYSTEM_ERROR                       2266  //SSD FileSystem Is Error
#define NET_DVR_INSUFFICIENT_SSD__FOR_FPD                   2267  //Insufficient SSD capacity for FPD
#define NET_DVR_ASSOCIATED_FACELIB_OVER_LIMIT               2268  //The number of associated faceLib reaches the upper limit
#define NET_DVR_NEED_DELETE_DIGITAL_CHANNEL                 2269  //The digital channel needs to be deleted
#define NET_DVR_ERR_FALL_DOWN_RULENUM_LIMIT                 2270  //Fall down rule num limit
#define NET_DVR_ERR_VIOLENT_MOTION_RULENUM_LIMIT            2271  //Violent motion rule num limit
#define NET_DVR_UPGRADE_ENGINE_VERSION_MISMATCH             2272  //upgrade package engine version mismatch

//Thermal error codes(3001 - 3500)
#define NET_DVR_ERR_NOTSUPPORT_DEICING              3001    //Notsupport Deicing
#define NET_DVR_ERR_THERMENABLE_CLOSE               3002    //Thermometry basic param enabled close 
#define NET_DVR_ERR_NOTMEET_DEICING                 3003    //The current temperature does not meet the manual de icing on the open condition 
#define NET_DVR_ERR_PANORAMIC_LIMIT_OPERATED        3004    //Panoramic maps and limit cannot be operated at the same time 
#define NET_DVR_ERR_SMARTH264_ROI_OPERATED          3005    //SmartH264 and ROI can not be operated at the same time 
#define NET_DVR_ERR_RULENUM_LIMIT   3006    //Rule Num Limit
#define NET_DVR_ERR_LASER_DEICING_OPERATED   3007    //Laser and deicing cannot be operated at the same time
#define NET_DVR_ERR_OFFDIGITALZOOM_OR_MINZOOMLIMIT   3008    //Turn off the digital zoom function or set the zoom limit to the minimum.
#define NET_DVR_ERR_FIREWAITING 3009 //Fire Waiting
#define NET_DVR_SYNCHRONIZEFOV_ERROR 3010 //
#define NET_DVR_CERTIFICATE_VALIDATION_ERROR 3011 //Certificate validation failed
#define NET_DVR_CERTIFICATES_NUM_EXCEED_ERROR 3012 //The number of certificates exceeded the upper limit
#define NET_DVR_RULE_SHIELDMASK_CONFLICT_ERROR 3013  //Regular zone conflicts with masked zone
#define NET_DVR_MOTOR_PREHEATING_ERROR 3014  //Motor preheating 
#define NET_DVR_PT_DEICING_ERROR 3015  //PT deicing

//IPC error codes(3501-4000)
#define NET_DVR_ERR_NO_SAFETY_HELMET_REGION            3501  //no safety helmet region
#define NET_DVR_ERR_UNCLOSED_SAFETY_HELMET             3502  //unclosed safety helmet
#define NET_DVR_ERR_MUX_RECV_STATE                     3503  // mux recv state error
#define NET_DVR_UPLOAD_HBDLIBID_ERROR                  3504  // HBDID or customHBDID Error
#define NET_DVR_NOTSUPPORT_SMALLER_RATIOS              3505  // This function cannot be set when the zoom ratio is smaller than 1 x

#define NET_ERR_NPQ_BASE_INDEX    8000    //NPQ base index
#define NET_ERR_NPQ_PARAM       (NET_ERR_NPQ_BASE_INDEX + 1)             //NPQ parameter error
#define NET_ERR_NPQ_SYSTEM      (NET_ERR_NPQ_BASE_INDEX + 2)             //NPQ system error
#define NET_ERR_NPQ_GENRAL      (NET_ERR_NPQ_BASE_INDEX + 3)             //NPQ gereral error
#define NET_ERR_NPQ_PRECONDITION    (NET_ERR_NPQ_BASE_INDEX + 4)         //NPQ precondition error
#define NET_ERR_NPQ_NOTSUPPORT        (NET_ERR_NPQ_BASE_INDEX + 5)       //NPQ not support

#define NET_ERR_NPQ_NOTCALLBACK    (NET_ERR_NPQ_BASE_INDEX + 100)        //NPQ NO callback
#define NET_ERR_NPQ_LOADLIB (NET_ERR_NPQ_BASE_INDEX + 101)               //NPQ library error
#define NET_ERR_NPQ_STEAM_CLOSE (NET_ERR_NPQ_BASE_INDEX + 104)           //NPQ stream close
#define NET_ERR_NPQ_MAX_LINK (NET_ERR_NPQ_BASE_INDEX + 110)              //NPQ max link
#define NET_ERR_NPQ_STREAM_CFG (NET_ERR_NPQ_BASE_INDEX + 111)            //NPQ stream config error
#define NET_ERR_NPQ_PLAYBACK_OVERSPEED (NET_ERR_NPQ_BASE_INDEX + 112)    //NPQ playbcak max speed
#define NET_ERR_NPQ_PLAYBACK_BELOWSPEED (NET_ERR_NPQ_BASE_INDEX + 113)   //NPQ playback min speed

//transdisp error codes 8501~9500
#define NET_ERR_UPGRADE_PROG_ERR                  8501                      //program execute error
#define NET_ERR_UPGRADE_NO_DEVICE                 8502                      //no device
#define NET_ERR_UPGRADE_NO_FILE                   8503                      //no find upgrade file
#define NET_ERR_UPGRADE_DATA_ERROR                8504                      //file data error
#define NET_ERR_UPGRADE_LINK_SERVER_ERR        8505                      //link server fail
#define NET_ERR_UPGRADE_OEMCODE_NOMATCH           8506                      //oemCode no match
#define NET_ERR_UPGRADE_FLASH_NOENOUGH            8507                      //flash no enough
#define NET_ERR_UPGRADE_RAM_NOENOUGH              8508                      //RAM no enough
#define NET_ERR_UPGRADE_DSPRAM_NOENOUGH           8509                      //DSP RAM no enough
#define NET_ERR_NOT_SUPPORT_CHECK                 8510                      //not support check
#define NET_ERR_LED_DEVICE_BUSY_CHECK             8511                      //led device busy in checking
#define NET_ERR_DEVICE_MEM_NOT_ENOUGH             8512                      //device mem not enough
#define NET_ERR_CHECK_PARAM                       8513                      //check param err
#define NET_ERR_RESOLUTION_OVER_LIMIT             8514                      //resolution over limit
#define NET_ERR_NO_CUSTOM_BASE                    8515                      //no custom base
#define NET_ERR_PRIORITY_LOWER                    8516                      //priority lower
#define NET_ERR_SEND_MESSAGE_EXCEPT               8517                      //send message except
#define NET_ERR_SENDCARD_UPGRADING                8518                      //sendcard upgrading
#define NET_ERR_NO_WIRELESS_NETCARD               8519                      //no wireless netcard
#define NET_ERR_LOAD_FS_FAIL                      8520                      //load from screen fail
#define NET_ERR_FLASH_UNSTORAGE_RECCARD           8521                      //Flash unstore receive card
#define NET_ERR_NOT_SUPPORT_SINGLE_NETWORKCARD_AGGREGA          8522        //not support single network card aggregation
#define NET_ERR_DISPLAYRESOLUTION_LESSTHAN_SMALLESTRESOLUTION     8523         //Display resolution is less than smallest resolution
#define NET_ERR_NOT_SUPPORT_LOCAL_SOURCE_DRAG_MORE              8524         //not support local sources drag more
#define NET_ERR_CANCEL_CURRENT_LED_AREA                   8525               //cancel the current led area first
#define NET_ERR_LED_OUT_ASSOCIATED_AREA                   8526               //led not in associated area
#define NET_ERR_MAX_VIRTUAL_LED_PICTURE_SIZE              8527              //virtual led picture size over limit
#define NET_ERR_DEVICE_CTRLED_BY_REMOTER                  8528              //device controlled by remoter
/*******************Global Error Code end**********************/

/*************************************************
Return value of NET_DVR_IsSupport () ,
the definition of bit 1 to bit 9 is below and TRUE means support
**************************************************/
#define NET_DVR_SUPPORT_DDRAW            0x01  // Support DIRECTDRAW,  otherwise Player can't work
#define NET_DVR_SUPPORT_BLT                0x02  // Display adapter supports BLT,  otherwise Player can't work
#define NET_DVR_SUPPORT_BLTFOURCC        0x04  // BLT supports color conversion,  otherwise,  Player will do RGB conversion in software mode; 
#define NET_DVR_SUPPORT_BLTSHRINKX        0x08  // BLT supports X- coordinate shrink,  otherwise,  Player will do it in software mode; 
#define NET_DVR_SUPPORT_BLTSHRINKY        0x10  // BLT supports Y- coordinate shrink,  otherwise,  Player will do it in software mode; 
#define NET_DVR_SUPPORT_BLTSTRETCHX        0x20  // BLT supports X- coordinate expand,  otherwise,  Player will do it in software mode; 
#define NET_DVR_SUPPORT_BLTSTRETCHY        0x40  // BLT supports Y- coordinate expand,  otherwise,  Player will do it in software mode; 
#define NET_DVR_SUPPORT_SSE                0x80  // CPU supports SSE commands, Intel Pentium3 or higher version supports SSE; 
#define NET_DVR_SUPPORT_MMX                0x100 // CPU supports MMX commands, Intel Pentium3 or higher version supports MMX

/**********************PTZ Commands begin*************************/
#define LIGHT_PWRON        2    // Switch on light 
#define WIPER_PWRON        3    // Switch on Wiper 
#define FAN_PWRON        4    // Switch on Fan 
#define HEATER_PWRON    5    // Switch on Heater 
#define AUX_PWRON1        6    // Switch on auxiliary equipment 1
#define AUX_PWRON2        7    // Switch on auxiliary equipment 2
#define SET_PRESET        8    // Configure Preset 
#define CLE_PRESET        9    // Clean Preset 

#define ZOOM_IN            11    // Zoom in
#define ZOOM_OUT        12    // Zoom out 
#define FOCUS_NEAR      13  // Focus in 
#define FOCUS_FAR       14  // Focus out
#define IRIS_OPEN       15  // Iris open 
#define IRIS_CLOSE      16  // Iris close 

#define TILT_UP            21    // PTZ tilt up 
#define TILT_DOWN        22    // PTZ tilt down
#define PAN_LEFT        23    // PTZ pan left 
#define PAN_RIGHT        24    // PTZ pan right
#define UP_LEFT            25    // PTZ turn up and left 
#define UP_RIGHT        26    // PTZ turn up and right 
#define DOWN_LEFT        27    // PTZ turn down and left 
#define DOWN_RIGHT        28    // PTZ turn down and right 
#define PAN_AUTO        29    // PTZ auto pan 

#define FILL_PRE_SEQ    30    // Add preset to sequence 
#define SET_SEQ_DWELL    31    // Set cruise point's residence time 
#define SET_SEQ_SPEED    32    // Set cruise point 
#define CLE_PRE_SEQ        33    // Delete preset from sequence 
#define STA_MEM_CRUISE    34    // Start recording trace 
#define STO_MEM_CRUISE    35    // Stop recoding trace  
#define RUN_CRUISE        36    // Start Cruise 
#define RUN_SEQ            37    // Start Sequence 
#define STOP_SEQ        38    // Stop Sequence 
#define GOTO_PRESET        39    // Go to preset 

#define SET_SEQ_START 41     //start cruise
#define SET_SEQ_END  42     //end cruise

#define DEL_SEQ         43  // delete cruise path
#define STOP_CRUISE            44    // stop cruise
#define DELETE_CRUISE        45    // delete cruise
#define DELETE_ALL_CRUISE    46    // delete all cruise

#define PAN_CIRCLE      50  // PTZ of the SS speed automatic circle scanning
#define DRAG_PTZ        51  // PTZ drag
#define LINEAR_SCAN     52  /* Area scanning */ //2014-03-15 
#define CLE_ALL_PRESET  53   /* Clean All Preset */ 
#define CLE_ALL_SEQ     54   /* Clean All Seq */ 
#define CLE_ALL_CRUISE  55   /* Clean All Cruise */ 

#define POPUP_MENU        56 /* Operation  Menu */

#define TILT_DOWN_ZOOM_IN    58    /* PTZ tilt down & Zoom in */
#define TILT_DOWN_ZOOM_OUT  59  /* PTZ tilt down & Zoom out */
#define PAN_LEFT_ZOOM_IN    60  /* PTZ pan left & Zoom in*/
#define PAN_LEFT_ZOOM_OUT   61  /* PTZ pan left & Zoom out*/
#define PAN_RIGHT_ZOOM_IN    62  /* PTZ pan right & Zoom in*/
#define PAN_RIGHT_ZOOM_OUT  63  /* PTZ pan right & Zoom out */
#define UP_LEFT_ZOOM_IN     64  /* PTZ turn up and left & Zoom in*/
#define UP_LEFT_ZOOM_OUT    65  /* PTZ turn up and left & Zoom Out*/
#define UP_RIGHT_ZOOM_IN    66  /* PTZ turn up and right & Zoom in*/
#define UP_RIGHT_ZOOM_OUT   67  /* PTZ turn up and right & Zoom Out*/
#define DOWN_LEFT_ZOOM_IN   68  /* PTZ turn down and left & Zoom in */
#define DOWN_LEFT_ZOOM_OUT  69  /* PTZ turn down and left & Zoom Out */
#define DOWN_RIGHT_ZOOM_IN    70  /* PTZ turn down and right & Zoom in */
#define DOWN_RIGHT_ZOOM_OUT    71  /* PTZ turn down and right & Zoom Out */
#define TILT_UP_ZOOM_IN        72    /* PTZ tilt up & Zoom in */
#define TILT_UP_ZOOM_OUT    73    /* PTZ tilt up & Zoom out */

#define DVR_VEHICLE_CONTROL_LIST   0x1 //Vehicle block and allow list data type (data type) 2013-11-04
/**********************PTZ Commands end*************************/

/*************************************************
Play Control Commands
Macro Definition
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl
**************************************************/
#define NET_DVR_PLAYSTART        1  // Start Play
#define NET_DVR_PLAYSTOP        2  // Stop Play
#define NET_DVR_PLAYPAUSE        3  // Pause Play
#define NET_DVR_PLAYRESTART        4  // Restore Play
#define NET_DVR_PLAYFAST        5  // Play faster
#define NET_DVR_PLAYSLOW        6  // Play slower
#define NET_DVR_PLAYNORMAL        7  // Normal Speed
#define NET_DVR_PLAYFRAME        8  // Play frame by frame
#define NET_DVR_PLAYSTARTAUDIO    9  // Open audio
#define NET_DVR_PLAYSTOPAUDIO    10 // Close audio
#define NET_DVR_PLAYAUDIOVOLUME    11 // Adjust volume 
#define NET_DVR_PLAYSETPOS        12 // Change the playback progress 
#define NET_DVR_PLAYGETPOS        13 // Get the playback progress
#define NET_DVR_PLAYGETTIME        14 // Get the played time (available when playback by time) 
#define NET_DVR_PLAYGETFRAME    15 // Get the played frame number (available when playback by file) 
#define NET_DVR_GETTOTALFRAMES  16 // Get total frame number of current file (available when playback by file) 
#define NET_DVR_GETTOTALTIME    17 // Get total time of current file (available when playback by file) 
#define NET_DVR_THROWBFRAME        20 // Discard B frame
#define NET_DVR_SETSPEED        24 // Setup stream speed
#define NET_DVR_KEEPALIVE        25 // Keep connection with server (if callback is blocked,  send it every 2 second) 
#define NET_DVR_PLAYSETTIME        26 // Set playback position according to absolute time 
#define NET_DVR_PLAYGETTOTALLEN    27 // Get total time length of all the detected files under playback by time mode
#define NET_DVR_PLAYSETTIME_V50    28//Set playback position according to absolute time (support time zone)
#define NET_DVR_PLAY_FORWARD    29 //change stream from reverse to forward
#define NET_DVR_PLAY_REVERSE    30 //change stream from froward to reverse
#define NET_DVR_SET_DECODEFFRAMETYPE 31 //Set decode frame type
#define NET_DVR_SET_TRANS_TYPE        32    //Set Transcodeing Type 
#define NET_DVR_PLAY_CONVERT    33 //playback decode
#define NET_DVR_START_DRAWFRAME 34 //start draw I Frame 
#define NET_DVR_STOP_DRAWFRAME  35 //stop draw I Frame
#define NET_DVR_CHANGEWNDRESOLUTION   36    //change wnd size
#define NET_DVR_RESETBUFFER	    37  //reset matrix decode buffer(remote playback file)
#define NET_DVR_VOD_DRAG_ING    38 //playback in drag 
#define NET_DVR_VOD_DRAG_END    39 //end of the playback drag 
#define NET_DVR_VOD_RESET_PLAYTIME    40 //reset playback time


#define PLAYM4_DECODE_NORMAIL              0   //normal
#define PLAYM4_DECODE_KEY_FRAME            1   //decode I frame
#define PLAYM4_DECODE_NONE                 2   //none 
#define PLAYM4_DECODE_TEMPORAL_LAYER_0     3   // half 
#define PLAYM4_DECODE_TEMPORAL_LAYER_1     4   //a quarter


//Remote Key//
/* key value send to CONFIG program */
#define KEY_CODE_1        1
#define KEY_CODE_2        2
#define KEY_CODE_3        3
#define KEY_CODE_4        4
#define KEY_CODE_5        5
#define KEY_CODE_6        6
#define KEY_CODE_7        7
#define KEY_CODE_8        8
#define KEY_CODE_9        9
#define KEY_CODE_0        10
#define KEY_CODE_POWER    11
#define KEY_CODE_MENU    12
#define KEY_CODE_ENTER    13
#define KEY_CODE_CANCEL 14
#define KEY_CODE_UP        15
#define KEY_CODE_DOWN    16
#define KEY_CODE_LEFT    17
#define KEY_CODE_RIGHT    18
#define KEY_CODE_EDIT    19
#define KEY_CODE_ADD    20
#define KEY_CODE_MINUS    21
#define KEY_CODE_PLAY    22
#define KEY_CODE_REC    23
#define KEY_CODE_PAN    24
#define KEY_CODE_M        25
#define KEY_CODE_A        26
#define KEY_CODE_F1        27
#define KEY_CODE_F2        28

/* for PTZ control */
#define KEY_PTZ_UP_START     KEY_CODE_UP
#define KEY_PTZ_UP_STOP         32

#define KEY_PTZ_DOWN_START     KEY_CODE_DOWN
#define KEY_PTZ_DOWN_STOP     33

#define KEY_PTZ_LEFT_START     KEY_CODE_LEFT
#define KEY_PTZ_LEFT_STOP     34

#define KEY_PTZ_RIGHT_START  KEY_CODE_RIGHT
#define KEY_PTZ_RIGHT_STOP     35

#define KEY_PTZ_AP1_START     KEY_CODE_EDIT /* Iris+ */
#define KEY_PTZ_AP1_STOP     36

#define KEY_PTZ_AP2_START     KEY_CODE_PAN /* Iris-  */
#define KEY_PTZ_AP2_STOP     37

#define KEY_PTZ_FOCUS1_START KEY_CODE_A /* Focus+ */
#define KEY_PTZ_FOCUS1_STOP  38

#define KEY_PTZ_FOCUS2_START KEY_CODE_M /* Focus-  */
#define KEY_PTZ_FOCUS2_STOP  39

#define KEY_PTZ_B1_START     40 /* Zoom+ */
#define KEY_PTZ_B1_STOP         41

#define KEY_PTZ_B2_START     42 /* Zoom-  */
#define KEY_PTZ_B2_STOP         43

//New in 9000
#define KEY_CODE_11             44
#define KEY_CODE_12             45
#define KEY_CODE_13             46
#define KEY_CODE_14             47
#define KEY_CODE_15             48
#define KEY_CODE_16             49

/*************************Parameter Configure Commands begin*******************************/
//Used for NET_DVR_SetDVRConfig and NET_DVR_GetDVRConfig,  pay attention to corresponding Structure

#define NET_DVR_GET_DEVICECFG        100        //Get DVR Parameters
#define NET_DVR_SET_DEVICECFG        101        //Set DVR Parameters
#define NET_DVR_GET_NETCFG            102        //Get Network Parameters
#define NET_DVR_SET_NETCFG            103        //Set Network Parameters
#define NET_DVR_GET_PICCFG            104        //Get Image Parameters
#define NET_DVR_SET_PICCFG            105        //Set Image Parameters
#define NET_DVR_GET_COMPRESSCFG        106        //Get Compression Parameters
#define NET_DVR_SET_COMPRESSCFG        107        //Set Compression Parameters
#define NET_DVR_GET_RECORDCFG        108        //Get Record Parameters
#define NET_DVR_SET_RECORDCFG        109        //Set Record Parameters
#define NET_DVR_GET_DECODERCFG        110        //Get PTZ Parameters
#define NET_DVR_SET_DECODERCFG        111        //Set PTZ Parameters
#define NET_DVR_GET_RS232CFG         112        //Get RS232 Parameters
#define NET_DVR_SET_RS232CFG        113        //Set RS232 Parameters
#define NET_DVR_GET_ALARMINCFG         114        //Get Alarm In Parameters
#define NET_DVR_SET_ALARMINCFG        115        //Set Alarm In Parameters
#define NET_DVR_GET_ALARMOUTCFG     116        //Get Alarm Out Parameters
#define NET_DVR_SET_ALARMOUTCFG        117        //Set Alarm Out Parameters
#define NET_DVR_GET_TIMECFG         118        //Get DVR time
#define NET_DVR_SET_TIMECFG            119        //Set DVR time
#define NET_DVR_GET_PREVIEWCFG         120        //Get Local Preview Parameters
#define NET_DVR_SET_PREVIEWCFG        121        //Set Local Preview Parameters
#define NET_DVR_GET_VIDEOOUTCFG     122        //Get Video Output Parameters
#define NET_DVR_SET_VIDEOOUTCFG        123        //Set Video Output Parameters
#define NET_DVR_GET_USERCFG         124        //Get User Parameters
#define NET_DVR_SET_USERCFG            125        //Set User Parameters
#define NET_DVR_GET_EXCEPTIONCFG     126        //Get Exception Parameters
#define NET_DVR_SET_EXCEPTIONCFG    127        //Set Exception Parameters
#define NET_DVR_GET_ZONEANDDST        128        //Get Time Zone & DST Parameters
#define NET_DVR_SET_ZONEANDDST        129        //Set Time Zone & DST Parameters
#define NET_DVR_GET_SHOWSTRING        130        //Get OSD Parameters
#define NET_DVR_SET_SHOWSTRING        131        //Set OSD Parameters
#define NET_DVR_GET_EVENTCOMPCFG    132        //Get Event Record Parameters
#define NET_DVR_SET_EVENTCOMPCFG    133        //Set Event Record  Parameters

#define NET_DVR_GET_FTPCFG            134        //get ftp parameters
#define NET_DVR_SET_FTPCFG            135        //set ftp parameters

#define NET_DVR_GET_AUXOUTCFG        140        //Get External Alarm Configuration
#define NET_DVR_SET_AUXOUTCFG        141        //Set External Alarm Configuration
#define NET_DVR_GET_PREVIEWCFG_AUX     142        //Get - S device dual output parameters
#define NET_DVR_SET_PREVIEWCFG_AUX    143        //Set - S device dual output parameters

#define NET_DVR_GET_PASSWORD_MANAGE_CFG 144        //get password manage parameters
#define NET_DVR_SET_PASSWORD_MANAGE_CFG    145        //set password manage parameters
#define NET_DVR_UNLOCK_USER             146        //unlock user
#define NET_DVR_GET_SECURITY_CFG         147        //Get Security parameters
#define NET_DVR_SET_SECURITY_CFG         148        //Set Security parameters
#define    NET_DVR_GET_LOCKED_INFO_LIST    149        //get all locked info


/*********************************Intelligence APIs Begin***************************************/

//VCA  (NET_VCA_RULECFG) 
#define NET_DVR_SET_RULECFG                    152  //Set rule of VCA
#define NET_DVR_GET_RULECFG                    153     //Get rule of VCA
//Track parameters of Speed dome (NET_DVR_TRACK_CFG) 
#define NET_DVR_SET_TRACK_CFG                160  //Set Speed dome config 
#define NET_DVR_GET_TRACK_CFG                161  //Get Speed dome config

//Config Commands for Getting Stream
#define NET_DVR_SET_IVMS_STREAMCFG            162     //Set IVMS Parameter for getting stream
#define NET_DVR_GET_IVMS_STREAMCFG            163     //Get IVMS Parameter

//Intelligent control parameter
#define NET_DVR_SET_VCA_CTRLCFG                164     //Set intelligent control parameter
#define NET_DVR_GET_VCA_CTRLCFG                165     //Get intelligent control parameter

//Mask Area,  NET_VCA_MASK_REGION_LIST
#define NET_DVR_SET_VCA_MASK_REGION            166     //Set Mask Area 
#define NET_DVR_GET_VCA_MASK_REGION            167     //Get Mask Area 

//Get/Set Enter ATM Region Commands,  NET_VCA_ENTER_REGION
#define NET_DVR_SET_VCA_ENTER_REGION        168     //Set region parameter
#define NET_DVR_GET_VCA_ENTER_REGION        169     //Get region parameter

//NET_VCA_LINE_SEGMENT_LIST
#define NET_DVR_SET_VCA_LINE_SEGMENT 170     //set vca line segment
#define NET_DVR_GET_VCA_LINE_SEGMENT 171     //get vca line segment

// ivms mask region,  NET_IVMS_MASK_REGION_LIST
#define NET_DVR_SET_IVMS_MASK_REGION        172     //SetIVMS mask region parameter 
#define NET_DVR_GET_IVMS_MASK_REGION        173     //GetIVMS mask region parameter 
// ivms enter detecting region,  NET_IVMS_ENTER_REGION
#define NET_DVR_SET_IVMS_ENTER_REGION        174     //Set IVMS enter region parameter 
#define NET_DVR_GET_IVMS_ENTER_REGION        175     //Get IVMS enter region parameter 

//IVMS VCA Config Commands
#define NET_DVR_SET_IVMS_BEHAVIORCFG        176    //Set IVMS VCA rule 
#define NET_DVR_GET_IVMS_BEHAVIORCFG        177    //Get IVMS VCA rule 

// IVMS Playback Search
#define NET_DVR_IVMS_SET_SEARCHCFG            178     //SetIVMS Playback Search parameter 
#define NET_DVR_IVMS_GET_SEARCHCFG            179       //GetIVMS Playback Search parameter 

// SDK_V35
#define NET_DVR_SET_POSITION_TRACK            180  // Set track scene configuration info
#define NET_DVR_GET_POSITION_TRACK            181  // Get track scene configuration info

#define NET_DVR_SET_CALIBRATION                182  // Set calibration info
#define NET_DVR_GET_CALIBRATION                183  // Get calibration info

#define NET_DVR_SET_PDC_RULECFG                184  // Set PDC counting rule
#define NET_DVR_GET_PDC_RULECFG                185  // Get PDC counting rule

#define NET_DVR_SET_PU_STREAMCFG            186  // Set PU stream configuration info
#define NET_DVR_GET_PU_STREAMCFG            187  // Get PU stream configuration info

#define NET_VCA_SET_IVMS_BEHAVIOR_CFG        192  // Set IVMS VCA without time period settings
#define NET_VCA_GET_IVMS_BEHAVIOR_CFG        193  // Get IVMS VCA without time period settings

//Global Target Size filter
#define NET_VCA_SET_SIZE_FILTER                194  //Set global target size filter
#define NET_VCA_GET_SIZE_FILTER                195  //Get global target size filter

#define NET_DVR_SET_TRACK_PARAMCFG            196  // Set local menu rules of speed dome
#define NET_DVR_GET_TRACK_PARAMCFG            197  // Get local menu rules of speed dome

#define NET_DVR_SET_DOME_MOVEMENT_PARAM        198  // Set movement parameters of speed dome
#define NET_DVR_GET_DOME_MOVEMENT_PARAM        199  // Get movement parameters of speed dome

/**************************************Intelligent APIs Begin**********************************/

#define NET_DVR_GET_PICCFG_EX        200        //Get Image Parameters  (Extended) 
#define NET_DVR_SET_PICCFG_EX        201        //Set Image Parameters  (Extended) 
#define NET_DVR_GET_USERCFG_EX         202        //Get User Parameters (Extended) 
#define NET_DVR_SET_USERCFG_EX        203        //Set User Parameters (Extended) 
#define NET_DVR_GET_COMPRESSCFG_EX    204        //Get Compression Parameters  (Extended) 
#define NET_DVR_SET_COMPRESSCFG_EX    205        //Set Compression Parameters  (Extended) 


#define NET_DVR_GET_NETAPPCFG        222        //Get Network Application Parameters NTP/DDNS/EMAIL
#define NET_DVR_SET_NETAPPCFG        223        //Set Network Application Parameters NTP/DDNS/EMAIL
#define NET_DVR_GET_NTPCFG            224        //Get Network Application Parameters NTP
#define NET_DVR_SET_NTPCFG            225        //Set Network Application Parameters NTP
#define NET_DVR_GET_DDNSCFG            226        //Get Network Application Parameters DDNS
#define NET_DVR_SET_DDNSCFG            227        //Set Network Application Parameters DDNS

//Corresponding with NET_DVR_EMAILPARA
#define NET_DVR_GET_EMAILCFG        228        //Get EMAIL Configuration
#define NET_DVR_SET_EMAILCFG        229        //Set EMAIL Configuration

#define NET_DVR_GET_NFSCFG            230        // NFS disk configuration 
#define NET_DVR_SET_NFSCFG            231        // NFS disk configuration 

#define NET_DVR_GET_SHOWSTRING_EX    238        //Get Extended OSD Parameters 
#define NET_DVR_SET_SHOWSTRING_EX    239        //Set Extended OSD Parameters
#define NET_DVR_GET_NETCFG_OTHER    244        //Get Network Parameters
#define NET_DVR_SET_NETCFG_OTHER    245        //Set Network Parameters 

//NET_DVR_EMAILCFG
#define NET_DVR_GET_EMAILPARACFG    250        //Get EMAIL parameters
#define NET_DVR_SET_EMAILPARACFG    251        //Setup EMAIL parameters


#define NET_DVR_GET_DDNSCFG_EX        274        //Get Extended DDNS Parameters
#define NET_DVR_SET_DDNSCFG_EX        275        //Set Extended DDNS Parameters


#define    NET_DVR_SET_PTZPOS            292        //Set PTZ Position
#define    NET_DVR_GET_PTZPOS            293        //Get PTZ Position
#define    NET_DVR_GET_PTZSCOPE        294        //Get PTZ Scope

#define NET_DVR_GET_AP_INFO_LIST                    305//Get wireless network resource settings
#define NET_DVR_SET_WIFI_CFG                        306    //Set wireless parameters for IP device
#define NET_DVR_GET_WIFI_CFG                        307    //Get wireless parameters for IP device
#define NET_DVR_SET_WIFI_WORKMODE                    308    //Set the network interface working mode of IP device 
#define NET_DVR_GET_WIFI_WORKMODE                    309    //Get the network interface working mode of IP device 
#define    NET_DVR_GET_WIFI_STATUS                        310    //Get wireless status for IP device

/*********************************Intelligent Traffic Event Begin***************************************/
#define NET_DVR_GET_REFERENCE_REGION        400     // Get reference region
#define NET_DVR_SET_REFERENCE_REGION        401     //Set reference region

#define NET_DVR_GET_TRAFFIC_MASK_REGION     402     //Get traffic event mask region
#define NET_DVR_SET_TRAFFIC_MASK_REGION     403     //Set traffic event mask region

// #define NET_DVR_GET_SCENE_MODE           404     // Get scenario mode
// #define NET_DVR_SET_SCENE_MODE           405     // Set scenario mode 

#define NET_DVR_SET_AID_RULECFG             404     // Set traffic event rule parameters
#define NET_DVR_GET_AID_RULECFG             405     // Get traffic event rule parameters

#define NET_DVR_SET_TPS_RULECFG             406     // Set traffic rule statistics
#define NET_DVR_GET_TPS_RULECFG             407     // Get traffic rule statistics    

#define NET_DVR_SET_LANECFG                    408        // Set traffic lane rules
#define    NET_DVR_GET_LANECFG                     409        // Get traffic lane rules
#define NET_DVR_GET_VCA_RULE_COLOR_CFG      410     // Get VCA Rule Relate Color Config
#define NET_DVR_SET_VCA_RULE_COLOR_CFG      411     // Set VCA Rule Relate Color Config     
#define NET_DVR_GET_SWITCH_LAMP_CFG         412     // Get Switch lamp Config
#define NET_DVR_SET_SWITCH_LAMP_CFG         413     // Set Switch lamp Config


/*********************************Intelligent traffic events end***************************************/
#define NET_DVR_SET_FACEDETECT_RULECFG      420      // Set face detection rule
#define NET_DVR_GET_FACEDETECT_RULECFG      421      // Get face detection rule

#define NET_DVR_SET_VEHICLE_RECOG_TASK      422      // Set Vehicle two recognition tasks 
#define NET_DVR_GET_VEHICLE_RECOG_TASK      423      // Get Vehicle two recognition tasks

#define NET_DVR_SET_TIMECORRECT                432      //set time corrrect(only operation,not configure)
#define    NET_DVR_GET_CONNECT_LIST            433         //get connect list
/***************************DS9000 New Commands (_V30)  begin *****************************/
//Network (NET_DVR_NETCFG_V30) 
#define NET_DVR_GET_NETCFG_V30                1000     //Get  Network  Parameters
#define NET_DVR_SET_NETCFG_V30                1001     //Set  Network  Parameters

//Image (NET_DVR_PICCFG_V30) 
#define NET_DVR_GET_PICCFG_V30                1002     //Get Image Parameters
#define NET_DVR_SET_PICCFG_V30                1003     //Set Image Parameters

//Record (NET_DVR_RECORD_V30) 
#define NET_DVR_GET_RECORDCFG_V30            1004        //Get Record Parameters
#define NET_DVR_SET_RECORDCFG_V30            1005     //Set Record Parameters

//User (NET_DVR_USER_V30) 
#define NET_DVR_GET_USERCFG_V30             1006     //Get User Parameters
#define NET_DVR_SET_USERCFG_V30                1007     //Set User Parameters

//Record (NET_DVR_RECORD_V40)
#define NET_DVR_GET_RECORDCFG_V40            1008    //Get Record Parameters(Extended)
#define NET_DVR_SET_RECORDCFG_V40            1009    //Set Record Parameters(Extended)

//9000DDNS Config (NET_DVR_DDNSPARA_V30) 
#define NET_DVR_GET_DDNSCFG_V30                1010     //Get DDNS  (9000Extended) 
#define NET_DVR_SET_DDNSCFG_V30                1011     //Set DDNS  (9000Extended) 

//EMAIL  (NET_DVR_EMAILCFG_V30) 
#define NET_DVR_GET_EMAILCFG_V30            1012     //Get EMAIL Configuration
#define NET_DVR_SET_EMAILCFG_V30            1013     //Set EMAIL Configuration

#define NET_DVR_GET_NETCFG_V50     1015    //Get network parameter configuration (V50) 
#define NET_DVR_SET_NETCFG_V50     1016    //Set network parameter configuration (V50) 

#define NET_GET_CRUISEPOINT_V40                1018     //Get CruisePoint V40

//Cruise  (NET_DVR_CRUISE_PARA) 
#define NET_DVR_GET_CRUISE                    1020        
#define NET_DVR_SET_CRUISE                    1021        


//Alarm input   (NET_DVR_ALARMINCFG_V30) 
#define NET_DVR_GET_ALARMINCFG_V30            1024        
#define NET_DVR_SET_ALARMINCFG_V30            1025

//Alarm output   (NET_DVR_ALARMOUTCFG_V30) 
#define NET_DVR_GET_ALARMOUTCFG_V30            1026        
#define NET_DVR_SET_ALARMOUTCFG_V30            1027

//Video output   (NET_DVR_VIDEOOUT_V30) 
#define NET_DVR_GET_VIDEOOUTCFG_V30            1028        
#define NET_DVR_SET_VIDEOOUTCFG_V30            1029    

//OSD   (NET_DVR_SHOWSTRING_V30) 
#define NET_DVR_GET_SHOWSTRING_V30            1030        
#define NET_DVR_SET_SHOWSTRING_V30            1031

//Exception   (NET_DVR_EXCEPTION_V30) 
#define NET_DVR_GET_EXCEPTIONCFG_V30        1034        
#define NET_DVR_SET_EXCEPTIONCFG_V30        1035

//RS232   (NET_DVR_RS232CFG_V30) 
#define NET_DVR_GET_RS232CFG_V30            1036        
#define NET_DVR_SET_RS232CFG_V30            1037

//Structure of Setting Network Hard Disk Drive   (NET_DVR_NET_DISKCFG struct) 
#define    NET_DVR_GET_NET_DISKCFG                1038        //Get the configuration of Network Hard Disk Drive    
#define    NET_DVR_SET_NET_DISKCFG                1039        //Set the configuration of Configuring Network Hard Disk Drive


//Encoding   (NET_DVR_COMPRESSIONCFG_V30) 
#define NET_DVR_GET_COMPRESSCFG_V30            1040        
#define NET_DVR_SET_COMPRESSCFG_V30            1041        

//RS485   (NET_DVR_DECODERCFG_V30) 
#define NET_DVR_GET_DECODERCFG_V30            1042        //Get Decoder Parameters
#define NET_DVR_SET_DECODERCFG_V30            1043        //Set Decoder parameters

//Preview   (NET_DVR_PREVIEWCFG_V30) 
#define NET_DVR_GET_PREVIEWCFG_V30            1044        //Get Preview Parameters
#define NET_DVR_SET_PREVIEWCFG_V30            1045        //Set Preview Parameters

//AUX Preview  (NET_DVR_PREVIEWCFG_AUX_V30) 
#define NET_DVR_GET_PREVIEWCFG_AUX_V30        1046        //Get AUX Preview Parameters
#define NET_DVR_SET_PREVIEWCFG_AUX_V30        1047        //Set AUX Preview Parameters

//IP Channel Configuration  (NET_DVR_IPPARACFG) 
#define NET_DVR_GET_IPPARACFG                1048        //Get IP Channel Configuration info 
#define NET_DVR_SET_IPPARACFG                1049        //Set IP Channel Configuration info 

//IP Alarm In Configuration  (NET_DVR_IPALARMINCFG) 
#define NET_DVR_GET_IPALARMINCFG            1050        //Get IP Alarm In Configuration info
#define NET_DVR_SET_IPALARMINCFG            1051        //Set IP Alarm In Configuration info

//IP Alarm Out Configuration  (NET_DVR_IPALARMOUTCFG) 
#define NET_DVR_GET_IPALARMOUTCFG            1052        //Get IP Alarm Out Configuration info  
#define NET_DVR_SET_IPALARMOUTCFG            1053        //Set IP Alarm Out Configuration info 

//HD management Configuration  (NET_DVR_HDCFG) 
#define NET_DVR_GET_HDCFG                    1054        //Get HD management Configuration
#define NET_DVR_SET_HDCFG                    1055        //Get HD management Configuration

//HD Group Configuration  (NET_DVR_HDGROUP_CFG) 
#define NET_DVR_GET_HDGROUP_CFG                1056        //Get HD Group Configuration Parameters
#define NET_DVR_SET_HDGROUP_CFG                1057        //Set HD Group Configuration Parameters

//Device AudioTalk Configuration (NET_DVR_COMPRESSION_AUDIO) 
#define NET_DVR_GET_COMPRESSCFG_AUD            1058        //Get AudioTalk Configuration Parameters
#define NET_DVR_SET_COMPRESSCFG_AUD            1059        //Set AudioTalk Configuration Parameters

//2008- 08- 25
//IP Camera parameter (NET_DVR_IPPARACFG_V31 struct) 
#define NET_DVR_GET_IPPARACFG_V31            1060        //Get IP device parameter 
#define NET_DVR_SET_IPPARACFG_V31            1061        //Set IP device parameter 

//Channel resource configuration(NET_DVR_IPPARACFG_V40 structure)
#define NET_DVR_GET_IPPARACFG_V40            1062        // Get IP device parameter V40
#define NET_DVR_SET_IPPARACFG_V40            1063        // Set IP device parameter V40



//2009- 10- 26 snap device begin

#define NET_DVR_GET_CCDPARAMCFG              1067       //Get IPC CCD parameters
#define NET_DVR_SET_CCDPARAMCFG              1068       //Set IPC CCD parameters

#define NET_DVR_GET_IOINCFG                     1070       //Get I0 input parameters
#define NET_DVR_SET_IOINCFG                     1071        //Set IO input parameters

#define NET_DVR_GET_IOOUTCFG                 1072       //Get I0 output parameters
#define NET_DVR_SET_IOOUTCFG                 1073        //Set IP output parameters

#define NET_DVR_GET_FLASHCFG                 1074       //Get io flash parameters
#define NET_DVR_SET_FLASHCFG                 1075        //Set io flash parameters

#define NET_DVR_GET_LIGHTSNAPCFG             1076       //Get light parameters
#define NET_DVR_SET_LIGHTSNAPCFG             1077        //Set light parameters

#define NET_DVR_GET_MEASURESPEEDCFG             1078       //Get measure speed parameters
#define NET_DVR_SET_MEASURESPEEDCFG             1079        //Set measure speed parameters

#define NET_DVR_GET_IMAGEOVERLAYCFG             1080       //Get image overlay parameters
#define NET_DVR_SET_IMAGEOVERLAYCFG             1081       //Set image overlay parameters

#define NET_DVR_GET_SNAPCFG                     1082       //Get single IO parameters
#define NET_DVR_SET_SNAPCFG                     1083       //Set single IO parameters

#define NET_DVR_GET_VTPPARAM                 1084       //Get virtual circuit parameters
#define NET_DVR_SET_VTPPARAM                 1085       //Set virtual circuit parameters

#define NET_DVR_GET_SNAPENABLECFG             1086       //Get snap enable parameters
#define NET_DVR_SET_SNAPENABLECFG             1087       //Set snap enable parameters

#define NET_DVR_GET_POSTEPOLICECFG           1088       //Get police parameters
#define NET_DVR_SET_POSTEPOLICECFG           1089       //Set police parameters

#define NET_DVR_GET_JPEGCFG_V30                 1090        //Get JPEG parameters
#define NET_DVR_SET_JPEGCFG_V30                 1091        //Set JPEG parameters

#define NET_DVR_GET_SPRCFG                     1092       //Get configuration of license plate recognition
#define NET_DVR_SET_SPRCFG                     1093       //Set configuration of license plate recognition

#define NET_DVR_GET_PLCCFG                   1094       //Get brightness compensation configuration of license plate
#define NET_DVR_SET_PLCCFG                   1095       //Set brightness compensation configuration of license plate

#define NET_DVR_GET_DEVICESTATECFG           1096       //Get current status of device
#define NET_DVR_SET_CALIBRATE_TIME           1097       //Set calibrate time
#define NET_DVR_GET_CALIBRATE_TIME           1098       //Get calibrate time

#define NET_DVR_GET_DEVICECFG_V40             1100       //Get extended device parameters 
#define NET_DVR_SET_DEVICECFG_V40             1101       //Set extended device parameters 

#define NET_DVR_GET_ZEROCHANCFG              1102        //Get Zero channel compression parameters
#define NET_DVR_SET_ZEROCHANCFG               1103        //Set Zero channel compression parameters

#define NET_DVR_GET_ZERO_PREVIEWCFG_V30      1104       //Get Zero channel live view parameters
#define NET_DVR_SET_ZERO_PREVIEWCFG_V30      1105       //Set Zero channel live view parameters


#define NET_DVR_SET_ZERO_ZOOM                 1106       //Set Zero channel zoom configuration 
#define NET_DVR_GET_ZERO_ZOOM                 1107       //Get Zero channel zoom configuration 

//2010- 04- 13 Add NAT configuration
#define    NET_DVR_NATASSOCIATECFG_GET          1110       //Get NAT function configuration info
#define    NET_DVR_NATASSOCIATECFG_SET             1111       //Set NAT function configuration info

#define NET_DVR_GET_SNMPCFG                    1112       //Get SNMP parameters
#define NET_DVR_SET_SNMPCFG                   1113       //Set SNMP parameters

#define NET_DVR_GET_SNMPCFG_V30                1114        //Get SNMPv30 parameters 
#define NET_DVR_SET_SNMPCFG_V30               1115        //Set SNMPv30 parameters

//2010- 06- 01 Video Management System alarm configuration
#define    NET_DVR_VIDEOPLATFORMALARMCFG_GET      1130       //Get Video Management System alarm configuration
#define    NET_DVR_VIDEOPLATFORMALARMCFG_SET     1131       //Set Video Management System alarm configuration

#define NET_DVR_GET_RAID_ADAPTER_INFO        1134       //Get RAID adapter's information
#define NET_DVR_SET_RAID_ADAPTER_INFO        1135       //Get adapter information
//Big Screen Splice
#define    NET_DVR_MATRIX_BIGSCREENCFG_GET         1140       //Get Parameter
#define    NET_DVR_MATRIX_BIGSCREENCFG_SET         1141        //Set Parameter

#define NET_DVR_GET_MB_PLATFORMPARA             1145        //Get platform parameter
#define NET_DVR_SET_MB_PLATFORMPARA             1146        //Set platform parameter
#define NET_DVR_GET_MB_DEVSTATUS             1147        //Get mobile device status

#define  NET_DVR_GET_DECODER_JOINT_CHAN         1151
#define  NET_DVR_SET_DECODER_JOINT_CHAN         1152
//Multi network card parameter
#define NET_DVR_GET_NETCFG_MULTI             1161        //Get multi network card parameter
#define NET_DVR_SET_NETCFG_MULTI             1162        //Set multi network card parameter
#define NET_DVR_GET_NETCFG_MULTI_V50         1163        //Get multi network card parameter(group)
#define NET_DVR_SET_NETCFG_MULTI_V50         1164        //Set multi network card parameter(group)

#define NET_DVR_GET_CMSPARA                     1170       //Get CMS CFG
#define NET_DVR_SET_CMSPARA                     1171       //Set CMS CFG
#define NET_DVR_GET_DIALSTATUS                 1172       //Get Dial Status
#define NET_DVR_GET_SMSRELATIVEPARA             1173       //Get SMS Relative CFG
#define NET_DVR_SET_SMSRELATIVEPARA             1174       //Set SMS Relative CFG
#define NET_DVR_GET_PINSTATUS                 1175       //Get Pin Status
#define NET_DVR_SET_PINCMD                     1176       //Set PIN CMD

#define NET_DVR_SET_SENSOR_CFG                 1180       //Set sensor parameter 
#define NET_DVR_GET_SENSOR_CFG                 1181       //Get sensor parameter 
#define NET_DVR_SET_ALARMIN_PARAM             1182        //Set alarm input parameter 
#define NET_DVR_GET_ALARMIN_PARAM             1183        //Get alarm input parameter 
#define NET_DVR_SET_ALARMOUT_PARAM             1184        //Set alarm output parameter 
#define NET_DVR_GET_ALARMOUT_PARAM             1185        //Get alarm output parameter 
#define NET_DVR_SET_SIREN_PARAM                 1186        //Set siren parameter 
#define NET_DVR_GET_SIREN_PARAM                 1187        //Get siren parameter 
#define NET_DVR_SET_ALARM_RS485CFG             1188        //Set alarm host RS-485 parameter 
#define NET_DVR_GET_ALARM_RS485CFG             1189        //Get alarm host RS-485 parameter 
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS     1190        //Get alarm host main status 
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS     1191        //Get alarm host other status
#define NET_DVR_SET_ALARMHOST_ENABLECFG         1192        //Set alarm host enable status
#define NET_DVR_GET_ALARMHOST_ENABLECFG         1193        //Get alarm host enable status
#define NET_DVR_SET_ALARM_CAMCFG             1194        //Set configation of video integrated platform alarm triggering CAM operation
#define NET_DVR_GET_ALARM_CAMCFG             1195        //Get configation of video integrated platform alarm triggering CAM operation
#define NET_DVR_GET_GATEWAY_CFG              1196       //Get gateway configuration 
#define NET_DVR_SET_GATEWAY_CFG              1197       //Set gateway configuration
#define NET_DVR_GET_ALARMDIALMODECFG         1198        //Get alarm dial parameter
#define NET_DVR_SET_ALARMDIALMODECFG         1199        //Set alarm dial parameter
#define NET_DVR_SET_ALARMIN_PARAM_V50            1200        // Set alarm input parameterV50
#define NET_DVR_GET_ALARMIN_PARAM_V50            1201            // Get alarm input parameterV50
#define    NET_DVR_SET_WINCFG                        1202//set windows cfg

#define NET_DVR_GET_ALARMHOSTDIALSETUPMODE     1204        //Get alarm dial setup mode
#define NET_DVR_SET_ALARMHOSTDIALSETUPMODE     1205        //Set alarm dial setup mode

//video alarm host V1.3
#define NET_DVR_SET_SUBSYSTEM_ALARM             1210        //Set system alarm
#define NET_DVR_GET_SUBSYSTEM_ALARM             1211        //get system alarm
#define NET_DVR_GET_ALLOWLIST_ALARM             1215        //set allowlist alarm
#define NET_DVR_SET_ALLOWLIST_ALARM             1216        //get allowlist alarm
#define    NET_DVR_GET_ALARMHOST_MODULE_LIST     1222        //get All module
#define NET_DVR_SET_PRIOR_ALARM                 1223        //set prior alarm
#define NET_DVR_GET_PRIOR_ALARM                 1224        //set prior alarm
#define NET_DVR_SET_TAMPER_ALARMIN_PARAM     1225        // set tamper alarm in param
#define NET_DVR_GET_TAMPER_ALARMIN_PARAM     1226        // get tamper alarm in param

#define NET_DVR_GET_HOLIDAY_PARAM_CFG        1240       //Get holiday parameter
#define NET_DVR_SET_HOLIDAY_PARAM_CFG        1241       //Set holiday parameter

#define NET_DVR_GET_MOTION_HOLIDAY_HANDLE    1242       //Get holiday alarm handling mode of motion detection
#define NET_DVR_SET_MOTION_HOLIDAY_HANDLE    1243       //Set holiday alarm handling mode of motion detection

#define NET_DVR_GET_VILOST_HOLIDAY_HANDLE    1244       //Get holiday alarm handling mode of video signal lost
#define NET_DVR_SET_VILOST_HOLIDAY_HANDLE    1245       //Set holiday alarm handling mode of video signal lost

#define NET_DVR_GET_HIDE_HOLIDAY_HANDLE      1246       //Get holiday alarm handling mode of video tampering
#define NET_DVR_SET_HIDE_HOLIDAY_HANDLE      1247       //Set holiday alarm handling mode of video tampering

#define NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE   1248       //Get holiday alarm handling mode of alarm input
#define NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE   1249       //Set holiday alarm handling mode of alarm input

#define NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE  1250       //Get holiday alarm handling mode of alarm output
#define NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE  1251       //Set holiday alarm handling mode of alarm output

#define NET_DVR_GET_HOLIDAY_RECORD           1252       //Get holiday recording parameter
#define NET_DVR_SET_HOLIDAY_RECORD           1253       //Set holiday recording parameter

#define NET_DVR_GET_NETWORK_BONDING          1254       //Get BONDING network card parameter
#define NET_DVR_SET_NETWORK_BONDING          1255       //Set BONDING network card parameter

#define NET_DVR_GET_LINK_STATUS              1256       //Get link status of channel

#define NET_DVR_GET_DISK_QUOTA_CFG           1278       //Get disk quota configuration
#define NET_DVR_SET_DISK_QUOTA_CFG           1279       //Set disk quota configuration

#define NET_DVR_GET_JPEG_CAPTURE_CFG         1280       //Get capture configuration
#define NET_DVR_SET_JPEG_CAPTURE_CFG         1281       //Set capture configuration

#define NET_DVR_GET_SCHED_CAPTURECFG         1282       //Get capture schedule configuration
#define NET_DVR_SET_SCHED_CAPTURECFG         1283       //Set capture schedule configuration

#define NET_DVR_GET_VGA_PREVIEWCFG           1284       //Get VGA preview configuration
#define NET_DVR_SET_VGA_PREVIEWCFG           1285       //Set VGA preview configuration 

#define NET_DVR_GET_VIDEO_INPUT_EFFECT       1286       //Get the video effect
#define NET_DVR_SET_VIDEO_INPUT_EFFECT       1287       //Set the video effect

#define NET_DVR_GET_STORAGE_SERVER_SWITCH     1290       //Get Storage Server Switch
#define NET_DVR_SET_STORAGE_SERVER_SWITCH     1291       //Set Storage Server Switch

#define NET_DVR_GET_DISK_QUOTA_CFG_V60          1292     //Get disk quota configurationV60
#define NET_DVR_SET_DISK_QUOTA_CFG_V60          1293     //Set disk quota configurationV60

#define NET_DVR_GET_OPTICAL_CHANNEL             1300        //Get coder subsystem optical channel relation
#define NET_DVR_SET_OPTICAL_CHANNEL             1301        //Set coder subsystem optical channel relation
#define NET_DVR_GET_FIBER_CASCADE             1302        //Get fiber cascade mode
#define NET_DVR_SET_FIBER_CASCADE             1303        //Set fiber cascade mode
#define NET_DVR_GET_SPARTAN_STATUS             1304        //Get spatan status
#define NET_DVR_SET_SPARTAN_STATUS             1305        //Set spatan status
#define NET_DVR_GET_ETHERNET_CHANNEL         1306        //Get ethernet channel configuration
#define NET_DVR_SET_ETHERMET_CHANNEL         1307        //Set ethernet channel configuration
#define NET_DVR_OPTICAL_REBOOT                 1320        //Reboot optical transceiver
#define NET_DVR_SET_AUDIOCHAN_CFG            1321        //set audio switch configuration
#define NET_DVR_GET_AUDIOCHAN_CFG            1322        //get audio switch configuration

//SDI1.0
#define NET_DVR_SET_MATRIX_BASE_CFG             1332     //set SDI matrix base config
#define NET_DVR_GET_MATRIX_BASE_CFG             1333     //get SDI matrix base config
#define NET_DVR_SWITCH_MATRIX_IO                1334     //switch matrix the relation of input and ouput
#define NET_DVR_GET_MATRIX_IO_RELATION          1335     //get matrix IO relation 

#define    NET_DVR_V6PSUBSYSTEMARAM_GET         1501        //get V6 subsystem config
#define    NET_DVR_V6PSUBSYSTEMARAM_SET         1502        //set V6 subsystem config
#define    NET_DVR_GET_ALLWINCFG                 1503        //get screen window information
#define    NET_DVR_BIGSCREENASSOCIATECFG_GET     1511 //get big screen associate information
#define    NET_DVR_BIGSCREENASSOCIATECFG_SET     1512 //et big screen associate information

#define    NET_DVR_GETSCREENINFO                 1601        //Get big screen information
#define    NET_DVR_SETSCREENINFO                 1602        //Set big screen information
#define    NET_DVR_GET_SCREEN_WINCFG             1603        //Get single window parameter 
#define    NET_DVR_LAYOUTLIST_GET                  1605        //Get layout list
#define    NET_DVR_SET_LAYOUTCFG                 1606        //Set layout
#define    NET_DVR_LAYOUTCTRL                     1607        //Layout control,1-open,2-close
#define    NET_DVR_INPUTLIST_GET                 1608        //Get signal source list
#define    NET_DVR_SET_INPUTSTREAMCFG             1609        //Set signal source
#define    NET_DVR_OUTPUT_SET                     1610        //Set output parameter
#define    NET_DVR_OUTPUT_GET                     1611        //Get output parameter
//2011-11-2
#define    NET_DVR_SET_OSDCFG                     1612        //Set OSD parameter
#define    NET_DVR_GET_OSDCFG                     1613        //Get OSD parameter
#define    NET_DVR_BIGSCREEN_GETSERIAL             1614        //Get serial information
#define    NET_DVR_GET_PLANLIST                1615        //get plan list
#define    NET_DVR_SET_PLAN                    1616        //set plan
#define    NET_DVR_CTRL_PLAN                    1617        //control plan
#define    NET_DVR_GET_DEVICE_RUN_STATUS        1618        //get the running status of the device
#define NET_DVR_GET_EXTERNAL_MATRIX_CFG        1619        //get matrix config
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG        1620        //set matrix config
#define    NET_DVR_GET_OUTPUT_SCREEN_RELATION    1621        //get the relation of screen and output channel
#define    NET_DVR_SET_OUTPUT_SCREEN_RELATION    1622        //set the relation of screen and output channel
#define NET_DVR_GET_VCS_USER_CFG            1623        //get user config
#define    NET_DVR_SET_VCS_USER_CFG            1624        //set user config
#define    NET_DVR_CONTROL_SCREEN                1625        //control screen
#define    NET_DVR_GET_EXTERNAL_MATRIX_CFG_V50        1626    //get matrix config
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG_V50        1627    //set matrix config
/********************************dvcs begin****************************/
/*1650~1700*/
#define NET_DVR_GET_DEV_BASEINFO             1650        // get single sub device base information
#define NET_DVR_SET_DEV_BASEINFO             1651        // set single sub device base information
#define NET_DVR_GET_DEV_NETINFO                 1652        // get single sub device net information
#define NET_DVR_SET_DEV_NETINFO                 1653        // set single sub device net information
#define NET_DVR_GET_SIGNAL_SOURCE_INFO         1654        // get signal source information
#define NET_DVR_SET_SIGNAL_SOURCE_INFO         1655        // set signal source information
#define NET_DVR_ADJUST_PIC_V40                 1656        // adjust picture
#define NET_DVR_RESTORE_V40                     1657        // restore default
#define    NET_DVR_SET_NET_SIGNAL                 1658        // set net signal
#define NET_DVR_REBOOT_V40                     1659        // reboot 
#define NET_DVR_CONTROL_PICTURE_V41             1660        // control picture 
#define NET_DVR_GET_AUTO_REBOOT_CFG          1710       // get auto reboot config
#define NET_DVR_SET_AUTO_REBOOT_CFG          1711       // set auto reboot config


#define     NET_DVR_GET_TRUNK_USE_STATE     1713    //Get trunk use state
#define     NET_DVR_SET_PTZ_CTRL_INFO         1714    //Set PTZ control information
#define     NET_DVR_GET_PTZ_CTRL_INFO         1715    //Get PTZ control information
#define     NET_DVR_GET_PTZ_STATUS             1716    //Get PTZ status
#define        NET_DVR_GET_DISP_ROUTE_LIST        1717    //Get disp route list

#define NET_DVR_GET_DEC_RESOURCE_LIST            1720//get available decode resource list
#define NET_DVR_SET_DEC_RESOURCE_LIST            1721//pre alloc decode resource
#define NET_DVR_GET_DEC_YUV                        1722//get decode channel relate YUV
#define NET_DVR_SET_DEC_YUV                        1723//set  decode channel relate YUV
#define NET_DVR_GET_DEC_RESOUCE                    1724//apply decode resource
#define NET_DVR_FREE_DEC_RESOURCE                1725//release decode resource

#define NET_DVR_SET_VIDEOWALLDISPLAYMODE        1730    //set video wall display mode
#define NET_DVR_GET_VIDEOWALLDISPLAYMODE        1731    //get video wall display mode
#define NET_DVR_GET_VIDEOWALLDISPLAYNO          1732    //get No. of video wall display channels
#define    NET_DVR_SET_VIDEOWALLDISPLAYPOSITION    1733    //set the position of each display channel
#define    NET_DVR_GET_VIDEOWALLDISPLAYPOSITION    1734    //get the position of each display channel
#define NET_DVR_GET_VIDEOWALLWINDOWPOSITION     1735    //get the position of each window on the video wall
#define NET_DVR_SET_VIDEOWALLWINDOWPOSITION     1736    //set the position of each window on the video wall
#define    NET_DVR_VIDEOWALLWINDOW_CLOSEALL        1737    //close all windows on the video wall
#define    NET_DVR_SET_VIRTUALLED                    1738    //set virtual led config
#define    NET_DVR_GET_VIRTUALLED                    1739    //get virtual led config
#define NET_DVR_GET_IMAGE_CUT_MODE              1740    //get the mode of image cut
#define NET_DVR_SET_IMAGE_CUT_MODE              1741    //set the mode of image cut
#define NET_DVR_GET_USING_SERIALPORT            1742    //get current using serial port
#define NET_DVR_SET_USING_SERIALPORT            1743    //set current using serial port
#define NET_DVR_SCENE_CONTROL                   1744    //scene control
#define NET_DVR_GET_CURRENT_SCENE               1745    //get current scene
#define NET_DVR_GET_VW_SCENE_PARAM              1746    //get video wall scene parameter
#define NET_DVR_SET_VW_SCENE_PARAM              1747    //set video wall scene parameter
#define NET_DVR_DISPLAY_CHANNO_CONTROL          1748    //display channel No. display control
#define NET_DVR_GET_WIN_DEC_INFO                1749    //get window decode information
#define NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION  1750  //Cancel the TV wall output interface binding
#define NET_DVR_SET_VW_AUDIO_CFG                1752    //set audio configure 
#define    NET_DVR_GET_VW_AUDIO_CFG                1753    //get audio configure 
#define NET_DVR_GET_GBT28181_DECCHANINFO_CFG    1754    //get decode channel information in the device using GBT28181 protocol
#define NET_DVR_SET_GBT28181_DECCHANINFO_CFG    1755    //set decode channel information in the device using GBT28181 protocol
#define    NET_DVR_SET_MAINBOARD_SERIAL            1756    //set main board serial parameter
#define    NET_DVR_GET_MAINBOARD_SERIAL            1757    //get main board serial parameter
#define NET_DVR_GET_SUBBOARD_INFO               1758    //get sub board information
#define NET_DVR_GET_SUBBOARD_EXCEPTION          1759    //get exception sub board information

#define NET_DVR_GET_CAMERACHAN_SERIALCFG        1760   //get Camera related serial port configuration
#define NET_DVR_SET_CAMERACHAN_SERIALCFG        1761   //set Camera related serial port configuration
#define NET_DVR_GET_MATRIX_STATUS                1762   //get matrix status
#define    NET_SET_MULTIFUNCTION_SERIALCFG         1763   //set multi function serial port configuration
#define    NET_GET_MULTIFUNCTION_SERIALCFG            1764   //get multi function serial port configuration
#define NET_DVR_PTZ_3D_SPEED                    1765   //3D PTZ control with speed

#define NET_DVR_GET_SIGNAL_JOINT                1766   //get signal joint configuration
#define NET_DVR_SET_SIGNAL_JOINT                1767   //set signal joint configuration
#define NET_DVR_SIGNAL_CUT                        1768   //cut signal
#define NET_DVR_DYNAMIC_DECODE_BATCH            1769   //start batch dynamic decode
#define NET_DVR_DECSWITCH_SET_BATCH                1770   //batch decode switch set
#define NET_DVR_DECSWITCH_GET_BATCH                1771   //batch decode switch get
#define NET_DVR_GET_ALL_SIGNAL_JOINT            1772   //get all joint signal configuration
#define    NET_DVR_GET_PLAYING_PLAN                1773   //get current playing plan No.
#define NET_DVR_WALL_RELATION_GET                1774   //get device wall and real wall relation configuration
#define NET_DVR_WALL_RELATION_SET                1775   //set device wall and real wall relation configuration
#define    NET_DVR_SET_INPUTSTREAMCFG_V40            1776   //set input signal configuration
#define NET_DVR_PTZCFG_INPUTSTREAM_GET            1777   //get input signal PTZ configuration
#define NET_DVR_PTZCFG_INPUTSTREAM_SET            1778   //set input signal PTZ configuration
#define NET_DVR_SIGNAL_CUTPARAM_GET                1779   //get input signal cut parameter

#define NET_DVR_GET_SUBSYSTEM_NETCFG            1780    // Get Subsystem netcard parameter
#define NET_DVR_SET_SUBSYSTEM_NETCFG              1781    // Set Subsystem netcard parameter
#define    NET_DVR_DEL_SIGNAL_JOINT                1782    //delete joint signal

#define NET_DVR_GET_PICTURE_INFO                1783     //get picture information
#define NET_DVR_SET_PICTURE_INFO                1784     //set picture information
#define NET_DVR_GET_VIDEO_INFO                    1785     //get video information
#define NET_DVR_SET_VIDEO_INFO                    1786     //set video information
#define NET_DVR_SET_PLAYLIST                    1787     //set play list
#define NET_DVR_GET_PLAYLIST                    1788     //get play list
#define NET_DVR_GET_ALL_PLAYLIST                1789     //get all play list
#define NET_DVR_PLAYITEM_CONTROL                1790     //play item control
#define NET_DVR_SET_PLAYPLAN_TEMPLATE            1791     //set play plan
#define NET_DVR_GET_PLAYPLAN_TEMPLATE            1792     //get play plan
#define NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE        1793     //get all play plan
#define NET_DVR_SET_WINDOW_PLAYPLAN                1794     //set window's play plan
#define NET_DVR_GET_WINDOW_PLAYPLAN                1795     //get window's play plan
#define NET_DVR_TOPLAY_ITEM                        1796     //assign play item
#define NET_DVR_DEVICE_PLAY_CONTROL                1797     //paly control
#define NET_DVR_GET_PLAY_INFO                    1798     //get current play information
#define NET_DVR_GET_ALL_PICTURE_INFO            1799     //get all pictures's information
#define NET_DVR_GET_ALL_VIDEO_INFO                1800     //get all videos's information
#define NET_DVR_DELETE_VIDEO_FILE                1801     //delete video file

#define NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG     2001        //    Get alarm subsystem
#define NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG     2002        //    Set alarm subsystem
#define NET_DVR_GETEXTENDALARMININFO         2003        //    Get alarm info
#define NET_DVR_MODIFYALARMINNO              2004        //    mod alarm info

#define NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG         2005        // Get GPRS info
#define    NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG         2006        // Set GPRS info
#define    NET_DVR_GET_ALARMHOST_NETCFG         2007        // Get Net info
#define    NET_DVR_SET_ALARMHOST_NETCFG         2008        // Set Net info

#define     NET_DVR_GET_LED_SCREEN_CFG        2009    // Get LED Parameter
#define     NET_DVR_SET_LED_SCREEN_CFG        2010    // Set LED Parameter
#define     NET_DVR_GET_LED_CONTENT_CFG        2011    // Get LED Content
#define        NET_DVR_SET_LED_CONTENT_CFG        2012    // Set LED Content
#define     NET_DVR_TURNON_LED                2013    // turn on LED
#define     NET_DVR_TURNOFF_LED                2014    // turn off LED
#define     NET_DVR_GET_LED_TIMER_SWITCH    2015    // Get LED timer switch
#define     NET_DVR_SET_LED_TIMER_SWITCH    2016    // Set LED timer switch
#define     NET_DVR_SET_LED_BRIGHTNESS        2017    // set LED brightness
#define     NET_DVR_GET_LED_TIMER_BRIGHTNESS 2018    // set timer brightness
#define     NET_DVR_SET_LED_TIMER_BRIGHTNESS 2019    // get timer brightness
#define     NET_DVR_LED_CHECKTIME            2020    // LED checktime

//2009-2020,2023 use for DS-19C08-JN V2.0
#define     NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM        2021 //Get audio associate alarm
#define     NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM        2022 //set audio associate alarm

#define        NET_DVR_GET_LED_STATUS            2023        //get LED status

#define NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM        2027       // Close subsystem fault alarm
#define NET_DVR_SET_SUBSYSTEM_BYPASS            2028       // subsystem bypass
#define NET_DVR_CANCEL_SUBSYSTEM_BYPASS            2029       // subsystem bypass resume

#define  NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX                2030            //Get subsystem external config parameter
#define     NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX                2031            //Set subsystem external config parameter
#define  NET_DVR_GET_ALARMHOST_PRINTER_CFG                    2032            //Get Printer config parameter
#define     NET_DVR_SET_ALARMHOST_PRINTER_CFG                    2033            //Set Printer config parameter
#define     NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM        2034            //Get all zones in the subsystem
#define     NET_DVR_GET_ALARMHOST_TRIGGER_LIST                    2035            //Get all the triggers
#define     NET_DVR_ARM_ALARMHOST_SUBSYSTEM                    2036            //subsystem arm and disarm
#define     NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG        2037            //Get event cause alarm out config parameter
#define  NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG        2038            //Set event cause alarm out config parameter
#define     NET_DVR_GET_ALARMHOST_FAULT_CFG                    2039            //Get fault process config parameter
#define  NET_DVR_SET_ALARMHOST_FAULT_CFG                    2040            //Set fault process config parameter
#define  NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE             2041            //Auto search
#define     NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE            2042            //Auto register
#define  NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM         2043            //Close Overall fault alarm

#define NET_DVR_GET_SAFETYCABIN_WORK_MODE            2044 //get safety cabin work mode parameter
#define NET_DVR_SET_SAFETYCABIN_WORK_MODE            2045 //set safety cabin work mode parameter
#define NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG   2046 //get safety cabin person signal parameter
#define NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG   2047 //set safety cabin person signal parameter

#define  NET_DVR_GET_ALARMHOST_MODULE_CFG                    2048            // get module config
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG                    2049            // set module config

/********************************DS_19DXX v20 begin****************************/
#define     NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE        2050        //get external device state
#define  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2051        //set limit value
#define  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2052        //get limit value
#define  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG                2053        // get sensor joint config
#define  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG                2054        // set sensor joint config
#define     NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG                2055        // set slot config
#define  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG                2056        // get slot config
/********************************DS_19DXX v20  end****************************/

/********************************DS_19DXX 104 protocol begin****************************/
#define NET_DVR_GET_ALL_VARIABLE_INFO      2057   // get all variable info
#define NET_DVR_GET_ALARM_POINT_CFG       2058   // get point config
#define NET_DVR_SET_ALARM_POINT_CFG       2059   // set point config
#define NET_DVR_GET_HISTORY_VALUE          2060   // get history value
#define NET_DVR_GET_ALARMHOST_ALARM_MODE  2061   // get alarm mode
#define NET_DVR_SET_ALARMHOST_ALARM_MODE  2062   // set alarm mode
/********************************DS_19DXX 104 protocol end****************************/

/*************************************DS-19D00-0402BN(0601BN) begin*************************************/
#define NET_DVR_GET_ALARMHOST_SENSOR_VALUE    2063   // get sensor value
/*************************************DS-19D00-0402BN(0601BN) end*************************************/

/*************************************alarm host 2.0 begin*************************************/
#define NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40    2064   // get data report mode v30
#define NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40    2065   // set data report mode v30
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG        2068   // get output schedule rule
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG     2069   // set output schedule rule
/************************************ alarm host2.0 end**************************************/

/*********************************EHOME begin******************************/
#define NET_DVR_GET_CMS_CFG                     2070
#define    NET_DVR_SET_CMS_CFG                        2071
#define NET_DVR_GET_PASSTHROUGH_CAP  2073
/*********************************EHOME end******************************/
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40    2072 
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V51    2083

/*************************************video alarm host v1.3 begin*************************************/
#define NET_DVR_GET_ALARM_CAPTRUE_CFG                 2074
#define    NET_DVR_SET_ALARM_CAPTRUE_CFG                2075
#define NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40        2078   // get one output schedule rule V40
#define NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40        2079   // set one output schedule rule V40
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40        2080   // get output schedule rule V40
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40     2081   // Set output schedule rule V40
#define  NET_DVR_ALARMHOST_CLOSE_SUBSYSTEM  2082  //close subsystem
/*************************************video alarm host v1.3 end**************************************/

#define NET_DVR_GET_WEEK_PLAN_CFG               2100    //get door status week plan config 
#define NET_DVR_SET_WEEK_PLAN_CFG               2101    //set door status week plan config 
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN    2102    //get door status holiday week plan config 
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN    2103    //set door status holiday week plan config
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP   2104    //get door holiday group parameter
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP   2105    //set door holiday group parameter
#define NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE   2106    //get door status plan template parameter
#define NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE   2107    //set door status plan template parameter
#define NET_DVR_GET_DOOR_CFG                    2108    //get door parameter
#define NET_DVR_SET_DOOR_CFG                    2109    //set door parameter
#define NET_DVR_GET_DOOR_STATUS_PLAN            2110    //get door status plan parameter
#define NET_DVR_SET_DOOR_STATUS_PLAN            2111    //set door status plan parameter
#define NET_DVR_GET_GROUP_CFG                   2112    //get group parameter
#define NET_DVR_SET_GROUP_CFG                   2113    //set group parameter
#define NET_DVR_GET_MULTI_CARD_CFG              2114    //get multi card parameter
#define NET_DVR_SET_MULTI_CARD_CFG              2115    //set multi card parameter
#define NET_DVR_GET_CARD_CFG                    2116    //get card parameter
#define NET_DVR_SET_CARD_CFG                    2117    //set card parameter
#define NET_DVR_CLEAR_ACS_PARAM                    2118    //clear access card parameter
#define NET_DVR_GET_SNEAK_CFG                    2119    //get sneak parameter
#define NET_DVR_SET_SNEAK_CFG                   2120    //set sneak parameter
#define NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG    2121    //get multi door interlock parameter
#define NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG    2122    //set multi door interlock parameter
#define NET_DVR_GET_ACS_WORK_STATUS                2123    //get device work status 
#define NET_DVR_GET_VERIFY_WEEK_PLAN            2124    //get reader card verfy week plan 
#define NET_DVR_SET_VERIFY_WEEK_PLAN            2125    //set reader card verfy week plan 
#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN        2126    //get card right week plan 
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN        2127    //set card right week plan 
#define NET_DVR_GET_VERIFY_HOLIDAY_PLAN         2128    //get card reader verify holiday plan 
#define NET_DVR_SET_VERIFY_HOLIDAY_PLAN         2129    //set card reader verify holiday plan 
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN     2130    //get card right holiday plan 
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN     2131    //set card right holiday plan
#define NET_DVR_GET_VERIFY_HOLIDAY_GROUP        2132    //get card reader verify holiday group 
#define NET_DVR_SET_VERIFY_HOLIDAY_GROUP        2133    //set card reader verify holiday group 
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP    2134    //get card right holiday group 
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP    2135    //set card right holiday group 
#define NET_DVR_GET_VERIFY_PLAN_TEMPLATE        2136    //get card reader verify plan template 
#define NET_DVR_SET_VERIFY_PLAN_TEMPLATE        2137    //set card reader verify plan template 
#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE    2138    //get card right plan template 
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE    2139    //set card right plan template 
#define NET_DVR_GET_CARD_READER_CFG                2140    //get card reader parameter
#define NET_DVR_SET_CARD_READER_CFG             2141    //set card reader parameter
#define NET_DVR_GET_CARD_READER_PLAN            2142    //get card reader verify plan parameter
#define NET_DVR_SET_CARD_READER_PLAN            2143    //set card reader verify plan parameter
#define NET_DVR_GET_CASE_SENSOR_CFG                2144    //get case sensor parameter
#define NET_DVR_SET_CASE_SENSOR_CFG             2145    //set case sensor parameter
#define NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG  2146    //get card readfer anti sneak parameter
#define NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG  2147    //set card readfer anti sneak parameter
#define NET_DVR_GET_PHONE_DOOR_RIGHT_CFG        2148    //get phone door right parameter
#define NET_DVR_SET_PHONE_DOOR_RIGHT_CFG        2149    //set phone door right parameter
#define NET_DVR_GET_FINGERPRINT_CFG             2150    //get fingerprint parameter
#define NET_DVR_SET_FINGERPRINT_CFG             2151    //set fingerprint parameter
#define NET_DVR_DEL_FINGERPRINT_CFG             2152    //delete fingerprint parameter
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG      2153    //get event card linkage parameter
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG      2154    //set event card linkage parameter
#define NET_DVR_GET_ANTI_SNEAK_HOST_CFG            2155    //get anti sneak host parameter
#define NET_DVR_SET_ANTI_SNEAK_HOST_CFG         2156    //set anti sneak host parameter
#define NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG  2157    //get reader anti sneak host parameter
#define NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG  2158    //set reader anti sneak host parameter
#define NET_DVR_GET_ACS_CFG                     2159    //get acs parameter
#define NET_DVR_SET_ACS_CFG                     2160    //set acs parameter
#define NET_DVR_GET_CARD_PASSWD_CFG                2161    //get card passwd parameter
#define NET_DVR_SET_CARD_PASSWD_CFG             2162    //set card passwd parameter
#define NET_DVR_GET_CARD_USERINFO_CFG           2163    //get card userinfo cfg
#define NET_DVR_SET_CARD_USERINFO_CFG           2164    //set card userinfo cfg


#define NET_DVR_GET_ACS_EXTERNAL_DEV_CFG        2165   //get ACS external device parameter
#define NET_DVR_SET_ACS_EXTERNAL_DEV_CFG        2166   //set ACS external device parameter
#define NET_DVR_GET_PERSONNEL_CHANNEL_CFG        2167   //get personnel channel parameter
#define NET_DVR_SET_PERSONNEL_CHANNEL_CFG        2168   //set personnel channel parameter
#define NET_DVR_SET_PLATFORM_VERIFY_CFG         2169    //The result issued by platform authentication
#define NET_DVR_GET_PERSON_STATISTICS_CFG        2170   //Get the number of statistical parameters 
#define NET_DVR_SET_PERSON_STATISTICS_CFG        2171   //Set the number of statistical parameters 
#define NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG        2172   //The screen for the string parameters 
#define NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG        2173   //String to use screen display parameters 
#define NET_DVR_GET_GATE_TIME_CFG               2174    //Access channel gate time parameter 
#define NET_DVR_SET_GATE_TIME_CFG               2175    //Setting up the staff channel gate time parameters 
#define NET_DVR_GET_LOCAL_CONTROLLER_STATUS     2176    //Access to on-site controller state 
#define NET_DVR_GET_ONLINE_LOCAL_CONTROLLER     2177    //Search online on the controller 
#define NET_DVR_GET_CARD_CFG_V50                2178    //Parameters to acquire new CARDS (V50)
#define NET_DVR_SET_CARD_CFG_V50                2179    //Setting up the new parameters (V50)
#define NET_DVR_GET_ACS_WORK_STATUS_V50            2180    //Access door host working condition (V50)
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V50  2181    //Get event card number linkage configuration parameters (V50)
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V50  2182    //Set up the event card number linkage configuration parameters (V50)
#define NET_DVR_GET_FINGERPRINT_CFG_V50         2183    //get fingerprint parameter (V50)
#define NET_DVR_SET_FINGERPRINT_CFG_V50         2184    //set fingerprint parameter (V50)

#define NET_DVR_GET_SAFETYCABIN_STATE            2197    //get safetycabin state
#define NET_DVR_GET_RS485_CASCADE_CFG            2198    //get Rs485 cascade cfg
#define NET_DVR_SET_RS485_CASCADE_CFG            2199    //set Rs485 cascade cfg

/*************************************video alarm host 2.0 begin*************************************/
#define NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG        2200    //get remotecontroller Permission config
#define NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG        2201    //set remotecontroller Permission config
#define NET_DVR_GET_KEYBOARD_CFG                        2202    //get keyborad config
#define NET_DVR_SET_KEYBOARD_CFG                        2203    //set keyborad config
#define    NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO    2204    //wireless service query
#define    NET_DVR_GET_ALL_REMOTECONTROLLER_LIST            2205    //get all remote controller
#define    NET_DVR_GET_PREVIEW_DELAY_CFG                    2206    //get delay preview config
#define    NET_DVR_SET_PREVIEW_DELAY_CFG                    2207    //set delay preview config
#define NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG            2208    //get alarm zone linkage channel config
#define NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG            2209    //set alarm zone linkage channel config 
#define NET_DVR_GET_CENTER_SERVER_CFG                    2210    //get alarm center server config
#define NET_DVR_SET_CENTER_SERVER_CFG                    2211    //set alarm center server config
/*************************************video alarm host 2.0 end*************************************/

/********************************energence alarm product V1.0.0 begin********************************/
#define NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP            2212    //get emergence alarm product ability
#define NET_DVR_GET_CALL_WAITTING_CFG_CAP                2213    //get call waiting configure ability
#define NET_DVR_GET_CALL_WAITTING_CFG                    2214    //get call waiting configure
#define NET_DVR_SET_CALL_WAITTING_CFG                    2215    //set call waiting configure
#define NET_DVR_GET_ALARM_LAMP_CFG_CAP                    2216    //get alarm lamp configure ability
#define NET_DVR_GET_ALARM_LAMP_CFG                        2217    //get alarm lamp configure
#define NET_DVR_SET_ALARM_LAMP_CFG                        2218    //set alarm lamp configure
#define NET_DVR_GET_VOICE_PROMPTION_CFG_CAP                2219    //get voice promption configure ability
#define NET_DVR_GET_VOICE_PROMPTION_CFG                    2220    //get voice promption configure
#define NET_DVR_SET_VOICE_PROMPTION_CFG                    2221    //set voice promption configure
#define NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP        2222    //get emergence alarm response ability
#define NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL            2223    //emergence alarm response ctrl
/********************************energence alarm product V1.0.0 end**********************************/

//net alarm host V2.2
#define NET_DVR_GET_ALARMHOST_NETCFG_V50                2224    //Get Net infoV50
#define NET_DVR_SET_ALARMHOST_NETCFG_V50                2225    //Set Net info V50
#define    NET_DVR_REGISTER_ALARM_RS485                    2226    //Re-register RS485

#define NET_DVR_GET_ALARMIN_PARAM_LIST                    2227    //Get sector parameter list 

#define NET_DVR_GET_ALARMHOST_OTHER_STATUS_V50            2228
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS_V51            2236
#define NET_DVR_GET_ALARMIN_ASSOCIATED_CHAN_LIST        2229

#define NET_DVR_GET_ALARMIN_TRIGGER                     2230    //get alarm in trigger
#define NET_DVR_SET_ALARMIN_TRIGGER                     2231    //set alarm in trigger
#define NET_DVR_GET_EMERGENCY_CALL_HELP_TRIGGER         2232    //get emergency call help trigger
#define NET_DVR_SET_EMERGENCY_CALL_HELP_TRIGGER         2233    //set emergency call help trigger
#define NET_DVR_GET_CONSULT_TRIGGER                     2234    //get consult trigger
#define NET_DVR_SET_CONSULT_TRIGGER                     2235    //set consult trigger
#define NET_DVR_GET_ALARMIN_PARAM_LIST_V50              2237    //Get sector parameter list V50

#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50    2304  //Access card right V50 weeks plan parameters
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50    2305  //Set card right V50 weeks plan parameters 

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50    2310  //Access card right parameters V50 holiday plan  
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50    2311  //Set card right parameters V50 holiday plan

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50      2316 //Access card right parameters V50 holiday group
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50      2317 //Set card right parameters V50 holiday group

#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50     2322 //Access card right parameters V50 plan template
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50     2323//Set card right parameters V50 plan template

/******************economical fingerprint access control product V1.0**************************/
#define NET_DVR_GET_SCHEDULE_INFO                       2500    //get schedule info
#define NET_DVR_GET_ATTENDANCE_SUMMARY_INFO             2501    //get attendance summary info
#define NET_DVR_GET_ATTENDANCE_RECORD_INFO              2502    //get attendance record info
#define NET_DVR_GET_ABNORMAL_INFO                       2503    //get abnormal
/******************economical fingerprint access control product V1.0**************************/

/*************************************vide acs integrated machine 1.0 begin**************************************/
#define NET_DVR_CAPTURE_FINGERPRINT_INFO                2504    //capture fingerprint info
/*************************************vide acs integrated machine 1.0 end**************************************/

/*************************************face acs integrated machine 1.0 begin**************************************/
#define NET_DVR_GET_CARD_READER_CFG_V50                2505    //get card reader param(V50)
#define NET_DVR_SET_CARD_READER_CFG_V50             2506    //set card reader param(V50)
#define NET_DVR_GET_FACE_PARAM_CFG                  2507    //get face param
#define NET_DVR_SET_FACE_PARAM_CFG                  2508    //set face param
#define NET_DVR_DEL_FACE_PARAM_CFG                  2509    //del face param
#define    NET_DVR_CAPTURE_FACE_INFO                    2510    //capture face info
/*************************************face acs integrated machine 1.0 end**************************************/
#define NET_DVR_GET_REGISTER_INFO                   2511    //get register info

#define NET_DVR_GET_SMSRELATIVEPARA_V50             2512    //get sms relative param v50 
#define NET_DVR_SET_SMSRELATIVEPARA_V50             2513    //set sms relative param v50
#define NET_DVR_GET_ACS_EVENT                       2514    //get device acs enent
#define NET_DVR_GET_MULTI_CARD_CFG_V50              2515    //get multi card cfg v50
#define NET_DVR_SET_MULTI_CARD_CFG_V50              2516    //set multi card cfg v50
#define NET_DVR_DEL_FINGERPRINT_CFG_V50             2517    //delete finger print cfg v50 
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V51      2518    //Get event card number linkage configuration parameters (V51)
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V51      2519    //Set up the event card number linkage configuration parameters (V51)

/*************************************Embedded intelligent terminal 1.0 begin**************************************/
#define NET_DVR_BULK_UPLOAD_BLOCKLIST_PICTURE          2520       //Bulk upload blocklist image 
#define NET_DVR_BULK_UPLOAD_ID_BLOCKLIST        2521        //Bulk upload blocklist
#define NET_DVR_GET_FAILED_FACE_INFO             2522        //when upgrade device,get the failed face info
#define NET_DVR_GET_FACE_AND_TEMPLATE          2523       //get face and template data
#define NET_DVR_SET_FACE_AND_TEMPLATE          2524       //set face and template data
/*************************************Embedded intelligent terminal 1.0 end**************************************/

#define NET_DVR_SET_EXAM_INFO                       2530    //set exam info
#define NET_DVR_SET_EXAMINEE_INFO                   2531    //set examinee info
#define NET_DVR_SEARCH_EXAM_COMPARE_RESULT          2532    //search exam compare result
#define NET_DVR_BULK_CHECK_FACE_PICTURE             2533    //check pictures
#define NET_DVR_JSON_CONFIG                         2550    //JSON 
#define NET_DVR_FACE_DATA_RECORD                    2551    //face data record
#define NET_DVR_FACE_DATA_SEARCH                    2552    //face data search
#define NET_DVR_FACE_DATA_MODIFY                    2553    //face data modify
#define NET_DVR_CAPTURE_DATA_SEARCH                 2554    //search
#define NET_DVR_SET_FORM_DATA                       2555    //set form data
#define NET_DVR_GET_FORM_DATA                       2556    //get form data

#define NET_DVR_GET_CARD                 2560
#define NET_DVR_SET_CARD                 2561
#define NET_DVR_DEL_CARD                 2562
#define NET_DVR_GET_FINGERPRINT          2563
#define NET_DVR_SET_FINGERPRINT          2564
#define NET_DVR_DEL_FINGERPRINT          2565
#define NET_DVR_GET_FACE                 2566
#define NET_DVR_SET_FACE                 2567

#define NET_DVR_GET_ALL_ALARM_RS485CFG            2705
#define NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG        2706
#define NET_DVR_GET_DEVICE_SELF_CHECK_STATE        2707
#define NET_DVR_GET_ALL_ALARM_POINT_CFG            2708
#define NET_DVR_GET_ALL_ALARM_SENSOR_CFG        2709
#define NET_DVR_GET_ALL_ALARM_SENSOR_JOINT        2710
#define NET_DVR_GET_AIR_CONDITION_PARAM            2711
#define NET_DVR_GET_OUT_SCALE_CFG                2712        
#define NET_DVR_SET_OUT_SCALE_CFG                2713        
#define NET_DVR_GET_ALARM_CHAN_ABLITITY            2714

#define NET_DVR_GET_ALARMCENTER_NETCFG            2715        
#define NET_DVR_SET_ALARMCENTER_NETCFG            2716


#define NET_ITC_GET_TRIGGERCFG               3003       //Get trigger configuration
#define NET_ITC_SET_TRIGGERCFG               3004        //Set trigger configuration
#define NET_ITC_GET_IOOUT_PARAM_CFG             3005        //Get io out configuration(3.1)
#define NET_ITC_SET_IOOUT_PARAM_CFG             3006        //Set io out configuration(3.1)
#define NET_DVR_GET_CAMERA_SETUPCFG             3007        //Get the camera Erection Parameters
#define NET_DVR_SET_CAMERA_SETUPCFG             3008        //Set the camera Erection Parameters
#define NET_ITC_GET_TRIGGER_DEFAULTCFG       3013        //Get trigger default configuration
#define NET_DVR_GET_STATUS_DETECTCFG         3015        //Get status detect configuration
#define NET_DVR_SET_STATUS_DETECTCFG         3016        //Set statue detect configuration
#define NET_ITC_GET_VIDEO_TRIGGERCFG         3017        //Get video epolice configuration
#define NET_ITC_SET_VIDEO_TRIGGERCFG         3018        //Set video epolice configuration
#define NET_DVR_GET_TPS_ALARMCFG             3019        //Get traffic statistics alarm parameters
#define NET_DVR_SET_TPS_ALARMCFG             3020        //Set traffic statistics alarm parameters
#define NET_DVR_GET_REDAREACFG               3100        //Get red area configuration
#define NET_DVR_SET_REDAREACFG               3101        //Set red area configuration
#define    NET_DVR_GET_TEST_SPOT                 3102       //Get SPOT port the test total number of steps and the first steps
#define    NET_DVR_SET_TEST_SPOT                 3103       //Set SPOT port the test total number of steps and the first steps
#define NET_DVR_GET_CABINETCFG                 3104       //Get CabinetCfg Param
#define NET_DVR_SET_CABINETCFG                 3105       //Set CabinetCfg Param
#define NET_DVR_VEHICLE_CHECK_START             3106       //block list check data pass back
#define NET_DVR_SET_CAPTUREPIC_CFG             3107        //set capture picture param
#define NET_DVR_GET_CAPTUREPIC_CFG             3108        //get capture picture param
#define NET_DVR_SET_MOBILEPLATE_RECOG_CFG     3109        //set plate recognize parm
#define NET_DVR_GET_MOBILEPLATE_RECOG_CFG     3110        //get plate recognize parm
#define NET_DVR_SET_MOBILE_RADAR_CFG         3111        //set radar configure parm
#define NET_DVR_GET_MOBILE_RADAR_CFG         3112        //get radar configure parm
#define NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG 3113        //set block list compare configure parm
#define NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG 3114        //get block list compare configure parm

#define  NET_ITC_GET_ICRCFG                        3115   //Get ICR Param Cfg
#define  NET_ITC_SET_ICRCFG                        3116   //Set ICR Param Cfg
#define  NET_ITC_GET_RS485_ACCESSINFO            3117   //Get Rs485 Access Info 
#define  NET_ITC_SET_RS485_ACCESSINFO            3118   //Set Rs485 Access Info
#define  NET_ITC_GET_EXCEPTIONCFG                 3119   //Get Exception Info Cfg 
#define  NET_ITC_SET_EXCEPTIONCFG                3120   //Set Exception Info Cfg
#define  NET_ITC_GET_FTPCFG                        3121   //Get ITC  FTP Param Cfg
#define  NET_ITC_SET_FTPCFG                        3122   //Set ITC  FTP Param Cfg

//2013-11-04 PJ01R2013091201
#define  NET_DVR_VEHICLE_CONTROL_LIST_START     3123   //Vehicle Control List Start
#define  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST   3124   //Get Vehicle Control List
#define  NET_DVR_VEHICLE_DELINFO_CTRL            3125   //Delete Vehicle Info
#define  NET_DVR_GET_ENTRANCE_PARAMCFG            3126   //Get Entrance Param CFG
#define  NET_DVR_SET_ENTRANCE_PARAMCFG            3127   //Set Entrance Param CFG
#define  NET_DVR_BARRIERGATE_CTRL               3128   //Barrier Gate Ctrl
#define  NET_DVR_GATELAMP_CTRL                  3129   //Gate Lamp
#define  NET_DVR_GET_CURTRIGGERMODE             3130   //Get Cur Trigger Mode
#define  NET_DVR_GET_GPSDATACFG                    3131   //Get GPS Param
#define  NET_DVR_SET_GPSDATACFG                    3132   //Set GPS Param
#define  NET_DVR_VEHICLELIST_CTRL_START            3133   //Start Vehicle List Ctrl

//Capture trigger mode support association Alarm time and Upload Center
#define  NET_DVR_GET_GUARDCFG                   3134   //Get 
#define  NET_DVR_SET_GUARDCFG                   3135   //Set

//Snap Picture Info
#define NET_DVR_GET_SNAPINFO_CFG                3136   //Get 
#define NET_DVR_SET_SNAPINFO_CFG                3137   //Set

//Snap Picture Info Expansion
#define  NET_DVR_GET_SNAPINFO_CFG_V40           3138   //Get 
#define  NET_DVR_SET_SNAPINFO_CFG_V40           3139   //Set

#define  NET_DVR_SET_CURTRIGGERMODE                3140   //Set device Current Trigger Mode (Only IPC/D)
#define     NET_DVR_GET_TRAFFIC_DATA                3141   //Get Traffic Data
#define     NET_DVR_GET_TRAFFIC_FLOW                3142   //Get Traffic Flow
#define  NET_DVR_PARKING_VEHICLE_SEND           3143   //Parking Vehicle Send
#define  NET_DVR_PARKING_CARD_SEND              3144   //Send Parking Card Info
#define     NET_DVR_PARKING_CARD_CTRL                3145    //Parking card control interface

#define    NET_DVR_GET_ALARMCTRL_CAPABILITIES        3146   //Get Alarm Ctrl Capabilties
#define    NET_DVR_SET_ALARMCTRL_CFG                3147   //Set Alarm Ctrl 
#define    NET_DVR_GET_ALARMCTRL_CFG                3148   //Get Alarm Ctrl

#define NET_DVR_GET_AUDIO_INPUT              3201        //Get audio in info
#define NET_DVR_SET_AUDIO_INPUT              3202        //Set audio in info
#define NET_DVR_GET_CAMERA_DEHAZE_CFG        3203        //Get fog remove configuration
#define NET_DVR_SET_CAMERA_DEHAZE_CFG        3204        //Set fog remove configuration
#define NET_DVR_REMOTECONTROL_ALARM          3205        //remote control alarm
#define NET_DVR_REMOTECONTROL_DISALARM       3206        //remote control disalarm
#define NET_DVR_REMOTECONTROL_STUDY          3207        //remote control study
#define NET_DVR_WIRELESS_ALARM_STUDY         3208        //wireless alarm study
#define NET_IPC_GET_AUX_ALARMCFG             3209        //get aux alarm configuration
#define NET_IPC_SET_AUX_ALARMCFG             3210        //set aux alarm configuration
#define NET_DVR_GET_PREVIEW_DISPLAYCFG         3211        //Get preview shows the parameters
#define NET_DVR_SET_PREVIEW_DISPLAYCFG         3212        //Set preview shows the parameters
#define NET_DVR_REMOTECONTROL_PTZ            3213       //Remote control of PTZ
#define NET_DVR_REMOTECONTROL_PRESETPOINT    3214       //Remote Control preset point
#define NET_DVR_REMOTECONTROL_CRUISE         3215       //Remote control cruise

#define NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG  3216    //Get muti stream compressioncfg
#define NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG  3217    //Set muti stream compressioncfg

#define NET_DVR_GET_WPSCFG                     3218        //Get WPS configuration
#define NET_DVR_SET_WPSCFG                     3219        //Set WPS configuration
#define NET_DVR_WPS_CONNECT                  3220        //WPS connect
#define NET_DVR_GET_DEVICE_PIN               3221        //Get device PIN
#define NET_DVR_UPDATE_PIN                   3223        //Update device PIN
#define NET_DVR_GET_PRESETCFG                3224        //Get preset point parameters
#define NET_DVR_GET_PTZCRUISECFG             3225        //Get cruise path parameters
#define NET_DVR_GET_PRESET_NUM                 3226        //Access to preset point number
#define NET_DVR_GET_PTZCRUISE_NUM             3227        //Access to the cruise path number

#define NET_DVR_GET_MOTION_TRACK_CFG         3228        //Access to track parameters
#define NET_DVR_SET_MOTION_TRACK_CFG         3229        //Set the track parameter
#define NET_DVR_CLEAR_IPC_PARAM                 3230       //To empty the front-end parameters 

#define NET_DVR_GET_IPADDR_FILTERCFG         3232        //Get IP address filter
#define NET_DVR_SET_IPADDR_FILTERCFG         3233        //Set IP address filter

#define NET_DVR_GET_LOGO_OVERLAYCFG             3234       //Get LOGO overlay configuration 
#define NET_DVR_SET_LOGO_OVERLAYCFG             3235       //Set LOGO overlay configuration
#define NET_DVR_GET_IPV6_LIST                3236        //Get all IPV6 address of the network card information
#define NET_DVR_GET_AUDIOOUT_VOLUME          3237 
#define NET_DVR_SET_AUDIOOUT_VOLUME          3238
#define NET_DVR_GET_FUZZY_UPGRADE            3239        //Get fuzzy matching information upgrade
#define NET_DVR_GET_BV_CORRECT_PARAM         3240        //Get the camera calibration parameters
#define NET_DVR_SET_BV_CORRECT_PARAM         3241        //Set the camera calibration parameters
#define NET_DVR_GET_OUTPUT_VIDEO_TYPE        3242        //Get Output Video Type
#define NET_DVR_SET_OUTPUT_VIDEO_TYPE        3243        //Set Output Video Type
#define NET_DVR_FISHEYE_CFG                  3244    //Create long link of fisheye
#define NET_DVR_GET_PTZ_POINT                3245    //Get ptz position
#define NET_DVR_SET_PTZ_POINT                3246    //Set ptz position
#define NET_DVR_REMOTECONTROL_DEV_PARAM      3247    //Set params of the logon device
#define NET_DVR_GET_FISHEYE_STREAM_STATUS    3248    //Get stream status of fisheye

#define NET_DVR_GET_GBT28181_ACCESS_CFG            3249 // Get GBT28181 Protocol Access Cfg        
#define NET_DVR_SET_GBT28181_ACCESS_CFG            3250 // Set GBT28181 Protocol Access Cfg
#define NET_DVR_GET_GBT28181_CHANINFO_CFG        3251 // Get GBT28181 Protocol Access Dev Channel Info
#define NET_DVR_SET_GBT28181_CHANINFO_CFG        3252 // Set GBT28181 Protocol Access Dev Channel Info
#define NET_DVR_GET_GBT28181_ALARMINCFG            3253 // Get GBT28181 Protocol Access Alarm Info
#define NET_DVR_SET_GBT28181_ALARMINCFG            3254 // Set GBT28181 Protocol Access Alarm Info
#define NET_DVR_GET_ISP_CAMERAPARAMCFG            3255 // Get ISP Camera Info cfg
#define NET_DVR_SET_ISP_CAMERAPARAMCFG            3256 // Set ISP Camera Info cfg
#define NET_DVR_GET_DEVSERVER_CFG                3257 // Get DevServer cfg
#define NET_DVR_SET_DEVSERVER_CFG                3258 // Set DevServer cfg

//2013-11-25
#define    NET_DVR_GET_WIPERINFO_CFG                3259   //Get Wiper Info
#define    NET_DVR_SET_WIPERINFO_CFG                3260   //Set Wiper Info
#define NET_DVR_GET_TRACK_DEV_PARAM             3261   //Get Track Device Param
#define NET_DVR_SET_TRACK_DEV_PARAM             3262   //Set Track Device Param
#define NET_DVR_GET_PTZ_TRACK_PARAM             3263   //Get PTZ Track Param
#define NET_DVR_SET_PTZ_TRACK_PARAM             3264   //Set PTZ Track Param
#define NET_DVR_GET_CENTER_POINT_CFG            3265   //get center point parameters
#define NET_DVR_SET_CENTER_POINT_CFG            3266   //set center point parameters
#define NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES        3267    //get center point parameters capabilities
#define NET_DVR_GET_FISHEYE_CAPABILITIES        3268        //get fisheye capabilities

#define NET_DVR_GET_BASICPARAMCFG                3270 //Get the basic parameters of PTZ configuration information         
#define NET_DVR_SET_BASICPARAMCFG                3271 //set the basic parameters of PTZ configuration information
#define NET_DVR_GET_PTZOSDCFG                    3272 //get PTZ OSD configuration parameter information        
#define NET_DVR_SET_PTZOSDCFG                    3273 //Set PTZ OSD configuration parameter information
#define NET_DVR_GET_POWEROFFMEMCFG                3274 //get power down memory model parameter information    
#define NET_DVR_SET_POWEROFFMEMCFG                3275 //set power down memory model parameter information
#define NET_DVR_GET_LIMITCFG                    3276 //get the limiting parameter configuration information    
#define NET_DVR_SET_LIMITCFG                    3277 //set the limiting parameter configuration information
#define NET_DVR_PTZLIMIT_CTRL                    3278 //clearance limit parameter control    

#define NET_DVR_PTZ_CLEARCTRL                    3279 //clear configuration information control interface    
#define NET_DVR_GET_PRIORITIZECFG                3281 //get Haeundae priority configuration information    
#define NET_DVR_SET_PRIORITIZECFG                3282 //set Haeundae priority configuration information
#define NET_DVR_PTZ_INITIALPOSITIONCTRL            3283 //zero azimuth control    
#define NET_DVR_GET_PRIVACY_MASKSCFG            3285 //get privacy parameter
#define NET_DVR_SET_PRIVACY_MASKSCFG            3286 //set privacy parameter
#define NET_DVR_GET_PTZLOCKCFG                    3287 //get Haeundae lock information    
#define NET_DVR_SET_PTZLOCKCFG                    3288 //set Haeundae lock information
#define NET_DVR_PTZ_ZOOMRATIOCTRL                3289 //set the tracking rate    
#define NET_DVR_GET_PTZLOCKINFO                    3290 //get Haeundae locking seconds remaining
#define NET_DVR_GET_PRIVACY_MASKS_ENABLECFG        3291 //get the global enable    
#define NET_DVR_SET_PRIVACY_MASKS_ENABLECFG        3292 //set the global enable
#define NET_DVR_GET_SMARTTRACKCFG                3293 //get acquisition intelligent motion tracking configuration information    
#define NET_DVR_SET_SMARTTRACKCFG                3294 //set acquisition intelligent motion tracking configuration information
#define NET_DVR_GET_EPTZ_CFG                    3295 //get EPTZ parameters
#define NET_DVR_SET_EPTZ_CFG                    3296 //set EPTZ parameters
#define NET_DVR_GET_EPTZ_CFG_CAPABILITIES        3297 //get EPTZ parameters capabilities

#define NET_DVR_GET_LOW_LIGHTCFG            3303       
#define NET_DVR_SET_LOW_LIGHTCFG            3304    

#define NET_DVR_GET_FOCUSMODECFG            3305       
#define NET_DVR_SET_FOCUSMODECFG            3306       

#define NET_DVR_GET_INFRARECFG              3307       
#define NET_DVR_SET_INFRARECFG              3308      

#define NET_DVR_GET_AEMODECFG               3309       
#define NET_DVR_SET_AEMODECFG               3310       

#define NET_DVR_CONTROL_RESTORE_SUPPORT     3311   // Restore the front end of the default parameters (parameter capabilities, some front-end parameters to configure the associated recovery)
#define NET_DVR_CONTROL_RESTART_SUPPORT     3312   

#define NET_DVR_CONTROL_PTZ_PATTERN         3313 //PTZ Pattern
#define NET_DVR_GET_PTZ_PARKACTION_CFG      3314       //Get PTZ Parkaction configuration
#define NET_DVR_SET_PTZ_PARKACTION_CFG      3315    //Set PTZ Parkaction configuration
#define NET_DVR_CONTROL_PTZ_MANUALTRACE     3316       //PTZ manual trace

#define NET_DVR_GET_ROI_DETECT_NUM            3349 //Get the number of ROI detection area number
#define NET_DVR_GET_ROI_DETECT                3350 //Get ROI detection area configuration
#define NET_DVR_SET_ROI_DETECT                3351 //Set ROI detection area configuration
#define NET_DVR_GET_FACE_DETECT                3352 //Get face detection configuration
#define NET_DVR_SET_FACE_DETECT                3353 //Set face detection configuration
#define NET_DVR_GET_CORRIDOR_MODE            3354 //Get corridor mode configuration
#define NET_DVR_SET_CORRIDOR_MODE            3355 //Set corridor mode configuration

//2013-07-16
#define NET_DVR_GET_SCENECHANGE_DETECTIONCFG    3356 //Get the scene change the alarm configuration 
#define NET_DVR_SET_SCENECHANGE_DETECTIONCFG    3357 //Set the scene change the alarm configuration 

#define NET_DVR_GET_TRAVERSE_PLANE_DETECTION    3360 
#define NET_DVR_SET_TRAVERSE_PLANE_DETECTION    3361 
#define NET_DVR_GET_FIELD_DETECTION             3362 //Get the field detection configuration
#define NET_DVR_SET_FIELD_DETECTION             3363 //Set the field detection configuration
#define NET_DVR_GET_DEFOCUSPARAM                3364 //Get the defouce detection configuration
#define NET_DVR_SET_DEFOCUSPARAM                3365 //Set the defouce detection configuration
#define NET_DVR_GET_AUDIOEXCEPTIONPARAM         3366 //Get the aduio exception configuration
#define NET_DVR_SET_AUDIOEXCEPTIONPARAM         3367 //Set the aduio exception configuration
#define NET_DVR_GET_CCDPARAMCFG_EX              3368 //Get the CCD configuration
#define NET_DVR_SET_CCDPARAMCFG_EX              3369 //Set the CCD configuration
#define NET_DVR_START_GET_INPUTVOLUME           3370 //Get the inputvolume

#define NET_DVR_SET_SCH_TASK                3380 //Set PTZ schdule tasks
#define NET_DVR_GET_SCH_TASK                3381 //Get PTZ schdule tasks
#define NET_DVR_SET_PRESET_NAME                3382 //Set the name of preset
#define NET_DVR_GET_PRESET_NAME                3383 //Get the name of preset
#define NET_DVR_SET_AUDIO_NAME                3384 //set the name of audio
#define NET_DVR_GET_AUDIO_NAME                3385  //get the name of audio

//[add] by zja 2013-10-29 10:55:31  IPC 5.1.4 resume initial tracking position 
#define NET_DVR_RESUME_INITRACKPOS              3386  //resume initial tracking position 

#define NET_DVR_NTP_SERVER_TEST                    3387    //NTP server test
#define    NET_DVR_NAS_SERVER_TEST                    3388    //NAS server test
#define    NET_DVR_EMAIL_SERVER_TEST                3389    //Email server test
#define    NET_DVR_FTP_SERVER_TEST                    3390    //FTP server test
#define    NET_DVR_IP_TEST                            3391    //IP conflict test
#define NET_DVR_GET_NET_DISKCFG_V40             3392 //Get net disk mount config v40
#define NET_DVR_SET_NET_DISKCFG_V40                3393 //Set net disk mount config v40

///20140220 IPC5.1.6 BEGIN
#define        NET_DVR_GET_IOOUT_CFG                3394    //    get supplement light configuration
#define        NET_DVR_SET_IOOUT_CFG                3395    //    set supplement light configuration

#define        NET_DVR_GET_SIGNAL_SYNC                3396    //     get signal light sync configuration
#define        NET_DVR_SET_SIGNAL_SYNC                3397    //     set signal light sync configuration    

#define        NET_DVR_GET_EZVIZ_ACCESS_CFG        3398    //    get EZVIZ access configuration
#define        NET_DVR_SET_EZVIZ_ACCESS_CFG        3399    //    set EZVIZ access configuration
///20140220 IPC5.1.6 end

#define    NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG        3400    //get schedule auto tracking configuration
#define    NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG        3401    //set schedule auto tracking configuration
#define    NET_DVR_MAKE_I_FRAME                    3402    //Make I Frame

//PJ01D2013032803  2014-03-04
#define  NET_DVR_GET_ALARM_RELATE                3403   //Get Alarm Relate
#define  NET_DVR_SET_ALARM_RELATE                3404   //Set Alarm Relate


/************************* IPC5.1.7  Begin 2014-03-21****************************/
#define NET_DVR_GET_PDC_RULECFG_V42             3405    //Set Traffic statistics
#define NET_DVR_SET_PDC_RULECFG_V42             3406    //Get Traffic statistics
#define NET_DVR_GET_HEATMAP_CFG                 3407    //Set Heat Map
#define NET_DVR_SET_HEATMAP_CFG                 3408    //Get Heat Map
/************************* IPC5.1.7  End 2014-03-21*****************************/

#define NET_DVR_REMOTECONTROL_LINEARSCAN        3409    //Set the left and right boundary parameters 2014-03-15
#define NET_DVR_DPC_CTRL                        3410    //DPC Ctrl
#define NET_DVR_FFC_MANUAL_CTRL                 3411    //FFC Manual Ctrl
#define NET_DVR_FFC_BACKCOMP_CTRL               3412    //FFC Background Ctrl 
#define NET_DVR_GET_FOCUSING_POSITION_STATE     3413    //Get Focusing Position State
#define NET_DVR_GET_PRIVATE_PROTOCOL_CFG        3414   //Get Private Protocol Cfg
#define NET_DVR_SET_PRIVATE_PROTOCOL_CFG        3415   //Set Private Protocol Cfg
#define NET_DVR_COMPLETE_RESTORE_CTRL           3420    //Complete Restore Ctrl

#define NET_DVR_CLOUDSTORAGE_SERVER_TEST        3421  //Cloud Storage Server Ctrl
#define NET_DVR_PHONE_NUM_TEST                  3422  //Phone Num Test
#define NET_DVR_GET_REMOTECONTROL_STATUS        3423  //Remote Control Status
#define NET_DVR_GET_MONITOR_LOCATION_INFO        3424  //Get Monitor Location Info
#define NET_DVR_SET_MONITOR_LOCATION_INFO        3425  //Set Monitor Location Info

#define    NET_DVR_GET_SMART_CAPABILITIES                3500    //get smart ability
#define    NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES        3501    //get event trigger ability
#define    NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES    3502    //get region entrance detection ability
#define    NET_DVR_GET_REGION_ENTR_DETECTION            3503    //get region entrance detection configuration
#define    NET_DVR_SET_REGION_ENTR_DETECTION            3504    //set region entrance detection configuration
#define    NET_DVR_GET_REGION_ENTR_REGION                3505    //get region entrance detection single region configuration
#define    NET_DVR_SET_REGION_ENTR_REGION                3506    //set region entrance detection single region configuration
#define    NET_DVR_GET_REGION_ENTR_TRIGGER                3507    //get region entrance detection trigger configuration
#define    NET_DVR_SET_REGION_ENTR_TRIGGER                3508    //set region entrance detection trigger configuration
#define    NET_DVR_GET_REGION_ENTR_SCHEDULE            3509    //get region entrance detection arm schedule configuration
#define    NET_DVR_SET_REGION_ENTR_SCHEDULE            3510    //set region entrance detection arm schedule configuration
#define    NET_DVR_GET_REGION_EXITINT_CAPABILITIES        3511    //get region exit detection ability
#define    NET_DVR_GET_REGION_EXITING_DETECTION        3512    //get region exit detection configuration
#define    NET_DVR_SET_REGION_EXITING_DETECTION        3513    //set region exit detection configuration
#define    NET_DVR_GET_REGION_EXITING_REGION            3514    //get region exit detection single region configuration
#define    NET_DVR_SET_REGION_EXITING_REGION            3515    //set region exit detection single region configuration
#define    NET_DVR_GET_REGION_EXIT_TRIGGER                3516    //get region exit detection trigger configuration
#define    NET_DVR_SET_REGION_EXIT_TRIGGER                3517    //set region exit detection trigger configuration
#define    NET_DVR_GET_REGION_EXIT_SCHEDULE            3518    //get region exit detection arm schedule configuration
#define    NET_DVR_SET_REGION_EXIT_SCHEDULE            3519    //set region exit detection arm schedule configuration
#define    NET_DVR_GET_LOITERING_CAPABILITIES            3520    //get region loiter detection ability
#define    NET_DVR_GET_LOITERING_DETECTION                3521    //get region loiter detection configuration
#define    NET_DVR_SET_LOITERING_DETECTION                3522    //set region loiter detection configuration
#define    NET_DVR_GET_LOITERING_REGION                3523    //get region loiter detection single region configuration
#define    NET_DVR_SET_LOITERING_REGION                3524    //set region loiter detection single region configuration
#define    NET_DVR_GET_LOITERING_TRIGGER                3525    //get region loiter detection trigger configuration
#define    NET_DVR_SET_LOITERING_TRIGGER                3526    //set region loiter detection trigger configuration
#define    NET_DVR_GET_LOITERING_SCHEDULE                3527    //get region loiter detection arm schedule configuration
#define    NET_DVR_SET_LOITERING_SCHEDULE                3528    //set region loiter detection arm schedule configuration
#define    NET_DVR_GET_GROUPDETECTION_CAPABILITIES        3529    //get region group detection ability
#define    NET_DVR_GET_GROUP_DETECTION                    3530    //get region group detection configuration
#define    NET_DVR_SET_GROUP_DETECTION                    3531    //set region group detection configuration
#define    NET_DVR_GET_GROUPDETECTION_REGION            3532    //get region group detection single region configuration
#define    NET_DVR_SET_GROUPDETECTION_REGION            3533    //set region group detection single region configuration
#define    NET_DVR_GET_GROUPDETECTION_TRIGGER            3534    //get region group detection trigger configuration
#define    NET_DVR_SET_GROUPDETECTION_TRIGGER            3535    //set region group detection trigger configuration
#define    NET_DVR_GET_GROUPDETECTION_SCHEDULE            3536    //get region group detection arm schedule configuration
#define    NET_DVR_SET_GROUPDETECTION_SCHEDULE            3537    //set region group detection arm schedule configuration
#define    NET_DVR_GET_RAPIDMOVE_CAPABILITIES            3538    //get region rapid move detection ability
#define    NET_DVR_GET_RAPIDMOVE_DETECTION                3539    //get region rapid move detection configuration
#define    NET_DVR_SET_RAPIDMOVE_DETECTION                3540    //set region rapid move detection configuration
#define    NET_DVR_GET_RAPIDMOVE_REGION                3541    //get region rapid move detection single region configuration
#define    NET_DVR_SET_RAPIDMOVE_REGION                3542    //set region rapid move detection single region configuration
#define    NET_DVR_GET_RAPIDMOVE_TRIGGER                3543    //get region rapid move detection trigger configuration
#define    NET_DVR_SET_RAPIDMOVE_TRIGGER                3544    //set region rapid move detection trigger configuration
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE                3545    //get region rapid move detection arm schedule configuration
#define    NET_DVR_SET_RAPIDMOVE_SCHEDULE                3546    //set region rapid move detection arm schedule configuration
#define    NET_DVR_GET_PATKING_CAPABILITIES            3547    //get region park detection ability
#define    NET_DVR_GET_PARKING_DETECTION               3548    //get region park detection configuration
#define    NET_DVR_SET_PARKING_DETECTION                3549    //set region park detection configuration
#define    NET_DVR_GET_PARKING_REGION                    3550    //get region park detection single region configuration
#define    NET_DVR_SET_PARKING_REGION                    3551    //set region park detection single region configuration
#define    NET_DVR_GET_PARKING_TRIGGER                    3552    //get region park detection trigger configuration
#define    NET_DVR_SET_PARKING_TRIGGER                    3553    //set region park detection trigger configuration
#define    NET_DVR_GET_PARKING_SCHEDULE                3554    //get region park detection arm schedule configuration
#define    NET_DVR_SET_PARKING_SCHEDULE                3555    //set region park detection arm schedule configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES    3556    //get region unattended baggage detection ability
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION    3557    //get region unattended baggage detection configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION    3558    //set region unattended baggage detection configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_REGION        3559    //get region unattended baggage detection single region configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_REGION        3560    //set region unattended baggage detection single region configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER        3561    //get region unattended baggage detection trigger configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER        3562    //set region unattended baggage detection trigger configuration
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE        3563    //get region unattended baggage detection arm schedule configuration
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE        3564    //set region unattended baggage detection arm schedule configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES    3565    //get region attended baggage detection ability
#define    NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION        3566    //get region attended baggage detection configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION        3567    //set region attended baggage detection configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_REGION            3568    //get region attended baggage detection single region configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_REGION            3569    //set region attended baggage detection single region configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER            3570    //get region attended baggage detection trigger configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER            3571    //set region attended baggage detection trigger configuration
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE        3572    //get region attended baggage detection arm schedule configuration
#define    NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE        3573    //set region attended baggage detection arm schedule configuration
#define    NET_DVR_GET_REGIONCLIP_CAPABILITIES            3574    //get region clip ability
#define    NET_DVR_GET_REGION_CLIP                     3575    //get region clip configuration
#define    NET_DVR_SET_REGION_CLIP                     3576    //set region clip configuration
#define    NET_DVR_GET_NETWORK_CAPABILITIES            3577    //get network ability
#define    NET_DVR_GET_WIRELESS_DIAL                     3578    //get wireless dial configuration
#define    NET_DVR_SET_WIRELESS_DIAL                     3579    //set wireless dial configuration
#define    NET_DVR_GET_WIRELESSDIAL_CAPABILITIES        3580    //get wireless dial configuration ability
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE            3581    //get wireless dial schedule configuration
#define    NET_DVR_SET_WIRELESSDIAL_SCHEDULE            3582    //set wireless dial schedule configuration
#define    NET_DVR_GET_WIRELESSDIAL_STATUS             3583    //get wireless dial status
#define    NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES    3584    //get region entrance detection arm schedule ability
#define    NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES    3585    //get region exit detection arm schedule ability
#define    NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES    3586    //get region loiter detection arm schedule ability
#define    NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES    3587    //get region group detection arm schedule ability
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES    3588    //get region rapid move detection arm schedule ability
#define    NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES    3589    //get region park detection arm schedule ability
#define    NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3590    //get region unattended baggage detection arm schedule ability
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3591    //get region attended baggage detection arm schedule ability
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES    3592    //get wireless dial schedule ability
#define    NET_DVR_WIRELESSDIAL_CONNECT    3593    //control connect wireless dial

#define    NET_DVR_GET_LITESTORAGE                    3594    
#define    NET_DVR_SET_LITESTORAGE                    3595    
#define    NET_DVR_GET_LITESTORAGE_CAPABILITIES    3596    

#define    NET_DVR_GET_VEHICLE_CAPABILITIES    3597
#define    NET_DVR_GET_VEHICLE_CALIBRATION     3598    

#define    NET_DVR_GET_SLAVECAMERA_CAPABILITIES    3599    //Get SlaveCamera IP Info Capabilities    
#define    NET_DVR_GET_SLAVECAMERA                    3600    //Get SlaveCamera IP Info
#define    NET_DVR_SET_SLAVECAMERA                    3601    //Set SlaveCamera IP Info
#define    NET_DVR_GET_SLAVECAMERA_STATUS            3602    //Get SlaveCamera Link Status
#define    NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES    3603  //Get SlaveCamera Calib Capabilities    
#define    NET_DVR_GET_SLAVECAMERA_CALIB            3604    //Get SlaveCamera Calib Param
#define    NET_DVR_SET_SLAVECAMERA_CALIB            3605    //Set SlaveCamera Calib Param
#define NET_DVR_GET_PHY_RATIO                    3606    //Get Physics Ratio Coordinate Info    
#define NET_DVR_SET_PHY_RATIO                    3607    //Set Physics Ratio Coordinate Info
#define NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES   3608  //Get MasterSlaveTracking Capabilities 
#define    NET_DVR_SET_TRACKINGRATIO                3610    //Set SlaveCamera Tracking Ratio 
#define    NET_DVR_GET_TRACKING                    3611    //Get tracking param
#define    NET_DVR_SET_TRACKING                    3612    //Set tracking param
#define    NET_DVR_GET_TRACKING_CAPABILITIES        3613    //Get tracking param capabilities
#define    NET_DVR_GET_SLAVECAMERA_CALIB_V50        3614    //Get SlaveCamera Calib Param V50
#define    NET_DVR_SET_SLAVECAMERA_CALIB_V50        3615    //Set SlaveCamera Calib Param V50
#define    NET_DVR_SET_TRACKINGRATIO_MANUAL        3616    //Set Tracking Ratio Manual Coefficient
#define    NET_DVR_GET_TRACKINGRATIO_MANUAL        3617    //Get Tracking Ratio Manual Coefficient
#define    NET_DVR_SET_TRACK_INITPOSTION            3618    //Set Tracking InitPostion 
#define    NET_DVR_GET_PTZ_CAPABILITIES            3619    //Get PTZ Capabilities

#define    NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES    3620 //Get Thermometry Basic Param capabilities
#define    NET_DVR_GET_THERMOMETRY_BASICPARAM      3621    //Get Thermometry Basic Param
#define    NET_DVR_SET_THERMOMETRY_BASICPARAM        3622    //Set Thermometry Basic Param
#define    NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES    3623 //Get Thermometry Scene capabilities
#define    NET_DVR_GET_THERMOMETRY_PRESETINFO      3624    //Get Thermometry Preset Info
#define    NET_DVR_SET_THERMOMETRY_PRESETINFO        3625    //Set Thermometry Preset Info
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES    3626 //Get Thermometry Alarm Rule Capabilities
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE       3627    //Get Thermometry Alarm Rule
#define    NET_DVR_SET_THERMOMETRY_ALARMRULE        3628    //Set Thermometry Alarm Rule
#define    NET_DVR_GET_REALTIME_THERMOMETRY        3629    //Get Realtime Thermometry
#define    NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON  3630    //Get Thermometry Temperature difference
#define    NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON    3631    //Set Thermometry Temperature difference
#define    NET_DVR_GET_THERMOMETRY_TRIGGER            3632    //Get Thermometry Trigger
#define    NET_DVR_SET_THERMOMETRY_TRIGGER            3633    //Set Thermometry Trigger

#define    NET_DVR_GET_THERMAL_CAPABILITIES        3634    //Get Thermal Capabilities
#define    NET_DVR_GET_FIREDETECTION_CAPABILITIES    3635    //Get FireDetection Capabilities
#define    NET_DVR_GET_FIREDETECTION               3636    //Get FireDetection
#define    NET_DVR_SET_FIREDETECTION               3637    //Set FireDetection
#define    NET_DVR_GET_FIREDETECTION_TRIGGER       3638    //Get FireDetection Trigger
#define    NET_DVR_SET_FIREDETECTION_TRIGGER        3639    //Set FireDetection Trigger

#define    NET_DVR_GET_OIS_CAPABILITIES            3640    //Get OIS Capabilities
#define    NET_DVR_GET_OIS_CFG                     3641    //Get OIS Info
#define    NET_DVR_SET_OIS_CFG                     3642    //Set OIS Info
#define    NET_DVR_GET_MACFILTER_CAPABILITIES      3643    //Get MAC Filter Capabilities
#define    NET_DVR_GET_MACFILTER_CFG               3644    //Get MAC Filter
#define    NET_DVR_SET_MACFILTER_CFG               3645    //Set MAC Filter
#define    NET_DVR_GET_EAGLEFOCUS_CALCFG_CAPABILITIES   3646    //Get Elagle Focus Calib Capabilities
#define    NET_DVR_GET_EAGLEFOCUSING_CALCFG        3647    //Get Elagle Focus Calib
#define    NET_DVR_SET_EAGLEFOCUSING_CALCFG        3648    //Set Elagle Focus Calib
#define    NET_DVR_GET_EAGLEFOCUSING_CFG_CAPABILITIES   3649   //Get Elagle Focus Capabilities
#define    NET_DVR_GET_EAGLEFOCUSING_CTRL          3650    //Get Elagle Focus
#define    NET_DVR_SET_EAGLEFOCUSING_CTRL          3651    //Set Elagle Focus 
#define    NET_DVR_GET_PXOFFLINE_CAPABILITIES      3652    //PX Offline Configuration capabilities
#define    NET_DVR_SET_PXOFFLINE_CFG                3653    //Set PX Offline Configuration
#define    NET_DVR_GET_PXOFFLINE_CFG                3654    //Get PX Offline Configuration
#define    NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES  3655  //Get parking lot entrance ticket information capabilities
#define    NET_DVR_SET_PAPERCHARGEINFO                3656    //Set parking lot entrance ticket information
#define    NET_DVR_GET_PARKINGSAPCE_CAPABILITIES    3657    //Get Parking sapce Capabilities
#define    NET_DVR_SET_PARKINGSAPCE_INFO            3658    //Set Parking sapce Info
#define    NET_DVR_GET_PXMULTICTRL_CAPABILITIES    3659    //PX Multi Ctrl Configuration Capabilities
#define    NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES    3661    //Get Charge Account Info Capabilities
#define    NET_DVR_SET_CHARGE_ACCOUNTINFO          3662    //Set Charge Account Info
#define    NET_DVR_SET_PXMULTICTRL_CFG                3663    //Set PX Multi Ctrl Configuration
#define    NET_DVR_GET_PXMULTICTRL_CFG                3664    //Get PX Multi Ctrl Configuration
#define    NET_DVR_GET_TME_CHARGERULE              3665    //Get Entrance Vehicle Card
#define    NET_DVR_SET_TME_CHARGERULE               3666    //Set Entrance Vehicle Card
#define    NET_DVR_GET_TME_CHARGERULE_CAPABILITIES 3667    //Get Entrance Vehicle Card Capabilities
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES  3668    //Get Illegal card filtering Capabilities
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CFG    3669    //Get Illegal card filtering
#define    NET_DVR_SET_ILLEGALCARDFILTERING_CFG    3670    //Set Illegal card filtering
#define    NET_DVR_GET_LEDDISPLAY_CAPABILITIES        3671    //Get LED Display Capabilities
#define    NET_DVR_SET_LEDDISPLAY_CFG              3672    //Set LED Display Cfg
#define    NET_DVR_GET_LEDDISPLAY_CFG              3673    //Get LED Display Cfg
#define    NET_DVR_GET_VOICEBROADCAST_CAPABILITIES    3674    //Get VoiceBroadcast Capabilities
#define    NET_DVR_SET_VOICEBROADCAST_CFG          3675    //Set VoiceBroadcast Cfg
#define    NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES    3676//Get Paper Print Format Capabilities
#define    NET_DVR_GET_PAPERPRINTFORMAT_CFG        3677    //Get Paper Print Format Cfg
#define    NET_DVR_SET_PAPERPRINTFORMAT_CFG        3678    //Set Paper Print Format Cfg
#define    NET_DVR_GET_LOCkGATE_CAPABILITIES       3679    //Get Lock Gate Capabilities
#define    NET_DVR_GET_LOCKGATE_CFG                3680    //Get Lock Gate Cfg
#define    NET_DVR_SET_LOCKGATE_CFG                3681    //Set Lock Gate Cfg
#define NET_DVR_GET_PARKING_DATASTATE            3682    //Get Parking Data State
#define NET_DVR_SET_PARKING_DATASTATE           3683    //Set Parking Data State
#define    NET_DVR_GET_TME_CAPABILITIES            3684    //Get TME Capabilities

#define    NET_DVR_GET_TMEVOICE_CAPABILITIES       3686    //Get TME Voice Capabilities
#define    NET_DVR_SET_TMEVOICE_CFG                3687    //Set TME Voice CFG
#define    NET_DVR_GET_TMEVOICE_CFG                3688    //Get TME Voice CFG
#define    NET_DVR_DEL_TMEVOICE_CFG                3689    //Delete TME Voice CFG
#define    NET_DVR_GET_POSITION                    3698    //Get Soft Position Work Mode Param
#define    NET_DVR_SET_POSITION                    3699    //Set Soft Position Work Mode Param
#define    NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES    3700//Get Centralized Ctrl Capbailities
#define    NET_DVR_GET_CENTRALIZEDCTRL                3701    //Get Centralized Ctrl
#define    NET_DVR_SET_CENTRALIZEDCTRL              3702    //Set Centralized Ctrl
#define    NET_DVR_GET_COMPASS_CAPABILITIES        3703    //Get Compass Capabilities
#define    NET_DVR_GET_VANDALPROOFALARM              3704    //Get Vandalproof Alarm
#define    NET_DVR_SET_VANDALPROOFALARM            3705    //Set Vandalproof Alarm
#define    NET_DVR_COMPASS_CALIBRATE_CTRL            3706    //Compass Calibrate Ctrl
#define    NET_DVR_COMPASS_NORTH_CTRL                3707    //Compass North Ctrl
#define    NET_DVR_GET_AZIMUTHINFO                    3708    //Get Azimuth Info
#define    NET_DVR_GET_SATELLITETIME                3709    //Get Satellite positioning Cfg
#define    NET_DVR_SET_SATELLITETIME                3710    //Set Satellite positioning Cfg
#define    NET_DVR_GET_GISINFO                     3711    //Get DIS Info
#define    NET_DVR_GET_STREAMING_CAPABILITIES        3712    //Get Streaming Capabilities 
#define    NET_DVR_GET_REFRESHFRAME_CAPABILITIES    3713    //Get Refresh Frame Capabilities
#define    NET_DVR_STREAMING_REFRESH_FRAME            3714    //Streaming Refresh Frame
#define    NET_DVR_FACECAPTURE_STATISTICS            3715    //Face Capture Statistic

#define    NET_DVR_GET_WIRELESSSERVER_CAPABILITIES    3716    //get wireless server capabilities
#define    NET_DVR_GET_WIRELESSSERVER                3717    //get wireless server
#define    NET_DVR_SET_WIRELESSSERVER                3718    //set wireless server
#define    NET_DVR_GET_CONNECT_LIST_CAPABILITIES    3719    //get connect list capabilities
#define    NET_DVR_GET_THSCREEN_CAPABILITIES        3720    //Get Thscreen capabilities
#define    NET_DVR_GET_THSCREEN                    3721    //Get Thscreen

#define    NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES    3722    //Get External Device Capabilities
#define    NET_DVR_GET_EXTERNALDEVICE              3723    //Get External Device
#define    NET_DVR_SET_EXTERNALDEVICE                3724    //Set External Device
#define    NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES    3725   //Get Led Display Info Capabilities
#define    NET_DVR_SET_LEDDISPLAYINFO                3726   //Set Led Display Info 
#define    NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES 3727   //get Builtin supplement Light Capabilities
#define    NET_DVR_GET_SUPPLEMENTLIGHT                 3728    //get Builtin supplement Light
#define    NET_DVR_SET_SUPPLEMENTLIGHT                 3729    //set Builtin supplement Light
#define    NET_DVR_SET_THSCREEN                     3730   //Set Thscreen
#define    NET_DVR_GET_LOWPOWER_CAPABILITIES        3731   //Get Low Power Capabilities
#define    NET_DVR_GET_LOWPOWER                     3732    //Get Low Power Cfg
#define    NET_DVR_SET_LOWPOWER                     3733    //Set Low Power Cfg
#define    NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES     3734   //Get Zoom Linkage Capabilities
#define    NET_DVR_GET_ZOOMLINKAGE                     3735    //Get Zoom Linkage
#define    NET_DVR_SET_ZOOMLINKAGE                     3736    //Set Zoom Linkage
#define    NET_DVR_THSCREEN_TIMING                     3737    //ThScreen Timing

#define NET_DVR_GET_OSD_BATTERY_POWER_CFG        3741        //get osd battery power parameter
#define NET_DVR_SET_OSD_BATTERY_POWER_CFG        3742        //set osd battery power parameter
#define    NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES    3743//get osd battery power parameter Capabilities
#define    NET_DVR_GET_VANDALPROOFALARM_TRIGGER    3744    //Get VandalProof alarm Trigger
#define    NET_DVR_SET_VANDALPROOFALARM_TRIGGER    3745    //Set VandalProof alarm Trigger
#define    NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES    3746    //Get panorama image Capabilities 
#define    NET_DVR_GET_PANORAMAIMAGE                3747    //Get panorama image param 
#define    NET_DVR_SET_PANORAMAIMAGE                3748    //Set panorama image param 
#define    NET_DVR_GET_STREAMENCRYPTION            3749    //Get Stream Encryption param
#define    NET_DVR_SET_STREAMENCRYPTION            3750    //Set Stream Encryption param
#define    NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES 3751  //Get Stream Encryption Capabilities
#define    NET_DVR_GET_REVISE_GPS_CAPABILITIES     3752    //Get Revise GPS Capabilities
#define    NET_DVR_GET_REVISE_GPS                  3753    //Get Revise GPS CFG    
#define    NET_DVR_SET_REVISE_GPS                  3754    //Set Revise GPS CFG
#define NET_DVR_GET_PDC_RECOMMEND                3755    //get PDC Recommend value
#define NET_DVR_REMOVE_FLASHSTORAGE                3756    //Remove PDC Flash Storage
#define    NET_DVR_GET_COUNTING_CAPABILITIES        3757    //get PDC(counting) capabilities
#define    NET_DVR_SET_SENSOR_ADJUSTMENT            3758    //Set Sensor Adjustment
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES        3759    //Get Sensor Adjustment capabilities
#define    NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG         3760    //Get wifi Cfg(Full Version)
#define    NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG         3761    //Set wifi Cfg(Full Version)

#define    NET_DVR_GET_ONLINEUSER_INFO                3762    //get online user info
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_INFO        3763    //get the sensor adjustment info
#define NET_DVR_SENSOR_RESET_CTRL               3764    //Sensor adjustment reset
#define    NET_DVR_GET_POSTRADAR_CAPABILITIES        3765    //Get Post Radar Capabilities
#define    NET_DVR_GET_POSTRADARSPEED_CFG          3766    //Get Post Radar Speed Cfg
#define    NET_DVR_SET_POSTRADARSPEED_CFG          3767    //Set Post Radar Speed Cfg
#define    NET_DVR_GET_POSTRADARSPEED_RECOM_CFG    3768    //Get Post Radar Speed Recom Cfg
#define    NET_DVR_GET_POSTRADARPARAM_CFG          3769    //Get Post Radar Param Cfg
#define    NET_DVR_SET_POSTRADARPARAM_CFG          3770    //Set Post Radar Param Cfg
#define    NET_DVR_GET_POSTRADARPARAM_RECOM_CFG    3771    //Get Post Radar Param Recom Cfg
#define NET_DVR_GET_ENCRYPT_DEVICE_INFO         3772   //get encrypt device info
#define NET_DVR_GET_ANR_ARMING_HOST             3773  //Get offline continuingly host information 
#define NET_DVR_GET_FIRMWARE_VERSION    3776    //GET firmware version
/********************************The IPC baseline FF license plate ****************************/
#define    NET_DVR_GET_FTP_CAPABILITIES         3782    //Access to FTP ability
#define    NET_DVR_GET_FTPUPLOAD_CFG             3783    //Get for FTP upload information structured parameters 
#define    NET_DVR_SET_FTPUPLOAD_CFG             3784    //set the FTP upload information structured parameters  
#define NET_DVR_GET_VEHICLE_INFORMATION         3785 //Get vehicle information 
#define    NET_DVR_GET_DDNS_COUNTRY_ABILITY        3800    //Get DDNS country Ability 
#define NET_DVR_GET_DEVICECFG_V50    3801    //Get equipment parameters V50
#define NET_DVR_SET_DEVICECFG_V50    3802    //Set equipment parameters V50
#define NET_DVR_SET_VEHICLE_RECOG_TASK_V50    3851  //Set vehicle recog task V50 EX
#define    NET_DVR_GET_SMARTCALIBRATION_CAPABILITIES    3900    //Get Smart behavior calibration filter size function Capabilities
#define NET_DVR_GET_TEMPERATURE_TRIGGER              3903    //Get Temperture trigger
#define NET_DVR_SET_TEMPERATURE_TRIGGER              3904    //Set Temperture trigger
#define    NET_DVR_GET_SMARTCALIBRATION_CFG             3910        //Get Smart behavior calibration filter size function 
#define    NET_DVR_SET_SMARTCALIBRATION_CFG             3911        //Set Smart behavior calibration filter size function
#define NET_DVR_POST_SETUP_CALIB                     3912  //Set up calibration 
#define NET_DVR_SET_POS_INFO_OVERLAY                 3913//Set the Pos information code superposition of flow control
#define NET_DVR_GET_POS_INFO_OVERLAY                 3914//Superposition of Pos information stream control 
#define NET_DVR_GET_CAMERA_WORK_MODE                 3915  //Set the camera work mode parameters camera work mode 
#define NET_DVR_SET_CAMERA_WORK_MODE                 3916  //Get the camera work mode parameters camera work mode 
#define NET_DVR_GET_RESOLUTION_SWITCH_CAPABILITIES   3917  //get resolution switch capabilities
#define NET_DVR_GET_RESOLUTION_SWITCH                3918  //get resolution switch
#define NET_DVR_SET_RESOLUTION_SWITCH                3919  //set resolution switch
#define NET_DVR_GET_VEHICLLE_RESULT_CAPABILITIES     3951   //get the results of vehicle information ability 
#define NET_DVR_GET_CALIB_CAPABILITIES               3952//Get setup calibration capability
#define NET_DVR_GET_POSINFO_OVERLAY_CAPABILITIES     3953//Get Pos stack capability
#define NET_SDK_FINDMEDICALFILE      3954    //search medical record files
#define NET_SDK_FINDMEDICALPICTURE   3955    //search medical pictures
#define NET_DVR_SET_POSINFO_OVERLAY                  3960//Set Pos overlay
#define NET_DVR_GET_POSINFO_OVERLAY                  3961//Get Pos overlay
#define NET_DVR_GET_FACELIB_TRIGGER                  3962   //get face lib trigger
#define NET_DVR_SET_FACELIB_TRIGGER                  3963   //set face lib trigger
#define NET_DVR_GET_FACECONTRAST_TRIGGER             3965//Get face alignment linkage configuration
#define NET_DVR_SET_FACECONTRAST_TRIGGER             3966//Set face alignment linkage configuration
#define NET_DVR_GET_FACECONTRAST_SCHEDULE_CAPABILITIES 3967 //Get on face time defending ability
#define NET_DVR_GET_FACECONTRAST_SCHEDULE            3968//Get face time allocation ratio
#define NET_DVR_SET_FACECONTRAST_SCHEDULE            3969//Configuration settings on face deployment time
#define NET_DVR_GET_FACELIB_SCHEDULE_CAPABILITIES    3970 //get face lib schedule capabilities
#define NET_DVR_GET_VCA_VERSION_LIST                 3973//Get algorithm library version
#define NET_DVR_GET_SETUP_CALIB                      3974//Set up calibration
#define NET_DVR_GET_PANORAMA_LINKAGE                 3975//Get to upload screenshots linkage configuration
#define NET_DVR_SET_PANORAMA_LINKAGE                 3976//Set the upload to capture linkage configuration
#define NET_DVR_GET_FACELIB_SCHEDULE                 3977 //get face lib schedule
#define NET_DVR_SET_FACELIB_SCHEDULE                 3978 //t facelib schedule
#define NET_DVR_GET_SOFTWARE_SERVICE_CAPABILITIES    3980//Get the ability of service 
#define NET_DVR_GET_SOFTWARE_SERVICE                 3981//Get software service configuration 
#define NET_DVR_SET_SOFTWARE_SERVICE                 3982//Set software and services 
#define NET_DVR_GET_PREVIEW_MODE_CAPABILITIES        3983//Get preview mode configuration
#define NET_DVR_SET_EAGLE_FOCUS_GOTOSCENE            3984//The eagle focus set camera turns to the specified scene ID
#define NET_DVR_EAGLE_FOCUS_SCENE_DEL                3985//Remove the focus of the eagle calibration scene
#define NET_DVR_GET_SAFETY_HELMET_TRIGGER            3986  //Get Safety helmet detection linkage configuration
#define NET_DVR_SET_SAFETY_HELMET_TRIGGER            3987  //Set Safety helmet detection linkage configuration
#define NET_DVR_GET_SAFETY_HELMET_SCHEDULE_CAPABILITIES 3988 //Get Safety helmet detection schedule capabilities
#define NET_DVR_GET_SAFETY_HELMET_SCHEDULE            3989//Get Safety helmet detection schedule configuration
#define NET_DVR_SET_SAFETY_HELMET_SCHEDULE            3990//Set Safety helmet detection schedule configuration

#define NET_DVR_GET_SIGN_ABNORMAL_TRIGGER            4150   //Get sign abnormal linkage configuration
#define NET_DVR_SET_SIGN_ABNORMAL_TRIGGER            4151   //Set sign abnormal linkage configuration
#define NET_DVR_ONE_KEY_CONFIG_SAN_V50               4152  //One key configuration SAN (V50) 
#define NET_DVR_GET_HDCFG_V50                        4153  //Get hard disk information parameters V50
#define NET_DVR_SET_HDCFG_V50                        4154  //Set hard disk information parameters V50
#define NET_DVR_GET_HDVOLUME_CFG                     4155  //Get hard disk volume information
#define NET_DVR_SET_HDVOLUME_CFG                     4156  //Set hard disk volume information
#define NET_DVR_GET_POWER_SUPPLY_CABINET_TRIGGER     4157  //get ITS Monitor linkage config
#define NET_DVR_SET_POWER_SUPPLY_CABINET_TRIGGER     4158  //set ITS Monitor linkage config
#define NET_DVR_GET_SENSOR_TRIGGER                   4159  //get Sensor Port linkage config
#define NET_DVR_SET_SENSOR_TRIGGER                   4160  //set Sensor Port linkage config
#define	NET_DVR_GET_FACESNAP_TRIGGER                 4161  //Get FaceSnap Trigger
#define	NET_DVR_SET_FACESNAP_TRIGGER	             4162  //Set FaceSnap Trigger
#define NET_DVR_GET_FACESNAP_SCHEDULE_CAPABILITIES   4163  //Get FaceSnap Scheule Time Capabilities
#define NET_DVR_GET_FACESNAP_SCHEDULE                4164  //Get FaceSnap Scheule Time
#define NET_DVR_SET_FACESNAP_SCHEDULE                4165  //Set FaceSnap Scheule Time

#define NET_DVR_SET_SCREEN_SWITCH                    4171  //Image switching control
#define NET_DVR_GET_BV_CALIB_PIC                     4172  //Get the device to grab images and additional information
#define NET_DVR_GET_BV_CALIB_RESULT                  4173  //Get the binocular calib result
#define NET_DVR_GET_BV_HCORRECTION                   4174  //Get the binocular height correction data
#define NET_DVR_DEL_BV_CALIB_PIC                     4175  //Delete the sample image
#define NET_DVR_GET_TV_SCREEN_CFG                    4176  //Get the broadcast screen stay time configuration
#define NET_DVR_SET_TV_SCREEN_CFG                    4177  //Set the broadcast screen stay time configuration
#define NET_DVR_ADJUST_BV_CALIB                      4178  //Adjust the binocular calibration
#define NET_DVR_GET_HUMAN_CALIB                      4179  //Get human position calibration cfg
#define NET_DVR_SET_HUMAN_CALIB                      4180  //Set human position calibration cfg
#define NET_DVR_GET_USERCFG_V51                      4181    //Get user parameters
#define NET_DVR_SET_USERCFG_V51                      4182    //Set user parameters
#define NET_DVR_GET_SOFTIO_TRIGGER                   4183   //Get the SoftIO linkage configuration
#define NET_DVR_SET_SOFTIO_TRIGGER                   4184   //Set the SoftIO linkage configuration
#define NET_DVR_GET_SOFTIO_SCHEDULE_CAPABILITIES     4185 //Get the SoftIO schedule time capabilities
#define NET_DVR_GET_SOFTIO_SCHEDULE                  4186 //Get the SoftIO schedule time
#define NET_DVR_SET_SOFTIO_SCHEDULE                  4187 //Set the SoftIO schedule time
#define NET_DVR_GET_HFPD_TRIGGER                     4188 //Get the HFPD linkage configuration
#define NET_DVR_SET_HFPD_TRIGGER                     4189 //Set the HFPD linkage configuration
#define NET_DVR_GET_HFPD_SCHEDULE_CAPABILITIES       4190 //Get the HFPD schedule time capabilities
#define NET_DVR_GET_HFPD_SCHEDULE                    4191 //Get the HFPD schedule time
#define NET_DVR_SET_HFPD_SCHEDULE                    4192 //Set the HFPD schedule time
#define	NET_DVR_GET_ALARM_INFO                       4193	//Get alarm information
#define NET_DVR_GET_USERCFG_V52                      4194    //Get user parameters V52
#define NET_DVR_SET_USERCFG_V52                      4195    //Set user parameters V52


/********************************NVR_Prodection Line****************************/
#define NET_DVR_GET_MUTEX_FUNCTION              4353  //get mutex function information

#define NET_DVR_GET_SINGLE_CHANNELINFO          4360  //get single channel information
#define NET_DVR_GET_CHANNELINFO                 4361  //get channnel information
#define NET_DVR_CHECK_LOGIN_PASSWORDCFG             4362  //admin login password check
#define NET_DVR_GET_SINGLE_SECURITY_QUESTION_CFG        4363    //get single device security question
#define NET_DVR_SET_SINGLE_SECURITY_QUESTION_CFG        4364    //set single device security question
#define NET_DVR_GET_SECURITY_QUESTION_CFG       4365    //get device security question
#define NET_DVR_SET_SECURITY_QUESTION_CFG       4366    //set device security question
#define NET_DVR_GET_ONLINEUSERLIST_SC           4367  //remote get user login inf (short connect)

#define    NET_DVR_GET_BLOCKLIST_FACECONTRAST_TRIGGER   4368   //GET BLOCKLIST FACECONTRAST TRIGGER
#define    NET_DVR_SET_BLOCKLIST_FACECONTRAST_TRIGGER   4369   //SET BLOCKLIST FACECONTRAST TRIGGER
#define    NET_DVR_GET_ALLOWLIST_FACECONTRAST_TRIGGER   4370   //GET ALLOWLIST FACECONTRAST TRIGGER
#define    NET_DVR_SET_ALLOWLIST_FACECONTRAST_TRIGGER   4371   //SET ALLOWLIST FACECONTRAST TRIGGER
#define    NET_DVR_GET_BLOCKLIST_FACECONTRAST_SCHEDULE_CAPABILITIES 4372 //GET BLOCKLIST FACECONTRAST SCHEDULE CAPABILITIES
#define NET_DVR_GET_BLOCKLIST_FACECONTRAST_SCHEDULE  4373   //GET_BLOCKLIST FACECONTRAST SCHEDULE
#define NET_DVR_SET_BLOCKLIST_FACECONTRAST_SCHEDULE  4374   //SET_BLOCKLIST FACECONTRAST SCHEDULE
#define NET_DVR_GET_ALLOWLIST_FACECONTRAST_SCHEDULE_CAPABILITIES 4375 //GET ALLOWLIST FACECONTRAST SCHEDULE CAPABILITIES
#define NET_DVR_GET_ALLOWLIST_FACECONTRAST_SCHEDULE  4376 //GET ALLOWLIST  FACECONTRAST SCHEDULE
#define NET_DVR_SET_ALLOWLIST_FACECONTRAST_SCHEDULE  4377 //SET ALLOWLIST FACECONTRAST SCHEDULE

#define NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE_CAPABILITIES 4378 //GET HUMAN RECOGNITION SCHEDULE CAPABILITIES
#define NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE 4379 //GET HUMAN RECOGNITION SCHEDULE
#define NET_DVR_SET_HUMAN_RECOGNITION_SCHEDULE 4380 //SET HUMAN RECOGNITION SCHEDULE
#define NET_DVR_GET_HUMAN_RECOGNITION_TRIGGER               4381 //GET HUMAN RECOGNITION TRIGGER
#define NET_DVR_SET_HUMAN_RECOGNITION_TRIGGER               4382 //SET HUMAN RECOGNITION TRIGGER
#define NET_DVR_GET_GBT28181_AUDIO_OUTPUT_CFG               4383 //GET GBT28181 AUDIO OUTPUT CFG
#define NET_DVR_SET_GBT28181_AUDIO_OUTPUT_CFG               4384 //SET GBT28181 AUDIO OUTPUT CFG

#define NET_DVR_GET_STUDENTS_STOODUP_TRIGGER         4386   //Get students to stand up to detect linkage configuration 
#define NET_DVR_SET_STUDENTS_STOODUP_TRIGGER         4387   //Set students to stand up to detect linkage configuration 
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE_CAPABILITIES    4388 //Get regional people counting schedule ability 
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE  4389    //Get regional people counting schedule
#define NET_DVR_SET_FRAMES_PEOPLE_COUNTING_SCHEDULE  4390    //Set regional people counting schedule
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_TRIGGER   4391   //Get regional people counting trigger
#define NET_DVR_SET_FRAMES_PEOPLE_COUNTING_TRIGGER   4392   //Set regional people counting trigger
#define NET_DVR_GET_PERSONDENSITY_TRIGGER   4393   //Get linkage of the personnel density test configuration 
#define NET_DVR_SET_PERSONDENSITY_TRIGGER   4394   //Set linkage of the personnel density test configuration 
#define NET_DVR_GET_PERSONDENSITY_SCHEDULE_CAPABILITIES 4395 //Get personnel density detection protection time configuration capabilities
#define NET_DVR_GET_PERSONDENSITY_SCHEDULE 4396 //Get personnel density detection protection time configuration
#define NET_DVR_SET_PERSONDENSITY_SCHEDULE 4397 //Set personnel density detection protection time configuration

#define NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE_CAPABILITIES  4398 //Get students to stand up detection protection ability 
#define NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE        4399    //Get students to stand up detection protection
#define NET_DVR_SET_STUDENTS_STOODUP_SCHEDULE        4400    //Set students to stand up detection protection

#define NET_DVR_SET_FACE_THERMOMETRY_TRIGGER         4401 //SET FACE THERMOMETRY TRIGGER
#define NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE_CAPABILITIES 4402 //GET FACE THERMOMETRY SCHEDULE CAPABILITIES
#define NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE        4403 //GET FACE THERMOMETRY SCHEDULE
#define NET_DVR_SET_FACE_THERMOMETRY_SCHEDULE        4404 //SET FACE THERMOMETRY SCHEDULE
#define NET_DVR_GET_FACE_THERMOMETRY_TRIGGER         4405 //GET FACE THERMOMETRY TRIGGER
#define	NET_DVR_GET_PERSONQUEUE_TRIGGER   4406   //GET PERSONQUEUE TRIGGER
#define	NET_DVR_SET_PERSONQUEUE_TRIGGER	  4407   //SET PERSONQUEUE TRIGGER
#define	NET_DVR_GET_PERSONQUEUE_SCHEDULE_CAPABILITIES	4408 //GET PERSONQUEUE SCHEDULE CAPABILITIES
#define	NET_DVR_GET_PERSONQUEUE_SCHEDULE	4409	//GET PERSONQUEUE SCHEDULE
#define	NET_DVR_SET_PERSONQUEUE_SCHEDULE	4410	//SET PERSONQUEUE SCHEDULE
#define	NET_DVR_SET_START_VIDEOAUDIO    	4411	//Set NVR to enable audio and video function (for device self-test only)

#define NET_DVR_GET_FACESNAPCFG              5001       //Get face snap configuration
#define NET_DVR_SET_FACESNAPCFG              5002       //Set face snap configuration
#define NET_DVR_GET_DEVACCESS_CFG            5005       //Get device access configuration
#define NET_DVR_SET_DEVACCESS_CFG            5006       //Set device access configuration
#define NET_DVR_GET_SAVE_PATH_CFG            5007       //Get storage information parameter
#define NET_DVR_SET_SAVE_PATH_CFG            5008       //Set storage information parameter
#define NET_VCA_GET_RULECFG_V41                 5011        //Get behavior analysis parameters (extended)
#define NET_VCA_SET_RULECFG_V41                 5012        //Set behavior analysis parameters (extended)
#define NET_DVR_GET_AID_RULECFG_V41          5013       //Get traffic event rule parameters(extended)
#define NET_DVR_SET_AID_RULECFG_V41          5014       //Set traffic event rule parameters(extended)
#define NET_DVR_GET_TPS_RULECFG_V41          5015       //Get traffic rule statistics(extended)
#define NET_DVR_SET_TPS_RULECFG_V41          5016       //Set traffic rule statistics(extended)
#define NET_VCA_GET_FACEDETECT_RULECFG_V41   5017       //Get ATM face detect analysis parameters(extended) 
#define NET_VCA_SET_FACEDETECT_RULECFG_V41   5018       //Set ATM face detect analysis parameters(extended) 
#define NET_DVR_GET_PDC_RULECFG_V41          5019       //Get PDC analysis parameters(extended)
#define NET_DVR_SET_PDC_RULECFG_V41          5020       //Set PDC analysis parameters(extended)
#define NET_DVR_GET_TRIAL_VERSION_CFG        5021       //Get trial version
#define NET_DVR_GET_VCA_CTRLINFO_CFG         5022       //Get vca ctrl info(extended)
#define NET_DVR_SET_VCA_CTRLINFO_CFG         5023       //Set vca ctrl info(extended)
#define NET_DVR_SYN_CHANNEL_NAME             5024       //Syn channel name
#define NET_DVR_GET_RESET_COUNTER            5025       //Get reset counter
#define NET_DVR_SET_RESET_COUNTER            5026       //Set reset counter
#define NET_DVR_GET_OBJECT_COLOR             5027       //Get object color attribute
#define NET_DVR_SET_OBJECT_COLOR             5028       //Set object color attribute
#define NET_DVR_GET_AUX_AREA                 5029       //Get auxiliary area list
#define NET_DVR_SET_AUX_AREA                 5030       //Set auxiliary area list
#define NET_DVR_GET_CHAN_WORKMODE            5031       //Get channel workmode
#define NET_DVR_SET_CHAN_WORKMODE            5032       //Set channel workmode
#define NET_DVR_GET_SLAVE_CHANNEL            5033       //Get slave channel parameters
#define NET_DVR_SET_SLAVE_CHANNEL            5034       //Set slave channel parameters
#define NET_DVR_GET_VQD_EVENT_RULE           5035       //Get VQD event rule
#define NET_DVR_SET_VQD_EVENT_RULE           5036       //Set VQD event rule
#define NET_DVR_GET_BASELINE_SCENE           5037       //Get baseline scene parameters
#define NET_DVR_SET_BASELINE_SCENE           5038       //Set baseline scene parameters
#define NET_DVR_CONTROL_BASELINE_SCENE       5039       //Operation on baseline scene
#define NET_DVR_SET_VCA_DETION_CFG             5040        //set vca detion cfg
#define NET_DVR_GET_VCA_DETION_CFG             5041        //get vca detion cfg
#define NET_DVR_GET_STREAM_ATTACHINFO_CFG    5042       //get stream attach parameters
#define NET_DVR_SET_STREAM_ATTACHINFO_CFG    5043       //set stream attach parameters

#define NET_DVR_GET_BV_CALIB_TYPE            5044       //Get Calib Type
#define NET_DVR_CONTROL_BV_SAMPLE_CALIB      5045       //Sample Calib 
#define NET_DVR_GET_BV_SAMPLE_CALIB_CFG      5046       //Get Sample Calib Point
#define NET_DVR_GET_RULECFG_V42                 5049       //Get rule V42 of VCA
#define NET_DVR_SET_RULECFG_V42                 5050       //Set rule V42 of VCA
#define NET_DVR_SET_VCA_DETION_CFG_V40         5051       //set vca detion cfg
#define NET_DVR_GET_VCA_DETION_CFG_V40       5052       //get vca detion cfg
#define NET_DVR_SET_FLASH_CFG                5110       //Write data to the Flash test 
/********************************ITS****************************/
//2014-12-03  
#define    NET_DVR_GET_T1TEST_CFG   5053     //Production line test configuration interface (get)
#define    NET_DVR_SET_T1TEST_CFG   5054     //Production line test configuration interface (set)

#define NET_ITS_GET_OVERLAP_CFG_V50             5055       //Get Overlap Cfg V50
#define NET_ITS_SET_OVERLAP_CFG_V50             5056       //Set Overlap Cfg V50
#define NET_DVR_GET_PARKLAMP_STATE             5057       //Get  Access to parking signal status information
#define NET_DVR_GET_CLOUDSTORAGE_CFG         5058       //Gets the cloud storage configuration parameters
#define NET_DVR_SET_CLOUDSTORAGE_CFG         5059       //Sets the cloud storage configuration parameters

#define NET_ITS_GET_BASE_INFO                 5060        //Get ITS base information
#define NET_DVR_GET_SENSOR_INFO              5061       //Get Sensor Cfg
#define    NET_DVR_SET_SENSOR_SWITCH             5062       //Set Sensor Switch
#define NET_ITS_GET_IMGMERGE_CFG             5063        //Get image merge configuration
#define NET_ITS_SET_IMGMERGE_CFG             5064        //Set image merge configuration
#define NET_ITS_GET_UPLOAD_CFG                 5065        //Get upload data configuration
#define NET_ITS_SET_UPLOAD_CFG                 5066        //Set upload data configuration
#define    NET_DVR_GET_SENSOR_PORT_CAPABILITIES 5067       //Get Sensor Port Capabilities
#define NET_ITS_GET_WORKSTATE                 5069        //Get ITS work state
#define NET_ITS_GET_IPC_CHAN_CFG             5070        //Get ITS IPC channel configuration
#define NET_ITS_SET_IPC_CHAN_CFG             5071        //Set ITS IPC channel configuration
#define NET_ITS_GET_OVERLAP_CFG                 5072        //Get overlap configuration
#define NET_ITS_SET_OVERLAP_CFG                 5073        //Set overlap configuration
#define NET_DVR_GET_TRIGGEREX_CFG            5074       //Get Trigger Configuration
#define NET_DVR_SET_TRIGGEREX_CFG            5075       //Set Trigger Configuration
#define NET_ITS_GET_ROAD_INFO                 5076        //Get road information

#define NET_ITS_REMOTE_DEVICE_CONTROL         5077        //Set Remote device control
#define NET_ITS_GET_GATEIPC_CHAN_CFG         5078        //Get the synchronization host configuration
#define NET_ITS_SET_GATEIPC_CHAN_CFG         5079        //Set the synchronization host configuration
#define NET_ITS_TRANSCHAN_START              5080       //Start Synchronous data server
#define NET_ITS_GET_ECTWORKSTATE             5081       //Get the import and export terminal state
#define NET_ITS_GET_ECT_CHAN_INFO            5082       //Get the import and export terminal channel status
#define NET_DVR_GET_HEATMAP_RESULT           5083       //Get Heat Map 2014-03-21

//2013-11-19
#define NET_DVR_SET_ITS_EXDEVCFG             5084       //Set ITS CFG
#define NET_DVR_GET_ITS_EXDEVCFG             5085       //Get ITS CFG
#define NET_DVR_GET_ITS_EXDEVSTATUS             5086       //Get ITS Device Status
#define NET_DVR_SET_ITS_ENDEVCMD             5087       //Set ITS Control
#define NET_DVR_SET_ENISSUED_DATADEL         5088       //Set ITS Data Delete

#define NET_DVR_GET_PDC_RESULT               5089       //Passenger flow data query 2014-03-21

#define NET_ITS_GET_LAMP_CTRLCFG             5090       //Get inside and outside the lamp parameters 
#define NET_ITS_SET_LAMP_CTRLCFG             5091       //Set inside and outside the lamp parameters 
#define NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG  5092       //Get special parking space parameters 
#define NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG  5093       //Set special parking space parameters 
#define NET_ITS_SET_LAMP_EXTERNAL_CFG        5095       //Set external control configuration parameters
#define NET_ITS_SET_COMPEL_CAPTURE           5096       //Set the parking enforcement 

#define  NET_DVR_SET_TIMESIGN_CFG            5097       //Set Custom Set Time Sign
#define  NET_DVR_GET_TIMESIGN_CFG            5098       //Get Custom Set Time Sign
#define NET_DVR_GET_SIGNALLAMP_STATUS        5099       //Signal lamp detection

#define NET_DVR_GET_MONITOR_PLAN_VQD         5100       //long connection to obtain diagnostic server program
#define NET_DVR_GET_MONITORID_VQD            5101       //long connection for monitoring points within the corresponding plan
#define NET_DVR_SET_MONITOR_INFO             5102       //monitoring points within the volume set plan 
#define NET_DVR_DEL_MONITOR_PLAN_VQD         5103       //delete plan
#define NET_DVR_GET_MONITOR_VQD_STATUS       5104       //platform state to query the server for diagnosis
#define NET_DVR_GET_RECORD_INFO              5105       //access to resources pictures inquiries
#define NET_DVR_GET_MONITOR_VQDCFG           5106       //Get server monitoring points
#define NET_DVR_SET_MONITOR_VQDCFG           5107       //set server monitoring points
#define NET_DVR_SET_MONITOR_PLAN_VQDCFG      5108       //settings management plan (individual plan)

#define NET_DVR_SCENE_CHANGE_UPDATE             5109        //scene change update

#define NET_DVR_GET_CALIBRATE_POINT          5153       //Normalized coordinate transformation (Shot the ball linkage equipment external interactive command code Baseline code does not realize, prevent conflict, submitted to the baseline )

#define NET_DVR_GET_SCENE_CFG                5201       //Get scene configuration
#define NET_DVR_SET_SCENE_CFG                5202       //Set scene configuration
#define NET_DVR_GET_SCENE_REFERENCE_REGION   5203       //Get scene reference region
#define NET_DVR_SET_SCENE_REFERENCE_REGION   5204       //Set scene reference region
#define NET_DVR_GET_SCENE_CALIBRATION        5205       //Get scene calibration
#define NET_DVR_SET_SCENE_CALIBRATION        5206       //Set scene calibration
#define NET_DVR_GET_SCENE_MASK_REGION        5207       //Get scene mask region
#define NET_DVR_SET_SCENE_MASK_REGION        5208       //Set scene mask region
#define    NET_DVR_GET_SCENE_LANECFG             5209       //Get scene lane rule parameters
#define NET_DVR_SET_SCENE_LANECFG             5210       //Set scene lane rule parameters
#define NET_DVR_GET_SCENE_AID_RULECFG        5211       //Get scene traffic event rule parameters
#define NET_DVR_SET_SCENE_AID_RULECFG        5212       //Set scene traffic event rule parameters
#define NET_DVR_GET_SCENE_TPS_RULECFG        5213       //Get scene traffic rule statistics
#define NET_DVR_SET_SCENE_TPS_RULECFG        5214       //Set scene traffic rule statistics
#define NET_DVR_GET_SCENE_TIME_CFG           5215       //Get scene effective time configuration
#define NET_DVR_SET_SCENE_TIME_CFG           5216       //Set scene effective time configuration
#define NET_DVR_GET_FORENSICS_MODE           5217       //Get forensics mode
#define NET_DVR_SET_FORENSICS_MODE           5218       //Set forensics mode
#define NET_DVR_FORCESTOP_FORENSICS_CTRL     5219       //Force stop Forensics Ctrl

#define NET_DVR_GET_ALARM_PROCESS_CFG           5220
#define NET_DVR_SET_ALARM_PROCESS_CFG           5221
#define NET_DVR_GET_BLOCKLIST_ALARM_INFO        5222
#define NET_DVR_GET_STORAGE_RESOURCE_CFG        5225
#define NET_DVR_SET_STORAGE_RESOURCE_CFG        5226
#define NET_DVR_DEL_BLOCKLIST_ALARM_RECORD        5227
#define NET_DVR_SET_BLOCKLIST_GROUP_INFO        5229
#define NET_DVR_DEL_BLOCKLIST_GROUP_INFO        5230
#define NET_DVR_GET_BLOCKLIST_GROUP_INFO        5231
#define NET_DVR_SET_BLOCKLIST_GROUP_RECORD_CFG    5232
#define NET_DVR_GET_BLOCKLIST_GROUP_RECORD_CFG    5234
#define NET_DVR_DEL_BLOCKLIST_GROUP_RECORD_CFG    5235
#define    NET_DVR_GET_AREA_MONITOR_CFG            5236
#define    NET_DVR_SET_AREA_MONITOR_CFG            5237
#define    NET_DVR_DEL_AREA_MONITOR_CFG            5238
#define NET_DVR_RETRIEVAL_SNAP_RECORD            5240
#define NET_DVR_GET_ALARMLIST                    5241
#define NET_DVR_DETECT_IMAGE                    5242
#define NET_DVR_GET_SNAP_RECORD                 5243
#define NET_DVR_DEL_SNAP_RECORD                 5244
#define NET_DVR_GET_FACE_RECORD                 5245
#define NET_DVR_SET_FACE_RECORD                    5246
#define NET_DVR_DEL_FACE_RECORD                    5247
#define NET_DVR_GET_FACE_DATABASE                5248
#define NET_DVR_SET_FACE_DATABASE                5249
#define NET_DVR_DEL_FACE_DATABASE                5250
#define NET_DVR_RETRIEVAL_FACE_DATABASE            5251
#define NET_DVR_SET_BLOCKLIST_REL_DEV_CFG        5252
#define NET_DVR_DEL_BLOCKLIST_REL_DEV            5253

//NVR which has 64 IPC: Get the information of disk raid.
#define NET_DVR_GET_DISK_RAID_INFO             6001       //Get the information of disk raid
#define NET_DVR_SET_DISK_RAID_INFO             6002       //Set the information of disk raid
#define NET_DVR_GET_DVR_SYNCHRONOUS_IPC      6005       //Set the parameter which is used to synchronise IPC.
#define NET_DVR_SET_DVR_SYNCHRONOUS_IPC      6006       //Get the parameter which is used to synchronise IPC.
#define NET_DVR_SET_DVR_IPC_PASSWD             6008        //Set the password of IPC.
#define NET_DVR_GET_DEVICE_NET_USING_INFO     6009        //Get the using information of device net.
#define NET_DVR_SET_DVR_IPC_NET              6012        //Set the IP of IPC.
#define NET_DVR_GET_RECORD_CHANNEL_INFO      6013        //Get record channel information
#define NET_DVR_SET_RECORD_CHANNEL_INFO      6014        //Set record channel information

#define NET_DVR_MOUNT_DISK                     6015       // Mount disk
#define NET_DVR_UNMOUNT_DISK                 6016       // Unmount disk

// CVR 
#define NET_DVR_GET_STREAM_SRC_INFO             6017        //Get stream source information
#define NET_DVR_SET_STREAM_SRC_INFO             6018        //Set stream source information
#define NET_DVR_GET_STREAM_RECORD_INFO         6019        //Get stream record information
#define NET_DVR_SET_STREAM_RECORD_INFO         6020        //Set stream record information
#define NET_DVR_GET_STREAM_RECORD_STATUS     6021        //Get stream record status
#define NET_DVR_SET_STREAM_RECORD_STATUS     6022        //Set stream record status
#define NET_DVR_GET_STREAM_INFO                 6023        //Get stream ID info
#define NET_DVR_GET_STREAM_SRC_INFO_V40         6024       //Get stream source information Expend
#define NET_DVR_SET_STREAM_SRC_INFO_V40       6025       //Set stream source information Expend
#define NET_DVR_GET_RELOCATE_INFO            6026       //Get N+0 relocate info
#define NET_DVR_START_GOP_INFO_PASSBACK      6032       //VCA or Smart Info Pass Back
#define NET_DVR_GET_CHANS_RECORD_STATUS_CFG  6035       //Get Chan Record Status
#define NET_DVR_SET_CHANS_RECORD_STATUS_CFG  6036       //Set Chan Record Status


//NVR:96xx
#define NET_DVR_GET_IP_ALARM_GROUP_NUM         6100  
#define NET_DVR_GET_IP_ALARM_IN                 6101  
#define NET_DVR_GET_IP_ALARM_OUT             6102
//9000 v2.2
#define NET_DVR_GET_FTPCFG_SECOND             6103          //Get FTP parameter to which upload the picture
#define NET_DVR_SET_FTPCFG_SECOND             6104          //Set FTP parameter to which upload the picture

#define NET_DVR_GET_DEFAULT_VIDEO_EFFECT     6105        //Get default video effect
#define NET_DVR_SET_VIDEO_EFFECT             6106       //Set video effect

#define NET_DVR_DEL_INVALID_DISK             6107       // Delete invalid disk

#define NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG 6109        //Get disk quota of frame extracting channel
#define NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG 6110        //Set disk quota of frame extracting channel

#define NET_DVR_GET_NAT_CFG                  6111       //Get NAT parameter
#define NET_DVR_SET_NAT_CFG                  6112       //Set NAT parameter  

#define NET_DVR_GET_AES_KEY                  6113       //Get device's AES key

#define NET_DVR_GET_POE_CFG                  6114        //Get POE parameter
#define NET_DVR_SET_POE_CFG                  6115        //Set POE parameter

#define NET_DVR_GET_CUSTOM_PRO_CFG           6116        //Get customized protocol parameter 
#define NET_DVR_SET_CUSTOM_PRO_CFG           6117        //Set customized protocol parameter  

#define NET_DVR_GET_STREAM_CABAC             6118        //Get Stream CABAC
#define NET_DVR_SET_STREAM_CABAC             6119        //Set Stream CABAC

#define NET_DVR_GET_ESATA_MINISAS_USAGE_CFG     6120        //Get eSATA & miniSAS usage
#define NET_DVR_SET_ESATA_MINISAS_USAGE_CFG     6121        //Set eSATA & miniSAS usage

#define NET_DVR_GET_HDCFG_V40                 6122        //Get hard disk info
#define NET_DVR_SET_HDCFG_V40                 6123        //Set hard disk info

#define NET_DVR_GET_POE_CHANNEL_ADD_MODE     6124        //Get POE channel add mode
#define NET_DVR_SET_POE_CHANNEL_ADD_MODE     6125        //Set POE channel add mode

#define NET_DVR_GET_DIGITAL_CHANNEL_STATE    6126        //Get digital channel state


#define   NET_DVR_GET_BONJOUR_CFG           6127 
#define   NET_DVR_SET_BONJOUR_CFG           6128 


#define NET_DVR_GET_SOCKS_CFG                6130        
#define NET_DVR_SET_SOCKS_CFG                  6131      

#define    NET_DVR_GET_QOS_CFG                    6132    
#define NET_DVR_SET_QOS_CFG                    6133

#define NET_DVR_GET_HTTPS_CFG                6134    
#define NET_DVR_SET_HTTPS_CFG                6135

#define NET_DVR_GET_WD1_CFG                 6136     //get WD1 Enable status
#define NET_DVR_SET_WD1_CFG                 6137     //set WD1 Enable status

#define NET_DVR_CREATE_CERT                 6138       
#define NET_DVR_DELETE_CERT                 6139      


#define NET_DVR_GET_RECORD_LOCK_PERCENTAGE    6140        //Get record lock percentage
#define NET_DVR_SET_RECORD_LOCK_PERCENTAGE  6141        //Set record lock percentage

#define NET_DVR_CMD_TRIGGER_PERIOD_RECORD    6144        //Comand trigger period record
#define NET_DVR_UPLOAD_CERT                 6145      
#define NET_DVR_DOWNLOAD_CERT               6146      
#define NET_DVR_GET_CERT                    6147

#define NET_DVR_GET_POS_FILTER_CFG                6148    //Get POS Filter Cfg
#define NET_DVR_SET_POS_FILTER_CFG                6149    //Set POS Filter Cfg
#define NET_DVR_GET_CONNECT_POS_CFG                6150    //Get DVR and POS Connect Cfg
#define NET_DVR_SET_CONNECT_POS_CFG                6151    //Set DVR and POS Connect Cfg
#define NET_DVR_GET_CHAN_FILTER_CFG                6152    //Get Filter and Channel Relationship  
#define NET_DVR_SET_CHAN_FILTER_CFG                6153    //Set Filter and Channel Relationship  


#define NET_DVR_GET_FTPCFG_V40                6162    //Get FTP information
#define NET_DVR_SET_FTPCFG_V40                6163    //Set FTP information

#define NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION 6164   
#define NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO  6165   
#define NET_DVR_GET_PREVIEW_SWITCH_CFG            6166   
#define NET_DVR_SET_PREVIEW_SWITCH_CFG            6167   

//Netra3.0.0
#define NET_DVR_GET_N_PLUS_ONE_WORK_MODE            6168    //Get N+1 work mode
#define NET_DVR_SET_N_PLUS_ONE_WORK_MODE            6169    //Set N+1 work mode

#define NET_DVR_GET_HD_STATUS                         6170    //Get HD status
#define NET_DVR_SET_HD_STATUS                         6171    //Set HD status

#define NET_DVR_IMPORT_IPC_CFG_FILE                    6172    //Import ip access config file
#define NET_DVR_EXPORT_IPC_CFG_FILE                    6173    //Export ip access config file 
#define NET_DVR_UPGRADE_IPC                            6174    //Upgrade ip channel

#define NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED        6175    
#define NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED        6176    



//marvell 256 NVR
#define NET_DVR_GET_EXCEPTIONCFG_V40                6177    //Get Exception Cfg 
#define NET_DVR_SET_EXCEPTIONCFG_V40                6178    //Set Exception Cfg 
#define NET_DVR_GET_PICCFG_V40                      6179    //Get Picture Param Cfg
#define NET_DVR_SET_PICCFG_V40                      6180    //Set Picture Param Cfg
#define NET_DVR_GET_ALARMINCFG_V40                  6181    //Get AlarmIn Cfg
#define NET_DVR_SET_ALARMINCFG_V40                  6182    //Set AlarmIn Cfg
#define NET_DVR_GET_IPALARMINCFG_V40                6183    //Get IP AlarmIn Cfg
#define NET_DVR_GET_IPALARMOUTCFG_V40               6185    //Set IP AlarmIn Cfg 
#define NET_DVR_GET_USERCFG_V40                     6187    //Get User Cfg
#define NET_DVR_SET_USERCFG_V40                     6188    //Set User Cfg
#define NET_DVR_GET_WORK_STATUS                     6189    //Get Device Work Status
#define NET_DVR_GET_JPEG_CAPTURE_CFG_V40            6190    //Get JPEG Capture Cfg
#define NET_DVR_SET_JPEG_CAPTURE_CFG_V40            6191    //Set JPEG Capture Cfg
#define NET_DVR_GET_HDGROUP_CFG_V40                 6192    //Get HD Group Cfg
#define NET_DVR_SET_HDGROUP_CFG_V40                 6193    //Set HD Group Cfg
#define NET_DVR_GET_SMD_HOLIDAY_HANDLE              6194    //Get SMD holiday handle cfg
#define NET_DVR_SET_SMD_HOLIDAY_HANDLE              6195    //Set SMD holiday handle cfg
#define NET_DVR_GET_PIC_MODEL_CFG                   6196    //Get picture model cfg
#define NET_DVR_SET_PIC_MODEL_CFG                   6197    //Set picture model cfg
#define NET_DVR_START_LOCAL_MOUSE_EVENT             6198    
#define NET_DVR_START_SIMULARE_MOUSE_EVENT          6199    
#define NET_DVR_GET_WORK_STATUS_V50                6200
#define NET_DVR_GET_ACCESS_CAMERA_INFO        6201        // Get access camera information
#define NET_DVR_SET_ACCESS_CAMERA_INFO      6202        // Set access camera information
#define NET_DVR_PULL_DISK                    6203        // Pull disk
#define NET_DVR_SCAN_RAID                    6204        // Scan raid

// CVR 2.0.X
#define NET_DVR_GET_USER_RIGHT_CFG                6210        // Get user right
#define NET_DVR_SET_USER_RIGHT_CFG                6211        // Set user right

#define NET_DVR_ONE_KEY_CONFIG                    6212        // CVR One key config
#define NET_DVR_RESTART_SERVICE                    6213        // Restart service

#define NET_DVR_GET_MAX_MACHINE_NUM_CFG            6214        // Get max machine
#define NET_DVR_SET_MAX_MACHINE_NUM_CFG            6215        // Set max machine

#define NET_DVR_ADD_DEVICE                        6216        //N+1 Add device
#define NET_DVR_DEL_DEVICE                        6217        //N+1 Del device

#define NET_DVR_GET_DATA_CALLBACK_CFG            6218        // Get data callback config
#define NET_DVR_SET_DATA_CALLBACK_CFG            6219        // Set data callback config

#define NET_DVR_CLONE_LUN                        6220    //Clone Lun
#define NET_DVR_EXPAND_LUN                        6221    //Expand Lun

#define NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO        6222    //Get N+1 device infomation
#define NET_DVR_MODIFY_DVR_NET_DISK                6223    //Mod DVR net disk
//#define NET_DVR_DEL_DVR_NET_DISK                6224    //Delete DVR net disk

#define NET_DVR_CREATE_NAS                        6225    //Create NAS
#define NET_DVR_DELETE_NAS                        6226    //Delete NAS 

#define NET_DVR_OPEN_ISCSI                         6227    //Open iSCSI
#define NET_DVR_CLOSE_ISCSI                        6228    //Close iSCSI 

#define NET_DVR_GET_FC                            6229    //Get FC info
#define NET_DVR_OPEN_FC                             6230    //Open FC
#define NET_DVR_CLOSE_FC                         6231    //Close FC    

#define NET_DVR_ONE_KEY_CONFIG_SAN                6232  // One key config SAN

//CVR2.3.2

#define NET_DVR_RECORD_CHECK                        6233  //check record integrity
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL        6234  //add record passback task
#define NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL    6235  //get all record passback task
#define NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL    6236  //record passback control
#define NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL        6237  //delete record passback task
#define NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG        6238  //get reocrd passback plan config
#define NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG        6239  //set reocrd passback plan config
#define NET_DVR_GET_DEV_STORAGE_CFG                    6240  //get device storage config
#define NET_DVR_GET_ONLINE_USER_CFG                    6241  //get online user config
#define NET_DVR_GET_RECORD_SEGMENT_CFG                6242  //get all record segment

#define NET_DVR_GET_REC_PASSBACK_TASK_EXECUTABLE    6243    //search manual passback task executable 
#define NET_DVR_GET_STREAM_MEDIA_CFG                6244    //get record passback by stream config(stream ID)
#define NET_DVR_SET_STREAM_MEDIA_CFG                6245    //set record passback by stream config(stream ID)
#define NET_DVR_GET_USERCFG_V50                     6246  //get User config V50
#define NET_DVR_SET_USERCFG_V50                     6247  //set User config V50

#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG_CAP    6248  //get ability to function based configuration CVR comes back 
#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG        6249  //get CVR back function based configuration 
#define NET_DVR_SET_RECORD_PASSBACK_BASIC_CFG        6250  //set CVR back function based configuration
#define NET_DVR_ONE_KEY_CONFIG_V50                    6251  //one key configuration CVR (V50) 
#define NET_DVR_GET_RACM_CAP                        6252  //get the total capacity (RACM) 
#define NET_DVR_GET_THUMBNAILS                        6253  //download time interval thumbnail (support flow ID) 
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL_V50        6254  //add record passback task (V50)
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG_CAP    6255  //Get CVR back history record planning ability 
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG        6256  //Get CVR back history record planning configuration 
#define NET_DVR_SET_RECORD_PASSBACK_HISTORY_PLAN_CFG        6257  //Set CVR back history record planning configuration 
#define NET_DVR_ONE_KEY_CONFIG_V51                          6258  //one key configuration CVR (V51) 

#define NET_DVR_GET_RECORD_PACK                     6301    //Get video package parameters
#define NET_DVR_SET_RECORD_PACK                    6302    //Set video package parameters
#define NET_DVR_GET_CLOUD_STORAGE_CFG           6303     //Get Dev Cur Work Mode
#define NET_DVR_SET_CLOUD_STORAGE_CFG           6304    //Set Dev Cur Work Mode
#define NET_DVR_GET_GOP_INFO                    6305    //Get GOP Info
#define NET_DVR_GET_PHY_DISK_INFO               6306    //Get physical disk info     

#define NET_DVR_GET_RECORDING_AUTO_TRACK_CFG    6307    //Get SDI config
#define NET_DVR_SET_RECORDING_AUTO_TRACK_CFG    6308    //Set SDI config

#define NET_DVR_GET_RECORDING_PUBLISH_CFG        6309  //Get one key publish info 
#define NET_DVR_SET_RECORDING_PUBLISH_CFG        6310  //Set one key publish info

#define NET_DVR_RECORDING_ONEKEY_CONTROL        6311  //recording host control

#define NET_DVR_GET_RECORDING_END_TIME        6312  //get recording remaining time

#define NET_DVR_RECORDING_PUBLISH                6313  //one key publish record

#define NET_DVR_GET_CURRICULUM_CFG            6314    //Get course config
#define NET_DVR_SET_CURRICULUM_CFG            6315    //Set course config

#define NET_DVR_GET_COURSE_INDEX_CFG        6316    //Get course index
#define NET_DVR_SET_COURSE_INDEX_CFG        6317  //Set course index

#define    NET_DVR_GET_PPT_CHANNEL                6318    //get PPT channel
#define    NET_DVR_GET_PPT_DETECT_CFG            6319    //get PPT detect param
#define    NET_DVR_SET_PPT_DETECT_CFG            6320    //set PPT detect param

#define NET_DVR_GET_RECORDINGHOST_CFG        6321    //Get record host config
#define NET_DVR_SET_RECORDINGHOST_CFG        6322    //Set record host config
#define NET_DVR_GET_BACKUP_RECORD_CFG           6323    //Get backup record Cfg
#define NET_DVR_SET_BACKUP_RECORD_CFG           6324    //Set backup record Cfg


#define NET_DVR_GET_AUDIO_ACTIVATION_CFG        6326    //get audio activation cfg
#define NET_DVR_SET_AUDIO_ACTIVATION_CFG        6327    //set audio activation cfg
#define NET_DVR_GET_DECODERCFG_V40              6328    //get decodercfg v40
#define NET_DVR_SET_DECODERCFG_V40                6329    //set decodercfg v40

#define NET_DVR_INFRARED_OUTPUT_CONTROL         6330   //infrared output control
#define NET_DVR_GET_INFRARED_CMD_NAME_CFG       6331   //get infrared cmd name cfg
#define NET_DVR_SET_INFRARED_CMD_NAME_CFG       6332   //set infrared cmd name cfg
#define NET_DVR_START_INFRARED_LEARN            6333   //infrared learn
#define NET_DVR_GET_TRIAL_SYSTEM_CFG            6334   //get trial system cfg
#define NET_DVR_SET_CASE_INFO                    6335    //case info
#define NET_DVR_GET_TRIAL_MICROPHONE_STATUS        6336  //get microphone status
#define NET_DVR_SET_TRIAL_MICROPHONE_STATUS        6337  //set microphone status
#define NET_DVR_GET_TRIAL_HOST_STATUS            6338  //get trial host status
#define NET_DVR_GET_LAMP_OUT                    6339  //get lamp out
#define NET_DVR_SET_LAMP_OUT                    6340  //set lamp out
#define NET_DVR_LAMP_REMOTE_CONTROL                6341  // LAMP control
#define NET_DVR_REMOTE_CONTROL_PLAY                6342  //remote control
#define NET_DVR_GET_LOCAL_INPUT_CFG                6343  //get local input cfg
#define NET_DVR_SET_LOCAL_INPUT_CFG                6344  //set local input cfg
#define NET_DVR_GET_CASE_INFO                    6345  //get case info

#define NET_DVR_INQUEST_GET_CDW_STATUS         6350  
#define NET_DVR_GET_MIX_AUDIOIN_CFG             6351  //Get mix audioin Cfg
#define NET_DVR_SET_MIX_AUDIOIN_CFG             6352  //Set mix audioin Cfg
#define NET_DVR_GET_MIX_AUDIOOUT_CFG            6353  //Get mix audioout Cfg
#define NET_DVR_SET_MIX_AUDIOOUT_CFG            6354  //Set mix audioout Cfg
#define NET_DVR_GET_AUDIOIN_VOLUME_CFG          6355  //Get AudioIn Volume Cfg
#define NET_DVR_SET_AUDIOIN_VOLUME_CFG          6356  //Set AudioIn Volume Cfg
#define NET_DVR_GET_AREA_MASK_CFG               6357  //Get Mask Area Cfg
#define NET_DVR_SET_AREA_MASK_CFG               6358  //Set Mask Area Cfg
#define NET_DVR_GET_AUDIO_DIACRITICAL_CFG       6359  //Get Audio Diacritical Cfg
#define NET_DVR_SET_AUDIO_DIACRITICAL_CFG       6360  //Set Audio Diacritical Cfg
#define NET_DVR_GET_WIFI_DHCP_ADDR_CFG          6361  //Get WIFI DHCP addr Cfg
#define NET_DVR_SET_WIFI_DHCP_ADDR_CFG          6362  //Set Get WIFI DHCP addr
#define NET_DVR_GET_WIFI_CLIENT_LIST_INFO       6363  //Get Wifi Client List
#define NET_DVR_REMOTECONTROL_POWER_ON            6364  //remote  control power on
#define NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG      6365  //Get Multi Stream relate Channel Cfg
#define NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG     6366  //Set Multi Stream relate Channel Cfg
#define NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG        6367  //Get Local videoout resolution Cfg
#define NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG        6368  //Set Local videoout resolution Cfg
#define NET_DVR_GET_AUDIOOUT_VOLUME_CFG         6369 //Get AudioOut Volume Cfg
#define NET_DVR_SET_AUDIOOUT_VOLUME_CFG         6370 //Set AudioOut Volume Cfg
#define NET_DVR_INQUEST_PAUSE_CDW               6371  //pause CDW
#define NET_DVR_INQUEST_RESUME_CDW              6372  //Resume CDW
#define NET_DVR_GET_INPUT_CHAN_CFG              6373  //Get Input Channel Cfg
#define NET_DVR_SET_INPUT_CHAN_CFG              6374  //Set Input Channel Cfg

#define NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG        6375    //Get inquest mix audioIn Cfg 
#define NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG        6376    //Set inquest mix audioIn Cfg
#define    NET_DVR_CASE_INFO_CTRL                    6377    //case info control 
#define NET_DVR_GET_INQUEST_USER_RIGHT            6378    //Get inquest user right Cfg
#define NET_DVR_SET_INQUEST_USER_RIGHT            6379    //Set inquest user right Cfg
#define NET_DVR_GET_INQUEST_CASE_INFO            6380    //Get inquest case info
#define NET_DVR_SET_INQUEST_CASE_INFO            6381    //Set inquest case info

#define    NET_DVR_GET_FILM_MODE_CFG               6387    //Get Film Mode Cfg
#define    NET_DVR_SET_FILM_MODE_CFG               6388    //Set Film Mode Cfg
#define    NET_DVR_GET_FILM_MODE_CFG_CAP            6389    //Set Film Mode Capabilities

#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG       6390    //Get Directed Strategy Cfg
#define    NET_DVR_SET_DIRECTED_STRATEGY_CFG        6391    //Set Directed Strategy Cfg
#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP    6392    //Get Directed Strategy Capabilities
#define    NET_DVR_GET_FRAME_CFG                    6393    //Get Frame Cfg
#define    NET_DVR_SET_FRAME_CFG                    6394    //Set Frame Cfg
#define    NET_DVR_GET_FRAME_CFG_CAP                6395    //Get Frame Capabilities

#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG            6396    //Get Audio Effective Cfg
#define    NET_DVR_SET_AUDIO_EFFECTIVE_CFG            6397    //Set Audio Effective Cfg
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP        6398    //Get Audio Effective Capabilities
#define    NET_DVR_GET_RECORD_VIDEO_CFG              6399    //Get Record Video Cfg
#define    NET_DVR_SET_RECORD_VIDEO_CFG            6400    //Set Record Video Cfg


#define NET_DVR_GET_OUTPUT_CFG              6401       //get output config
#define NET_DVR_SET_OUTPUT_CFG              6402       //set output config
#define NET_DVR_CODER_DISPLAY_START         6403       //start display
#define NET_DVR_CODER_DISPLAY_STOP          6404       //stop display
#define NET_DVR_GET_WINDOW_STATUS           6405       //get display window status

#define NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG   6406        //Get VQD Loop Diagnose Cfg 
#define NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG   6407        //Set VQD Loop Diagnose Cfg 
#define NET_DVR_GET_VQD_DIAGNOSE_INFO       6408        //Manually get VQD diagnose info

#define    NET_DVR_RECORDING_PUBLISH_FILE            6421        //Set Recording Publish File
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP    6422        //Get Recording Publish File Capabilities
#define    NET_DVR_GET_PUBLISH_PROGRESS            6423           //Get Publish Progress
#define    NET_DVR_GET_RECORD_VIDEO_CFG_CAP    6424        //Get Record Video Capabilities
#define    NET_DVR_GET_RTMP_CFG                6425        //Get RTMP Cfg
#define    NET_DVR_SET_RTMP_CFG                6426        //Set RTMP Cfg
#define    NET_DVR_GET_RTMP_CFG_CAP            6427        //Get RTMP Capabilities
#define    NET_DVR_DEL_BACKGROUND_PIC                6428        //Delect BackGround Picture
#define    NET_DVR_GET_BACKGROUND_PIC_CFG            6429    //Get BackGround Picture 
#define    NET_DVR_GET_BACKGROUND_PIC_INFO            6430        //Get BackGround Picture Info
#define    NET_DVR_SET_BACKGROUND_PIC_INFO            6431        //Set BackGround Picture Info
#define    NET_DVR_GET_BACKGROUND_PIC_INFO_CAP      6432           //Get BackGround Picture Info Capabilities
#define    NET_DVR_GET_RECORD_HOST_CAP                6433        //Get Record Host Capabilities
#define NET_DVR_GET_COURSE_LIST                 6434    //get course list
#define    NET_DVR_GET_RECORD_STATUS                6435 //get record status
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL        6436    //manual curriculum control
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG        6437    //get image diff detection cfg
#define    NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG        6438    //set image diff detection cfg
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP    6439    //get image diff detection cfg Capabilities
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO    6440    //get recording publish file cfg
#define    NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO    6441    //set recording publish file cfg
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP        6442    //get recording publish file cfg Capabilities
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP        6443    //get manual curriculum control Capabilities
#define NET_DVR_GET_STATISTIC_DATA_LIST             6444    //get list statistics 

#define    NET_DVR_GET_DEVICE_LAN_ENCODE        6501        //get device language encode format
#define NET_DVR_GET_GBT28181_SERVICE_CFG        6503    //Get GB28181 Server Cfg
#define NET_DVR_SET_GBT28181_SERVICE_CFG        6504    //Set GB28181 Server Cfg
#define NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES 6505  //Get GB28181 Server Capabilities

#define NET_DVR_GET_CLOUD_URL               6506    //get cloud storage url
#define NET_DVR_GET_CLOUD_URL_CAP           6507    //get cloud storage url-ability
#define NET_DVR_GET_CLOUD_CFG               6508    //get cloud storage configure parameter
#define NET_DVR_SET_CLOUD_CFG               6509    //set cloud storage configure parameter
#define NET_DVR_GET_CLOUD_CFG_CAP           6510    //get cloud storage configure parameter-ability
#define NET_DVR_GET_CLOUD_UPLOADSTRATEGY    6511    //get cloud storage upload strategy
#define NET_DVR_SET_CLOUD_UPLOADSTRATEGY    6512    //set cloud storage upload strategy
#define NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP     6513    //cloud storage upload strategy-ability

#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG        6601        //Get Video Image DB CFG
#define    NET_DVR_SET_VIDEO_IMAGE_DB_CFG        6602        //Set Video Image DB CFG
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP    6603        //Get Video Image DB CFG Capabilities
#define    NET_DVR_GET_FILE_INFO_BY_ID            6604        //Get File Info
#define    NET_DVR_QUERY_FILE_INFO_CAP            6605        //Get File Info Capabilities
#define    NET_DVR_DEL_FILE_FROM_DB            6606        //Del File From DB
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CAP        6607        //Get Video All Capabilities

#define NET_DVR_GET_FIGURE                    6610        //Get Figure picture

#define    NET_DVR_SYNC_IPC_PASSWD                  6621    //Sync IPC PASSWORD
#define    NET_DVR_GET_VEHICLE_BLOCKLIST_SCHEDULE 6622    //Get Blocklist schedule
#define    NET_DVR_SET_VEHICLE_BLOCKLIST_SCHEDULE 6623    //Set Blocklist schedule
#define    NET_DVR_GET_VEHICLE_ALLOWLIST_SCHEDULE 6624    //Get Allowlist schedule
#define    NET_DVR_SET_VEHICLE_ALLOWLIST_SCHEDULE 6625    //Set Allowlist schedule

#define    NET_DVR_GET_VEHICLE_BLOCKLIST_EVENT_TRIGGER     6626    //Get block list event
#define    NET_DVR_SET_VEHICLE_BLOCKLIST_EVENT_TRIGGER     6627    //Set block list event

#define    NET_DVR_GET_VEHICLE_ALLOWLIST_EVENT_TRIGGER     6628    //Get allow list event
#define    NET_DVR_SET_VEHICLE_ALLOWLIST_EVENT_TRIGGER     6629    //Set allow list event


#define    NET_DVR_GET_TRAFFIC_CAP                         6630    //Get traffic cap
#define    NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER     6631    //Get All VehicleList Event Trigger Cfg
#define    NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER     6632    //Set All VehicleList Event Trigger Cfg
#define    NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6633    //Get Other VehicleList Event Trigger Cfg
#define    NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6634    //Set Other VehicleList Event Trigger Cfg

#define    NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER     6635    //Get Storage Detection Event Trigger
#define    NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER     6636    //Set Storage Detection Event Trigger
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES    6637    //Get Storage Detection Schedule Capabilities
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE         6638    //Get Storage Detection Schedule
#define    NET_DVR_SET_STORAGEDETECTION_SCHEDULE         6639    //Set Storage Detection Schedule
#define    NET_DVR_GET_STORAGEDETECTION_STATE             6640    //Get Storage Detection State


#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK             6646    //Get Storage Detection RwLock
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES    6647    //Get Storage Detection RwLock Capabilities
#define    NET_DVR_SET_STORAGEDETECTION_RWLOCK             6648    //Set Storage Detection RwLock
#define    NET_DVR_GET_PTZTRACKSTATUS                     6649    //Get Ptz Track Status


#define    NET_DVR_SET_STORAGEDETECTION_UNLOCK             6653    //Set Storage Detection UnLock
#define    NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES    6654    //Get Storage Detection UnLock Capabilities

#define    NET_DVR_SET_SHIPSDETECTION_CFG                 6655    //Set the ship detection parameter configuration 
#define    NET_DVR_GET_SHIPSDETECTION_CFG                 6656    //Get ship detection parameter configuration 
#define    NET_DVR_GET_SHIPSDETECTION_CAPABILITIES         6657    //Get ship detection parameters configuration ability 
#define    NET_DVR_GET_SHIPSDETECTION_COUNT               6658    //Get ships counting information 
#define    NET_DVR_SHIPSCOUNT_DELETE_CTRL                  6659   //Empty vessels counting information

#define    NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES     6660   //Get Bare Data Overlay Capablities
#define    NET_DVR_SET_BAREDATAOVERLAY_CFG                 6661    //Set Bare Data Overlay Cfg
#define    NET_DVR_GET_BAREDATAOVERLAY_CFG                 6662    //Get Bare Data Overlay Cfg
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE             6663    //Get ship detection protection time configuration 
#define    NET_DVR_SET_SHIPSDETECTION_SCHEDULE             6664    //Set the ship detection protection time configuration
#define NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER     6665    //Get ships to detect linkage configuration  
#define    NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER     6666    //Set the ship detection linkage configuration 
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES    6667    //Get ship detection protection time ability 

#define    NET_DVR_FIRE_FOCUSZOOM_CTRL                  6670   //Fire Focus Zoom Ctrl
#define    NET_DVR_GET_FIREDETECTION_SCHEDULE_CAPABILITIES    6671 //Get fire detection protection time ability
#define    NET_DVR_GET_FIREDETECTION_SCHEDULE    6672    //Get fire detection protection time configuration
#define    NET_DVR_SET_FIREDETECTION_SCHEDULE    6673    //Set fire detection protection time configuration
#define    NET_DVR_GET_MANUALRANGING_CAPABILITIES    6675    //Get Manual Rangin Capbailities


#define    NET_DVR_SET_MANUALRANGING           6677        //Set Manual Rangin
#define    NET_DVR_GET_MANUALDEICING_CAPABILITIES    6678    //Get Manual Deicing capabilities
#define    NET_DVR_SET_MANUALDEICING           6679        //Set Manual Deicing
#define    NET_DVR_GET_MANUALDEICING           6680        //Get Manual Deicing

#define    NET_DVR_GET_THERMALPOWER_CAPABILITIES   6689    //Get Thermal power capablities
#define    NET_DVR_GET_THERMALPOWER                6690    //Get Thermal power
#define    NET_DVR_SET_THERMALPOWER                6691    //Set Thermal power
#define    NET_DVR_GET_PTZABSOLUTEEX_CAPABILITIES  6695    //GET absolute PTZ ex cability
#define    NET_DVR_GET_PTZABSOLUTEEX               6696    //GET absolute PTZ ex config
#define    NET_DVR_SET_PTZABSOLUTEEX               6697    //SET absolute PTZ ex config

#define    NET_DVR_GET_CRUISE_CAPABILITIES              6698    //Get equipment cruise mode configuration 
#define    NET_DVR_GET_CRUISE_INFO                      6699    //Get equipment cruise mode 
#define    NET_DVR_GET_TEMP_HUMI_CAPABILITIES           6700    //Get temperature and humidity real-time ability 
#define  NET_DVR_GET_TEMP_HUMI_INFO                  6701   //Get temperature and humidity real-time

#define    NET_DVR_GET_MANUALTHERM_INFO                 6706   //Get manual temperature measurement in real time 
#define    NET_DVR_GET_MANUALTHERM_CAPABILITIES         6707   //Get manual measuring temperature real-time ability 
#define    NET_DVR_SET_MANUALTHERM                      6708     //Set manual temperature measurement data 

//NVR - 96000
#define    NET_DVR_GET_ACCESSORY_CARD_INFO_CAPABILITIES    6709 //Accessories plate information ability
#define    NET_DVR_GET_ACCESSORY_CARD_INFO                    6710 //For accessories plate information 

#define    NET_DVR_GET_THERMINTELL_CAPABILITIES            6711 //Get thermal intelligent configuration capbailities
#define    NET_DVR_GET_THERMINTELL                         6712 //Get thermal intelligent configuration parameters 
#define    NET_DVR_SET_THERMINTELL                         6713 //Set thermal intelligent configuration parameters 
#define NET_GET_CRUISEPOINT_V50                         6714     //Cruise Point V50
#define    NET_DVR_GET_MANUALTHERM_BASIC_CAPABILITIES        6715   //Get temperature measuring basic parameters configuration manually
#define    NET_DVR_SET_MANUALTHERM_BASICPARAM              6716     //Set the manual temperature measuring basic parameters 
#define    NET_DVR_GET_MANUALTHERM_BASICPARAM              6717     //Get the manual temperature measuring basic parameters 

#define    NET_DVR_GET_FIRESHIELDMASK_CAPABILITIES            6718 

#define NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES    6720 //The allocation of hidden information capacity 
#define NET_DVR_GET_HIDDEN_INFORMATION                 6721 //get Hidden information parameters 
#define NET_DVR_SET_HIDDEN_INFORMATION                 6722 //Set the hidden information parameters 

#define    NET_DVR_SET_FIRESHIELDMASK_CFG                  6723    
#define    NET_DVR_GET_FIRESHIELDMASK_CFG                  6724     
#define    NET_DVR_GET_SMOKESHIELDMASK_CAPABILITIES            6725   
#define    NET_DVR_SET_SMOKESHIELDMASK_CFG                     6726     
#define    NET_DVR_GET_SMOKESHIELDMASK_CFG                     6727        

#define    NET_DVR_GET_AREASCAN_CAPABILITIES                  6728        
#define    NET_DVR_GET_AREASCAN_CFG                          6730        

#define    NET_DVR_DEL_AREASCAN_CFG                          6731        
#define    NET_DVR_AREASCAN_INIT_CTRL                        6732       
#define    NET_DVR_AREASCAN_CONFIRM_CTRL                     6733        
#define    NET_DVR_AREASCAN_STOP_CTRL                        6734        
#define    NET_DVR_SAVE_SCANZOOM_CTRL                        6735        
#define    NET_DVR_GET_SCANZOOM_CTRL                         6736 
#define    NET_DVR_DEL_FIRESHIELDMASK_CTRL                   6737        
#define    NET_DVR_DEL_SMOKESHIELDMASK_CTRL                  6738

#define    NET_DVR_GET_DENSEFOG_EVENT_TRIGGER     6740    //Get dense fog to detect linkage configuration
#define    NET_DVR_SET_DENSEFOG_EVENT_TRIGGER     6741    //Set dense fog to detect linkage configuration
#define    NET_DVR_SET_DENSEFOGDETECTION_CFG    6742    //Get dense fog to detect parameters configuration
#define    NET_DVR_GET_DENSEFOGDETECTION_CFG    6743    //Set dense fog to detect parameters configuration
#define    NET_DVR_GET_DENSEFOGDETECTION_CAPABILITIES    6744    //Get dense fog to detect parameters configuration capacity

#define    NET_DVR_GET_THERMOMETRY_SCHEDULE_CAPABILITIES    6750 //Get Temperature detection protection time ability
#define    NET_DVR_GET_THERMOMETRY_SCHEDULE    6751    //Get Temperature detection protection time configuration 
#define    NET_DVR_SET_THERMOMETRY_SCHEDULE    6752    //SetTemperature detection protection time configuration 
#define    NET_DVR_GET_TEMPERTURE_SCHEDULE_CAPABILITIES    6753 //Get differential protection time ability 
#define    NET_DVR_GET_TEMPERTURE_SCHEDULE    6754    //Get differential protection time configuration 
#define    NET_DVR_SET_TEMPERTURE_SCHEDULE    6755    //SetDifferential protection time configuration 
#define NET_DVR_GET_SEARCH_LOG_CAPABILITIES        6756    //Log types support ability
#define    NET_DVR_GET_VEHICLEFLOW    6758    //Get vehicle flow configuration
#define NET_DVR_GET_IPADDR_FILTERCFG_V50        6759  //Get IP address filter configuration
#define NET_DVR_SET_IPADDR_FILTERCFG_V50        6760  //Get IP address filter configuration 
#define    NET_DVR_GET_TEMPHUMSENSOR_CAPABILITIES    6761//Get temperature and humidity sensor capabilities
#define    NET_DVR_GET_TEMPHUMSENSOR    6762    //Get temprature and humidity sensor configuration
#define    NET_DVR_SET_TEMPHUMSENSOR    6763    //Set temprature and humidity sensor configuration

#define    NET_DVR_GET_THERMOMETRY_MODE_CAPABILITIES  6764  //Get Thermometry Mode Capability
#define    NET_DVR_GET_THERMOMETRY_MODE               6765  //Get Thermometry Mode
#define    NET_DVR_SET_THERMOMETRY_MODE               6766  //Set Thermometry Mode

#define    NET_DVR_GET_THERMAL_PIP_CAPABILITIES    6767    //Get thermal imaging picture in picture configuration ability 
#define    NET_DVR_GET_THERMAL_PIP   6768    //Get thermal imaging picture in picture configuration parameters 
#define    NET_DVR_SET_THERMAL_PIP   6769    //Set thermal imaging picture in picture configuration parameters 
#define    NET_DVR_GET_THERMAL_INTELRULEDISPLAY_CAPABILITIES    6770    //Get thermal imaging smart rules display ability 
#define    NET_DVR_GET_THERMAL_INTELRULE_DISPLAY   6771    //Get thermal imaging smart rules display parameters
#define    NET_DVR_SET_THERMAL_INTELRULE_DISPLAY   6772    //Set thermal imaging smart rules display parameters
#define    NET_DVR_GET_THERMAL_ALGVERSION   6773   //Get thermal Algorithm library Version
#define    NET_DVR_GET_CURRENT_LOCK_CAPABILITIES    6774    //Get Current Lock Capabilities
#define    NET_DVR_GET_CURRENT_LOCK   6775    //Get Current Lock Cfg
#define    NET_DVR_SET_CURRENT_LOCK   6776    //Set Current Lock Cfg

#define    NET_DVR_DEL_MANUALTHERM_RULE  6778  //Delete Manual Therm Rule
#define NET_DVR_GET_UPGRADE_INFO    6779    //Get upgrade information

#define    NET_DVR_SWITCH_TRANSFER  7000  

#define NET_DVR_GET_MB_POWERCTRLPARA            8000//get start control parm
#define    NET_DVR_SET_MB_POWERCTRLPARA            8001//set start control parm
#define NET_DVR_GET_AUTOBACKUPPARA                8002//get auto backup parm
#define NET_DVR_SET_AUTOBACKUPPARA                8003//set auto backup parm
#define NET_DVR_GET_MB_GPSPARA                    8004//get GPS parm
#define NET_DVR_SET_MB_GPSPARA                    8005//set GPS parm
#define NET_DVR_GET_MB_SENSORINPARA                8006//get SENSOR parm 
#define NET_DVR_SET_MB_SENSORINPARA                8007//set SENSOR parm
#define NET_DVR_GET_GSENSORPARA                    8008//get GSENSOR parm
#define NET_DVR_SET_GSENSORPARA                    8009//set GSENSORparm
#define NET_DVR_GET_MB_DOWNLOADSVRPARA            8010//get load server parm
#define NET_DVR_SET_MB_DOWNLOADSVRPARA            8011//set load server parm
#define NET_DVR_GET_PLATERECOG_PARA                8012//get License plate recognition parm
#define NET_DVR_SET_PLATERECOG_PARA                8013//set License plate recognition parm
#define NET_DVR_GET_ENFORCESYS_PARA                8014//get Vehicle inspection parm
#define NET_DVR_SET_ENFORCESYS_PARA                8015//set Vehicle inspection parm
#define NET_DVR_GET_GPS_DATA                    8016 //get GPS parm 
#define NET_DVR_GET_ANALOG_ALARMINCFG            8017//get analog alarm in parm
#define NET_DVR_SET_ANALOG_ALARMINCFG            8018//set analog alarm in parm

#define NET_DVR_GET_SYSTEM_CAPABILITIES         8100 //Access to system capacity of the equipment 
#define NET_DVR_GET_EAGLEEYE_CAPABILITIES       8101 //Acquire equipment eagle eye 
#define NET_DVR_GET_SLAVECAMERA_CALIB_V51       8102    //get camera calibration configuration V51
#define NET_DVR_SET_SLAVECAMERA_CALIB_V51       8103    //set the camera calibration configuration V51
#define NET_DVR_SET_GOTOSCENE                   8105  //Set the main camera to the specified scenario ID

//I, K, E series NVR product upgrade 
#define NET_DVR_GET_PTZ_NOTIFICATION        8201//Get multi-channel linkage PTZ events
#define NET_DVR_SET_PTZ_NOTIFICATION        8202//Set multi-channel linkage PTZ events
/*****************************video start****************************/
#define    NET_DVR_MATRIX_WALL_SET                    9001  //set video wall configuration
#define    NET_DVR_MATRIX_WALL_GET                    9002  //get video wall configuration
#define    NET_DVR_WALLWIN_GET                        9003  //get video wall window configuration 
#define    NET_DVR_WALLWIN_SET                        9004  //set video wall window configuration 
#define    NET_DVR_WALLWINPARAM_SET                9005  //set video wall related parameter
#define    NET_DVR_WALLWINPARAM_GET                9006  //get video wall related parameter
#define NET_DVR_WALLSCENEPARAM_GET                9007  //get scene parameter
#define NET_DVR_WALLSCENEPARAM_SET                9008  //set scene parameter
#define NET_DVR_MATRIX_GETWINSTATUS             9009  //get window decode status
#define    NET_DVR_GET_WINASSOCIATEDDEVINFO        9010  //get resource information associated with the window in video wall
#define    NET_DVR_WALLOUTPUT_GET                    9011  //get output configuration
#define    NET_DVR_WALLOUTPUT_SET                    9012  //set output configuration
#define NET_DVR_GET_UNITEDMATRIXSYSTEM          9013  //get video platform united system info
#define NET_DVR_GET_WALL_CFG                    9014  //get wall param
#define NET_DVR_SET_WALL_CFG                    9015  //set wall param
#define NET_DVR_CLOSE_ALL_WND                    9016  //close all window
#define NET_DVR_SWITCH_WIN_TOP                  9017  //move window to top layer
#define NET_DVR_SWITCH_WIN_BOTTOM               9018  //move window to bottom layer
#define    NET_DVR_CLOSE_ALL_WND_V41                9019  //close all windows in the wall
#define    NET_DVR_GET_WALL_WINDOW_V41                9020  //get windows in the wall
#define    NET_DVR_SET_WALL_WINDOW_V41                9021  //set windows in the wall
#define    NET_DVR_GET_CURRENT_SCENE_V41            9022  //get current scene 
#define    NET_DVR_GET_WALL_SCENE_PARAM_V41        9023  //get wall scene
#define    NET_DVR_SET_WALL_SCENE_PARAM_V41        9024  //set wall scene
#define NET_DVR_GET_MATRIX_LOGO_CFG             9025  //set logo configuration
#define NET_DVR_SET_MATRIX_LOGO_CFG             9026  //get logo configuration
#define NET_DVR_GET_WIN_LOGO_CFG                9027  //get window logo configuration
#define NET_DVR_SET_WIN_LOGO_CFG                9028  //set window logo configuration
#define NET_DVR_DELETE_LOGO                     9029  //delete logo
#define NET_DVR_SET_DISPLAY_EFFECT_CFG            9030  //set display effect v41
#define NET_DVR_GET_DISPLAY_EFFECT_CFG            9031  //get display effect v41
#define NET_DVR_DEC_PLAY_REMOTE_FILE            9032  //decoder play remote file
#define NET_DVR_DEC_PLAY_REMOTE_FILE_V50        9314  //decoder play remote file V50
#define NET_DVR_GET_WIN_ZOOM_STATUS             9033  //get window electronic enlargement status
#define NET_DVR_GET_ALL_MATRIX_LOGOCFG          9034  //get all logos' configuration
/*****************************video end******************************/

/***********************************LCD Screen begin********************************/
#define NET_DVR_SIMULATE_REMOTE_CONTROL         9035    //Simulate Remote Control 2013-09-05
#define NET_DVR_SET_SCREEN_SIGNAL_CFG            9036    //Set Screen Signal CFG
#define    NET_DVR_GET_SCREEN_SIGNAL_CFG            9037    //Get Screen Signal CFG
#define NET_DVR_SET_SCREEN_SPLICE_CFG              9038    //Set Screen Splice CFG
#define    NET_DVR_GET_SCREEN_SPLICE_CFG            9039    //Get Screen Splice CFG
#define NET_DVR_GET_SCREEN_FAN_WORK_MODE         9040    //Get Screen Fan Work Mode
#define NET_DVR_SET_SCREEN_FAN_WORK_MODE         9041    //Set Screen Fan Work Mode
//#define NET_DVR_UPGRADE_LCD                      9042    //LCD Upgrade
#define NET_DVR_SHOW_SCREEN_WORK_STATUS          9044    //Show Screen Work Status
#define NET_DVR_GET_VGA_CFG                      9045    //Get VGA 
#define NET_DVR_SET_VGA_CFG                      9046    //Set VGA
#define NET_DVR_GET_SCREEN_MENU_CFG                9048    //Get Screen Menu
#define NET_DVR_SET_SCREEN_MENU_CFG              9049    //Set Screen Menu
#define NET_DVR_SET_SCREEN_DISPLAY_CFG          9050    //set screen display CFG 2013-08-28
#define    NET_DVR_GET_SCREEN_DISPLAY_CFG            9051    //get screen display CFG 2013-08-28
#define NET_DVR_SET_FUSION_CFG                    9052    //set picture fusion configuration
#define NET_DVR_GET_FUSION_CFG                    9053    //get picture fusion configuration
#define NET_DVR_SET_PIP_CFG                      9060    //Set Pip Cfg
#define    NET_DVR_GET_PIP_CFG                        9061    //Get Pip Cfg
#define NET_DVR_SET_DEFOG_LCD                      9073    //Set Defog 
#define    NET_DVR_GET_DEFOG_LCD                    9074    //Get Defog 
#define NET_DVR_SHOW_IP                          9075    //Show IP
#define NET_DVR_SCREEN_MAINTENANCE_WALL            9076    //Screen Maintenance Wall
#define NET_DVR_SET_SCREEN_POS                  9077    //Set Screen Pos
#define    NET_DVR_GET_SCREEN_POS                    9078    //Get Screen Pos
/***********************************LCD Screen end********************************/

/*******************************LCD Screen V1.2 begin******************************************/
#define    NET_DVR_SCREEN_INDEX_SET                9079    //Set screen index parameter
#define    NET_DVR_SCREEN_INDEX_GET                9080    //Get screen index parameter
#define NET_DVR_SCREEN_SPLICE_SET               9081    //Set screen splice parameter
#define NET_DVR_SCREEN_SPLICE_GET               9082    //Get screen splice parameter
#define NET_DVR_SET_SCREEN_PARAM                9083    //Set screen parameter
#define NET_DVR_GET_SCREEN_PARAM                9084    //Get screen parameter
#define NET_DVR_SET_SWITCH_CFG                  9085    //Set time switch parameter
#define NET_DVR_GET_SWITCH_CFG                  9086    //Get time switch parameter
#define NET_DVR_SET_POWERON_DELAY_CFG           9087    //Set delay power on parameter
#define NET_DVR_GET_POWERON_DELAY_CFG           9088    //Get delay power on parameter
#define    NET_DVR_SET_SCREEN_POSITION                9089    //Set screen position
#define    NET_DVR_GET_SCREEN_POSITION                9090    //Get screen position
#define NET_DVR_SCREEN_SCENE_CONTROL            9091    //Screen scene control 
#define NET_DVR_GET_CURRENT_SCREEN_SCENE        9092    //Get current screen index
#define NET_DVR_GET_SCREEN_SCENE_PARAM          9093    //Get screen scene parameter
#define NET_DVR_SET_SCREEN_SCENE_PARAM          9094    //Set screen scene parameter
#define NET_DVR_GET_EXTERNAL_MATRIX_RELATION    9095    //Get the relation input and output between external matrix

/*******************************LCD Screen V1.2 end ******************************************/

#define     NET_DVR_GET_LCD_AUDIO_CFG            9096     //Get LCDScreen Audio
#define     NET_DVR_SET_LCD_AUDIO_CFG            9097     //Set LCDScreen Audio
#define     NET_DVR_GET_LCD_WORK_STATE            9098     //Get LCD work state
#define     NET_DVR_GET_BOOT_LOGO_CFG            9099    //Get boot logo 
#define     NET_DVR_SET_BOOT_LOGO_CFG            9100    //Set boot logo


#define NET_DVR_GET_STREAM_DST_COMPRESSIONINFO    9101  //get target compression information
#define NET_DVR_SET_STREAM_DST_COMPRESSIONINFO  9102  //set target compression information
#define NET_DVR_GET_STREAM_TRANS_STATUS            9103  //get stream transcode status
#define NET_DVR_GET_DEVICE_TRANS_STATUS            9104  //get device transcode status
#define NET_DVR_GET_ALLSTREAM_SRC_INFO          9105  //get all stream source information
#define NET_DVR_GET_BIG_SCREEN_AUDIO            9106  //get big screen audio information
#define NET_DVR_SET_BIG_SCREEN_AUDIO            9107  //set big screen audio information
#define NET_DVR_GET_DEV_WORK_MODE                9108  //get transcode device work mode
#define NET_DVR_SET_DEV_WORK_MODE                9109  //set transcode device work mode
#define NET_DVR_APPLY_TRANS_CHAN                9110  //apply transcode channel by stream ID
#define NET_DVR_GET_DISPCHAN_CFG                9111  //get display channel configure batch
#define NET_DVR_SET_DISPCHAN_CFG                9112  //set display channel configure batch
#define NET_DVR_GET_DEC_CHAN_STATUS                9113  //get decode channel status
#define NET_DVR_GET_DISP_CHAN_STATUS            9114  //get display channel status        
#define NET_DVR_GET_ALARMIN_STATUS                9115  //get alarm in status
#define NET_DVR_GET_ALARMOUT_STATUS                9116  //get alarm out status
#define NET_DVR_GET_AUDIO_CHAN_STATUS            9117  //get audio channel status

#define  NET_DVR_GET_VIDEO_AUDIOIN_CFG            9118   //get Audio video input parameters
#define  NET_DVR_SET_VIDEO_AUDIOIN_CFG            9119   //set Audio video input parameters

#define    NET_DVR_SET_BASEMAP_CFG                    9120  //set basemap config
#define NET_DVR_GET_BASEMAP_CFG                    9121  //get basemap config
#define NET_DVR_GET_VIRTUAL_SCREEN_CFG          9122  //get virtual screen config
#define NET_DVR_SET_VIRTUAL_SCREEN_CFG          9123  //set virtual screen config
#define NET_DVR_GET_BASEMAP_WIN_CFG                9124  //get basemap window config
#define NET_DVR_SET_BASEMAP_WIN_CFG                9125  //set basemap window config
#define NET_DVR_DELETE_PICTURE                    9126  //delete basemap picture
#define NET_DVR_GET_BASEMAP_PIC_INFO            9127  //get basemap picture information
#define    NET_DVR_SET_BASEMAP_WIN_CFG_V40         9128  //set base map window configuration V40
#define NET_DVR_GET_BASEMAP_WIN_CFG_V40         9129  //get base map window configuration V40

#define NET_DVR_GET_DEC_VCA_CFG                    9130    //get the vca alarm configure from decoder
#define NET_DVR_SET_DEC_VCA_CFG                    9131    //set the vca alarm configure from decoder

#define NET_DVR_SET_VS_INPUT_CHAN_INIT_ALL  9132  //Initializes the virtual screen all input channels 
#define NET_DVR_GET_VS_INPUT_CHAN_INIT_ALL  9133  //Get virtual screen all input channels initialization parameters
#define NET_DVR_GET_VS_INPUT_CHAN_INIT 9134  //Get virtual screen a single input channel initialization parameters
#define NET_DVR_GET_VS_INPUT_CHAN_CFG  9135  //Get virtual screen input channel configuration parameters 

#define NET_DVR_GET_TERMINAL_CONFERENCE_STATUS    9136    
#define NET_DVR_GET_TERMINAL_INPUT_CFG_CAP        9137    
#define NET_DVR_GET_TERMINAL_INPUT_CFG            9138    
#define NET_DVR_SET_TERMINAL_INPUT_CFG            9139    

#define NET_DVR_GET_CONFERENCE_REGION_CAP        9140    
#define NET_DVR_GET_CONFERENCE_REGION            9141    
#define NET_DVR_SET_CONFERENCE_REGION            9142    
#define NET_DVR_GET_TERMINAL_CALL_CFG_CAP        9143    
#define NET_DVR_GET_TERMINAL_CALL_CFG            9144    
#define NET_DVR_SET_TERMINAL_CALL_CFG            9145    
#define NET_DVR_GET_TERMINAL_CTRL_CAP            9146
#define NET_DVR_TERMINAL_CTRL                    9147    
#define    NET_DVR_GET_CALL_QUERY_CAP                9148    
#define NET_DVR_GET_CALLINFO_BY_COND            9149    
#define    NET_DVR_SET_FUSION_SCALE                9150    //set camera fusion scale
#define NET_DVR_GET_FUSION_SCALE                9151    //get camera fusion scale
#define NET_DVR_GET_VCS_CAP                        9152
#define NET_DVR_GET_TERMINAL_GK_CFG_CAP            9153    //get terminal register GK abilities
#define NET_DVR_GET_TERMINAL_GK_CFG                9154    //get terminal terminal register gk parameter
#define NET_DVR_SET_TERMINAL_GK_CFG                9155    //set terminal register gk parameter
#define NET_DVR_GET_MCU_CONFERENCESEARCH_CAP    9156    //get MCU conference search abilities
#define NET_DVR_SET_VS_INPUT_CHAN_CFG  9157  //Set virtual screen input channel configuration parameters
#define NET_DVR_GET_VS_NETSRC_CFG      9158  //Get virtual screen network source parameters
#define NET_DVR_SET_VS_NETSRC_CFG      9159  //Set virtual screen network source parameters
#define    NET_DVR_GET_LLDP_CFG                    9160    //set LLDP parameter
#define    NET_DVR_SET_LLDP_CFG                    9161    //get LLDP parameter
#define NET_DVR_GET_LLDP_CAP                    9162    //get LLDP abilities
#define    NET_DVR_GET_FIBER_CONVERT_BASIC_INFO    9163    //get fiber basic information
#define    NET_DVR_GET_FIBER_CONVERT_WORK_STATE    9164    //get fiber work status
#define    NET_DVR_GET_FIBER_CONVERT_TOPOLOGY      9165    //get fiber topology
#define    NET_DVR_GET_FC_PORT_REMARKS                9166    //get fiber port remarks
#define    NET_DVR_SET_FC_PORT_REMARKS                9167    //set fiber port remarks
#define NET_DVR_GET_PORT_REMARKS_CAP            9168    //get fiber port remarks abilities

#define NET_DVR_GET_MCU_CONFERENCECONTROL_CAP   9169    //get MCU conference control abilities
#define NET_DVR_GET_MCU_TERMINALCONTROL_CAP     9170    //get MCU terminal control abilities
#define NET_DVR_GET_MCU_TERIMINALGROUP_CAP      9171    //get MCU terminal group abilities
#define NET_DVR_GET_MCU_TERMINAL_CAP            9174    //get MCU terminal ability
#define NET_DVR_GET_MCU_CONFERENCE_CAP          9175    //get MCU conference ability
#define NET_DVR_GET_MCU_GK_CFG_CAP              9176    //get MCUGK config ability
#define NET_DVR_GET_MCU_GK_SERVER_CAP           9177    //get MCUGK server ability

#define NET_DVR_GET_EDID_CFG_FILE_INFO  9178  //get EDID file information
#define NET_DVR_GET_EDID_CFG_FILE_INFO_LIST  9179  //get EDID file information list
#define NET_DVR_SET_EDID_CFG_FILE_INFO  9180  //set EDID file information
#define NET_DVR_DEL_EDID_CFG_FILE_INFO  9181  //delete EDID file information (include file)
#define NET_DVR_GET_EDID_CFG_FILE_INFO_CAP  9182  //get EDID file information capabilities

#define NET_DVR_GET_SUBWND_DECODE_OSD  9183  //get information on child window decoding OSD
#define NET_DVR_GET_SUBWND_DECODE_OSD_ALL  9184  //get information on all child window decoding OSD
#define NET_DVR_SET_SUBWND_DECODE_OSD  9185  //set information on child window decoding OSD
#define NET_DVR_GET_SUBWND_DECODE_OSD_CAP  9186  //get information on child window decoding OSD capabilities
#define NET_DVR_GET_DECODE_CHANNEL_OSD  9187  //get decode channel OSD info
#define NET_DVR_SET_DECODE_CHANNEL_OSD  9188  //set decode channel OSD info

#define NET_DVR_GET_OUTPUT_PIC_INFO             9200    //get output picture information 
#define NET_DVR_SET_OUTPUT_PIC_INFO             9201    //set output picture information
#define NET_DVR_GET_OUTPUT_PIC_WIN_CFG          9202    //get output picture window parameter
#define NET_DVR_SET_OUTPUT_PIC_WIN_CFG          9203    //set output picture window parameter
#define NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG      9204    //get all output picture window parameter
#define NET_DVR_DELETE_OUPUT_PIC                9205    //delete output picture 
#define NET_DVR_GET_OUTPUT_OSD_CFG              9206    //get output OSD parameter
#define NET_DVR_SET_OUTPUT_OSD_CFG              9207    //set output OSD parameter
#define NET_DVR_GET_OUTPUT_ALL_OSD_CFG          9208    //get all the output OSD parameter
#define NET_DVR_GET_CHAN_RELATION               9209    //get encode relate resource 
#define NET_DVR_SET_CHAN_RELATION               9210    //set encode relate resource
#define NET_DVR_GET_ALL_CHAN_RELATION           9211    //get all encode relate resource  
#define  NET_DVR_GET_NS_RING_CFG                9212    //get fiber board ring configure
#define  NET_DVR_SET_NS_RING_CFG                   9213    //set fiber board ring configure
#define  NET_DVR_GET_NS_RING_STATUS              9214    //get fiber ring status
#define NET_DVR_GET_OPTICAL_PORT_INFO            9220    //get optical port information
#define NET_DVR_SET_OPTICAL_PORT_INFO            9221    //set optical port information
#define NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG        9222    //get coder channel related optical port information
#define NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG        9223    //set coder channel related optical port information
#define NET_DVR_GET_WIN_ROAM_SWITCH_CFG         9224    //Get roaming decoder window switch parameters 
#define NET_DVR_SET_WIN_ROAM_SWITCH_CFG         9225    //Set roaming decoder window switch parameters 
#define    NET_DVR_START_SCREEN_CRTL                9226    //Start Screen Control
#define    NET_DVR_GET_SCREEN_FLIE_LIST            9227    //Get the screen file list
#define    NET_DVR_GET_SCREEN_FILEINFO                9228    //Get screen file information parameters
#define    NET_DVR_SET_SCREEN_FILEINFO             9229    //Set screen file information parameters

/*******************************LED begin***************************************/
#define NET_DVR_GET_LED_OUTPUT_CFG                9230    //get led send card output parameters
#define NET_DVR_SET_LED_OUTPUT_CFG                9231    //set led send card output parameters
#define NET_DVR_GET_LED_OUTPUT_PORT_CFG            9232    //get led send card output port parameters
#define NET_DVR_SET_LED_OUTPUT_PORT_CFG            9233    //set led send card output port parameters
#define NET_DVR_GET_LED_DISPLAY_AREA_CFG        9234    //get led send card display area
#define NET_DVR_SET_LED_DISPLAY_AREA_CFG        9235    //set led send card display area
#define NET_DVR_GET_LED_PORT_CFG                9236    //get led send card port parameters
#define NET_DVR_SET_LED_PORT_CFG                9237    //set led send card port parameters
#define NET_DVR_GET_LED_DISPLAY_CFG                9238    //get led send card display parameters
#define NET_DVR_SET_LED_DISPLAY_CFG                9239    //set led send card display parameters
#define NET_DVR_GET_ALL_LED_PORT_CFG            9240    //get led all port parameters
#define NET_DVR_SAVE_LED_CONFIGURATION            9241    //save led configuration
#define NET_DVR_GET_LED_TEST_SIGNAL_CFG            9242    //get led test signal parameters
#define NET_DVR_SET_LED_TEST_SIGNAL_CFG            9243    //set led test signal parameters
#define NET_DVR_GET_LED_NOSIGNAL_CFG            9244    //get led no signal display parameters
#define NET_DVR_SET_LED_NOSIGNAL_CFG            9245    //set led no signal display parameters
#define NET_DVR_GET_LED_INPUT_CFG                9246    //get led send card input parameters
#define NET_DVR_SET_LED_INPUT_CFG                9247    //get led send card input parameters
#define NET_DVR_GET_LED_RECV_GAMMA_CFG            9248    //get receive card GAMMA table parameters
#define NET_DVR_SET_LED_RECV_GAMMA_CFG            9249    //set led receive card GAMMA table parameters
#define NET_DVR_GET_LED_RECV_CFG                9250    //get led receive card basic parameters
#define NET_DVR_SET_LED_RECV_CFG                9251    //set led receive card basic parameters
#define NET_DVR_GET_LED_RECV_ADVANCED_CFG        9252    //get led receive card advanced parameters
#define NET_DVR_SET_LED_RECV_ADVANCED_CFG        9253    //set led receive card advanced parameters
#define NET_DVR_GET_LED_SCREEN_DISPLAY_CFG        9254    //get led screen display parameters
#define NET_DVR_SET_LED_SCREEN_DISPLAY_CFG        9255    //set led screen display parameters
/*******************************LED end*****************************************/

#define    NET_DVR_GET_SCREEN_CONFIG               9260    //Get the server screen parameter
#define    NET_DVR_SET_SCREEN_CONFIG               9261    //Set the server screen parameter 
#define NET_DVR_GET_SCREEN_CONFIG_CAP              9262    //Ability to screen server parameters were obtained 

#define    NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS    9271    //get schedule publish progress
#define    NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS    9272    //get info publish termal upgrade progress

#define NET_DVR_GET_INSERTPLAY_PROGRESS            9273    //get insert play progress

#define NET_DVR_GET_INPUT_BOARD_CFG                9281    //get input board configuration
#define NET_DVR_GET_INPUT_BOARD_CFG_LIST        9282    //get input board configuration list
#define NET_DVR_SET_INPUT_BOARD_CFG                9283    //set input board configuration

#define NET_DVR_GET_INPUT_SOURCE_TEXT_CAP    9284
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG    9285
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT 9286    
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG    9287
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST 9288
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP    9289
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG    9290
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST    9291
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG    9292
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST  9293
#define NET_DVR_GET_LED_AREA_INFO_LIST  9295
#define NET_DVR_GET_DISPINPUT_CFG  9296  //get display input parameters
#define NET_DVR_GET_DISPINPUT_CFG_LIST  9297  //get all display input parameters
#define NET_DVR_SET_DISPINPUT_CFG  9298  //set display input parameters
#define NET_DVR_GET_DISPINPUT_CFG_CAP  9299  //get display input parameters capabilities

#define NET_DVR_GET_CURRENT_VALID_PORT          9300    //get current valid port
#define    NET_DVR_SET_ONLINE_UPGRADE                9301    //allow the device upgrade online
#define NET_DVR_GET_ONLINEUPGRADE_PROGRESS      9302    //get online upgrade progress
#define    NET_DVR_GET_FIRMWARECODE                9303    //get firmware code
#define NET_DVR_GET_ONLINEUPGRADE_SERVER        9304    //get upgrade server status
#define NET_DVR_GET_ONLINEUPGRADE_VERSION       9305    //get new version information
#define NET_DVR_GET_RECOMMEN_VERSION            9306    //check the version is recommened
#define NET_DVR_GET_ONLINEUPGRADE_ABILITY       9309    //get the ability of online upgrade

#define    NET_DVR_GET_FIBER_CONVERT_BASIC_INFO_V50     9310
#define    NET_DVR_GET_FIBER_CONVERT_WORK_STATE_V50     9311

#define NET_SDK_LED_SCREEN_CHECK            9312
#define  NET_SDK_GET_MATRIX_STATUS_V51   9313    
#define NET_SDK_GENERATE_OUTPUT_CONTROL	    9315


//DS-19D2000-S V2.0 update alarm linkage parameter code
#define  NET_DVR_GET_ALARM_LINKAGE_CFG    9316    //get DH alarm linkage parameter
#define  NET_DVR_SET_ALARM_LINKAGE_CFG    9317    //get DH alarm linkage parameter


#define NET_DVR_GET_RS485_WORK_MODE             10001 //get RS485 serial port work mode
#define NET_DVR_SET_RS485_WORK_MODE             10002 //set Rs485 serial port work mode
#define NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG     10003 //get splitter transparent channel config
#define NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG     10004 //set splitter transparent channel config


#define NET_DVR_GET_RS485_PROTOCOL_VERSION              10301       //get rs485 protocol version
#define	 NET_DVR_ALARMHOST_REGISTER_DETECTOR  10302			//auto registor detector




#define  NET_DVR_GET_SIP_CFG                    11001   //IP View get SIP config
#define  NET_DVR_SET_SIP_CFG                    11002   //IP View set SIP config
#define  NET_DVR_GET_IP_VIEW_DEVCFG                11003   //IP View get sub device config
#define  NET_DVR_SET_IP_VIEW_DEVCFG                11004   //IP View set sub device config
#define  NET_DVR_GET_IP_VIEW_AUDIO_CFG            11005   //IP View get audio config
#define  NET_DVR_SET_IP_VIEW_AUDIO_CFG            11006   //IP View set audio config
#define     NET_DVR_GET_IP_VIEW_CALL_CFG            11007   //IP View get call config
#define  NET_DVR_SET_IP_VIEW_CALL_CFG            11008   //IP View set call config
#define     NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG        11009    //IP View get audio limit alarm config
#define     NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG        11010    //IP View set audio limit alarm config
#define     NET_DVR_GET_BUTTON_DOWN_ALARM_CFG        11011    //IP View get button down alarm config
#define     NET_DVR_SET_BUTTON_DOWN_ALARM_CFG        11012    //IP View set button down alarm config

#define NET_DVR_GET_ISCSI_CFG                   11070      //Get ISCSI storage configuration protocol
#define NET_DVR_SET_ISCSI_CFG                   11071      //Set ISCSI storage configuration protocol
/*************************Parameter Configure Commands end*******************************/
#define NET_DVR_GET_SECURITYMODE                12004   
//2013-11-21 Get Temperature Humidity
#define NET_DVR_GET_TEMP_HUMI                   12005

//2014-02-15 Civil IPC test project
#define  NET_DVR_SET_ALARMSOUNDMODE             12006   //Set Alarm Sound Mode
#define  NET_DVR_GET_ALARMSOUNDMODE             12007   //Get Alarm Sound Mode
#define    NET_DVR_SET_IPDEVICE_ACTIVATED       13000//activate ipc by nvr
#define NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS    13001   //get ip device security status
#define    NET_DVR_GET_ACTIVATE_IPC_ABILITY     13003    //get ability of activate ipc by nvr

#define NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG  16001  //Get Video intercom DeviceID config
#define NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG  16002  //Set Video intercom DeviceID config
#define NET_DVR_SET_PRIVILEGE_PASSWORD           16003  //Get Privilege password
#define NET_DVR_GET_OPERATION_TIME_CFG           16004  //Get Opreation Time Config
#define NET_DVR_SET_OPERATION_TIME_CFG           16005  //Set Opreation Time Config
#define NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG 16006  //Get related Device Config
#define NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG 16007  //Set related Device Config
#define NET_DVR_REMOTECONTROL_NOTICE_DATA        16008  //Notice Data
#define NET_DVR_REMOTECONTROL_GATEWAY            16009  //remote control Gateway
#define NET_DVR_REMOTECONTROL_OPERATION_AUTH     16010  //Remote Control operation auth

#define NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG      16016  //Get IO In Cfg
#define NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG      16017  //Set IO In Cfg
#define NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG     16018  //Get IO Out Cfg
#define NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG     16019  //Set IO Out Cfg
#define NET_DVR_GET_ELEVATORCONTROL_CFG          16020  //Get Elevator control Cfg
#define NET_DVR_SET_ELEVATORCONTROL_CFG          16021  //Set Elevator control Cfg
#define NET_DVR_GET_VIDEOINTERCOM_STREAM         16022  //Get Stream Cfg
#define NET_DVR_SET_VIDEOINTERCOM_STREAM         16023  //Set Stream Cfg
#define NET_DVR_GET_WDR_CFG                      16024  //Get WDR Cfg
#define NET_DVR_SET_WDR_CFG                      16025  //Set WDR Cfg
#define NET_DVR_GET_VIS_DEVINFO                  16026  //Get VIS Device Info
#define NET_DVR_GET_VIS_REGISTER_INFO            16027  //Get VIS Register Info
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V40      16028  //Get Elevator control Cfg V40
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V40      16029  //Set Elevator control Cfg  V40
#define NET_DVR_GET_CALL_ROOM_CFG                 16030  //Get Room Call Config
#define NET_DVR_SET_CALL_ROOM_CFG                 16031  //Set Room Call Config
#define NET_DVR_VIDEO_CALL_SIGNAL_PROCESS        16032  //Video Call Signal Process
#define NET_DVR_GET_CALLER_INFO                  16033  //get caller info
#define NET_DVR_GET_CALL_STATUS                  16034  //get call status
#define NET_DVR_GET_SERVER_DEVICE_INFO           16035  //get server device infi
#define NET_DVR_SET_CALL_SIGNAL                  16036  //set call signal
#define NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG       16037    //get video intercom alarm cfg
#define NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG       16038    //set video intercom alarm cfg
#define NET_DVR_GET_RING_LIST                    16039    //get ring list

#define NET_DVR_GET_ROOM_CUSTOM_CFG             16040  //get room custom cfg
#define NET_DVR_SET_ROOM_CUSTOM_CFG             16041  //set room custom cfg
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V50     16042  //Get Elevator control Cfg V50
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V50     16043  //Set Elevator control Cfg V50
#define NET_DVR_GET_SIP_CFG_V50                 16044   //Get SIP config V50
#define NET_DVR_SET_SIP_CFG_V50                 16045   //Set SIP config V50
#define NET_DVR_GET_NOTICE_VIDEO_DATA           16050  //Get Notice Video Data

#define    NET_DVR_DEBUGINFO_START                     18000    //Debug Info Start
#define    NET_DVR_AUTO_TEST_START                     18001    //Start auto test

/***************************DS9000 New Commands (_V30)  end *****************************/
//[add] by zja 2013-10-29 10:47:57
#define NET_DVR_GET_SELFCHECK_RESULT        20000    //Get selfcheck status 
#define NET_DVR_SET_TEST_COMMAND            20001    //Set test control command
#define NET_DVR_SET_TEST_DEVMODULE          20002    //set the contorl command of the hardware module
#define NET_DVR_GET_TEST_DEVMODULE          20003    //get the contorl command of the hardware module


#define NET_DVR_SET_AUTOFOCUS_TEST          20004    //Set Autofocus Test 2013-10-26
#define NET_DVR_CHECK_USER_STATUS           20005    //Detect the user is online
#define NET_DVR_GET_TEST_COMMAND            20010    //Get test control command
#define NET_DVR_GET_DIAL_SWITCH_CFG         20200    //Get Dial Switch 
#define NET_DVR_SET_AGING_TRICK_SCAN          20201  //Set the tool parameters before and after aging 
#define NET_DVR_GET_ECCENTRIC_CORRECT_STATE   20202  //Capture the eccentric calibration status 
#define	NET_DVR_GET_THERMOMETRYRULE_TEMPERATURE_INFO   23001
#define  NET_DVR_T1_TEST_CMD                     131073 


// American branch office coustom
#define NET_DVR_GET_MEMU_OUTPUT_MODE         155649        //Get menu output mode
#define NET_DVR_SET_MEMU_OUTPUT_MODE         155650        //Set menu output mode


#define NET_DVR_GET_DEV_LOGIN_RET_INFO      16777200  //get device login return parameters

/*******************Return Value of File&Log Query API*************************/
#define NET_DVR_FILE_SUCCESS            1000    //Get log information
#define NET_DVR_FILE_NOFIND                1001    //No log
#define NET_DVR_ISFINDING                1002    //On searching
#define    NET_DVR_NOMOREFILE                1003    //No more files
#define    NET_DVR_FILE_EXCEPTION            1004    //Error on log query
#define NET_DVR_FIND_TIMEOUT        1005   //query timeout

//alarm of plate: NET_DVR_PLATE_RESULT

/*************Operation Exception**********************/
#define EXCEPTION_EXCHANGE                0x8000    //Network user exception
#define EXCEPTION_AUDIOEXCHANGE            0x8001    //Network voice talk exception
#define EXCEPTION_ALARM                    0x8002    //Alarm exception
#define EXCEPTION_PREVIEW                0x8003    //Network preview exception
#define EXCEPTION_SERIAL                0x8004    //Transparent channel exception
#define EXCEPTION_RECONNECT                0x8005    //Network preview reconnected
#define EXCEPTION_ALARMRECONNECT        0x8006    //Alarm reconnected
#define EXCEPTION_SERIALRECONNECT        0x8007    //Transparent channel reconnected
#define SERIAL_RECONNECTSUCCESS            0x8008    //Transparent reconnected success
#define EXCEPTION_PLAYBACK                0x8010    //Playback exception
#define EXCEPTION_DISKFMT                0x8011    //Hard Disk format exception
#define EXCEPTION_PASSIVEDECODE            0x8012  //Passive decode exception
#define EXCEPTION_EMAILTEST                0x8013  //Email test exception    
#define EXCEPTION_BACKUP                0x8014  //Backup exception
#define PREVIEW_RECONNECTSUCCESS        0x8015  //Network preview reconnected successfully
#define ALARM_RECONNECTSUCCESS            0x8016  //Alarm reconnected successfully
#define RESUME_EXCHANGE                    0x8017    //User interaction resume

#define NETWORK_FLOWTEST_EXCEPTION      0x8018  // Network flow exception
//2011-11-24
#define EXCEPTION_PICPREVIEWRECONNECT    0x8019    //Picture Preview reconnect
#define PICPREVIEW_RECONNECTSUCCESS        0x8020    //Picture Preview reconnect successfully
#define EXCEPTION_PICPREVIEW            0x8021    //Picture Preview exception
#define    EXCEPTION_MAX_ALARM_INFO        0x8022    //too many alarm info
#define EXCEPTION_LOST_ALARM            0x8023    //lost alarm
#define EXCEPTION_PASSIVETRANSRECONNECT 0x8024  //Passive trans code reconnect
#define PASSIVETRANS_RECONNECTSUCCESS   0x8025  //Passive trans code reconnect success
#define EXCEPTION_PASSIVETRANS          0x8026  //Passive trans code exception
#define SUCCESS_PUSHDEVLOGON            0x8030
#define EXCEPTION_RELOGIN                0x8040    //User Relogin 
#define RELOGIN_SUCCESS                    0x8041    //User Relogin Success
#define EXCEPTION_PASSIVEDECODE_RECONNNECT  0x8042  //Passive decode reconnect
#define EXCEPTION_CLUSTER_CS_ARMFAILED      0x8043  //cluster arm cs exception

#define EXCEPTION_RELOGIN_FAILED                0x8044   //Relogin failed,stop relogin
#define EXCEPTION_PREVIEW_RECONNECT_CLOSED      0x8045   //stop preveiw reconnect
#define EXCEPTION_ALARM_RECONNECT_CLOSED        0x8046   //stop alarm reconnect
#define EXCEPTION_SERIAL_RECONNECT_CLOSED       0x8047   //stop serial reconnect
#define EXCEPTION_PIC_RECONNECT_CLOSED          0x8048   //stop picture reconnect
#define EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED 0x8049 //stop passive decode reconnect
#define EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED 0x804a  //stop passive transcoding reconnect
#define EXCEPTION_VIDEO_DOWNLOAD 0x804b // playback video download exception
/********************Preview Callback Function*********************/
#define NET_DVR_SYSHEAD                    1    //System header
#define NET_DVR_STREAMDATA                2    //stream data
#define NET_DVR_AUDIOSTREAMDATA            3    //Audio Stream data
#define NET_DVR_STD_VIDEODATA            4    //Standard video stream data
#define NET_DVR_STD_AUDIODATA            5    //Standard audio stream data
#define NET_DVR_SDP                        6   //SDP data(valid for rtsp protocol) 
#define NET_DVR_CHANGE_FORWARD            10  //stream change from reverse to forward  
#define NET_DVR_CHANGE_REVERSE            11  //stream change from forward to reverse
#define NET_DVR_PLAYBACK_ALLFILEEND      12  //Play back All File End
#define NET_DVR_VOD_DRAW_FRAME              13  //vod draw Frame
#define NET_DVR_VOD_DRAW_DATA               14  //vod drawing
#define NET_DVR_HLS_INDEX_DATA              15  //HLS data
#define NET_DVR_PLAYBACK_NEW_POS            16  //new pos
#define NET_DVR_METADATA_DATA              107  //Metadata
#define NET_DVR_PRIVATE_DATA            112 //Private data

/******************************Abilities Set*********************************/
//Capabilities
#define DEVICE_SOFTHARDWARE_ABILITY   0x001  //Software / hardware abilities of the device
#define DEVICE_NETWORK_ABILITY        0x002  //Network abilities of the device
#define DEVICE_ENCODE_ALL_ABILITY     0x003  //Encode abilities of the device
#define    DEVICE_ENCODE_CURRENT         0x004  //Current encode ability of the device
#define IPC_FRONT_PARAMETER              0x005     //Network camera parameters
#define IPC_UPGRADE_DESCRIPTION          0x006     //Network camera upgrade info
#define DEVICE_RAID_ABILITY           0x007  //RAID 
#define DEVICE_ENCODE_ALL_ABILITY_V20 0x008     //Encode abilities of the device 2.0
#define IPC_FRONT_PARAMETER_V20          0x009     //Network camera parameters 2.0
#define DEVICE_ALARM_ABILITY          0x00a  //alarm ability
#define DEVICE_DYNCHAN_ABILITY          0x00b  //device dyn channel ability
#define DEVICE_USER_ABILITY           0x00c  //user ability
#define DEVICE_NETAPP_ABILITY         0x00d  //net app ability
#define DEVICE_VIDEOPIC_ABILITY       0x00e  //video picture ability
#define DEVICE_JPEG_CAP_ABILITY       0x00f  //JPEG capture ability
#define DEVICE_SERIAL_ABILITY         0x010  //RS232 and RS485 ability
#define DEVICE_ABILITY_INFO              0x011     //Device common ability
#define STREAM_ABILITY                0x012  //Stream ability
#define SYSTEM_MANAGEMENT_ABILITY     0x013  //Device system management ability
#define IP_VIEW_DEV_ABILITY              0x014  //IP VIEW ability
#define VCA_DEV_ABILITY               0x100  //Intelligent analysis ability of the device
#define VCA_CHAN_ABILITY              0x110  //VCA ability of the device
#define TRANSFER_ABILITY              0x120 
#define MATRIXDECODER_ABILITY         0x200  //display and decoding ability of the multi-channel decoder
#define VIDEOPLATFORM_ABILITY         0x210  //Ability set of video management system
#define WALL_ABILITY                  0x212  //ability set of video wall
#define MATRIX_ABILITY                0x213  //ability set of SDI matrix 
#define VIDEOPLATFORM_ABILITY_V40     0x230  //ability set of Multi-function Video Center
#define MATRIXMANAGEDEVICE_ABILITY    0x240
#define MATRIXDECODER_ABILITY_V41     0x260  //decoder ability
#define DECODER_ABILITY               0x261  //decoder ability
#define CODECARD_ABILITY              0x271  //coder card server ability
#define SNAPCAMERA_ABILITY            0x300  //Ability set for the camera
#define ITC_TRIGGER_MODE_ABILITY      0x301  //IPC Trigger mode ability
#define COMPRESSIONCFG_ABILITY        0x400  //Get compression parameter abilities
#define COMPRESSION_LIMIT             0x401  //get compression ability between main and sub stream
#define PIC_CAPTURE_ABILITY           0x402  //get picture capture ability 
#define IT_DEVICE_ABILITY             0x501  //ITS ability
#define    SCREENCONTROL_ABILITY          0x600  //Ability of screen controller
#define    SCREENSERVER_ABILITY          0x610  //Ability of screen server
#define FISHEYE_ABILITY               0x700  //Fisheye ability
#define LCD_SCREEN_ABILITY              0x800     //Ability of LCD Screen 
#define ACS_ABILITY                   0x801  //Ability of Access Control System  
#define MERGEDEV_ABILITY              0x802  //Ability of merge code device
#define CAM_FUSION_ABILITY            0x803  //Camera fusion ability
#define OPTICAL_DEV_ACCESS_ABILITY    0x805  //Node optical device access ability
#define NET_RING_ABILITY              0x806     //Net ring ability
#define LED_ABILITY                      0x807     //LED screen ability
#define SCREEN_EXCHANGE_ABILITY       0x80b  //Screen interactive ability
#define REMOTE_NETMGR_FOT_ABILITY   0x80e   //Remote network management FOT ability

//board exception type
//main type
#define EXCEPTION_MAJOR_MAINBOARD_BOOT                    0x1  //main board boot exception
//sub type
#define EXCEPTION_MINOR_PCIE_SCAN                        0x1  //PCIE scan exception 
#define EXCEPTION_MINOR_DOWNLOAD_SUBBOARD                 0xa  //download sub board exception

//main type
#define EXCEPTION_MAJOR_SUBBOARD_BOOT                    0x2  //sub board boot exception
//sub type
#define EXCEPTION_MINOR_INEXISTENCE                       0x1  //sub board not found
#define EXCEPTION_MINOR_UBOOT_DOWNLOAD                  0xa  //uboot download exception
#define EXCEPTION_MINOR_UBOOT_INIT                      0xe  //uboot initialization fail
#define EXCEPTION_MINOR_ROOTFS_DOWNLOAD                 0x14  //rootfs.img download fail
#define EXCEPTION_MINOR_UIMAGE_DOWNLOAD                 0x19  //uImage download fail
#define EXCEPTION_MINOR_UBOOT_SETBOOTFLAG               0x1e  //uboot boot flags exception    
#define EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD            0x23  //rootfs boot exception
#define EXCEPTION_MINOR_NEED_FILE_FINISH                0x28  //sub board file transfer exception

//main type
#define EXCEPTION_MAJOR_SUBBOARD_HARDWARE                0x3  //sub board hardware exception
//sub type
#define EXCEPTION_MINOR_AD                               0x1  //AD exception  
#define EXCEPTION_MINOR_DA                                 0xa  //DA exception
#define EXCEPTION_MINOR_TIMER                            0xb     //timer exception

//main type
#define EXCEPTION_MAJOR_FPGA                            0x4  //FPGA exception
//sub type
#define EXCEPTION_MINOR_IDLE                              0x1  //IDLE exception  
#define EXCEPTION_MINOR_LANE                             0xa  //LANE exception
#define EXCEPTION_MINOR_REGISTER_ALL_F                     0xe  //FPGA register all F
#define EXCEPTION_MINOR_MEMORY_INIT_FAIL                 0x14 //FPGA memory initialization fail
//main type
#define EXCEPTION_MAJOR_DSP                                0x5  //DSP exception

//main type
#define EXCEPTION_MAJOR_ARM                                0x6  //ARM exception

//main type
#define EXCEPTION_MAJOR_BACKBOARD                        0x7  //back board exception
//sub type
#define EXCEPTION_MINOR_BACKBOARD_TYPE                   0x1  //get back board type fail
#define EXCEPTION_MINOR_SERDES                           0xa  //serdes exception   
#define EXCEPTION_MINOR_CLOCK                             0xe  //clock exception
#define EXCEPTION_MINOR_SYNCH                             0x14 //synchronous signal exception


//main type
#define EXCEPTION_MAJOR_SUBBOARD_NET                    0x8  //sub board network exception
//sub type
#define EXCEPTION_MINOR_IP_CONFLICT                       0x1  //IP conflict
#define EXCEPTION_MINOR_DISCONNECT                         0x14 //network disconnect

//alarm callback
#define COMM_ALARM                      0x1100  //8000 Upload alarm message

//corresponding to NET_VCA_RULE_ALARM
#define COMM_ALARM_RULE                  0x1102  //VCA alarm info
#define COMM_ALARM_PDC                0x1103  //PDC alarm info
#define COMM_ALARM_AID                0x1110  //Traffic event alarm info
#define COMM_ALARM_VIDEOPLATFORM      0x1104  //Video Management System alarm
#define COMM_ALARM_ALARMHOST          0x1105  //Network alarm host alarm 
#define COMM_ALARM_FACE               0x1106  //Face detection recognition alarm information
#define COMM_RULE_INFO_UPLOAD         0x1107  //Event data information upload
#define COMM_ALARM_AID                0x1110  //Traffic event alarm info
#define COMM_ALARM_TPS                0x1111  //Traffic statistics alarm info
#define COMM_UPLOAD_FACESNAP_RESULT   0x1112  //Upload face snap result
#define COMM_ALARM_TFS                0x1113  //Traffic forensic alarm info
#define COMM_ALARM_TPS_V41            0x1114  //Traffic statistics alarm info(extended)
#define COMM_ALARM_AID_V41            0x1115  //Traffic event alarm info(extended)
#define COMM_ALARM_VQD_EX             0x1116  //Video quality diagnosis alarm(extended)
#define COMM_ALARM_NOTIFICATION_REPORT 0x1117 //Notification report
#define COMM_SENSOR_VALUE_UPLOAD      0x1120  //Sensor data realtime upload
#define COMM_SENSOR_ALARM                0x1121  //Analog alarm upload
#define COMM_SWITCH_ALARM              0x1122    
#define COMM_ALARMHOST_EXCEPTION      0x1123  //Alarm host exception alarm
#define COMM_ALARMHOST_OPERATEEVENT_ALARM    0x1124
#define COMM_ALARMHOST_SAFETYCABINSTATE 0x1125//SafetyCabin State
#define COMM_ALARMHOST_ALARMOUTSTATUS 0x1126  //Alarm Out Status
#define COMM_ALARMHOST_CID_ALARM       0x1127  // CID ALARM
#define    COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM 0x1128    // external device alarm
#define COMM_ALARMHOST_DATA_UPLOAD    0x1129  //Alarm data upload
#define COMM_FACECAPTURE_STATISTICS_RESULT   0x112a  //face Capture Statistics Result
#define COMM_ALARM_WIRELESS_INFO     0x122b  // wirless info upload
#define COMM_SCENECHANGE_DETECTION_UPLOAD    0x1130    //Scene change alarm upload 2013-7-16
#define COMM_CROSSLINE_ALARM                0x1131  //CrossLine Alram 
#define COMM_UPLOAD_VIDEO_INTERCOM_EVENT     0x1132  //upload video intercon event
#define COMM_ALARM_VIDEO_INTERCOM               0x1133  //upload video intercon alarm
#define COMM_UPLOAD_NOTICE_DATA                 0x1134  //upload notice data
#define COMM_ALARM_AUDIOEXCEPTION     0x1150  //Aduio alarm info
#define COMM_ALARM_DEFOCUS            0x1151  //Defous alarm info
#define COMM_ALARM_BUTTON_DOWN_EXCEPTION     0x1152
#define COMM_ALARM_ALARMGPS                  0x1202  //GPS alarm info upload
#define    COMM_TRADEINFO                  0x1500  //ATM DVR transaction information
//NET_DVR_PLATE_RESULT
#define COMM_UPLOAD_PLATE_RESULT      0x2800  //Uploaded License info
#define COMM_ITC_STATUS_DETECT_RESULT 0x2810  //status detect
#define COMM_IPC_AUXALARM_RESULT      0x2820  //PIR alarm\wireless alarm\callhelp alarm
#define COMM_UPLOAD_PICTUREINFO       0x2900    
#define COMM_SNAP_MATCH_ALARM         0x2902  //blocklist comparison result upload
#define COMM_ITS_PLATE_RESULT            0x3050  //ITS plate result upload
#define    COMM_ITS_TRAFFIC_COLLECT      0x3051  //ITS traffic collect upload
#define COMM_ITS_GATE_VEHICLE          0x3052  //Gate vehicle snapshot data upload
#define COMM_ITS_GATE_FACE            0x3053  //Gate vehicle Face data upload
#define COMM_ITS_GATE_COSTITEM          0x3054  //Gate Costitem 2013-11-19
#define COMM_ITS_GATE_HANDOVER          0x3055  //Gate Handover  2013-11-19
#define COMM_ITS_PARK_VEHICLE         0x3056  //Parking data upload
#define COMM_ITS_BLOCKLIST_ALARM      0x3057  //BlockList data upload
#define COMM_VEHICLE_CONTROL_LIST_DSALARM    0x3058  //Vehicle Control List Alarm 2013-11-04
#define COMM_VEHICLE_CONTROL_ALARM           0x3059  //Vehicle Alarm 2013-11-04
#define COMM_FIRE_ALARM                      0x3060  //Fire Alarm 2013-11-04
#define COMM_ITS_GATE_ALARMINFO       0x3061      //ITS gate Alarm Info
#define COMM_VEHICLE_RECOG_RESULT     0x3062  //Upload a secondary result of the vehicle identification 2014-11-12 
#define COMM_PLATE_RESULT_V50         0x3063  //Plate Result V50

#define COMM_GATE_CHARGEINFO_UPLOAD          0x3064  //Charge Info Upload
#define COMM_TME_VEHICLE_INDENTIFICATION     0x3065  //TME Vehicle upload
#define COMM_GATE_CARDINFO_UPLOAD            0x3066  //Entrance card information upload
#define COMM_LOADING_DOCK_OPERATEINFO     0x3067        //loading dock operate info upload

#define COMM_ALARM_SENSORINFO_UPLOAD  0x3077  //Sensor Info Upload
#define COMM_ALARM_CAPTURE_UPLOAD      0x3078  //Capture Upload
#define COMM_ITS_RADARINFO            0x3079  //Radar Alarm Info

#define COMM_SIGNAL_LAMP_ABNORMAL     0x3080  //Signal Lamp Abnormal

#define COMM_ALARM_TPS_REAL_TIME      0x3081  //TPS Real Time
#define COMM_ALARM_TPS_STATISTICS     0x3082  //TPS Statistics

#define COMM_ALARM_V30                  0x4000  //9000 upload alarm message
#define COMM_IPCCFG                      0x4001  //9000 IPC configuration changed,  upload with push mode
#define COMM_IPCCFG_V31                  0x4002  //Initiative alarm upload when IPC connection configuration changes on 9000 device,  extended for 9000_1.1
#define COMM_IPCCFG_V40                  0x4003  //Alarm information upload when IPC connection configuration of IVMS-2000 or NVR changes
#define COMM_ALARM_DEVICE             0x4004
#define COMM_ALARM_CVR                  0x4005  //CVR 2.0.X alarm
#define COMM_ALARM_HOT_SPARE          0x4006  //Hot alarm exception(N+1 abnormal alarm)
#define COMM_ALARM_V40                  0x4007  //upload alarm message(Expend)
#define COMM_UPLOAD_HEATMAP_RESULT    0x4008 //Heat Map 2014-03-21
#define COMM_ALARM_DEVICE_V40         0x4009  
#define COMM_ALARM_FACE_DETECTION     0x4010 //Face Detection
#define COMM_ALARM_TARGET_LEFT_REGION  0x4011 // Target left Region 
#define COMM_GISINFO_UPLOAD           0x4012 //GIS Info upload
#define COMM_VANDALPROOF_ALARM        0x4013 // prevent damage
#define COMM_PEOPLE_DETECTION_UPLOAD  0x4014 //People Detection Upload
#define COMM_ALARM_STORAGE_DETECTION  0x4015 //Storge Detection Alarm
#define COMM_MVM_REGISTER             0x4016 //Magnetic Vehicle Manager register info
#define COMM_MVM_STATUS_INFO          0x4017 //Magnetic Vehicle Manager status info upload
#define COMM_UPLOAD_HEATMAP_RESULT_PDC           0x4018 //Heat map result pdc
#define COMM_UPLOAD_HEATMAP_RESULT_DURATION      0x4019 //Heat map result duration
#define COMM_UPLOAD_HEATMAP_RESULT_INTERSECTION  0x4020 //Heat map result intersection
#define COMM_UPLOAD_AIOP_VIDEO        0x4021 //AIOP Video
#define COMM_UPLOAD_AIOP_PICTURE      0x4022 //AIOP Picture
#define COMM_UPLOAD_AIOP_POLLING_SNAP        0x4023 //polling snap
#define COMM_UPLOAD_AIOP_POLLING_VIDEO       0x4024 //polling video
#define COMM_UPLOAD_AIOP_HISTORY_VIDEO			0x4025 //AIOP history video

#define    COMM_ITS_ROAD_EXCEPTION          0x4500  //ITS road exception upload
#define    COMM_ITS_EXTERNAL_CONTROL_ALARM        0x4520 //External control Alarm
#define COMM_ALARM_SHIPSDETECTION      0x4521  //Ships Detection

#define COMM_VCA_DBD_ALARM 0x4550       //dbd alarm
#define COMM_VCA_ADAS_ALARM 0x4551      //adas alarm
#define COMM_VEH_REALTIME_INFO 0x4552   //vehicel realtime info
#define COMM_VCA_ATTEND_ALARM 0x4553       //Attendance event alarm information

#define COMM_FIREDETECTION_ALARM      0x4991  //Fire Detection Alarm
#define COMM_ALARM_DENSEFOGDETECTION    0x4992     //Fog Detection Alarm
#define COMM_VCA_ALARM                     0x4993     //VCA Detection Alarm
#define  COMM_FACE_THERMOMETRY_ALARM       0x4994 //face temp Alarm

#define  COMM_TAPE_ARCHIVE_ALARM        0x4996 //Tape archive alarm

#define    COMM_SCREEN_ALARM              0x5000  //Alarm type
#define COMM_DVCS_STATE_ALARM          0x5001  // alarm of dvcs
#define COMM_ALARM_ACS                  0x5002  //access card alarm
#define COMM_ALARM_FIBER_CONVERT      0x5003  //fiber convert alarm 
#define COMM_ALARM_SWITCH_CONVERT     0x5004  //switch alarm
#define COMM_ALARM_DEC_VCA            0x5010  //vca decode alarm 
#define COMM_ALARM_LCD                  0x5011   //LCD alarm 
#define COMM_CONFERENCE_CALL_ALARM      0x5012  //conference call alarm
#define COMM_ALARM_WALL_CONFERNECE  0x5015

#define COMM_DIAGNOSIS_UPLOAD         0x5100  //alarm of VQD
#define COMM_HIGH_DENSITY_UPLOAD      0x5101  //high density status upload

#define COMM_ID_INFO_ALARM                   0x5200  //id info alarm
#define COMM_PASSNUM_INFO_ALARM              0x5201  //pass number info alarm
#define COMM_PASSPORT_ALARM                   0x5202  //passport alarm

#define COMM_THERMOMETRY_DIFF_ALARM   0x5211  //Thermometry Difference Alarm
#define COMM_THERMOMETRY_ALARM        0x5212  //Thermometry Alarm
#define COMM_PANORAMIC_LINKAGE_ALARM         0x5213  //Panoramic linkage Alarm
#define COMM_TAG_INFO_ALARM           0x5215  //Tag Information Upload

#define COMM_ALARM_VQD                0x6000  //VQD alarm up 
#define COMM_PUSH_UPDATE_RECORD_INFO  0x6001  //Push mode record info upload
#define COMM_SWITCH_LAMP_ALARM        0x6002  //Swicth lamp Alarm
#define COMM_INQUEST_ALARM      0x6005  //Inquest alarm
#define COMM_VIDEO_PARKING_POLE_ALARM       0x6006  //Video Parking Pole Alarm
#define COMM_GPS_STATUS_ALARM         0x6010  // GPS status upload
#define COMM_BASE_STATION_INFO_ALARM  0x6011  // Base Station upload
#define COMM_ALARM_SUBSCRIBE_EVENT    0x6012  //Subscription results reported
#define COMM_FACESNAP_RAWDATA_ALARM   0x6015  //Face Snap Raw Data Alarm
#define COMM_CLUSTER_ALARM       0x6020
#define COMM_ISAPI_ALARM              0x6009  //ISAPI alarm

//PJ01C20170209084 super-brainNVS customization dedicated
#define COMM_FRAMES_PEOPLE_COUNTING_ALARM	 0x6069	 //Single frame people count result upload 

#define  COMM_SIGN_ABNORMAL_ALARM            0x6120 //Sign abnormal alarm
#define  COMM_HFPD_ALARM                     0x6121 //High frequency personnel detection alarm

#define   COMM_HCU_ALARM  0x6150  //HCU Alarm, SDK lib not support

#define  COMM_DEV_STATUS_CHANGED             0x7000  //Device status change alarm upload

#define  COMM_ALARM_EXCEPTION                0x7fff  //Alarm exception type
/* Device model*/
#define DVR                            1                //Undefined DVR
#define ATMDVR                        2                //ATM DVR
#define DVS                            3                //DVS
#define DEC                            4                //6001DI 
#define ENC_DEC                        5                //6001FI 
#define DVR_HC                        6                //8000HCI
#define DVR_HT                        7                //8000HTI
#define DVR_HF                        8                //8000HFI
#define DVR_HS                        9                //8000HSI DVR (no audio) 
#define DVR_HTS                        10              //8016HTS DVR (no audio) 
#define DVR_HB                        11              //HB DVR (SATA HD)  
#define DVR_HCS                        12              //8000HCS DVR 
#define DVS_A                        13              //DVS with ATA Hard disk 
#define DVR_HC_S                    14              //8000HCI- S 
#define DVR_HT_S                    15              //8000HTI- S 
#define DVR_HF_S                    16              //8000HFI- S 
#define DVR_HS_S                    17              //8000HSI- S 
#define ATMDVR_S                    18              //ATM- S 
#define DVR_7000H                    19                //7000HI Series
#define DEC_MAT                        20              //Multichannel Decoder
#define DVR_MOBILE                    21                //Mobile DVR           
#define DVR_HD_S                    22              //8000HDI- S 
#define DVR_HD_SL                    23                //8000HDI- SL
#define DVR_HC_SL                    24                //8000HCI- SL
#define DVR_HS_ST                    25                //8000HSI- ST
#define DVS_HW                        26              //6000HW 
#define DS630X_D                    27                //DS630X_DI
#define DS640X_HD                    28                //DS640X_HDI
#define DS610X_D                    29              //610X Decoder
#define IPCAM                        30                //IP Camera
#define MEGA_IPCAM                    31                //Mega Pixels IP Camera
#define IPCAM_X62MF                    32                //862MF IP Camera
#define ITCCAM                      35              //ITC Camera
#define IVS_IPCAM                   36              //VCA ITC Camera
#define ZOOMCAM                     38              //ZOOM Camera
#define IPDOME                      40                 //IP Speed Dome
#define IPDOME_MEGA200              41                 //Mega Pixels IP Dome (2 million) 
#define IPDOME_MEGA130              42                 //Mega Pixels IP Dome (1.3 million) 
#define IPDOME_AI                   43              //IP AI Dome
#define TII_IPCAM                   44              //Thermal infrared imaging IP camera
#define IPTC_DOME                   45              /*IPTC Dome*/
#define DS_2DP_Z                    46              /*Spherical eagle eye (large) */
#define DS_2DP                      47              /*The spherical eagle eye (small) */
#define ITS_WMS                      48              /*Weighing data management server*/
#define IPMOD                        50                //IP Model
#define TRAFFIC_YTDOME              51              //Intelligence Cloud Terrace
#define TRAFFIC_RDDOME              52              //Radar Intelligence Cloud Terrace
#define IDS6101_HF_A                61              //61ATM
#define IDS6002_HF_B                62              //Tracked by two camera:  iDS6002- HF/B
#define IDS6101_HF_B                63              //VCA:  iDS6101- HF/B
#define IDS52XX                        64              //Intelligent Analysis:  IVMS
#define IDS90XX                        65                //9000 with intelligent function
#define IDS8104_AHL_S_HX            66              //Face Recognition ATM
#define IDS8104_AHL_S_H             67              //Private Face Recognition ATM
#define IDS91XX                        68                //9100 with intelligent function
#define IIP_CAM_B                   69              //intelligent behavior analyze IP camera
#define IIP_CAM_F                   70              //intelligent face analyze IP camera
#define DS71XX_H                    71                //DS71XXHI_S 
#define DS72XX_H_S                    72                //DS72XXHI_S 
#define DS73XX_H_S                    73                //DS73XXHI_S 
#define DS72XX_HF_S                 74              //DS72XX_HF_S
#define DS73XX_HFI_S                75              //DS73XX_HFI_S
#define DS76XX_H_S                    76                //DVR, e.g. DS7604_HI_S 
#define DS76XX_N_S                    77                //NVR, e.g. DS7604_NI_S 
#define DS_TP3200_EC                   78              //DS_TP3200_EC
#define DS81XX_HS_S                    81                //DS81XX_HSI_S 
#define DS81XX_HL_S                    82                //DS81XX_HLI_S 
#define DS81XX_HC_S                    83                //DS81XX_HCI_S 
#define DS81XX_HD_S                    84                //DS81XX_HDI_S 
#define DS81XX_HE_S                    85                //DS81XX_HE_S 
#define DS81XX_HF_S                    86                //DS81XX_HFI_S 
#define DS81XX_AH_S                    87                //DS81XX_AHI_S 
#define DS81XX_AHF_S                88                //DS81XX_AHFI_S 
#define DS90XX_HF_S                    90              //DS90XX_HFI_S
#define DS91XX_HF_S                    91              //DS91XX_HFI_S
#define DS91XX_HD_S                    92              //91XXHDI- S (MD) 
#define IDS90XX_A                    93                //9000 intelligent ATM
#define IDS91XX_A                    94                //9100 intelligent ATM
#define DS95XX_N_S                    95              //DS95XX_NI_S NVR with no output interfaces
#define DS96XX_N_SH                    96              //DS96XX_NI_SH NVR
#define DS90XX_HF_SH                97              //DS90XX_HFI_SH    
#define DS91XX_HF_SH                98              //DS91XX_HFI_SH 
#define DS_B10_XY                   100             //Video integrated platform Device Type (X: Encoder Number, Y: Decoder Number) 
#define DS_6504HF_B10               101             //Video integrated platform Encoder
#define DS_6504D_B10                102             //Video integrated platform Decoder
#define DS_1832_B10                 103                //Video integrated platform code splitter
#define DS_6401HFH_B10              104             //Video integrated platform optical
#define DS_65XXHC                    105                //65XXHCI DVS
#define DS_65XXHC_S                    106                //65XXHCI- SATA DVS
#define DS_65XXHF                    107                //65XXHFI DVS
#define DS_65XXHF_S                    108                //65XXHFI- SATA DVS
#define DS_6500HF_B                 109             //DS- 6500 series rack mount DVS
#define IVMS_6200_C                 110             //IVMS- 6200 (/C)   
#define IVMS_6200_B                 111             //IVMS- 6200 (/B) 
#define DS_72XXHV_ST15                112                //72XXHVI_ST  Hi3515 DVR
#define DS_72XXHV_ST20                113                //72XXHVI_ST  Hi3520 DVR
#define IVMS_6200_T                    114             //IVMS- 6200 (/T) 
#define IVMS_6200_BP                115             //IVMS- 6200 (/BP) 
#define DS_81XXHC_ST                116                //DS_81XXHC_ST
#define DS_81XXHS_ST                117                //DS_81XXHS_ST
#define DS_81XXAH_ST                118                //DS_81XXAH_ST ATM
#define DS_81XXAHF_ST                119                //DS_81XXAHF_ST ATM
#define DS_66XXDVS                    120                //66XX DVS

#define DS_1964_B10                 121             /*DS-1964-B10*/
#define DS_B10N04_IN                122             /*DS-B10N04-IN*/
#define DS_B10N04_OUT                123             /*DS-B10N04-OUT */
#define DS_B10N04_INTEL             124             /*DS-B10N04-INTEL*/
#define DS_6408HFH_B10E_RM          125             //DS-6408HFH-B10E-RM
#define DS_B10N64F1_RTM             126             //DS-B10N64F1-RTM
#define DS_B10N64F1D_RTM            127             //DS-B10N64F1D-RTM
#define DS_B10_SDS                  128             //DS-B10-SDS
#define DS_B10_DS                   129             //DS-B10-DS
#define DS_6401HFH_B10V                130             //DS-6401HFH-B10V
#define DS_6504D_B10B               131             /*DS-6504D-B10B*/
#define DS_6504D_B10H               132             /*DS-6504D-B10H*/
#define DS_6504D_B10V               133             /*DS-6504D-B10V*/
#define DS_6408HFH_B10S                134             //DS-6408HFH-B10S 
#define DS_18XX_N                      135             /* DS-18XX-N*/ 
#define DS_6504HF_B10F_CLASS        136                //DS-6504HF-B10F-CLASS

#define DS_18XX_PTZ                    141                
#define DS_19AXX                    142                
#define DS_19BXX                    143                
#define DS_19CXX                    144                
#define DS_19DXX                    145                //DS_19DXX    
#define DS_19XX                     146             //DS_19XX
#define DS_19SXX                    147                //DS_19SXX
#define DS_1HXX                        148                //CS
#define DS_PEAXX                    149                //DS_PEAXX
#define DS_PWXX                        150
#define DS_PMXX                     151
#define DS_19DXX_S                  152
#define DS_PWAXX                    153                 /* Axiom Hub */
#define DS_PHAXX                    154                 /* Axiom Hybrid */
#define DS_PHAProXX                 155                 /* Axiom Hybrid Pro*/

//2011-11-30
#define    DS_C10H                        161                /*CVCS*/
#define DS_C10N_BI                    162                //DVCS BNC processor 
#define DS_C10N_DI                    163                //DVCS RGB processor
#define DS_C10N_SI                    164                //DVCS STREAM processor
#define DS_C10N_DO                    165                //DVCS DISP processor
#define DS_C10N_SERVER                166                //DVCS SERVER

#define IDS_8104_AHFL_S_H           171             //8104ATM 
#define IDS_65XX_HF_A               172             //65 ATM
#define IDS90XX_HFI_RH              173             //9000 intelligent RH
#define IDS91XX_HFI_RH              174             //9100 intelligent RH
#define IDS_65XX_HF_B               175             //65 behavior analyze
#define IDS_65XX_HF_P               176             //65 plate recognize
#define IVMS_6200_F                 177             //IVMS-6200(/F)
#define IVMS_6200_A                 178             //IVMS-6200(/A)
#define IVMS_6200_F_S                 179             // IVMS-6200(/F_S)

#define DS90XX_HF_RH                181             //9000 RH
#define DS91XX_HF_RH                182             //9100 RH
#define DS72XXHVI_S                 183             //DVR DS-7204HVI-ST/SE 
#define DS81XXHW_S                    185                //81 Resolution 960 
#define DS81XXHW_ST                    186             //DS81XXHW_ST
#define DS91XXHW_ST                    187             //DS91XXHW_ST
#define DS91XX_ST                    188             //DS91XX_ST
#define DS81XX_ST                    189             //DS81XX_ST
#define DS81XXHX_ST                    190             //DS81XXHDI_ST,DS81XXHE_ST ky2012
#define DS73XXHX_ST                    191             //DS73XXHI_ST ky2012
#define DS81XX_SH                   192             //Inquest81SH,81SHF
#define DS81XX_SN                   193             //Inquest81SNL

#define DS96XXN_ST                  194             //NVR:DS96xxN_ST
#define DS86XXN_ST                  195             //NVR:DS86xxN_ST
#define DS80XXHF_ST                 196             //DVR:DS80xxHF_ST
#define DS90XXHF_ST                 197             //DVR:DS90xxHF_ST
#define DS76XXN_ST                  198             //NVR:DS76xxN_ST

#define ENCODER_SERVER                200                // ENCODER_SERVER
#define DECODER_SERVER              201             // DECODER_SERVER
#define PCNVR_SERVER                202             // PCNVR_SERVER
#define CVR_SERVER                  203             // CVR
#define DS_91XXHFH_ST                204             // 91HD-SDI
#define DS_66XXHFH                    205             // 66 decoder
#define    TRAFFIC_TS_SERVER            210                //ITS server
#define    TRAFFIC_VAR                    211                //ITS VAR
#define IPCALL                      212             //IP call
#define SAN_SERVER                  213                //SAN

#define DS_B11_M_CLASS                 301             /*Video platform B11*/
#define DS_B12_M_CLASS                  302             /*Video platform B12*/
#define DS_6504HF_B11_CLASS         303             /*inter encoder of video platform*/
#define DS_6504HF_B12_CLASS         304              /*inter encoder of video platform*/
#define  DS_6401HFH_B11V_CLASS         305     //VGA HD encoder
#define  DS_6401HFH_B12V_CLASS         306     //VGA HD encoder
#define  DS_6408HFH_B11S_CLASS         307     //SDI encoder
#define  DS_6408HFH_B12S_CLASS      308     //SDI encoder
#define  DS_6504D_B11H_CLASS        309   /*inter HD decoder of video platform*/
#define  DS_6504D_B11B_CLASS        310    /*inter SD decoder of video platform*/
#define  DS_6504D_B12B_CLASS        311       /*inter SD decoder of video platform*/
#define  DS_6504D_B11V_CLASS        312      /*inter VGA decoder of video platform*/
#define  DS_6504D_B12V_CLASS        313     /*inter VGA decoder of video platform*/
//B10
#define  DS_6401HFH_B10R_CLASS         314     //B10 RGB HD encoder
#define  DS_6401HFH_B10D_CLASS         315     //B10 DVI HD encoder
#define  DS_6401HFH_B10H_CLASS         316     //B10 HDMI HD encoder
//B11
#define  DS_6401HFH_B11R_CLASS         317     //B11 RGB HD encoder
#define  DS_6401HFH_B11D_CLASS         318     //B11 DVI HD encoder
#define  DS_6401HFH_B11H_CLASS         319     //B11 HDMI HD encoder
//B12
#define  DS_6401HFH_B12R_CLASS         320     //B12 RGB HD encoder
#define  DS_6401HFH_B12D_CLASS         321     //B12 DVI HD encoder
#define  DS_6401HFH_B12H_CLASS         322     //B12 HDMI HD encoder
#define  DS_65XXD_B10Ex_CLASS        323     //netra HD decoder
//B10 V2.1
#define  DS_6516HW_B10_CLASS        324     //netra encoder of B10
#define  DS_6401HFH_B10F_RX_CLASS   326        //optical interface encoder(support 1/2 optical access)
#define  DS_6502HW_B10F_RX_CLASS    327        //960H optical interface encoder(support 1/4/8 optical access)
#define  DS_6504D_B11Ex_CLASS        328     //netra HD decoder
#define  DS_6504D_B12Ex_CLASS        329     //netra HD decoder
#define  DS_6512_B11_CLASS            330     //netra encoder
#define  DS_6512_B12_CLASS            331     //netra encoder
#define  DS_6504D_B10H_CLASS        332     //inter HD decoder of video platform
#define  DS_65XXT_B10_CLASS         333     //transcoder of video platform
#define  DS_65XXD_B10_CLASS         335     //65XXD decoder of video platform
#define  DS_IVMSE_B10X_CLASS        336     //X86 service
#define  DS_6532D_B10ES_CLASS        337     //enhance decode board_SDI(b10)
#define  DS_6508HFH_B10ES_CLASS        338     //SDI encoder
#define  DS_82NCG_CLASS                340     //DS_82NCG
#define  DS_82VAG_CLASS                341     //DS_82VAG 
#define  DS_1802XXF_B10_CLASS       342     //DS_1802XXF_B10
#define  iDS_6504_B10EVAC_CLASS     343     //intelligence sub system
#define  iDS_6504_B10EDEC_CLASS     344     //intelligence sub system
#define  DS_6402HFH_B10EV_CLASS     345     //netra encoder(VGA)
#define  DS_6402HFH_B10ED_CLASS     346     //netra encoder(DVI)
#define  DS_6402HFH_B10EH_CLASS     347     //netra encoder(HDMI)
#define  DS_6404HFH_B10T_RX_CLASS   348     //fiber access encoder
#define  DS_6504D_AIO_CLASS         349        //netra HD decoder
#define  DS_IVMST_B10_CLASS            350        //stream transform sub system
#define  DS_6402_AIO_CLASS          351     //netra encoder
#define  DS_iVMSE_AIO_CLASS         352     //x86 server sub system
#define  DS_AIO_M_CLASS             353     //Integrated machine


#define  DS_6508HF_B10E_CLASS        355        //BNC encoder
#define  DS_6404HFH_B10ES_CLASS        356        //SDI encoder
#define  DS_6402HFH_B10ER_CLASS        358        //RGB encoder
#define  DS_6404HFH_B10T_RM_CLASS    361        //fiber encoder
#define  DS_6516D_B10EB_CLASS        362        //BNC decoder
#define  DS_6516D_B10ES_CLASS        363        //SDI decoder

//DVI/HDMI/VGA free show decoder share one type
#define DS_6508D_B10FH_CLASS        364
#define DS_6508D_B10FD_CLASS        364
#define DS_6508D_B10FV_CLASS        364

#define  DS_6508_B11E_CLASS            365        //BNC encoder
#define  DS_6402_B11ES_CLASS        366        //SDI encoder
#define  DS_6402_B11EV_CLASS        367        //VGA encoder
#define  DS_6402_B11ER_CLASS        368        //RGB encoder
#define  DS_6402_B11ED_CLASS        369        //DVI encoder
#define  DS_6402_B11EH_CLASS        370        //HDMI encoder
#define  DS_6516D_B11EB_CLASS        371        //BNC decoder
#define  DS_6516D_B11ES_CLASS        372        //SDI decoder

#define  DS_6508_B12E_CLASS         373     //BNC encoder
#define     DS_6402_B12ES_CLASS        375        //SDI encoder
#define  DS_6402_B12EV_CLASS        376        //VGA encoder
#define  DS_6402_B12ER_CLASS        377        //RGB encoder
#define  DS_6402_B12ED_CLASS        378        //DVI encoder
#define  DS_6402_B12EH_CLASS        379        //HDMI encoder
#define  DS_6516D_B12EB_CLASS        380        //BNC decoder

#define  DS_iVMSE_AIO_8100x_CLASS   381     //iVMSE 8100X sub system
#define  DS_iVMSE_AIO_87x_CLASS     382     //iVMSE 87X sub system
#define  DS_6532D_B11ES_CLASS        384        //enhance decode board_SDI(b11)
#define  DS_6532D_B12ES_CLASS        385        //enhance decode board_SDI(b12)
#define  DS_B20_MSU_NP              400     //DS_B20_MSU_NP
#define  DS_6416HFH_B20S            401     //6416HFH_B20S encoder
#define  DS_6416HFH_B20_RM          402     //6416HFH_B20_RM encoder
#define  DS_6564D_B20D              403     //6564D_B20D decoder
#define  DS_6564D_B20H              404     //6564D_B20H decoder
#define  DS_6564D_B20V              405        //6564D_B20V decoder
#define  DS_6408HFH_B20V            407     //6408HFH_B20V encoder
#define  DS_MMC_B20_CLASS           408     //DS_MMC_B20_
#define  DS_CARD_CHIP_B20_CLASS     409     //DS_CARD_CHIP_B20
#define  DS_6564D_B20B_DEV_CLASS    410     //BNC decoder
#define  DS_6564D_B20S_DEV_CLASS    411     //SDI decoder
#define  DS_6532HF_B20B_DEV_CLASS   412     //BNC encoder
#define  DS_6408HFH_B20D_DEV_CLASS  413     //DVI encoder
#define  DS_6408HFH_B20H_DEV_CLASS  414     //HDMI encoder
#define  DS_IVMSE_B20_CLASS            415     //x86 server sub system
#define  DS_6402HFH_B20Y_DEV_CLASS  416     //YUV encoder
#define  DS_6508HW_B20_DEV_CLASS    417     //HW encoder
#define  DS_B20N128Fx_B20_DEV_CLASS 418     //cascade sub system
#define  DS_AIO_MCU_NP_DEV_CLASS    419     //AIO main board
#define  DS_6402_AIO_EV_DEV_CLASS   420     //VGA coder
#define  DS_6508D_AIO_EV_DEV_CLASS  421     //VGA decoder
#define  DS_6508D_AIO_ED_DEV_CLASS  422     //DVI decoder
#define  DS_6508D_AIO_EH_DEV_CLASS  423     //HDMI decoder
#define  DS_6508HD_B20F_DEV_CLASS    424     //enhanced decoder
#define  DS_6402HFH_B20ES_DEV_CLASS 425     //3G SID coder
#define  DS_6532D_B20_DEV_CLASS     426     //B20 decoder            
#define  DS_IVMST_B20_DEV_CLASS     427     //X86 service sub system
#define  DS_6416HFH_B20DD_DEV_CLASS 428     //Dual link DVI coder
#define  DS_6441VS_B20_DEV_CLASS    429        //signal joint sub system
#define  DS_6404HFH_B20T_CLASS         431        //TVI coder
#define  DS_FS22_B20_DEV_CLASS         432        //fiber switcher sub system
#define  DS_IVMSE_B20UH_DEV_CLASS   433     //Ultra HD input sub system
#define  IDS_6524J_B20_DEV_CLASS    434
#define  IDS_6532B_B20_DEV_CLASS    435
#define  DS_6404HFH_B20Fx_DEV_CLASS 436        //node optical device input coder
#define  DS_N128x_B20Fy_CLASS        437     //cascade sub system
#define  DS_181600F_B20_CLASS        438     //net fiber sub system
#define  DS_6904UD_B20H_CLASS       439     //Ultra HD decoder
#define  DS_B21_MCU_NP_CLASS        440     //DS_B21_MCU_NP_CLASS
#define  DS_C10S                    501     //C10S Video Wall Controller
#define  DS_C3X                     502     //Centralized splicing controller
#define  DS_C10N_SDI                551        //SDI processor
#define  DS_C10N_BIW                552        //8 channels BNC processor
#define  DS_C10N_DON                553        //display processor
#define  DS_C10N_TVI                554     //TVI processor
#define  DS_C10N_DI2                555     //2 channels DVI processor 
#define  DS_C10N_AUDIO_OUT          556     //DVI,HDMI,VGA display processor with audio output
#define  DS_C10N_AUDIO_IN           557     //DVI,HDMI,VGA processor with audio input

//Soft server version of the distributed screen controller
#define  DS_C20N                    570     //C20N server
#define  DS_C20N_BNC                571     //C20N BNC input device
#define  DS_C20N_DVI                572     //C20N DVI input device 
#define  DS_C20N_DP                 573     //C20N DP input device
#define  DS_C20N_OUT                574     //output device

//Centralized splicing controller
#define DS_C30                      5301    //C30 centralized splicing controller
#define DS_C31                      5302    //C31 centralized splicing controller
#define DS_M0804                    5303    //M0804 economical splicing controller

//Hard server version of the distributed screen controller 
#define DS_C20N_VWMS                5351    //Server
#define DS_C20N_DI2                 5352    //Two channels DVI input device
#define DS_C20N_DO2                 5353    //Two channels DVI output device
#define DS_C20N_UHDI                5354    //DP/HDMI one channel 4K high-definition input device
#define DS_C20N_YI2                 5355    //double channels YPbPr input device

#define DS_C12N_VWMS                5356
#define DS_C12N_DO                  5357
#define DS_C12N_HOE                 5358

#define DS_C20N_HI2             5359 // HDMI-input node(2 line)
#define DS_C20N_VI2             5360 //VGA-input node(2 line)
#define DS_C20N_SI2             5361 //SDI-input node(2 line)
#define DS_C20N_HO2             5362 //HDMI-output node(2 line)
#define DS_C20N_S24G            5363 //C20N-KMB-switch(24 line)
#define DS_C20N_S24X            5364 //C20N-GB-switch(24 line)
#define DS_C12A_0104H           5365 
#define DS_C20N_DO2_V2          5366 //Two channels DVI output device V2
#define DS_C20N_HO2_V2          5367 //Two channels HDMI output device V2
#define DS_C21N                 5368 //C21N controller
#define DS_C21K                 5369 //KVM system C21
#define DS_68TS_A               5370 //Touch  integrated machine

//Holographic display device
#define DS_D1HXX                    5591    //holographic display device
#define DS_60SDL_X                  5592    //Windows double side terminal
#define DS_6043DL_B                 5593    //android double side 43 terminal
#define DS_6049DL_B                 5594    //android double side 49 terminal
#define DS_6055DL_B                 5595    //android double side 55 terminal

#define ELEVATO_BRIDGE  5751  //wireless elevator bridge
#define DS_3WF01S_5NG_M  5752  //5.8G wireless construction site bridge(1 kilometer outside)
#define DS_3WF0EC_2N_D  5753  //2.4G wireless construction site bridge(half kilometer outside)
#define DS_3WF0EC_5ACT  5754  //5.8G 11ac wireless elevator bridge
#define DS_3WF03S_5AC    5755   //5.8G 3 kilometer wireless elevator bridge
#define DS_3WF0ES_5AC_H  5756    //5.8G outdoor 500m high penetration bridge
#define DS_3WF05S_5AC_H  5765    //5.8G 5KM Gigabit Ethernet port dialing bridge
#define DS_3WSXXX      5766     //gateway router series (including AC controller)
#define DS_3WAXXX      5767     //ceiling, outdoor AP series
#define DS_3WAXXXP     5768     //panel AP series
#define DS_3WRXXX      5769     //common wireless router series
#define DS_3WMRXXX     5770     //MESH router series
#define DS_3WAX18      5881     //outdoor AP

//net management
#define DS_3CXXXX        5891    //net management platform

#define DS_19M00_MN                    601        //network module
#define DS_KDXXX                       608    //interactive

#define DS64XXHD_T                    701        //64-T Decoder

#define DS_65XXD                    703     //65 Decoder
#define DS63XXD_T                    704        //63-T Decoder
#define DS_64XXHD_S                 706     //64XXHD-S Decoder
#define DS_68XXT                    707        //multi transcoder
#define DS_65XXD_T                  708     //65D-T Decoder
#define DS_65XXHD_T                 709     //65HD-T Decoder
#define DS_69XXUD                   710     //69XXUD Decoder
#define DS_65XXUD                   711     //65XXUD Decoder
#define DS_65XXUD_L                 712     //65XXUD_L Decoder
#define DS_65XXUD_T                 713     //65XXUD_T Decoder


#define DS_D20XX                    750     //LCD Screen
//SDI matrix
#define DS_C50S                     751     //SDI Matrix
#define DS_D50XX                    752     //LCD Screen
#define DS_D40                      760     //LED screen controller

#define DS_65VMXX                   770     //conference system server
#define DS_65VTXX                   771     //conference system terminal
#define DS_65VTA                    772     //conference system Integrated terminal
#define DS_65VT_RX                  773     //Interactive teaching terminal
#define DS_65VM_MCU_NP              774     //multiple MCU


#define DS_CS_SERVER                800     //Virtual screen server
#define DS_68GAP_MCU                831     //video gap
#define DS_K260X                    850     //Access control system
#define DS_K1TXXX                   851     //
#define DS_K280X                    852     //
#define DS_K1T80X                   854     //
#define RAC_6X00                    856     //
#define DS_K2602_AX                 857     //
#define DS_K1T803F                  858     //
#define DS_K2700                    859     //
#define DS_K270X                    860     //
#define DS_K1T500S                  861     //
#define DS_K1A801F                  862     //
#define DS_K1T600X                  863     //
#define DS_K22X                     864     //
#define DS_K2M0016AX                865     //
#define DS_K2602S_AX                867     //
#define DS_K560XX                   870     //Vertical/Desktop identification intelligent terminal
#define DS_K260X_E                  873     //
#define DS_K5603X                   874     //Embedded Vertical identification intelligent terminal
#define DS_K3M200X                  875     //
#define DS_K3M100X                  879     //
#define DS_K1T8101XT                881     //
#define DS_K1T8101XX                882     //
#define DS_K5604                    883      //5604
#define DS_K1T607XXXX               884     //DS_K1T607(M/MF/E/EF/MG/MFG/MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW)
#define DS_K1A850X                  885     //
#define DS_K1T800X                  886     //
#define DS_K1T610XXXX               887     //DS_K1T610(M/MF/E/EF/MG/MFG/MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW)
#define DS_K1T8115X                 888     //DS-K1T8115,DS-K1T8115M,DS-K1T8115M-Z
#define DS_K1T815LC_M               889     //
#define DS_K1T606M_Z                890     //
#define DS_K5607_XXX                891     //K5607
#define DS_K1T950MX                 893
#define DS_K1T331XX                 894
#define DS_K1T671T                  895     
#define DS_K1T671                   896     
#define DS_K5671                    897     
#define DS_K1T640                   898     
#define DS_K1A802A                  899

#define DS_6800M                    900     //68M merger
#define DS_68NTH                    901     //information publish device
#define DS_D60S                     902     //information publish server
#define DS_D60W                     903     //information publish windows terminal
#define    DS_D10                        931        //Rear-projection device
#define DS_3K0X_NM                    951        //Fiber Converter
#define DS_3E2328                    952     //100M Switches
#define DS_3E1528                    953     //1000M Switches
#define SCREEN_LINK_SERVER          971     //Screen link server
#define DS_D51OPSXX                 972     //OPS computer box
#define IP_PTSYS_MEGA200            1001    //IP_PTSYS_MEGA200
#define IPCAM_FISHEYE               1002    //Fisheye IP Camera
#define IPCAM_FISHEYE_E             1003    //Economic Fisheye IP Camera
#define IPCAM_365                    1010    //IPC CAM support 365 platform
#define IPCAM_R0                    1011    //IPC CAM support A5S platform
#define IPCAM_R1                    1012    //IPC CAM support 385 platform
#define IPCAM_R2                    1013    //IPC CAM support R2 platform
#define IPCAM_R3                    1014    //IPC CAM support 8127 platform
#define IPCAM_R4                    1015    //IPC CAM support S2 platform

#define IPDOME_365                    1110    //IPD CAM support 365 platform
#define IPDOME_R0                    1111    //IPD CAM support A5S platform
#define IPDOME_R1                    1112    //IPD CAM support 385 platform
#define IPDOME_R2                    1113    //IPD CAM support R2 platform
#define IPDOME_R3                    1114    //IPD CAM support 8127 platform
#define IPDOME_R4                    1115    //IPD CAM support S2 platform
#define ITCCAM_R3                    1211    //ITCCAM support 8127 platform

#define UAV_S                       1300    //Ummanned Aerial Vehicle - Station

//Add Device Type 2013-11-19
#define  TRAFFIC_ECT                1400  //ECT Device Type
#define  TRAFFIC_PARKING_SERVER     1401  //Parking Server
#define  TRAFFIC_TME                1402  //Entrance control machine
// DVR
#define DS90XXHW_ST                    2001    // DS90XXHW_ST
#define DS72XXHX_SH                 2002    // DS-72xxHV_SH, DS-72xxHF-SH 
#define DS_92XX_HF_ST                2003    // DS-92XX-HF-ST 
#define DS_91XX_HF_XT                2004    // NETRET_9100DVR_HF_XT
#define DS_90XX_HF_XT               2005    // NETRET_9000DVR_HF_XT 
#define DS_73XXHX_SH                2006    // NETRET_7300DVR_HX_SH  
#define DS_72XXHFH_ST                2007    // NETRET_7200DVR_HFH_ST

//DS_67XX

#define DS_67XXHF_SATA              2008    // DS-67XXHF-SATA
#define DS_67XXHW                   2009    // DS-67XXHW 
#define DS_67XXHW_SATA              2010    // DS-67XXHW-SATA
#define DS_67XXHF                   2011    // DS-67XXHF

//Netra2.3
#define DS_72XXHF_SV                 2012   // DS-72xxHF-SV 
#define DS_72XXHW_SV                 2013   // DS-72xxHW-SV

#define DS_81XXHX_SH                2014   // NETRET_8100DVR_HX_SH

#define DS_71XXHX_SL                2015    // KY2013 DVR

#define DS_76XXH_ST                    2016    // Netra DS_76XXH_ST


#define DS_73XXHFH_ST               2017   //NETRET_7300HFH_ST
#define DS_81XXHFH_ST               2018   //NETRET_8100HFH_ST

#define DS_72XXHFH_SL                2019    //hi3521 
#define DS_FDXXCGA_FLT                2020    //2 HD ATM

#define IDS_91XX_HF_ST_A            2100    //iDS-9100HF-ST/A
#define IDS_91XX_HF_ST_B            2101    //iDS-9100HF-ST/B
#define IDS_90XX_HF_ST_A            2102    //iDS-9000HF-ST/A
#define IDS_90XX_HF_ST_B            2103    //iDS-9000HF-ST/B
#define IDS_81XX_HF_ST_A            2104    //iDS-8100HF-ST/A
#define IDS_81XX_HF_ST_B            2105    //iDS-8100HF-ST/B
#define IDS_80XX_HF_ST_A            2106    //iDS-8000HF-ST/A
#define IDS_80XX_HF_ST_B            2107    //iDS-8000HF-ST/B
#define IDS_8104_AHFL_ST            2108    //iDS-8104-AHFL-ST
#define IDS_2CD6812F_C              2109    //iDS_2CD6812F_C


// NVR
#define DS_77XXN_ST                    2201            // Netra NVR DS-77XXHF-ST
#define DS_95XX_N_ST                2202            // Netra 95XXN_ST NVR          
#define DS_85XX_N_ST                2203            // Netra 85XXN_ST NVR
#define DS_96XX_N_XT                2204            // NETRET_9600NVR_N_XT
#define DS_76XX_N_SE                2205            // NETRET_7600NVR_N_SE

//Inquest DVR
#define DS_86XXSN_SX                2206    // NETRET_8608NVR_SX,Include DS-8608SNL-SP,DS-8608SNL-ST,DS-8608SN-SP,DS-8608SN-ST

//#define DS_96XX_N_RX                2207  //Netra DS-96XX-N-RX
#define DS_71XXN_SL                    2208  //8107 DS-71XXN-SL for civil use
#define CS_N1_1XX                    2209  //8107 CS_N1_1XX,civil

#define DS_71XXN_SN                    2210    //NETRET_71XX_N_SN  
#define CS_N1_2XX                    2211    //NETRET_N1_2XX   
#define DS_76XX_N_SHT                2212    //NETRET_76XX_N_SHT  

#define DS_96XXX_N_E                2213    //NVR 

#define    DS_76XXN_EX                    2214 /* HISI3535  76 78 Series NVR, Note: Includes 4,8,16 road E1 / N / P devic;  8,16, 32 road, / N / P device */
#define DS_77XXN_E4                    2215/* HISI3535  77 Series NVR,  Note: Includes 8,16, 32 road, / N / P device*/
#define DS_86XXN_E8                    2216/* HISI3535  86Series NVR, Includes 8,16 32 road, / N / P device*/
#define DS_9616N_H8                 2217   //DS_9616N_H8
#define DS_72XXHX_EX_GXY            2218   //72 series wireless DVR/NVR 
#define DS_76XXN_EX_GXY             2219   //76 series wireless NVR
#define DS_72XXHXH_SH_21            2220   //  72XXHXH_SH_21
#define DS_72XXHXH_SH_31            2221  //  72XXHXH_SH_31
#define DS_73XXHXH_SH_31            2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31            2223  //  81XXHXH_SH_31
#define DS_71XXHXH_SH_21            2224  // 71XXHXH_SH_21
#define DS_71XXHXH_SH_31            2225  // 71XXHXH_SH_31
#define DS_NBXX_N_E1_X              2226  //NBXX_N_E1_X
#define DS_96XXN_FX                 2230
#define DS_86XXN_FX                 2231
#define DS_96XXXN_HX                2232  

#define DS_86XXN_I                    2233    //DS_86XXN_I
#define DS_77XX_N_I                    2234    //DS_77XX_N_I
#define DS_76XX_N_I                    2235    //DS_76XX_N_I
#define DS_78XX_N_I                    2236    //DS_78XX_N_I
#define DS_96XXXN_IX                 2237    //DS-96XXX_N_I(DS-96128N-I16,DS-96128N-I24,DS-96256N-I16,DS-96256N-I24)

#define DS_90XXHXH_XT               2238    //DS_90XXHXH_XT(DS-9016HQH-XT)

#define DS_NVR_ALL                2239    //NVR device unified type code, and DS NVR all is used for all subsequent NVR products (including defined Series)
#define DS_DVR_ALL                2240    //DVR equipment unified type code is used by all subsequent DVR products (including defined Series)

//PCNVR
#define PCNVR_IVMS_4200             2301    //PCNVR_IVMS_4200

#define IVMS_6200_TP                2401    //iVMS-6200/TP
#define IVMS_6200_TF                2402    //iVMS-6200/TF
#define IVMS_6200_D                 2403   //iVMS-6200(/D)
#define IDS_81XXAHW_ST              2405   //iDS-81xxAHW-ST
#define IDS_81XXAHW_SP              2406   //iDS-81xxAHW-SP
#define IDS_81XXAHWL_ST             2407   //iDS-81xxAHWL-ST 
#define IDS_81XXAHWL_SP             2408   //iDS-81xxAHWL-SP
#define IDS_9616N_H8                2409   //iDS_9616N_H8
#define IVMS_6200_SMD               2500   //IVMS_6200_SMD

//HISI3531 ATM DVR
#define DS_81XXAHW_ST                2501
#define DS_81XXAHW_SP                2502
#define DS_81XXAHWL_ST                2503
#define DS_81XXAHWL_SP                2504

//TVI ATM
#define DS_81XXAHGH_E4                2601    //DS_81XXAHGH_E4

#define DS_6904UD_AIOE_H_CLASS      4002    //Integrated machine
#define DS_6402HFH_B21B_CLASS       4005    //B21 BNC coder
#define DS_6902UD_B21H_CLASS        4006    //B21 HDMI decoder
#define DS_6902UD_B21D_CLASS        4007    //B21 DVI decoder
#define DS_6902UD_B21V_CLASS        4008    //B21 VGA decoder
#define DS_6904UD_B20D_CLASS        4010    //B20 DVI decoder
#define DS_6904UD_B20V_CLASS        4011    //B20 VGA decoder

//B21 all-in-one device
#define DS_AIOH_MCU_NP              4042    //main control board
#define DS_6404HFH_AIOH_D           4043    //4 channels DVI input board
#define DS_6908UD_AIOH_D            4044    //4 channels DVI output board
#define DS_6908UD_AIOH_H            4045    //4 channels HDMI output board

//decode all-in-one device
#define DS_69XXUD_B                 4046    //main control board
#define DS_6404HFH_I                4047    //4 channels DVI input board
#define DS_6904UD_O                 4048    //8 channels HDMI output board


//Centralized trainer
#define DS_C12L_0204H               4060   //economical small size controller

//Decoder 5001-5050
#define DS_69XXHD                   5001    //69XXHD Decoder
#define DS_69UD_V2                  5002    //69UD Decoder V2
#define DS_69UD_T                   5003    //6UD Decoder T

//TRANSCODE    5401 - 5450  50
#define DS_68VTG          5401 //integrated transcoding gateway

//vedio Conference device  5571 - 5590 (20)
#define DS_65VT0010                 5571    //unit type terminal
#define DS_65VM_MCU                 5572    //High density MCU main bord
#define DS_65VM_MPC                 5573    //High density MCU resoure bord
#define DS_65VT2XXYR_SF             5574    //Judicial interrogate terminal
#define DS_65VT0XXY                 5575    //Video conference big terminal
#define DS_65VT0010Z                5576    //smart unit type terminal
#define DS_65VT0050Z                5577    //smart video conference big terminal
#define DS_65VS0XXXS                5878    //opensips sip server
#define DS_65VS0XXXM                5579    //video conference control platform
#define DS_65VM00XX_X               5580    //MCU for x86 system
#define DS_65VA800_BOX              5581    //Video conference Box
#define DS_65VT0020S                5582    //Integrated monocular intelligent conference terminal
#define DS_65VT0020D                5583    //Integrated binocular intelligent conference terminal
#define DS_65VM00XX_G               5584    //Video conference MCU server
#define DS_65VM0000_GPU             5585    //Video conference media processing card
#define DS_65VTA011                 5586    //High integrated monocular terminal
#define DS_65VCP1100M_S             5587    //4K monocular tracking camera(intelligent conference terminal)
#define Z_MINISMC_01                5588    //4K USB camera

//Y10 series
//video cloud magic cube
#define DS_Y10_MCU                  5771    //main board
#define DS_Y10_SW1                  5772    //switch board
#define DS_6516UD_Y10D              5773    //8 channels DVI video output board 
#define DS_6532UD_Y10D              5774    //16 channels DVI video output board
#define DS_6E2724_Y10               5775    //encode access board of 24 10G ports
#define DS_68SAA_AA_Y10             5776    //double channels 2620, 32G memory service board
#define DS_68SBA_AA_Y10             5777    //double channels 2630, 32G memory service board
#define DS_68SCA_AA_Y10             5778    //double channels 2650, 32G memory service board
#define DS_68GPU_A1_Y10             5779    //P4 display board


#define DS_B80_MCU                 5821//main bord
#define DS_B80_SW                  5822//switch bord
#define DS_B80_SR_01               5823//service board
#define DS_B80_AI04                5824//smart analyze board
#define DS_B80_ST                  5825//store board
#define DS_B80_D04                 5826//data collection service board
#define DS_B80_BNC08               5827//SD encoding board
#define DS_B80_SDI08               5828//HD encoding board
#define DS_B80_VP                  5829//Transcoding board/Plywood board
#define DS_B80_VO02                5830//Video output board
#define DS_B81_MCU                 5831//B81 main bord
#define DS_B81_AI                  5832//B81 smart analyze board
#define DS_B81_TVI                 5833//B81 Analog video input moduleTVI/BNC
#define DS_B81_APL                 5834//B81service module X86
#define DS_B81_D08T                5835//B81 data collection service board
#define DS_B85                     5836//B85 small IoT host
#define DS_B86                     5837//B86 IoT central control host
#define AX_GW100_V16A00M           5838//B81 host(non isolated), OEM device
#define DS_B81_AT_M                5839//B81 host(non isolated)

//Gateway
#define DS_3LGCX                   5841 //general IOT gateway
#define DS_3LGRX                   5842//LoRa gateway
#define DS_3LGT4                   5843    //elevator gateway
#define DS_3LGT40_N 			   5844    //NB-IoT elevator gateway
#define DS_3LGS_I                  5845    //intelligent gateway


#define IDS_90XX_HXH_XX_S            6001    //iDS-9016HUHI-K8/S
#define IDS_90XX_HXH_XX_FA           6002    //iDS-9016HUHI-K8/FA

#define DS_81XX_SHXL_K4               6101    //DS-8104SHFH(L)-K4/4P

#define DS_8116THFHL_F4               6201    //DS-8116THFHL-F4

#define DS_81XXAHQ_E4                 6301    //DS_81XXAHQ_E4(TVI ATM)
#define IDS_81XXAHQ_E4                6302    //IDS_81XXAHQ_E4(Smart TVI ATM)

#define IDS_86XX_NX_A               7501    //IDS_86XX_NX_A(iDS-8632NX-I8/A)
#define IDS_96XX_NX_S               7502    //IDS_96XX_NX_S 
#define IDS_96XX_NX_V               7503    //iDS-9632NX-I8/V
#define IDS_96XX_NX_FA              7504    //iDS-9632NX-I8/FA
#define IDS_86XX_NX_IX_B            7505    //iDS-8632NX-I8/B
#define IDS_67XX_NX_S_X             7506    //IDS_67XX_NX/S_X
#define NP_ST204_X_                  7507   //

#define IDS_ECDXX_HE                8001//iDS-ECD8092-H/BNSE
#define IDS_ECDXX_HT                8002//iDS-ECD8092-H/T

#define IDS_ECDXX_E                 8101//iDS-ECD8012-H/E

#define IDS_EPTXX_HF                8201//iDS-EPT8142-H/F

#define DS_2CD69XXX_I               8351    //DS_2CD69XXX_I
#define DS_TRIXX                    8471    //DS_TRI900

#define DS_K1F600_D6EXX                  10501   //DS_K1F60C/CF/IF
#define DS_K1T341                   10502   //DS-K1T341
#define DS_K1T641XXX                10503   //DS_K1T641XXX
#define DS_K1T642XXX                10504   //DS_K1T642XXX
#define DS_K1T601                   10505   //DS_K1T601
#define DS_K1T672XXX                10506   //DS_K1T672XXX
#define DS_K56A0X                   10507   //DS_K56A0X
#define DS_K56Q_F70                 10508   //DS_K56Q_F70
#define DS_K1T6Q_F70M               10509   //DS_K1T6Q_F70M
#define DS_K1T6Q_F40X               10510   //DS_K1T6Q_F40X
#define DS_K5604A_XXX               10511   //DS_K5604A_XXX
#define DS_K1A330X                  10512   //DS_K1A330X
#define DS_K1T804A                  10513
#define DS_K1T202                   10514
#define DS_K1T343MX                 10515   //DS-K1T343M DS-K1T343MW
#define DS_K1T331W_D                10516   //DS-K1T331W(D)
#define DS_K1T671WX_D               10517   //DS-K1T671M(D) DS-K1T671MW(D) DS-K1T671MG(D)
#define DS_K1T680X                  10518   //DS-K1T680M DS-K1T680D
#define DS_K1T640A                  10519   //DS-K1T640AM DS-K1T640AMW
#define DS_K1F600U_D6E_X            10520   //DS-K1F600U-D6E DS-K1F600U-D6E-F DS-K1F600U-D6E-IF
#define DS_K1T671AMX                10521   //DS-K1T671AM DS-K1T671AMW DS-K1T671AM-5G
#define DS_VISITORXX                10530
#define DS_FACE_PAYMENT_TERMINALXX  10531
#define DS_K1T341B_T                10532   //DS-K1T341BMWI-T  DS-K1T341BMI-T
#define DS_K1T343                   10533   //DS-K1T343M/MX/MW/MWX/MF/MFX/MFW/MFWX/EX/EWX/EFX/EFWX,D10,D10W/F/FW
#define DS_K1T673                   10534   //DS_K1T673M/MG/MW/TMW/TMG/DX/DWX/TDX/TDWX/TDGX
#define DS_K1T981                   10535   //
#define DS_K5680X                   10536   //DS_K5680X
#define DS_K5022A_X                 10537   //DS_K5022A_X
#define DS_K1T342                   10538   //DS-K1T342M/MX/MW/MWX/MF/MFX/MFW/MFWX/EX/EWX/EFWX/DX/DWX,D11,D11S/Pro/Plus
#define DS_K1T690                   10539   //DS_K1T690
#define DS_K1T340                   10540   //DS_K1T340
#define DS_K1T6QT_F72               10541   //F72
#define DS_K1T641A                  10542   
#define DS_K1TACS                   10543   //ACS

#define DS_KBS6XXX_WX               11001   //DS-KBS6100-WV/DS-KBS6101-W/DS-KBS6100-W/DS-KBS6101-W/DS-KBS6200-W/DS-KBS6201-W
#define DS_KBC6XXX_X                11002   //DS-KBC6300/DS-KBC6600
#define DS_KBI6000_P                11003   //DS-KBI6000-P
#define DS_KBA6XXX                  11004   //DS-KBA6120/DS-KBA6240/DS-KBA6360/DS-KBA6650/DS-KBA6400-2/DS-KBA6800-2

#define DS_IEXX_E_J                 11501    //DS_IEXX_E_J(DS-IE6316-E/J)

#define IDS_67XX_NX_A               12501    //IDS_67XX_NX_A(iDS-6704NX/A)
#define IDS_67XX_NX_L               12502    //IDS_67XX_NX_L(iDS-6760NX/L)
#define IDS_ENIXX_XHE               12503    //IDS_ENIXX_XHE(iDS-ENI6001-H/E)
#define IDS_67XX_NX_V               12504    //iDS-6716NX/V
#define IDS_67XX_NX_B               12505    //iDS-6708NX/B

#define DS_IE63XX_E_FA              13001 
#define DS_DS_GPKIA                 13002 
#define DS_DS_PURE                  13003 
#define DS_DS_FS                    13004
#define DS_DS_FD                    13005
#define DS_DS_BLADE                 13006
#define DS_DS_HMCP                  13007
#define DS_LNX_RF                   13501
#define DS_PA_RADAR                 13551
#define DS_PERIMETER_RADAR          13552
#define DS_SECURITY_RADAR           13553
#define DS_N1104X                   14001
#define DS_N1103X                   14002
#define NP_FSC201                   14003
#define NP_FDC240                   14004
#define DS_N1107                    14005
#define NP_FAXXX                    14006
#define NP_FVY100                   14007
#define NP_FVW100                   14008
#define NP_FVG100                   14009
#define NP_FVY300                   14010
#define NP_FVR212_P                 14011

// security check 14501-15000
#define NP_ST204_X                  14501
#define ISD_SG2XXL_X                14502 //(ISD-SG206L ISD-SG218L ISD-SG218L-F)

//switch
#define DS_3E11XX     5681    //100M switch
#define DS_3E13XX     5682    //1000M up-link switch
#define DS_3E15XX     5683    //1000M switch
#define DS_3E11XXP     5684    //100M POE switch
#define DS_3E13XXP     5685    //1000M up-link POE switch
#define DS_3E15XXP     5686    //1000M switch
#define DS_3E1520U     5687    //USB charging tank
#define DS_3EODM_H     5688     //huasan switch
#define DS_3EODM_W     5689     //hengmao switch
#define DS_3T1XXX      5690     //DS-3T1XXX series switches

//fiber
#define DS_3D01R_NM     5691    //fiber send card
#define DS_3D01T_NM     5692    //fiber receive card
#define DS_3K02_RNM     5693    //fiber manage card

//simulate and audio 15001-15500
#define IPA                         15001
/**********************Device model end***********************/

/**********************Device Class begin**********************/

/* dvr 1-50 */
#define DEV_CLASS_DVR      1          //dvr 
#define DEV_CLASS_INTERROGATION  2    //Interrogation
#define DEV_CLASS_SIMPLE_TRAIL  3    //simple trail
#define DEV_CLASS_TRAIL  4           //trail
#define DEV_CLASS_RECORD_PLAY  5     //record play
#define DEV_CLASS_ATM 6           //ATM

/* dvs 51-100 */
#define DEV_CLASS_DVS 51          //dvs

/* nvr 101-150 */
#define DEV_CLASS_NVR 101          //nvr

/* ipc 151-200 */
#define DEV_CLASS_GUN 151          //ipc gun
#define DEV_CLASS_BALL 152          //ipc ball
#define DEV_CLASS_SNAP 153          //snap
#define DEV_CLASS_INTELLI_TILT 154   //intrllt tilt
#define DEV_CLASS_FISH_EYE 155          //fish eye
#define DEV_CLASS_2DP_Z 156         //2DP_Z
#define DEV_CLASS_2DP 157   //2DP
#define DEV_CLASS_PT 158   //PT
#define DEV_CLASS_TRI 159   //TRI

/* CVR 201 - 250*/
#define DEV_CLASS_CVR 201          //CVR

/* Transfer & Display 251 - 300*/
#define DEV_CLASS_B20 251          //B20
#define DEV_CLASS_B10 252          //B10
#define DEV_CLASS_DECODER 253      //DECODER
#define DEV_CLASS_MATRIXMANAGEDEVICE 254      //MATRIXMANAGEDEVICE
#define DEV_CLASS_OTICAL 255      //OTICA
#define DEV_CLASS_CODESPITTER 256      //CODESPITTER
#define DEV_CLASS_ALARMHOST 257      //ALARMHOST
#define DEV_CLASS_MOVING_RING 258      //MOVING_RING
#define DEV_CLASS_CVCS 259      //CVCS
#define DEV_CLASS_DVCS 260      //DVCS
#define DEV_CLASS_TRANSCODER 261      //TRANSCODER
#define DEV_CLASS_LCD_SCREEN 262      //LCD SCREEN
#define DEV_CLASS_LED_SCREEN 263      //LED SCREEN
#define DEV_CLASS_MATRIX 264      //MATRIX
#define DEV_CLASS_CONFERENCE_SYSTEM 265      //CONFERENCE_SYSTEM
#define DEV_CLASS_INFORMATION_RELEASE_EQUIPMENT  266      // Information release equipment 
#define DEV_CLASS_NET_GAP 267      //net gap
#define DEV_CLASS_MERGE 268      //merge
#define DEV_CLASS_REAR_PROJECTION 269      //rear projection
#define DEV_CLASS_SWITCH 270      //switch
#define DEV_CLASS_FIBER_CONVERTER 271      //fiber converter
#define DEV_CLASS_SCREEN_SERVER 272      //screen server
#define DEV_CLASS_SCE_SERVER 273      //SCE server
#define DEV_CLASS_WIRELESS_TRANS  274    //wireless transmission equipment
#define DEV_CLASS_Y10_SERIES      275    //Y10 series
#define DEV_CLASS_SAFETY_MAVHINE  276    //safety mavhine
#define DEV_CLASS_IOTGATEWAY 277    //IOT gateway
#define DEV_CLASS_NET_MANAGEMENT_EQUIPMENT  278     //net management equipment
#define DEV_CLASS_PUBLISH_SIGNAGE  279   //publish signage
/* ALARM 301 - 350*/
#define DEV_CLASS_VIDEO_ALARM_HOST 301          //video alarm host
#define DEV_CLASS_NET_ALARM_HOST 302          //net alarm host
#define DEV_CLASS_ONE_KEY_ALARM 303      //one key alarm
#define DEV_CLASS_WIRELESS_ALARM_HOST 304      //wireless alarm host
#define DEV_CLASS_ALARM_MODULE 305      //Alarm MOdule
#define DEV_CLASS_HOME_ALARM_HOST 306      //home alarm host
#define DEV_CLASS_HYBRID_ALARM_HOST 307      //hybrid alarm host

/* access control 351 - 400*/
#define DEV_CLASS_ACCESS_CONTROL 351          //access control
#define DEV_CLASS_VISITOR        352          //visitor
#define DEV_CLASS_FACE_PAYMENT_TERMINALXX     353  //face payment terminal
/* video intercom 401 - 450*/
#define DEV_CLASS_VIDEO_INTERCOM 401          //video intercom

/* UNNanned aerial vehicle 451 - 500*/
#define DEV_CLASS_UMMANNED_AERIAL_VEHICLE 451          //UNNanned aerial vehicle

/* mobile: 501-550*/
#define DEV_CLASS_MOBILE 501          //mobile

/* mobile vehicle: 551-600*/
#define DEV_CLASS_MOBILE_VEHICLE 551          //mobile vehicle

//Intelligent analyzer :601-650
#define DEV_CLASS_INTELLIGENT_ANALYZER 601  //Intelligent analyzer 

//Intelligent traffic server :651-700
#define DEV_CLASS_INTELLIGENT_TRAFFIC_SERVER 651  //Intelligent traffic server 
#define DS_TP2200_EC                         652  //

/* nvs 701-750 */
#define DEV_CLASS_NVS 701          //nvs

/*RFID 751-800*/
#define DS_TRI21A_1_P 751   //RFID

/* 801-850 */
#define DS_CLASS_FA              801 
#define DS_CLASS_PURE            802 
#define DS_CLASS_FS              803
#define DS_CLASS_FD              804
#define DS_CLASS_HAWK            805
#define DS_CLASS_BLADE           806
#define DS_CLASS_HMCP            807

/* smartlock 851 - 900*/
#define DEV_CLASS_SMART_LOCK     851

/* radar 901 - 950*/
#define DEV_CLASS_RADAR          901

/*firecontrol 951 - 1000*/
#define DEV_CLASS_FIRE_CONTROL   951

/* security check 1001 - 1050*/
#define DEV_CLASS_SECURITY_CHECK 1001

#define DEV_CLASS_CONFERENCE_TABLET  1051  //conference tablet

#define DEV_CLASS_JUDICIAL_TABLET  1101  //judicial tablet

/*panorama detail camera:8451-8470*/
#define iDS_PT              8451  //panorama detail camera

/* other class 65534 */
#define DEV_CLASS_DEFAULT 65534   //default
/**********************Device Class end**********************/

/************************DVR Log begin***************************/

/* Alarm */
//Main Type
#define MAJOR_ALARM                        0x1
//Hypo- Type
#define MINOR_ALARM_IN                    0x1   //Alarm input 
#define MINOR_ALARM_OUT                    0x2   //Alarm output
#define MINOR_MOTDET_START                0x3   //Motion detection alarm start 
#define MINOR_MOTDET_STOP                0x4   //Motion detection alarm stop
#define MINOR_HIDE_ALARM_START            0x5   //Mask alarm start 
#define MINOR_HIDE_ALARM_STOP            0x6   //Mask alarm stop 
#define MINOR_VCA_ALARM_START            0x7   //VCA alarm start 
#define MINOR_VCA_ALARM_STOP            0x8   //VCA alarm stop
#define MINOR_ITS_ALARM_START           0x09  // Traffic event alarm start
#define MINOR_ITS_ALARM_STOP            0x0A  //Traffic event alarm stop
#define MINOR_NETALARM_START            0x0b  //Net alarm start
#define MINOR_NETALARM_STOP             0x0c  //Net alarm stop
#define MINOR_NETALARM_RESUME           0x0d
//2012-4-5 IPC PIR\wireless\callhelp
#define MINOR_WIRELESS_ALARM_START        0x0e  /* wireless alarm start */
#define MINOR_WIRELESS_ALARM_STOP          0x0f /* wireless alarm stop */
#define MINOR_PIR_ALARM_START           0x10  /* PIR alarm start */
#define MINOR_PIR_ALARM_STOP               0x11  /* PIR alarm stop */
#define MINOR_CALLHELP_ALARM_START      0x12  /* callhelp start */
#define MINOR_CALLHELP_ALARM_STOP          0x13  /* callhelp stop */
#define MINOR_IPCHANNEL_ALARMIN_START   0x14  //IP channel alarm in start: It happens whenPCNVR receives the alarm in from its IP channel.After 10s,  "IP channel alarm in stop" happens if PCNVR can't receive it.  
#define MINOR_IPCHANNEL_ALARMIN_STOP    0x15  //IP channel alarm in stop. 
#define MINOR_DETECTFACE_ALARM_START    0x16  /* Face detection alarm start */
#define MINOR_DETECTFACE_ALARM_STOP      0x17  /* Face detection alarm stop */
#define MINOR_VQD_ALARM_START           0x18  //VQD alarm start
#define MINOR_VQD_ALARM_STOP            0x19  //VQD alarm stop 
#define MINOR_VCA_SECNECHANGE_DETECTION 0x1a  //Sencne Change Detection 2013-07-16 

#define MINOR_SMART_REGION_EXITING_BEGIN                0x1b  //Region Exiting Begin
#define MINOR_SMART_REGION_EXITING_END                  0x1c  //Region Exiting End
#define MINOR_SMART_LOITERING_BEGIN                     0x1d  //Loitering Begin
#define MINOR_SMART_LOITERING_END                       0x1e  //Loitering End

#define MINOR_VCA_ALARM_LINE_DETECTION_BEGIN            0x20  
#define MINOR_VCA_ALARM_LINE_DETECTION_END                0x21 
#define MINOR_VCA_ALARM_INTRUDE_BEGIN                      0x22  //field start    
#define MINOR_VCA_ALARM_INTRUDE_END                           0x23  //field stop    
#define MINOR_VCA_ALARM_AUDIOINPUT                        0x24   //Audio Exception
#define MINOR_VCA_ALARM_AUDIOABNORMAL                     0x25   //Voice ABNORMAL 
#define MINOR_VCA_DEFOCUS_DETECTION_BEGIN                0x26  //defous detection start
#define MINOR_VCA_DEFOCUS_DETECTION_END                    0x27  //defous detection end
#define MINOR_EXT_ALARM                                    0x28             /*IPC External alarm*/
#define MINOR_VCA_FACE_ALARM_BEGIN                        0x29       /*face detect begin*/
#define MINOR_SMART_REGION_ENTRANCE_BEGIN               0x2a  //Region Entrance Begin
#define MINOR_SMART_REGION_ENTRANCE_END                 0x2b  //Region Entrance End
#define MINOR_SMART_PEOPLE_GATHERING_BEGIN              0x2c  //People Gathering Begin
#define MINOR_SMART_PEOPLE_GATHERING_END                0x2d  //People Gathering End
#define MINOR_SMART_FAST_MOVING_BEGIN                   0x2e  //Fast Moving Begin
#define MINOR_SMART_FAST_MOVING_END                     0x2f  //Fast Moving End

#define MINOR_VCA_FACE_ALARM_END                        0x30       /*face detect end*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN                0x31   /*scene change start*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_END                0x32   /*scene change end*/
#define MINOR_VCA_ALARM_AUDIOINPUT_BEGIN                0x33   /*audio in put start*/
#define MINOR_VCA_ALARM_AUDIOINPUT_END                    0x34   /*audio in put end*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN                0x35  /*audio abnormal start*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_END                0x36  /*audio abnormal end*/

#define MINOR_VCA_LECTURE_DETECTION_BEGIN               0x37  //Lecture Alarm Begin
#define MINOR_VCA_LECTURE_DETECTION_END                 0x38  //Lecture Alarm End
#define MINOR_VCA_SITDOWN_DETECTION                         0x38  //Sit Down Detection Alarm
#define MINOR_VCA_ALARM_AUDIOSTEEPDROP                  0x39  //Audio Decibel Steep Drop 2014-03-21
#define MINOR_VCA_ANSWER_DETECTION_BEGIN                0x3a //Answer Detection Begin 
#define MINOR_VCA_ANSWER_DETECTION_END                  0x3b //Answer Detection End

#define MINOR_SMART_PARKING_BEGIN                       0x3c   //Parking Begin
#define MINOR_SMART_PARKING_END                         0x3d   //Parking End
#define MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN            0x3e   //Unattended Baggage Begin
#define MINOR_SMART_UNATTENDED_BAGGAGE_END              0x3f   //Unattended Baggage End
#define MINOR_SMART_OBJECT_REMOVAL_BEGIN                0x40   //Object Removal Begin
#define MINOR_SMART_OBJECT_REMOVAL_END                  0x41   //Object Removal End
#define MINOR_SMART_VEHICLE_ALARM_START                 0x46   //Vehicle alarm Begin
#define MINOR_SMART_VEHICLE_ALARM_STOP                  0x47   //Vehicle alarm Begin
#define MINOR_THERMAL_FIREDETECTION                     0x48   //Fire Detection Begin
#define MINOR_THERMAL_FIREDETECTION_END                 0x49   //Fire Detection End
#define MINOR_SMART_VANDALPROOF_BEGIN                   0x50   //Vandalproof Detection Begin
#define MINOR_SMART_VANDALPROOF_END                     0x51   //Vandalproof Detection End

#define MINOR_FACESNAP_MATCH_ALARM_START                0x55  /*Face snap match alarm start*/
#define MINOR_FACESNAP_MATCH_ALARM_STOP                 0x56  /*Face snap match alarm stop*/
#define MINOR_ALLOWLIST_FACESNAP_MATCH_ALARM_START      0x57  /*Allow list facecontrast alarm start*/
#define MINOR_ALLOWLIST_FACESNAP_MATCH_ALARM_STOP       0x58  /*Allow list facecontrast alarm end*/

#define MINOR_THERMAL_SHIPSDETECTION                    0x5a   //Thermal Ship Detection
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN    0x5b   //Thermal Thermometry Early Warning Begin
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END      0x5c   //Thermal Thermometry Early Warning End
#define MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN           0x5d   //Thermal Thermometry Alarm Begin
#define MINOR_THERMAL_THERMOMETRY_ALARM_END             0x5e   //Thermal Thermometry Alarm End
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN      0x5f   //Thermal Thermometry diff Alarm Begin
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END        0x60   //Thermal Thermometry diff Alarm End
#define MINOR_FACE_THERMOMETRY_ALARM                0x63   //face Thermometry Alarm
#define MINOR_SMART_DENSEFOGDETECTION_BEGIN         0x6e  //Dense fog detection Begin
#define MINOR_SMART_DENSEFOGDETECTION_END        0x6f  //Dense fog detection End
#define MINOR_RUNNING_ALARM                         0x70   //Run detection
#define MINOR_RETENTION_ALARM                       0x71   //Detention detection
#define MINOR_SAFETY_HELMET_ALARM_START             0x72  /*No Safety Helmet Alarm Start*/
#define MINOR_SAFETY_HELMET_ALARM_STOP              0x73  /*No Safety Helmet Alarm End*/
#define MINOR_HFPD_ALARM_START                      0x74  /*HFPD alarm start*/
#define MINOR_HFPD_ALARM_STOP                       0x75  /*HFPD alarm stop*/
#define MINOR_MIXED_TARGET_ALARM_START              0x76  /*Mixed target alarm start*/
#define MINOR_MIXED_TARGET_ALARM_STOP               0x77  /*Mixed target alarm stop*/
#define MINOR_VCA_PLAY_CELLPHONE_ALARM_BEGIN  0x78  //play cellphone alarm start
#define MINOR_VCA_PLAY_CELLPHONE_ALARM_END    0x79   //play cellphone alarm stop
#define MINOR_VCA_GET_UP_ALARM_BEGIN        0x80   //get up alarm begin
#define MINOR_VCA_GET_UP_ALARM_END        0x81   //get up alarm end
#define MINOR_VCA_ADV_REACH_HEIGHT_ALARM_BEGIN      0x82   //adv reach height alarm begin
#define MINOR_VCA_ADV_REACH_HEIGHT_ALARM_END        0x83   //adv reach height alarm end
#define MINOR_VCA_TOILET_TARRY_ALARM_BEGIN        0x84   //toilet tarry alarm begin
#define MINOR_VCA_TOILET_TARRY_ALARM_END        0x85   //toilet tarry alarm end
#define MINOR_HUMAN_RECOGNITION_ALARM_BEGIN         0x86   //humanrecognition alarm begin
#define MINOR_HUMAN_RECOGNITION_ALARM_END           0x87   //humanrecognition alarm end
#define MINOR_STUDENTS_STOODUP_ALARM_BEGIN          0x88   //Students stoodup alarm begin
#define MINOR_STUDENTS_STOODUP_ALARM_END            0x89   //Students stoodup alarm end
#define MINOR_FRAMES_PEOPLE_COUNTING_ALARM          0x8a   //Frames People Counting Alarm
#define MINOR_FACE_SNAP_ALARM_BEGIN                 0x8b   //Face snap alarm begin
#define MINOR_FACE_SNAP_ALARM_END                   0x8c   //Face snap alarm end
#define MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_BEGIN   0x8d   //Teacher behavior detect alarm begin
#define MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_END     0x8e   //
#define MINOR_PERIMETER_CAPTURE_ALARM_BEGIN         0x8f   //perimeterCapture alarm begin
#define MINOR_PERIMETER_CAPTURE_ALARM_END           0x90   //perimeterCapture alarm end
#define MINOR_UNREGISTERED_STREET_VENDOR_ALARM      0x91  //unregistered street vendor alarm

#define MINOR_PERSON_QUEUE_TIME_ALARM_BEGIN         0x92   //Queue time detection alarm begin
#define MINOR_PERSON_QUEUE_TIME_ALARM_END           0x93   //Queue time detection alarm end
#define MINOR_PERSON_QUEUE_COUNTING_ALARM_BEGIN     0x94   //Queue cpunting detection alarm begin
#define MINOR_PERSON_QUEUE_COUNTING_ALARM_END       0x95   //Queue cpunting detection alarm end
#define MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_START   0x96   //Face snap match failure alarm start
#define MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_END     0x97   //Face snap match failure alarm end


#define MINOR_ACCESS_CONTROLLER_EVENT               0x100  //access controller event
#define MINOR_VIDEO_INTERCOM_EVENT                  0x101  //video intercom event
#define MINOR_GJD_EVENT                             0x102  //GJD event
#define MINOR_LUMINITE_EVENT                        0x103  //LUMINITE event
#define MINOR_OPTEX_EVENT                           0x104  //OPTEX event
#define MINOR_CAMERA_DETECTOR_EVENT                 0x105  //camera detector event
#define MINOR_SECURITY_CONTROL_PANEL_EVENT          0x106  //security control panel event

#define MINOR_VCA_SPACE_CHANGE_START                0x10c //Space change detect start
#define MINOR_VCA_SPACE_CHANGE_STOP                 0x10d //Space change detect end
#define MINOR_MANUAL_ALARM                          0x10e //Manual alarm
#define MINOR_DETECTOR_ALARM                        0x10f //Detector alarm
#define MINOR_LINKAGE_ALARM                         0x110 //Linkage alarm
#define MINOR_VCA_SITUATION_ANALYSIS_START          0x111 //Situational analysis testing begin
#define MINOR_VCA_SITUATION_ANALYSIS_STOP           0x112 //Situational analysis testing end
#define MINOR_FIRE_ALARM                            0x113 //Fire alarm
#define MINOR_SUPERVISE_ALARM                       0x114 //supervise Alarm
#define MINOR_SHIELD_ALARM                          0x115 //shield Alarm
#define MINOR_ABNORMAL_ALARM                        0x116 //abnormal alarm
#define MINOR_RESIDUAL_CURRENT_ALARM                0x117 //resiidual current alarm
#define MINOR_TEMPERATURE_ALARM                     0x118 //temperature alarm
#define MINOR_ARC_ALARM                             0x119 //arc alarm

#define MINOR_VCA_YARD_TARRY_ALARM_BEGIN        0x11a   //Yard tarry alarm begin
#define MINOR_VCA_YARD_TARRY_ALARM_END      0x11b   //Yard tarry alarm end
#define MINOR_VCA_KEY_PERSON_GET_UP_ALARM_BEGIN     0x11c     //Key person get up alarm begin
#define MINOR_VCA_KEY_PERSON_GET_UP_ALARM_END       0x11d     //Key person get up alarm end
#define MINOR_VCA_SIT_QUIETLY_ALARM_BEGIN       0x11e     //Sit quietly alarm begin
#define MINOR_VCA_SIT_QUIETLY_ALARM_END     0x11f     //Sit quietly alarm end
#define MINOR_VCA_STAND_UP_ALARM_BEGIN      0x120     //Stand up alarm begin
#define MINOR_VCA_STAND_UP_ALARM_END        0x121     //Stand up alarm end
#define MINOR_VCA_REACH_HIGHT_ALARM_BEGIN       0x122     //Reach hight alarm begin
#define MINOR_VCA_REACH_HIGHT_ALARM_END     0x123     //Reach hight alarm end

#define MINOR_LFPD_ALARM_START                      0x124  /*LFPD alarm start*/
#define MINOR_LFPD_ALARM_STOP                       0x125  /*LFPD alarm stop*/

#define MINOR_DREDGERDETECTION_ALARM                0x126// Detection and alarm of sand dredger
#define MINOR_STUDENT_BEHAVIOR_ALARM_BEGIN          0x127  //Student behavior alarm begin
#define MINOR_STUDENT_BEHAVIOR_ALARM_END            0x128  //Student behavior alarm end
#define MINOR_VCA_ALARM_VEHICLEMONITOR              0x129   //vehicleMonitor Alarm
#define MINOR_WASTEGASDETECTION_ALARM                0x130// waste gas
#define MINOR_GREYSCALE_ALARM                        0x131// grey scale
#define MINOR_VIBRATION_DETECTION_ALARM_BEGIN          0x132  //vibration Detection begin
#define MINOR_VIBRATION_DETECTION_ALARM_END            0x133  //vibration Detection Stop
#define MINOR_SMOKE_DETECT_ALARM_BEGIN                 0x134  //smoking detection alarm begin
#define MINOR_SMOKE_DETECT_ALARM_END                   0x135  //Smoking detection alarm end
#define MINOR_METHANE_CONCENTRATION_ALARM              0x136  //Methane concentration exception
#define MINOR_METHANE_LIGHTINTENSITY_ALARM             0x137  //Methane light intensity exception

//0x400-0x1000 access card alarm 
#define MINOR_ALARMIN_SHORT_CIRCUIT                 0x400  //region short circuit 
#define MINOR_ALARMIN_BROKEN_CIRCUIT                0x401  //region broken circuit
#define MINOR_ALARMIN_EXCEPTION                     0x402  //region exception 
#define MINOR_ALARMIN_RESUME                        0x403  //region resume 
#define MINOR_HOST_DESMANTLE_ALARM                  0x404  //host desmantle alarm 
#define MINOR_HOST_DESMANTLE_RESUME                 0x405  //host desmantle resume 
#define MINOR_CARD_READER_DESMANTLE_ALARM           0x406  //card reader desmantle alarm 
#define MINOR_CARD_READER_DESMANTLE_RESUME          0x407  //card reader desmantle resume
#define MINOR_CASE_SENSOR_ALARM                     0x408  //case sensor alarm 
#define MINOR_CASE_SENSOR_RESUME                    0x409  //case sensor resume 
#define MINOR_STRESS_ALARM                          0x40a  //stress alarm 
#define MINOR_OFFLINE_ECENT_NEARLY_FULL             0x40b  //offline ecent nearly full 
#define MINOR_CARD_MAX_AUTHENTICATE_FAIL            0x40c  //card max authenticate fall  
#define MINOR_SD_CARD_FULL                          0x40d  //SD card is full
#define MINOR_LINKAGE_CAPTURE_PIC                   0x40e  //lingage capture picture
#define MINOR_SECURITY_MODULE_DESMANTLE_ALARM        0x40f  //Door control security module desmantle alarm
#define MINOR_SECURITY_MODULE_DESMANTLE_RESUME        0x410  //Door control security module desmantle resume
#define MINOR_POS_START_ALARM                       0x411  //POS Start
#define MINOR_POS_END_ALARM                         0x412  //POS end
#define MINOR_FACE_IMAGE_QUALITY_LOW                0x413  //face image quality low
#define MINOR_FINGE_RPRINT_QUALITY_LOW              0x414  //finger print quality low
#define MINOR_FIRE_IMPORT_SHORT_CIRCUIT             0x415  //Fire import short circuit
#define MINOR_FIRE_IMPORT_BROKEN_CIRCUIT            0x416  //Fire import broken circuit
#define MINOR_FIRE_IMPORT_RESUME                    0x417  //Fire import resume
#define MINOR_FIRE_BUTTON_TRIGGER                   0x418  //fire button trigger
#define MINOR_FIRE_BUTTON_RESUME                    0x419  //fire button resume
#define MINOR_MAINTENANCE_BUTTON_TRIGGER            0x41a  //maintenance button trigger
#define MINOR_MAINTENANCE_BUTTON_RESUME             0x41b  //maintenance button resume
#define MINOR_EMERGENCY_BUTTON_TRIGGER              0x41c  //emergency button trigger
#define MINOR_EMERGENCY_BUTTON_RESUME               0x41d  //emergency button resume
#define MINOR_DISTRACT_CONTROLLER_ALARM             0x41e  //distract controller alarm
#define MINOR_DISTRACT_CONTROLLER_RESUME            0x41f  //distract controller resume

#define MINOR_PERSON_DENSITY_DETECTION_START        0x420  //Person Density Detection Start
#define MINOR_PERSON_DENSITY_DETECTION_END          0x421  //Person Density Detection Start

#define MINOR_CHANNEL_CONTROLLER_DESMANTLE_ALARM    0x422  //channel controller desmantle alarm
#define MINOR_CHANNEL_CONTROLLER_DESMANTLE_RESUME   0x423  //channel controller desmantle resume
#define MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM  0x424  //channel controller fire import alarm
#define MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME 0x425  //channel controller fire import resume

#define MINOR_HEART_RATE_ABNORMAL_BEGIN             0x426    //Abnormal heart rate alarm begin
#define MINOR_HEART_RATE_ABNORMAL_END               0x427    //Abnormal heart rate alarm end
#define MINOR_BLOOD_OXYGEN_ABNORMAL_BEGIN           0x428    //Blood oxygen abnormal alarm begin
#define MINOR_BLOOD_OXYGEN_ABNORMAL_END             0x429    //Blood oxygen abnormal alarm end
#define MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN   0x42a    //Blood pressure systolic abnormal alarm begin
#define MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_END     0x42b    //Blood pressure systolic abnormal alarm end
#define MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN  0x42c    //Blood pressure diastolic abnormal alarm begin
#define MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_END    0x42d    //Blood pressure diastolic abnormal alarm end
#define MINOR_VCA_LEAVE_POSITION_START              0x42e//Leave position start
#define MINOR_VCA_LEAVE_POSITION_STOP               0x42f//Leave position end
#define MINOR_VCA_STOOODUP_START                    0x430//Stand up start
#define MINOR_VCA_STOOODUP_STOP                     0x431//Stand up end
#define MINOR_VCA_PEOPLENUM_CHANGE_START            0x434//People number change start
#define MINOR_VCA_PEOPLENUM_CHANGE_STOP             0x435//People number change end
#define MINOR_VCA_RUNNING_START                     0x438//Running start
#define MINOR_VCA_RUNNING_STOP                      0x439//Running end
#define MINOR_VCA_VIOLENT_MOTION_START              0x43a//Violent motion start
#define MINOR_VCA_VIOLENT_MOTION_STOP               0x43b//Violent motion end
#define MINOR_VCA_FAIL_DOWN_START                   0x43c//Fail down start
#define MINOR_VCA_FAIL_DOWN_STOP                    0x43d//Fail down end
#define MINOR_VCA_RETENTION_START                   0x43e//Rention start
#define MINOR_VCA_RETENTION_STOP                    0x43f//Rention end

#define MINOR_PRINTER_OUT_OF_PAPER               0x440   //printer no paper
#define MINOR_LEGAL_EVENT_NEARLY_FULL            0x442   //Offline legal event nearly full
#define MINOR_FIRE_IMPORT_ALARM                  0x443   //Fire in alarm
#define MINOR_TRANSACTION_RECORD_NEARLY_FULL        0x444
#define MINOR_ALARM_CUSTOM1                         0x900  //alarm custom 1
#define MINOR_ALARM_CUSTOM2                         0x901  //alarm custom 2
#define MINOR_ALARM_CUSTOM3                         0x902  //alarm custom 3
#define MINOR_ALARM_CUSTOM4                         0x903  //alarm custom 4
#define MINOR_ALARM_CUSTOM5                         0x904  //alarm custom 5
#define MINOR_ALARM_CUSTOM6                         0x905  //alarm custom 6
#define MINOR_ALARM_CUSTOM7                         0x906  //alarm custom 7
#define MINOR_ALARM_CUSTOM8                         0x907  //alarm custom 8
#define MINOR_ALARM_CUSTOM9                         0x908  //alarm custom 9
#define MINOR_ALARM_CUSTOM10                        0x909  //alarm custom 10
#define MINOR_ALARM_CUSTOM11                        0x90a  //alarm custom 11
#define MINOR_ALARM_CUSTOM12                        0x90b  //alarm custom 12
#define MINOR_ALARM_CUSTOM13                        0x90c  //alarm custom 13
#define MINOR_ALARM_CUSTOM14                        0x90d  //alarm custom 14
#define MINOR_ALARM_CUSTOM15                        0x90e  //alarm custom 15
#define MINOR_ALARM_CUSTOM16                        0x90f  //alarm custom 16
#define MINOR_ALARM_CUSTOM17                        0x910  //alarm custom 17
#define MINOR_ALARM_CUSTOM18                        0x911  //alarm custom 18
#define MINOR_ALARM_CUSTOM19                        0x912  //alarm custom 19
#define MINOR_ALARM_CUSTOM20                        0x913  //alarm custom 20
#define MINOR_ALARM_CUSTOM21                        0x914  //alarm custom 21
#define MINOR_ALARM_CUSTOM22                        0x915  //alarm custom 22
#define MINOR_ALARM_CUSTOM23                        0x916  //alarm custom 23
#define MINOR_ALARM_CUSTOM24                        0x917  //alarm custom 24
#define MINOR_ALARM_CUSTOM25                        0x918  //alarm custom 25
#define MINOR_ALARM_CUSTOM26                        0x919  //alarm custom 26
#define MINOR_ALARM_CUSTOM27                        0x91a  //alarm custom 27
#define MINOR_ALARM_CUSTOM28                        0x91b  //alarm custom 28
#define MINOR_ALARM_CUSTOM29                        0x91c  //alarm custom 29
#define MINOR_ALARM_CUSTOM30                        0x91d  //alarm custom 30
#define MINOR_ALARM_CUSTOM31                        0x91e  //alarm custom 31
#define MINOR_ALARM_CUSTOM32                        0x91f  //alarm custom 32
#define MINOR_ALARM_CUSTOM33                        0x920  //alarm custom 33
#define MINOR_ALARM_CUSTOM34                        0x921  //alarm custom 34
#define MINOR_ALARM_CUSTOM35                        0x922  //alarm custom 35
#define MINOR_ALARM_CUSTOM36                        0x923  //alarm custom 36
#define MINOR_ALARM_CUSTOM37                        0x924  //alarm custom 37
#define MINOR_ALARM_CUSTOM38                        0x925  //alarm custom 38
#define MINOR_ALARM_CUSTOM39                        0x926  //alarm custom 39
#define MINOR_ALARM_CUSTOM40                        0x927  //alarm custom 40
#define MINOR_ALARM_CUSTOM41                        0x928  //alarm custom 41
#define MINOR_ALARM_CUSTOM42                        0x929  //alarm custom 42
#define MINOR_ALARM_CUSTOM43                        0x92a  //alarm custom 43
#define MINOR_ALARM_CUSTOM44                        0x92b  //alarm custom 44
#define MINOR_ALARM_CUSTOM45                        0x92c  //alarm custom 45
#define MINOR_ALARM_CUSTOM46                        0x92d  //alarm custom 46
#define MINOR_ALARM_CUSTOM47                        0x92e  //alarm custom 47
#define MINOR_ALARM_CUSTOM48                        0x92f  //alarm custom 48
#define MINOR_ALARM_CUSTOM49                        0x930  //alarm custom 49
#define MINOR_ALARM_CUSTOM50                        0x931  //alarm custom 50
#define MINOR_ALARM_CUSTOM51                        0x932  //alarm custom 51
#define MINOR_ALARM_CUSTOM52                        0x933  //alarm custom 52
#define MINOR_ALARM_CUSTOM53                        0x934  //alarm custom 53
#define MINOR_ALARM_CUSTOM54                        0x935  //alarm custom 54
#define MINOR_ALARM_CUSTOM55                        0x936  //alarm custom 55
#define MINOR_ALARM_CUSTOM56                        0x937  //alarm custom 56
#define MINOR_ALARM_CUSTOM57                        0x938  //alarm custom 57
#define MINOR_ALARM_CUSTOM58                        0x939  //alarm custom 58
#define MINOR_ALARM_CUSTOM59                        0x93a  //alarm custom 59
#define MINOR_ALARM_CUSTOM60                        0x93b  //alarm custom 60
#define MINOR_ALARM_CUSTOM61                        0x93c  //alarm custom 61
#define MINOR_ALARM_CUSTOM62                        0x93d  //alarm custom 62
#define MINOR_ALARM_CUSTOM63                        0x93e  //alarm custom 63
#define MINOR_ALARM_CUSTOM64                        0x93f  //alarm custom 64
#define MINOR_LOCK_HIJIACK_FINGER_ALARM         0x950       
#define MINOR_LOCK_HIJIACK_PASSWORD_ALARM       0x951       
#define MINOR_LOCK_PRY_DOOR_ALARM               0x952       
#define MINOR_LOCK_LOCKED_ALARM                 0x953       
#define MINOR_LOCK_BATTERLOW_ALARM              0x954      
#define MINOR_LOCK_BLOCKLIST_DOOR_ALARM         0x955       
#define MINOR_LOCK_OFFLINE_ALARM                0x956       
#define MINOR_LOCK_UNCLOSED_ALARM               0x957       
#define MINOR_LOCK_NO_HOME_ALARM                0x958       
#define MINOR_LOCK_MAGNETOMETER_ALARM           0x959       
#define MINOR_LOCK_IR_DETECTOR_ALARM            0x95a       
#define MINOR_LOCK_FP_LOCKED_ALARM              0x95b       
#define MINOR_LOCK_PASSWORD_LOCKED_ALARM        0x95c       
#define MINOR_LOCK_HIJIACK_ALARM              0x95d 


//2018-04-23 General gateway alarm type log
#define MINOR_ALARMHOST_SHORT_CIRCUIT    	      0x1001      //Short circuit alarm
#define MINOR_ALARMHOST_BROKEN_CIRCUIT   		  0x1002       //Broken circuit alarm
#define MINOR_ALARMHOST_ALARM_RESET      	      0x1003       //alarm reset
#define MINOR_ALARMHOST_ALARM_NORMAL			  0x1004   	//Alarm resumes to normal
#define MINOR_ALARMHOST_PASSWORD_ERROR 		  0x1005		//Password error(consecutive times for password error)
#define MINOR_ALARMHOST_ID_CARD_ILLEGALLY 	  0x1006		//Illegal proximity card ID
#define MINOR_ALARMHOST_KEYPAD_REMOVE 		  0x1007	//Keypad tamper
#define MINOR_ALARMHOST_KEYPAD_REMOVE_RESTORE   0x1008	//Keypad tamper reset

#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT1 	  0x1011	//Analog lower than alarm limit 1
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT2 	  0x1012    //Analog lower than alarm limit 2
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT3 	  0x1013    //Analog lower than alarm limit 3
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT4 	  0x1014    //Analog lower than alarm limit 4
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT1 	  0x1015    //Analog higher than alarm limit 1
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT2 	0x1016    //Analog higher than alarm limit 2
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT3 	0x1017     //Analog higher than alarm limit 3
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT4 	0x1018     //Analog higher than alarm limit 4

#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_BANDIT 	0x1021      //Virtual zone bandit
#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_FIRE 		0x1022       //virtual zone fire
#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_URGENT 		0x1023       //virtual zone urgent

#define MINOR_UPS_ALARM			0x1028      //UPS alarm
#define MINOR_ELECTRICITY_METER_ALARM 0x1029     //electricity meter alarm
#define MINOR_SWITCH_POWER_ALARM	  0x1030     //switch power alarm
#define MINOR_GAS_DETECT_SYS_ALARM	  0x1031    //gas detect system alarm
#define MINOR_TRANSFORMER_TEMPRATURE_ALARM 0x1032     //transformer temprature alarm
#define MINOR_TEMP_HUMI_ALARM		0x1033   //temprature&huminity sensor alarm
#define MINOR_UPS_ALARM_RESTORE	0x1034    //UPS alarm restore
#define MINOR_ELECTRICITY_METER_ALARM_RESTORE 0x1035   //electricity meter alarm restore
#define MINOR_SWITCH_POWER_ALARM_RESTORE	0x1036   //switch power alarm restore
#define MINOR_GAS_DETECT_SYS_ALARM_RESTORE	  0x1037   //gas detect system alarm restore
#define MINOR_TRANSFORMER_TEMPRATURE_ALARM_RESTORE 0x1038            //transformer temprature alarm restore
#define MINOR_TEMP_HUMI_ALARM_RESTORE	0x1039     //temprature&huminity sensor alarm restore
#define MINOR_WATER_LEVEL_SENSOR_ALARM 		0x1040     //water level sensor alarm
#define MINOR_WATER_LEVEL_SENSOR_ALARM_RESTORE 	0x1041  //water level sensor alarm restore
#define MINOR_DUST_NOISE_ALARM 	0x1042  //dust and noise alarm
#define MINOR_DUST_NOISE_ALARM_RESTORE 	0x1043     //dust and noise alarm restore
#define MINOR_ENVIRONMENTAL_LOGGER_ALARM 	0x1044    //environmental logger alarm
#define MINOR_ENVIRONMENTAL_LOGGER_ALARM_RESTORE 0x1045            //environmental logger alarm restore

#define MINOR_TRIGGER_TAMPER    0x1046     //trigger tamper
#define MINOR_TRIGGER_TAMPER_RESTORE     0x1047    //trigger tamper restore
#define MINOR_EMERGENCY_CALL_HELP_ALARM    0x1048       //emergency call help alarm
#define MINOR_EMERGENCY_CALL_HELP_ALARM_RESTORE 0x1049            //emergency call help alarm restore
#define MINOR_CONSULTING_ALARM     0x1050    //consult alarm
#define MINOR_CONSULTING_ALARM_RESTORE   0x1051     //consult alarm restore
#define MINOR_ALARMHOST_ZONE_MODULE_REMOVE      0x1052    //zone module remove
#define MINOR_ALARMHOST_ZONE_MODULE_RESET     0x1053       //zone module reset

#define MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM      0x1054      //anemograph sensor alarm
#define MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM_RESTORE   0x1055      //anemograph sensor alarm restore
#define MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_ALARM   0x1056   //general output module alarm
#define MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_RESTORE    0x1057     //general output module alarm restore
#define MINOR_ALARMHOST_ALARM_SOAK_ALARM      0x1058      //soggy sensor alarm
#define MINOR_ALARMHOST_ALARM_SOAK_ALARM_RESTORE   0x1059  //soggy sensor alarm restore
#define MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM    0x1060    //solar power sensor alarm
#define MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM_RESTORE 0x1061   //solar power sensor alarm restore
#define MINOR_ALARMHOST_ALARM_SF6_ALARM   0x1062      //SF6 alarm host alarm
#define MINOR_ALARMHOST_ALARM_SF6_ALARM_RESTORE   0x1063    //SF6 alarm host alarm restore
#define MINOR_ALARMHOST_ALARM_WEIGHT_ALARM    0x1064      //weighing instrument alarm
#define MINOR_ALARMHOST_ALARM_WEIGHT_ALARM_RESTORE    0x1065   //weighing instrument alarm restore
#define MINOR_ALARMHOST_ALARM_WEATHER_ALARM   0x1066   //atmospherium system alarm
#define MINOR_ALARMHOST_ALARM_WEATHER_ALARM_RESTORE    0x1067     //atmospherium system alarm restore
#define MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM     0x1068  //Gas monitor system alarm
#define MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM_RESTORE  0x1069 //Gas monitor system alarm restore
#define MINOR_ALARMHOST_ALARM_FIRE_ALARM   0x1070  //fire disaster alarm system alarm
#define MINOR_ALARMHOST_ALARM_FIRE_ALARM_RESTORE    0x1071   //fire disaster alarm system alarm restore
#define  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_REMOVE     0x1072   //wireless output module alarm
#define  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_RESET    0x1073  //wireless output module alarm restore
#define  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_REMOVE   0x1074  //wireless repeater tamper alarm

#define  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_REMOVE     0x1075  //wireless alarm number tamper alarm
#define  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_RESET     0x1076 //wireless alarm number tamper alarm restore

#define  MINOR_RS485_DEV_ALARM     0x1077   //rs485 device alarm (for unknown rs485 device type)
#define  MINOR_RS485_DEV_RESTORE    0x1078  //rs485 device restore (for unknown rs485 device type)
#define  MINOR_ALARMHOST_ALARM_HOST_ALARM     0x1079      //Alarm host alarm
#define  MINOR_ALARMHOST_ALARM_HOST_RESTORE    0x107a     //Alarm host restore

#define  MINOR_AIR_CONDITION_DEV_ALARM     0x107b      //Air condition alarm
#define  MINOR_AIR_CONDITION_DEV_RESTORE    0x107c     //Air condition restore

#define  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_RESET  0x107d //wireless repeater tamper alarm restore

#define	 MINOR_ALARM_ELEVATOR_BREAKDOWN     0x107e//Elevator breakdown
#define  MINOR_WATER_PRESSURE_SENSOR_ALARM      0x107f    // water pressure sensor alarm
#define  MINOR_FLOW_SENSOR_ALARM                0x1080    // flow sensor alarm
#define  MINOR_SENSOR_LINKAGE_ALARM                0x1081    //sensor linkage alarm
#define  MINOR_SENSOR_LINKAGE_ALARM_RESTORE        0x1082    //sensor linkage alarm restore
#define  MINOR_SHELF_ABNORMAL_ALARM        0x1083    //Shelf abnormal alarm

//LED alarm Hypo Type 0x1201 ~ 0x1300
#define  MINOR_SYSTEM_CHECK_ALARM                  0x1201    //system check alarm

/*Exception */
//Main Type
#define MAJOR_EXCEPTION                    0x2
//Hypo- Type
#define MINOR_SUBSYSTEM_ERROR           0x0a    /* subsystem error */
#define MINOR_RAID_ERROR                0x20    /* RAID Exception */
#define MINOR_VI_LOST                    0x21  //Video loss
#define MINOR_ILLEGAL_ACCESS            0x22  //Illegal access 
#define MINOR_HD_FULL                    0x23  //HD full 
#define MINOR_HD_ERROR                    0x24  //HD error 
#define MINOR_DCD_LOST                    0x25  //MODEM  off- line (Reserved)  
#define MINOR_IP_CONFLICT                0x26  //IP conflict 
#define MINOR_NET_BROKEN                0x27  //Network disconnected 
#define MINOR_REC_ERROR                 0x28  //Record error 
#define MINOR_IPC_NO_LINK               0x29  //IPC connection failed 
#define MINOR_VI_EXCEPTION              0x2a  //Video input error  (for analog channel only)  
#define MINOR_IPC_IP_CONFLICT           0x2b  //IPC IP conflict
#define MINOR_SENCE_EXCEPTION           0x2c  //Sence exception
#define MINOR_PIC_REC_ERROR             0x2d  //Snapshot error!
#define MINOR_VI_MISMATCH               0x2e  //Video format error.
#define MINOR_RESOLUTION_MISMATCH        0x2f    /*Resolution miamatch */

//2009- 12- 16 Add Video integrated platform Log Type
#define MINOR_FANABNORMAL                0x31  //Video integrated platform: fan abnormal
#define MINOR_FANRESUME                    0x32  //Video integrated platform: fan resume normal
#define MINOR_SUBSYSTEM_ABNORMALREBOOT    0x33  //Video integrated platform: 6467abnormal reboot
#define MINOR_MATRIX_STARTBUZZER        0x34  //Video integrated platform: dm6467 abnormal, start buzzer
//2010- 01- 22
#define MINOR_NET_ABNORMAL                0x35  //Net abnormal
#define MINOR_MEM_ABNORMAL                0x36  //Memory abnormal
#define MINOR_FILE_ABNORMAL                0x37  //File abnormal
#define MINOR_PANEL_ABNORMAL            0x38 
#define MINOR_PANEL_RESUME                0x39   
#define MINOR_RS485_DEVICE_ABNORMAL        0x3a     /*RS485 connect status exception*/
#define MINOR_RS485_DEVICE_REVERT        0x3b    /*RS485 connect status exception recovry*/
#define MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT   0x3c            //abnormal reboot
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT    0x3d            //sub board insert
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT    0x3e            //sub board pull out
#define    MINOR_SCREEN_ABNARMALTEMPERATURE        0x3f            //abnormal temperature
//2012-07-26
#define MINOR_HIGH_TEMPERATURE_PROTECT  0x40 //sub board high temperature protect
//Netra 2.2.2
#define MINOR_RECORD_OVERFLOW           0x41              //Record overflow
#define MINOR_DSP_ABNORMAL              0x42              //DSP abnormal
//Netra 3.0.0
#define MINOR_ANR_RECORD_FAIED                 0x43            /*ANR record failed*/ 
#define MINOR_SPARE_WORK_DEVICE_EXCEPT         0x44            /*Work device failed*/
#define MINOR_START_IPC_MAS_FAILED             0x45            /*Open IPC mas failed*/ 
#define MINOR_IPCM_CRASH                       0x46         /*IPCM crash*/
#define MINOR_POE_POWER_EXCEPTION              0x47         /*POE Power Exception*/
#define MINOR_UPLOAD_DATA_CS_EXCEPTION         0x48          //upload data to cs Exception/
#define MINOR_DIAL_EXCEPTION                   0x49
#define MINOR_AI_LOST                           0x52            /* audio lost */   


#define MINOR_SYNC_IPC_PASSWD                   0x53        /* Sync IPC password exception */
#define MINOR_EZVIZ_OFFLINE                        0x54        /* EZVIZ Offline*/      
#define MINOR_VQD_ABNORMAL                        0x55 //VQD anomalies 
#define MINOR_ACCESSORIES_PLATE                0x57 //accessories abnormal plate 
#define MINOR_KMS_EXPAMSION_DISK_LOST         0x58 // KMS Expansion disk lost 
#define MINOR_ABNORMAL_PORT                 0x59 // Abnormal port 
#define MINOR_CAMERA_ANGLE_ANOMALY          0x60//  Camera angle anomaly
#define MINOR_DATA_DISK_ERROE               0x61//  Data disk error  
#define MINOR_INTELLIGENT_SYSTEM_RUNNING_ERROR     0x62//  Intelligent system running error
#define MINOR_FACESNAP_RESOLUTION_OVERFLOW         0x63//  Face Snap Resolution Overflow
#define MINOR_SMD_RESOLUTION_OVERFLOW              0x64//  SMD Resolution Overflow
#define MINOR_AUDIO_LOSS_EXCEPTION                 0x65//  audio loss exception
#define MINOR_SAFETY_HELMET_EXCEPTION              0x66 // No Safety Helmet Exception
#define MINOR_VCA_PIC_LENGTH_OVERFLOW              0x67 // VCA picture length overflow
#define MINOR_FACE_MODEL_EXCEPTION                 0x68//  Face library model synchronization exception
#define MINOR_SSD_EXCEPTION                        0x69 // SSD exception
#define MINOR_CLUSTER_DEVICE_OFFLINE                 0x70 // cluster devie offline
#define MINOR_CLUSTER_CONFIG_FAILED                  0x71 // cluster config failed
#define MINOR_CLUSTER_DISASTER_TOLERANCE_EXCEPT      0x72 // cluster disaster tolerance except
#define MINOR_CLUSTER_STORFULL_EXCEPTION             0x73 //cluster storfull
#define MINOR_CLUSTER_VERSION_EXCEPTION              0x74  //cluster version exception
#define MINOR_CLUSTER_OFFLINENODE_EXCEPTION          0x75   //cluster offline node exciption
#define MINOR_CLUSTER_RECORDCYCLE_EXCEPTION          0x76   //cluster record cycle exception
#define MINOR_CLUSTER_IPCTRANSFER_EXCEPTION          0x77   //cluster IP transfer exception
#define MINOR_CLUSTER_IPCONFLICT_EXCEPTION           0x78   // cluster IP conflict

#define MINOR_GET_SUB_STREAM_FAILURE                 0x79//get sub stream failure
#define MINOR_HDD_SHM_DETECT_EXCEPTION               0x7a//The hard disk SHM detects the abnormality
#define MINOR_DEVICE_FORTIFY_FAILURE                 0x7b//The alarm of front-end device failed
#define MINOR_EVENT_UPLOAD_EXCEPTION                 0x7c //Event upload exception

#define MINOR_LORA_EXCEPTION                         0x7d//LoRa exception
#define MINOR_AK_OR_SK_IS_EMPTY                      0x7e//The cloud storage password or encryption password is empty

#define MINOR_HIGH_HD_TEMPERATURE   0x80  /*High hard disk temperature*/
#define MINOR_LOW_HD_TEMPERATURE   0x81  /*Low hard disk temperature*/
#define MINOR_HD_IMPACT   0x82  /*Hard disk impact*/
#define MINOR_HD_BAD_BLOCK   0x83  /*Hard disk bad block*/
#define MINOR_SEVERE_HD_FAILURE   0x84  /*Severe hard disk failure*/
#define MINOR_RELEASE_FAILED                         0x85 //release failed
#define MINOR_PORT_CONFLICT                          0x86  //pprt conflict
#define MINOR_MODULE_STARTUP_FAILED                  0x87  //module startup failed
#define  MINIOR_VCA_RUNNING_EXCEPTION     0x88 //vca running exception

//0x400-0x1000 access card exception type 
#define MINOR_DEV_POWER_ON                     0x400  //device power on 
#define MINOR_DEV_POWER_OFF                    0x401  //device power off
#define MINOR_WATCH_DOG_RESET                  0x402  //watch dog reset 
#define MINOR_LOW_BATTERY                      0x403  //low battery 
#define MINOR_BATTERY_RESUME                   0x404  //battery resume 
#define MINOR_AC_OFF                           0x405  //AC off
#define MINOR_AC_RESUME                        0x406  //AC resume 
#define MINOR_NET_RESUME                       0x407  //Net resume
#define MINOR_FLASH_ABNORMAL                   0x408  //FLASH abnormal 
#define MINOR_CARD_READER_OFFLINE              0x409  //card reader offline 
#define MINOR_CARD_READER_RESUME               0x40a  //card reader resume     
#define MINOR_INDICATOR_LIGHT_OFF              0x40b  //Indicator Light Off
#define MINOR_INDICATOR_LIGHT_RESUME           0x40c  //Indicator Light Resume
#define MINOR_CHANNEL_CONTROLLER_OFF           0x40d  //channel controller off
#define MINOR_CHANNEL_CONTROLLER_RESUME        0x40e  //channel controller resume
#define MINOR_SECURITY_MODULE_OFF              0x40f  //Door control security module off
#define MINOR_SECURITY_MODULE_RESUME           0x410  //Door control security module resume
#define MINOR_BATTERY_ELECTRIC_LOW             0x411  //battery electric low(only face device usage)
#define MINOR_BATTERY_ELECTRIC_RESUME          0x412  //battery electric resume(only face device usage)
#define MINOR_LOCAL_CONTROL_NET_BROKEN           0x413  //Local control net broken
#define MINOR_LOCAL_CONTROL_NET_RSUME           0x414  //Local control net resume
#define MINOR_MASTER_RS485_LOOPNODE_BROKEN     0x415  //Master RS485 loop node broken
#define MINOR_MASTER_RS485_LOOPNODE_RESUME     0x416  //Master RS485 loop node resume
#define MINOR_LOCAL_CONTROL_OFFLINE            0x417  //Local control offline
#define MINOR_LOCAL_CONTROL_RESUME             0x418  //Local control resume
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN  0x419  //Local downside RS485 loop node broken
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME  0x41a  //Local downside RS485 loop node resume
#define MINOR_DISTRACT_CONTROLLER_ONLINE       0x41b  //distract controller online
#define MINOR_DISTRACT_CONTROLLER_OFFLINE      0x41c  //distract controller offline
#define MINOR_ID_CARD_READER_NOT_CONNECT       0x41d  //Id card reader not connected(intelligent dedicated)
#define MINOR_ID_CARD_READER_RESUME            0x41e  //Id card reader connection restored(intelligent dedicated)
#define MINOR_FINGER_PRINT_MODULE_NOT_CONNECT  0x41f  //fingerprint module is not connected(intelligent dedicated)
#define MINOR_FINGER_PRINT_MODULE_RESUME       0x420  //The fingerprint module connection restored(intelligent dedicated)
#define MINOR_CAMERA_NOT_CONNECT               0x421  //Camera not connected
#define MINOR_CAMERA_RESUME                    0x422  //Camera connection restored
#define MINOR_COM_NOT_CONNECT                  0x423  //COM not connected
#define MINOR_COM_RESUME                       0x424  //COM connection restored
#define MINOR_DEVICE_NOT_AUTHORIZE             0x425  //device are not authorized
#define MINOR_PEOPLE_AND_ID_CARD_DEVICE_ONLINE 0x426  //people and ID card device online
#define MINOR_PEOPLE_AND_ID_CARD_DEVICE_OFFLINE 0x427 //people and ID card device offline
#define MINOR_LOCAL_LOGIN_LOCK                 0x428  //local login lock
#define MINOR_LOCAL_LOGIN_UNLOCK               0x429  //local login unlock
#define MINOR_SUBMARINEBACK_COMM_BREAK         0x42a  //submarineback communicate break
#define MINOR_SUBMARINEBACK_COMM_RESUME        0x42b  //submarineback communicate resume
#define MINOR_MOTOR_SENSOR_EXCEPTION           0x42c  //motor sensor exception
#define MINOR_CAN_BUS_EXCEPTION                0x42d  //can bus exception
#define MINOR_CAN_BUS_RESUME                   0x42e  //can bus resume
#define MINOR_GATE_TEMPERATURE_OVERRUN         0x42f  //gate temperature over run
#define MINOR_IR_EMITTER_EXCEPTION             0x430  //IR emitter exception
#define MINOR_IR_EMITTER_RESUME                0x431  //IR emitter resume
#define MINOR_LAMP_BOARD_COMM_EXCEPTION        0x432  //lamp board communicate exception
#define MINOR_LAMP_BOARD_COMM_RESUME           0x433  //lamp board communicate resume
#define MINOR_IR_ADAPTOR_COMM_EXCEPTION        0x434  //IR adaptor communicate exception
#define MINOR_IR_ADAPTOR_COMM_RESUME           0x435  //IR adaptor communicate resume
#define MINOR_PRINTER_ONLINE                    0x436  //printer online
#define MINOR_PRINTER_OFFLINE                    0x437  //printer offline
#define MINOR_4G_MOUDLE_ONLINE       0x438  //4G module online
#define MINOR_4G_MOUDLE_OFFLINE         0x439  //4G module offline
#define MINOR_DSP_START_FAILED         0x43a  //DSP start exception
#define MINOR_SMART_REGULATION_NOT_ALLOWED         0x43b  //smart regulation not allowed
#define MINOR_AUXILIARY_BOARD_OFFLINE          0x43c
#define MINOR_AUXILIARY_BOARD_RESUME           0x43d
#define MINOR_IDCARD_SECURITY_MOUDLE_EXCEPTION 0x43e
#define MINOR_IDCARD_SECURITY_MOUDLE_RESUME    0x43f
#define MINOR_FP_PERIPHERAL_EXCEPTION          0x440
#define MINOR_FP_PERIPHERAL_RESUME             0x441
#define MINOR_REPLAY_ATTACK                    0x442  
#define MINOR_TLS_ABNORMAL                     0x443 
#define MINOR_SMART_PLATE_OFFLINE           0x444 
#define MINOR_SMART_PLATE_ONLINE            0x445 
#define MINOR_REFUND_LOCKED                 0x446
#define MINOR_CODER_ONLINE                 0x447 
#define MINOR_CODER_OFFLINE                 0x448 
#define MINOR_KEYBOARD_OFFLINE             0x449
#define MINOR_KEYBOARD_ONLINE              0x44a 
#define MINOR_5G_MOUDLE_ONLINE          0x44b
#define MINOR_5G_MOUDLE_OFFLINE         0x44c
#define MINOR_EXTEND_MODULE_ONLINE         0x44d
#define MINOR_EXTEND_MODULE_OFFLINE        0x44e
#define MINOR_INTERLOCK_SERVER_DISCONNECTED 0x44f
#define MINOR_INTERLOCK_SERVER_CONNECTED    0x450
#define MINOR_QRCODE_READER_OFFLINE             0x451
#define MINOR_QRCODE_READER_ONLINE              0x452

#define MINOR_EXCEPTION_CUSTOM1                 0x900  //exception custom 1
#define MINOR_EXCEPTION_CUSTOM2                 0x901  //exception custom 2
#define MINOR_EXCEPTION_CUSTOM3                 0x902  //exception custom 3
#define MINOR_EXCEPTION_CUSTOM4                 0x903  //exception custom 4
#define MINOR_EXCEPTION_CUSTOM5                 0x904  //exception custom 5
#define MINOR_EXCEPTION_CUSTOM6                 0x905  //exception custom 6
#define MINOR_EXCEPTION_CUSTOM7                 0x906  //exception custom 7
#define MINOR_EXCEPTION_CUSTOM8                 0x907  //exception custom 8
#define MINOR_EXCEPTION_CUSTOM9                 0x908  //exception custom 9
#define MINOR_EXCEPTION_CUSTOM10                0x909  //exception custom 10
#define MINOR_EXCEPTION_CUSTOM11                0x90a  //exception custom 11
#define MINOR_EXCEPTION_CUSTOM12                0x90b  //exception custom 12
#define MINOR_EXCEPTION_CUSTOM13                0x90c  //exception custom 13
#define MINOR_EXCEPTION_CUSTOM14                0x90d  //exception custom 14
#define MINOR_EXCEPTION_CUSTOM15                0x90e  //exception custom 15
#define MINOR_EXCEPTION_CUSTOM16                0x90f  //exception custom 16
#define MINOR_EXCEPTION_CUSTOM17                0x910  //exception custom 17
#define MINOR_EXCEPTION_CUSTOM18                0x911  //exception custom 18
#define MINOR_EXCEPTION_CUSTOM19                0x912  //exception custom 19
#define MINOR_EXCEPTION_CUSTOM20                0x913  //exception custom 20
#define MINOR_EXCEPTION_CUSTOM21                0x914  //exception custom 21
#define MINOR_EXCEPTION_CUSTOM22                0x915  //exception custom 22
#define MINOR_EXCEPTION_CUSTOM23                0x916  //exception custom 23
#define MINOR_EXCEPTION_CUSTOM24                0x917  //exception custom 24
#define MINOR_EXCEPTION_CUSTOM25                0x918  //exception custom 25
#define MINOR_EXCEPTION_CUSTOM26                0x919  //exception custom 26
#define MINOR_EXCEPTION_CUSTOM27                0x91a  //exception custom 27
#define MINOR_EXCEPTION_CUSTOM28                0x91b  //exception custom 28
#define MINOR_EXCEPTION_CUSTOM29                0x91c  //exception custom 29
#define MINOR_EXCEPTION_CUSTOM30                0x91d  //exception custom 30
#define MINOR_EXCEPTION_CUSTOM31                0x91e  //exception custom 31
#define MINOR_EXCEPTION_CUSTOM32                0x91f  //exception custom 32
#define MINOR_EXCEPTION_CUSTOM33                0x920  //exception custom 33
#define MINOR_EXCEPTION_CUSTOM34                0x921  //exception custom 34
#define MINOR_EXCEPTION_CUSTOM35                0x922  //exception custom 35
#define MINOR_EXCEPTION_CUSTOM36                0x923  //exception custom 36
#define MINOR_EXCEPTION_CUSTOM37                0x924  //exception custom 37
#define MINOR_EXCEPTION_CUSTOM38                0x925  //exception custom 38
#define MINOR_EXCEPTION_CUSTOM39                0x926  //exception custom 39
#define MINOR_EXCEPTION_CUSTOM40                0x927  //exception custom 40
#define MINOR_EXCEPTION_CUSTOM41                0x928  //exception custom 41
#define MINOR_EXCEPTION_CUSTOM42                0x929  //exception custom 42
#define MINOR_EXCEPTION_CUSTOM43                0x92a  //exception custom 43
#define MINOR_EXCEPTION_CUSTOM44                0x92b  //exception custom 44
#define MINOR_EXCEPTION_CUSTOM45                0x92c  //exception custom 45
#define MINOR_EXCEPTION_CUSTOM46                0x92d  //exception custom 46
#define MINOR_EXCEPTION_CUSTOM47                0x92e  //exception custom 47
#define MINOR_EXCEPTION_CUSTOM48                0x92f  //exception custom 48
#define MINOR_EXCEPTION_CUSTOM49                0x930  //exception custom 49
#define MINOR_EXCEPTION_CUSTOM50                0x931  //exception custom 50
#define MINOR_EXCEPTION_CUSTOM51                0x932  //exception custom 51
#define MINOR_EXCEPTION_CUSTOM52                0x933  //exception custom 52
#define MINOR_EXCEPTION_CUSTOM53                0x934  //exception custom 53
#define MINOR_EXCEPTION_CUSTOM54                0x935  //exception custom 54
#define MINOR_EXCEPTION_CUSTOM55                0x936  //exception custom 55
#define MINOR_EXCEPTION_CUSTOM56                0x937  //exception custom 56
#define MINOR_EXCEPTION_CUSTOM57                0x938  //exception custom 57
#define MINOR_EXCEPTION_CUSTOM58                0x939  //exception custom 58
#define MINOR_EXCEPTION_CUSTOM59                0x93a  //exception custom 59
#define MINOR_EXCEPTION_CUSTOM60                0x93b  //exception custom 60
#define MINOR_EXCEPTION_CUSTOM61                0x93c  //exception custom 61
#define MINOR_EXCEPTION_CUSTOM62                0x93d  //exception custom 62
#define MINOR_EXCEPTION_CUSTOM63                0x93e  //exception custom 63
#define MINOR_EXCEPTION_CUSTOM64                0x93f  //exception custom 64
#define MINOR_SWITCH_WIRED_NETWORK            0x950
#define MINOR_SWITCH_WIRELESS_NETWORK         0x951
#define MINOR_LOCK_ONLINE_RESUME              0x952

#define MINOR_SUBSYSTEM_IP_CONFLICT            0x4000        //subsystem IP conflict    
#define MINOR_SUBSYSTEM_NET_BROKEN             0x4001        //subsystem net broken
#define    MINOR_FAN_ABNORMAL                  0x4002        //fan abnormal
#define    MINOR_BACKPANEL_TEMPERATURE_ABNORMAL 0x4003        //back panel abnormal
#define    MINOR_SDCARD_ABNORMAL               0x4004  //SD Card Abnormal
#define    MINOR_SDCARD_DAMAGE                 0x4005  //SD Card Damage
#define    MINOR_POC_ABNORMAL				   0x4006   //device poc Abnormal
#define MINOR_MAIN_POWER_FAULT              0x4007 //main power fault
#define MINOR_BACK_UP_POWER_FAULT           0x4008 //back up power fault
#define MINOR_TAMPER_FAULT                  0x4009 //tamper fault
#define MINOR_RS232_FAULT                   0x400a //RS232 fault
#define MINOR_RS485_FAULT                   0x400b //RS485 fault
#define MINOR_LAN_STATUS_FAULT              0x400c //LAN status fault
#define MINOR_LAN_LINK1_FAULT               0x400d //LAN link1 fault
#define MINOR_LAN_LINK2_FAULT               0x400e //LAN link2 fault
#define MINOR_SIM_CARD_STATUS_FAULT         0x400f //SIM card status fault
#define MINOR_4G_LINK1_FAULT                0x4010 //4G link1 fault
#define MINOR_4G_LINK2_FAULT                0x4011 //4G link2 fault
#define MINOR_OTHER_FAULT                   0x4012 //other fault
#define MINOR_FIRE_CONTROL_CONNECT_FAULT    0x4013 //host link fault
#define MINOR_SENSOR_SHORT_CIRCUIT          0x4014 //sensor short circuit
#define MINOR_SENSOR_OPEN_CIRCUIT           0x4015 //sensor open circuit
#define MINOR_SENSOR_MIS_CONNECT            0x4016 //sensor misconnect
#define MINOR_SENSOR_FAULT_RESTORE          0x4017 //sensor fault restore
#define MINOR_DEVICE_FAULT                  0x4018 //device fault
#define MINOR_OVERVOLTAGE                   0X4019  //Overvoltage of power supply
#define MINOR_UNDERVOLTAGE                  0X401a  //Power supply voltage is too low
#define MINOR_PANLOCKING                    0x401b //pan locking
#define MINOR_TILTLOCKING                   0x401c //tilt locking
#define MINOR_SUBBOARD_TEMPERATURE_ABNORMAL   0x401d  //sub_board temperature abnormal

//2018-04-23 General gateway exception type log
#define MINOR_ALARMHOST_WDT_RESET 			    0x1003    //WDT reset
#define MINOR_ALARMHOST_RTC_EXCEPTION 			0x1007    //RTC real-time clock exception

#define MINOR_ALARMHOST_TEL_LINE_CONNECT_FAILURE 	0x100a    //Telephone line is disconnected
#define MINOR_ALARMHOST_TEL_LINE_CONNECT_RESTORE 	0x100b    //Telephone line restore
#define MINOR_ALARMHOST_EXPANDER_BUS_LOSS 		0x100c    //Expansion bus module dropped
#define MINOR_ALARMHOST_EXPANDER_BUS_RESTORE 	0x100d    //Expansion bus module restore
#define MINOR_ALARMHOST_KEYPAD_BUS_LOSS 			0x100e    //Keyboard bus module dropped
#define MINOR_ALARMHOST_KEYPAD_BUS_RESTORE 		0x100f    //Keyboard bus module restore
#define MINOR_ALARMHOST_SENSOR_FAILURE 			0x1010    //Analog sensor failure
#define MINOR_ALARMHOST_SENSOR_RESTORE 			0x1011    //Analog sensor restore
#define MINOR_ALARMHOST_RS485_CONNECT_FAILURE 	0x1012    //RS485 channel is disconnected
#define MINOR_ALARMHOST_RS485_CONNECT_RESTORE 	0x1013    //RS485 channel disconnection restore

#define	MINOR_ALARMHOST_WIRED_NETWORK_ABNORMAL 	0x1015    //network abnormal
#define	MINOR_ALARMHOST_WIRED_NETWORK_RESTORE 		0x1016    //network restore
#define	MINOR_ALARMHOST_GPRS_ABNORMAL 				0x1017    //GPRS abnormal
#define	MINOR_ALARMHOST_GPRS_RESTORE 					0x1018    //GPRS restore
#define	MINOR_ALARMHOST_3G_ABNORMAL 					0x1019    //3G abnormal
#define	MINOR_ALARMHOST_3G_RESTORE 					0x101a    //3G restore
#define	MINOR_ALARMHOST_SIM_CARD_ABNORMAL 			0x101b    //SIM Card abnormal
#define	MINOR_ALARMHOST_SIM_CARD_RESTORE 			0x101c    //SIM Card restore

#define	MINOR_FORMAT_HDD_ERROR  0x1026 //format hard disk error
#define	MINOR_USB_ERROR		0x1027    //USB connect error
#define	MINOR_USB_RESTORE		0x1028    //USB connect restore
#define	MINOR_PRINT_ERROR	  0x1029    //printer error
#define	MINOR_PRINT_RESTORE   0x1030    //printer restore
#define  MINOR_ALARMHOST_SUBSYSTEM_COMMUNICATION_ERROR    0x1031  //subsystem communication error

#define  MINOR_MCU_RESTART    0x1035    //MCU restart
#define  MINOR_GPRS_MODULE_FAULT    0x1036  //GPRS Module Fault
#define  MINOR_TELEPHONE_MODULE_FAULT    0x1037     //Telephone Module Fault
#define  MINOR_WIFI_ABNORMAL  0x1038    //WIFI abnormal
#define  MINOR_WIFI_RESTORE    0x1039    //WIFI restore
#define  MINOR_RF_ABNORMAL   0x103a    //RF signal abnormal
#define  MINOR_RF_RESTORE     0x103b   //RF signal restore
#define  MINOR_DETECTOR_ONLINE   0x103c    //trigger online
#define  MINOR_DETECTOR_OFFLINE    0x103d    //trigger offline
#define  MINOR_DETECTOR_BATTERY_NORMAL    0x103e  //trigger battery normal
#define  MINOR_DETECTOR_BATTERY_LOW 0x103f  //trigger battery low power
#define  MINOR_DATA_TRAFFIC_OVERFLOW    0x1040    //traffic overflow
#define  MINOR_ALARMHOST_ZONE_MODULE_LOSS     0x1041    //zone module offline
#define  MINOR_ALARMHOST_ZONE_MODULE_RESTORE     0x1042    //zone module online
#define  MINOR_WIRELESS_OUTPUT_LOSS     0x1043    //wireless output module loss
#define  MINOR_WIRELESS_OUTPUT_RESTORE    0x1044    //wireless output module restore
#define  MINOR_WIRELESS_REPEATER_LOSS    0x1045    //wireless repeater loss
#define  MINOR_WIRELESS_REPEATER_RESTORE    0x1046    //wireless repeater restore
#define  MINOR_ALARMHOST_TRIGGER_MODULE_LOSS     0x1047    //trigger module loss
#define  MINOR_ALARMHOST_TRIGGER_MODULE_RESTORE    0x1048    //trigger module restore
#define  MINOR_ALARMHOST_WIRELESS_SIREN_LOSS    0x1049    //wireless siren loss
#define  MINOR_ALARMHOST_WIRELESS_SIREN_RESTORE     0x104a    //wireless siren  restore
#define  MINOR_TX1_SUB_SYSTEM_EXCEPTION             0x1050   /*TX1 sub system exception*/
#define  MINOR_TX1_REBOOT_EXCEPTION       0x1051   /*TX1 system reboot exception*/
#define  MINOR_TX1_SUB_SYSTEM_LOSS      0x1052   /*TX1 sub system loss*/
#define  MINOR_TX1_SUB_SYSTEM_RESTORE     0x1053   /*TX1 sub system restore*/
#define  MINOR_WIRELESS_SPEED_EXCEPTION   0x1054   //wireless transmit speed exception
#define  MINOR_SUB_BOARD_HEARTBEAT_EXCEPTION   0x1055 //sub board heartbeat exception
#define  MINOR_HOTSTANDBY__EXCEPTION    0x1056     //hot-standby exception
#define  MINOR_PRODUCTIONDATA_EXCEPTION 0x1057     //producting data exception


//LED except Hypo Type 0x1201~0x1300
#define MINOR_LED_SYSTEM_EXCEPTION   0x1201   //LED system except
#define MINOR_FLASH_NOTENOUGH_EXCEPTION   0x1202   //FLASH not enough

#define MINOR_LOG_EXCEPTION   0x1301   //Log disk exception

#define MINOR_EZVIZ_UPGRADE_EXCEPTION     0x401e     //ezviz upgrade exception

#define MINOR_EZVIZ_OPERATION_ABNORMAL   0x4020  //ezviz operation exception

#define MINOR_IFRAME_IS_TOO_LARGE   0x4030  //I frame is too large

/* Operation */
//Main Type
#define MAJOR_OPERATION                    0x3

#define MINOR_VCA_MOTIONEXCEPTION        0x29  //VCA detect exception


//Hypo- Type
#define MINOR_START_DVR                    0x41    /* Power On */
#define MINOR_STOP_DVR                    0x42    /* Power off */
#define MINOR_STOP_ABNORMAL                0x43    /* Illegal shut down */
#define MINOR_REBOOT_DVR                0x44    /*Local reboot DVR*/

#define MINOR_LOCAL_LOGIN                0x50    /* Login  (local)  */
#define MINOR_LOCAL_LOGOUT                0x51    /* Logout  (local) */
#define MINOR_LOCAL_CFG_PARM            0x52    /* Configuration  (local)  */
#define MINOR_LOCAL_PLAYBYFILE            0x53    /* Playback  (local)  */
#define MINOR_LOCAL_PLAYBYTIME            0x54    /* Playback or download by time  (local) */
#define MINOR_LOCAL_START_REC            0x55    /* Start record  (local)  */
#define MINOR_LOCAL_STOP_REC            0x56    /* Stop record  (local) */
#define MINOR_LOCAL_PTZCTRL                0x57    /* PTZ control  (local)  */
#define MINOR_LOCAL_PREVIEW                0x58    /* Preview  (local)  (Reserved) */
#define MINOR_LOCAL_MODIFY_TIME         0x59    /* Change time  (local)  (Reserved)  */
#define MINOR_LOCAL_UPGRADE                0x5a    /* Upgrade  (local)  */
#define MINOR_LOCAL_RECFILE_OUTPUT      0x5b    /* Backup  (local)  */
#define MINOR_LOCAL_FORMAT_HDD          0x5c    /* HD format (local)  */
#define MINOR_LOCAL_CFGFILE_OUTPUT      0x5d    /* Export Configuration  (local)  */
#define MINOR_LOCAL_CFGFILE_INPUT       0x5e    /* Import Configuration  (local)  */
#define MINOR_LOCAL_COPYFILE            0x5f    /* Backup file  (local)  */
#define MINOR_LOCAL_LOCKFILE            0x60    /* File lockup  (local) Reboot IPC  (local)  */
#define MINOR_LOCAL_UNLOCKFILE          0x61    /* File unlock  (local)  */
#define MINOR_LOCAL_DVR_ALARM           0x62    /* Clear/Trigger Alarm  (Local) */
#define MINOR_IPC_ADD                   0x63    /* Add IPC  (local)  */
#define MINOR_IPC_DEL                   0x64    /* Delete IPC  (local) */
#define MINOR_IPC_SET                   0x65    /* Set IPC  (local)  */
#define MINOR_LOCAL_START_BACKUP        0x66    /* local start backup file */
#define MINOR_LOCAL_STOP_BACKUP            0x67    /* local stop backup file*/
#define MINOR_LOCAL_COPYFILE_START_TIME 0x68    /* local backup: file start time*/
#define MINOR_LOCAL_COPYFILE_END_TIME    0x69    /* local backup: file end time*/
#define MINOR_LOCAL_ADD_NAS             0x6a    /* Add network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_DEL_NAS             0x6b    /* Delete network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_SET_NAS             0x6c    /* Set network hard disk in local configuration  (NFS/iSCSI) */
#define MINOR_LOCAL_RESET_PASSWD        0x6d    /* Local Resume Admin's Password*/ 

#define MINOR_REMOTE_LOGIN                0x70    /* Login  (remote) */
#define MINOR_REMOTE_LOGOUT                0x71    /* Logout   (remote)  */
#define MINOR_REMOTE_START_REC            0x72    /* Start record  (remote) */
#define MINOR_REMOTE_STOP_REC            0x73    /* Stop record   (remote)  */
#define MINOR_START_TRANS_CHAN            0x74    /* Start transparent channel  (remote)  */
#define MINOR_STOP_TRANS_CHAN            0x75    /* Stop transparent channel  (remote)  */
#define MINOR_REMOTE_GET_PARM            0x76    /* Get parameter  (remote) */
#define MINOR_REMOTE_CFG_PARM            0x77    /* configuration  (remote) */
#define MINOR_REMOTE_GET_STATUS         0x78    /* Get status  (remote)  */
#define MINOR_REMOTE_ARM                0x79    /* On guard   (remote)  */
#define MINOR_REMOTE_DISARM                0x7a    /* Disarm   (remote)  */
#define MINOR_REMOTE_REBOOT                0x7b    /* Reboot   (remote)  */
#define MINOR_START_VT                    0x7c    /* Start voice talk */
#define MINOR_STOP_VT                    0x7d    /* Stop voice talk */
#define MINOR_REMOTE_UPGRADE            0x7e    /* upgrade  (remote)  */
#define MINOR_REMOTE_PLAYBYFILE         0x7f    /* Playback or download by file name  (remote)  */
#define MINOR_REMOTE_PLAYBYTIME         0x80    /* Playback or download by time  (remote)  */
#define MINOR_REMOTE_PTZCTRL            0x81    /* PTZ control  (remote)  */
#define MINOR_REMOTE_FORMAT_HDD         0x82    /* Format hard disk (remote)  */
#define MINOR_REMOTE_STOP               0x83    /* Shut Down  (remote)  */
#define MINOR_REMOTE_LOCKFILE            0x84    /* File lockup  (remote)  */
#define MINOR_REMOTE_UNLOCKFILE         0x85    /* File unlock  (remote */
#define MINOR_REMOTE_CFGFILE_OUTPUT     0x86    /* Export Configuration   (remote)  */
#define MINOR_REMOTE_CFGFILE_INTPUT     0x87    /* Import Configuration  (remote)  */
#define MINOR_REMOTE_RECFILE_OUTPUT     0x88    /* Backup recording files  (remote)  */
#define MINOR_REMOTE_DVR_ALARM          0x89    /* Trigger/clear alarm  (remote) */
#define MINOR_REMOTE_IPC_ADD            0x8a    /* Add IPC  (remote) */
#define MINOR_REMOTE_IPC_DEL            0x8b    /* Delete IPC  (remote) */
#define MINOR_REMOTE_IPC_SET            0x8c    /* Set  IPC  (remote) */
#define MINOR_REBOOT_VCA_LIB            0x8d    /* Reboot vca library*/
#define MINOR_REMOTE_ADD_NAS            0x8e    /* Remote add nas disk*/
#define MINOR_REMOTE_DEL_NAS            0x8f    /* Remote delete nas disk*/
#define MINOR_REMOTE_SET_NAS            0x90    /* Remote set nas disk*/
#define MINOR_SCHEDULE_ANGLECALIBRATION 0X139    /*Periodic inclination calibration*/
#define MINOR_OTHER_OPERATE             0x200    /* other operations */
//2012-11-29 Netra2.3 
#define MINOR_LOCAL_OPERATE_LOCK        0x9d    /* local operate Lock*/
#define MINOR_LOCAL_OPERATE_UNLOCK      0x9e    /* local operate UnLock */
#define MINOR_REMOTE_DELETE_HDISK       0x9a    /* Remote delete HDisk */
#define MINOR_REMOTE_LOAD_HDISK         0x9b    /* Remote Load HDisk*/
#define MINOR_REMOTE_UNLOAD_HDISK       0x9c    /* Remote Unload HDisk   */

//2010- 05- 26 Add Inquest DVR Log Type
#define MINOR_LOCAL_START_REC_CDRW      0x91    /* Local start CD/DVD writing */
#define MINOR_LOCAL_STOP_REC_CDRW       0x92    /* Local stop CD/DVD writing */
#define MINOR_REMOTE_START_REC_CDRW     0x93    /* Remote Start CD/DVD writing  */
#define MINOR_REMOTE_STOP_REC_CDRW      0x94    /* Remote stop CD/DVD writing */

#define MINOR_LOCAL_PIC_OUTPUT            0x95    /* local save picture */ 
#define MINOR_REMOTE_PIC_OUTPUT            0x96    /* remote save picture */

//2011-07-26 Add 81 Inquest DVR Log Type
#define MINOR_LOCAL_INQUEST_RESUME      0x97    /* local resume inquest event*/
#define MINOR_REMOTE_INQUEST_RESUME     0x98    /* remote resume inquest event*/

#define MINOR_LOCAL_ADD_FILE            0x99       
#define MINOR_LOCAL_DEL_FILE            0x9f

#define MINOR_DELETE_LOGO               0xdd    /* delete logo */

#define MINOR_REMOTE_INQUEST_ADD_FILE   0x100       




//2009- 12- 16 Add Video integrated platform Log Type
#define MINOR_SUBSYSTEMREBOOT           0xa0    /*Video integrated platform: dm6467 normal reboot*/
#define MINOR_MATRIX_STARTTRANSFERVIDEO 0xa1    /*Video integrated platform: Matrix Switch start transmitting images*/
#define MINOR_MATRIX_STOPTRANSFERVIDEO    0xa2    /*Video integrated platform: Matrix Switching to stop transmission of images*/
#define MINOR_REMOTE_SET_ALLSUBSYSTEM   0xa3    /*Video integrated platform: Set all the 6467 sub- systems of information*/
#define MINOR_REMOTE_GET_ALLSUBSYSTEM   0xa4    /*Video integrated platform: Get all the 6467 sub- systems of information*/
#define MINOR_REMOTE_SET_PLANARRAY      0xa5    /*Video integrated platform: Set plan array*/
#define MINOR_REMOTE_GET_PLANARRAY      0xa6    /*Video integrated platform: Get plan array*/
#define MINOR_MATRIX_STARTTRANSFERAUDIO 0xa7    /*Video integrated platform: Start transmission Audio Matrix Switch */
#define MINOR_MATRIX_STOPRANSFERAUDIO   0xa8    /*Video integrated platform: Stop transmission Audio Matrix Switch*/
#define MINOR_LOGON_CODESPITTER         0xa9    /*Video integrated platform: Logon spitter code*/
#define MINOR_LOGOFF_CODESPITTER        0xaa    /*Video integrated platform: Logoff spitter code*/
//2010- 01- 22 Add Video integrated platform Log Type
#define MINOR_START_DYNAMIC_DECODE         0xb0    /*Start dynamic decode*/
#define MINOR_STOP_DYNAMIC_DECODE        0xb1    /*Stop dynamic decode*/
#define MINOR_GET_CYC_CFG                0xb2    /*Get cycle config*/
#define MINOR_SET_CYC_CFG                0xb3    /*Set cycle config*/
#define MINOR_START_CYC_DECODE            0xb4    /*Start cycle decode*/
#define MINOR_STOP_CYC_DECODE            0xb5    /*Stop cycle decode*/
#define MINOR_GET_DECCHAN_STATUS        0xb6    /*Get decode channel status*/
#define MINOR_GET_DECCHAN_INFO            0xb7    /*Get decode channel information*/
#define MINOR_START_PASSIVE_DEC            0xb8    /*Start passive*/
#define MINOR_STOP_PASSIVE_DEC            0xb9    /*Stop passive decode*/
#define MINOR_CTRL_PASSIVE_DEC            0xba    /*Passive decode control*/
#define MINOR_RECON_PASSIVE_DEC            0xbb    /*Passive decode reconnect*/
#define MINOR_GET_DEC_CHAN_SW            0xbc    /*Get decode channel switch*/
#define MINOR_SET_DEC_CHAN_SW            0xbd    /*Set decode channel switch*/
#define MINOR_CTRL_DEC_CHAN_SCALE        0xbe    /*Decode channel scale control*/
#define MINOR_SET_REMOTE_REPLAY            0xbf    /*Set remote replay*/
#define MINOR_GET_REMOTE_REPLAY            0xc0    /*Get remote replay*/
#define MINOR_CTRL_REMOTE_REPLAY        0xc1    /*Remote replay control*/
#define MINOR_SET_DISP_CFG                0xc2    /*Set display config*/
#define MINOR_GET_DISP_CFG                0xc3    /*Get display config*/
#define MINOR_SET_PLANTABLE                0xc4    /*Set plan table*/
#define MINOR_GET_PLANTABLE                0xc5    /*Get plan table*/
#define MINOR_START_PPPPOE                0xc6    /*Start pppoe*/
#define MINOR_STOP_PPPPOE                0xc7    /*Stop pppoe*/
#define MINOR_UPLOAD_LOGO                0xc8    /*Upload logo*/

#define MINOR_LOCAL_PIN                    0xc9    /* local PIN operation*/
#define MINOR_LOCAL_DIAL                0xca    /* local manual disconnect dialing*/    
#define MINOR_SMS_CONTROL                0xcb    /* SMS control on line/off line*/    
#define MINOR_CALL_ONLINE                0xcc    /* call control on line*/    
#define MINOR_REMOTE_PIN                0xcd    /* remote PIN operation*/

#define MINOR_REMOTE_BYPASS             0xd0    
#define MINOR_REMOTE_UNBYPASS           0xd1    
#define MINOR_REMOTE_SET_ALARMIN_CFG    0xd2    
#define MINOR_REMOTE_GET_ALARMIN_CFG    0xd3    
#define MINOR_REMOTE_SET_ALARMOUT_CFG   0xd4    
#define MINOR_REMOTE_GET_ALARMOUT_CFG   0xd5    
#define MINOR_REMOTE_ALARMOUT_OPEN_MAN  0xd6    /* remote mamual open alarmout */
#define MINOR_REMOTE_ALARMOUT_CLOSE_MAN 0xd7    /* remote mamual close alarmout*/
#define MINOR_DELETE_LOGO               0xdd    /* delete logo */
#define MINOR_REMOTE_INQUEST_DEL_FILE   0xde 

#define MINOR_LOCAL_CONF_REB_RAID       0x101           /*Rebuild configuration automatically and locally*/
#define MINOR_LOCAL_CONF_SPARE          0x102           /*Hot spare of local configuration*/
#define MINOR_LOCAL_ADD_RAID            0x103           /*Add RAID locally*/
#define MINOR_LOCAL_DEL_RAID            0x104           /*Delete RAID locally*/
#define MINOR_LOCAL_MIG_RAID            0x105           /*Migrate RAID locally*/
#define MINOR_LOCAL_REB_RAID            0x106           /*Rebuild RAID manually and locally*/
#define MINOR_LOCAL_QUICK_CONF_RAID     0x107           /*Quick local configuration by one key*/
#define MINOR_LOCAL_ADD_VD              0x108           /*Add visual disk locally*/
#define MINOR_LOCAL_DEL_VD              0x109           /*Delete visual disk locally*/
#define MINOR_LOCAL_RP_VD               0x10a           /*Repair visual disk locally*/
#define MINOR_LOCAL_FORMAT_EXPANDVD     0X10b           /*Expand volume of visual disk locally*/
#define MINOR_LOCAL_RAID_UPGRADE        0X10c           /*Upgrade RAID locally*/
#define MINOR_LOCAL_STOP_RAID           0x10d           /*Local stop RAID*/

#define MINOR_REMOTE_CONF_REB_RAID      0x111           /*Rebuild configuration automatically and remotely*/
#define MINOR_REMOTE_CONF_SPARE         0x112           /*Hot spare of remote configuration*/
#define MINOR_REMOTE_ADD_RAID           0x113           /*Add RAID remotely*/
#define MINOR_REMOTE_DEL_RAID           0x114           /*Delete RAID remotely*/
#define MINOR_REMOTE_MIG_RAID           0x115           /*Migrate RAID remotely*/
#define MINOR_REMOTE_REB_RAID           0x116           /*Rebuild RAID manually and remotely*/
#define MINOR_REMOTE_QUICK_CONF_RAID    0x117           /*Quick remote configuration by one key*/
#define MINOR_REMOTE_ADD_VD             0x118           /*Add visual disk remotely*/
#define MINOR_REMOTE_DEL_VD             0x119           /*Delete visual disk remotely*/
#define MINOR_REMOTE_RP_VD              0x11a           /*Repair visual disk remotely*/
#define MINOR_REMOTE_FORMAT_EXPANDVD    0X11b           /*Expand volume of visual disk remotely*/
#define MINOR_REMOTE_RAID_UPGRADE       0X11c           /*Upgrade RAID remotely*/  
#define MINOR_REMOTE_STOP_RAID          0x11d           /*Remote stop RAID*/

#define MINOR_LOCAL_START_PIC_REC        0x121           /*local start snapshot*/ 
#define MINOR_LOCAL_STOP_PIC_REC        0x122           /*local stop snapshot*/
#define MINOR_LOCAL_SET_SNMP            0x125           /*local set SNMP*/
#define MINOR_LOCAL_TAG_OPT                0x126           /*local operate label*/
#define MINOR_REMOTE_START_PIC_REC        0x131           /*remote start snapshot*/
#define MINOR_REMOTE_STOP_PIC_REC        0x132           /*remote stop snapshot*/
#define MINOR_REMOTE_SET_SNMP            0x135           /*remote set SNMP*/
#define MINOR_REMOTE_TAG_OPT            0x136           /*remote operate label*/  
#define MINOR_REMOTE_LOGIN_LOCK         0x137           //remote login lock
#define MINOR_REMOTE_LOGIN_UNLOCK       0x138          //remote login unlock
// 9000 v2.2.0
#define MINOR_LOCAL_VOUT_SWITCH         0x140    /* local video out switch*/
#define MINOR_STREAM_CABAC                 0x141    /* stream cabac configuration*/


//Netra 3.0.0
#define MINOR_LOCAL_SPARE_OPT           0x142   /*Local spare opration*/
#define MINOR_REMOTE_SPARE_OPT            0x143   /*Remote spare opration*/
#define MINOR_LOCAL_IPCCFGFILE_OUTPUT    0x144      /*Local export ipc config file*/
#define MINOR_LOCAL_IPCCFGFILE_INPUT      0x145   /*Local import ipc config file */
#define MINOR_LOCAL_IPC_UPGRADE         0x146   /*Local ipc upgrade */
#define MINOR_REMOTE_IPCCFGFILE_OUTPUT  0x147   /*Remote export ipc config file*/
#define MINOR_REMOTE_IPCCFGFILE_INPUT   0x148   /*Remote import ipc config file*/
#define MINOR_REMOTE_IPC_UPGRADE        0x149   /*Remote ipc upgrade*/

#define MINOR_LOCAL_UNLOAD_HDISK        0x150     /*Local unload hdisk*/
#define MINOR_LOCAL_AUDIO_MIX           0x151     /*Local audio mix*/
#define MINOR_REMOTE_AUDIO_MIX          0x152     /*Remote audio mix*/
#define MINOR_LOCAL_TRIAL_PAUSE         0x153     /*Local inquest pause*/
#define MINOR_LOCAL_TRIAL_RESUME        0x154     /*Local inquest resume*/
#define MINOR_REMOTE_TRIAL_PAUSE        0x155     /*Remote inquest paus*/
#define MINOR_REMOTE_TRIAL_RESUME       0x156     /*Remote inquest resume*/
#define MINOR_REMOTE_MODIFY_VERIFICATION_CODE   0x157 /*modify Remote verification code*/

#define MINOR_LOCAL_MAKECALL            0x180          /*Local make call*/
#define MINOR_LOCAL_REJECTCALL          0x181          /*Local reject call*/
#define MINOR_LOCAL_ANSWERCALL          0x182          /*Local answer call*/
#define MINOR_LOCAL_HANGUPCALL          0x183          /*Local hang up call*/

#define MINOR_REMOTE_MAKECALL           0x188          /*Remote make call*/
#define MINOR_REMOTE_REJECTCALL         0x189          /*Remote reject call*/
#define MINOR_REMOTE_ANSWERCALL         0x18a          /*Remote answer call*/
#define MINOR_REMOTE_HANGUPCALL         0x18b          /*Remote hang up call*/

#define MINOR_LOCAL_CHANNEL_ORDERED         0x19b          /*Local channel sorting*/

#define MINOR_SET_MULTI_MASTER          0x201    /*set multi master*/
#define MINOR_SET_MULTI_SLAVE           0x202    /*set multi slave*/
#define MINOR_CANCEL_MULTI_MASTER       0x203    /*cancel multi master*/
#define MINOR_CANCEL_MULTI_SLAVE        0x204    /*cancel multi slave*/

#define MINOR_DISPLAY_LOGO                0x205    /*display LOGO*/
#define MINOR_HIDE_LOGO                 0x206    /*hide LOGO*/
#define MINOR_SET_DEC_DELAY_LEVEL       0x207    /*set delay level of decode*/
#define MINOR_SET_BIGSCREEN_DIPLAY_AREA 0x208    /*set big screen display area*/
#define MINOR_CUT_VIDEO_SOURCE          0x209    /*cut video source*/
#define MINOR_SET_BASEMAP_AREA          0x210    /*set basemap area*/
#define MINOR_DOWNLOAD_BASEMAP          0x211    /*download basemap*/
#define MINOR_CUT_BASEMAP               0x212    /*cut basemap*/
#define MINOR_CONTROL_ELEC_ENLARGE      0x213    /*control electronic amplification*/
#define MINOR_SET_OUTPUT_RESOLUTION     0x214    /*set output resolution*/
#define MINOR_SET_TRANCSPARENCY         0X215    /*set layer transparency*/
#define MINOR_SET_OSD                   0x216    /*set OSD*/
#define MINOR_RESTORE_DEC_STATUS        0x217    /*restore decode status after switching scene*/
#define MINOR_SCREEN_OPEN_SCREEN        0x218   //open screen
#define MINOR_SCREEN_CLOSE_SCREEN       0x219   //close screen
#define MINOR_SCREEN_SWITCH_SIGNAL      0x21a   //switch signal
#define MINOR_SCREEN_MODIFY_NETWORK     0x21b   //configure network parameters
#define MINOR_SCREEN_MODIFY_LEDRES      0x21c   //configure output LED resolution
#define MINOR_SCREEN_SHOW_NORMAL        0x21d   //configure window normal show module
#define MINOR_SCREEN_SHOW_TILE          0x21e   //configure window tile show module
#define MINOR_SCREEN_DEC_NORMAL         0x21f   //configure normal decode module
#define MINOR_SCREEN_DEC_LOWLATENCY     0x220   //configure low latency decode module
#define MINOR_SCREEN_MODIFY_SELFRES     0x221   //configure signal self-define resolution
#define MINOR_SCREEN_OUTPUT_POSITION    0x222   //configure ouput channel position
#define MINOR_SCREEN_IMAGE_ENHANCE      0x223   //image enhance
#define MINOR_SCREEN_JOIN_SIGNAL        0x224   //signal join
#define MINOR_SCREEN_SIGNAL_OSD         0x225   //signal OSD
#define MINOR_SCREEN_ASSOCIATED_INTERACTION 0x226   //signal associateed to interactive server
#define MINOR_SCREEN_MODIFY_MATRIX      0x227   //configure matrix
#define MINOR_SCREEN_WND_TOP_KEEP       0x228   //window top keep
#define MINOR_SCREEN_WND_OPEN_KEEP      0x229   //window open keep
#define MINOR_SCREEN_WALL_MIRROR        0x22a   //video wall area mirror
#define MINOR_SCREEN_UPLOAD_BASEMAP     0x22b   //upload basemap
#define MINOR_SCREEN_SHOW_BASEMAP       0x22c   //show basemap
#define MINOR_SCREEN_HIDE_BASEMAP       0x22d   //hide basemap
#define MINOR_SCREEN_MODIFY_SERIAL      0x22e   //configure serial port

#define MINOR_SCREEN_SET_INPUT            0x251    /*set input signal*/
#define MINOR_SCREEN_SET_OUTPUT            0x252    /*set output channel*/
#define MINOR_SCREEN_SET_OSD            0x253    /*set virtual LED*/
#define MINOR_SCREEN_SET_LOGO            0x254    /*set LOGO*/
#define MINOR_SCREEN_SET_LAYOUT            0x255    /*set layout*/
#define    MINOR_SCREEN_PICTUREPREVIEW        0x256     /*picture preview*/

#define MINOR_SCREEN_GET_OSD            0x257   /*get virtual LED*/
#define MINOR_SCREEN_GET_LAYOUT            0x258   /*get layout*/
#define MINOR_SCREEN_LAYOUT_CTRL        0x259   /*layout control*/
#define MINOR_GET_ALL_VALID_WND            0x260    /*get all valid window*/
#define MINOR_GET_SIGNAL_WND            0x261    /*get single window information*/
#define MINOR_WINDOW_CTRL                0x262    /*window control*/
#define MINOR_GET_LAYOUT_LIST            0x263    /*get layout list*/
#define MINOR_LAYOUT_CTRL                0x264    /*layout control*/
#define MINOR_SET_LAYOUT                0x265    /*set single layout*/
#define MINOR_GET_SIGNAL_LIST            0x266    /*get input signal list*/
#define MINOR_GET_PLAN_LIST                0x267    /*get plan list*/
#define MINOR_SET_PLAN                    0x268    /*set plan*/
#define MINOR_CTRL_PLAN                    0x269    /*plan control*/
#define MINOR_CTRL_SCREEN                0x270    /*screen control*/
#define MINOR_ADD_NETSIG                0x271    /*add net signal*/
#define MINOR_SET_NETSIG                0x272    /*mod net signal*/
#define MINOR_SET_DECBDCFG                0x273    /*set decoder parameter*/
#define MINOR_GET_DECBDCFG                0x274    /*get decoder parameter*/
#define MINOR_GET_DEVICE_STATUS            0x275    /*get device status*/
#define MINOR_UPLOAD_PICTURE            0x276    /*upload picture*/
#define MINOR_SET_USERPWD                0x277    /*set user name and password*/
#define MINOR_ADD_LAYOUT                0x278    /*add layout*/
#define MINOR_DEL_LAYOUT                0x279    /*delete layout*/
#define MINOR_DEL_NETSIG                0x280    /*delete net signal*/
#define MINOR_ADD_PLAN                    0x281    /*add plan*/
#define MINOR_DEL_PLAN                    0x282    /*delete plan*/
#define MINOR_GET_EXTERNAL_MATRIX_CFG    0x283    //get external matrix config
#define MINOR_SET_EXTERNAL_MATRIX_CFG    0x284    //set external matrix config
#define    MINOR_GET_USER_CFG                0x285    //get user config
#define    MINOR_SET_USER_CFG                0x286    //set user config
#define    MINOR_GET_DISPLAY_PANEL_LINK_CFG 0x287    //get display panel link config
#define    MINOR_SET_DISPLAY_PANEL_LINK_CFG 0x288    //set display panel link config
#define    MINOR_GET_WALLSCENE_PARAM    0x289        //get scene parameter
#define    MINOR_SET_WALLSCENE_PARAM    0x28a        //set scene parameter
#define    MINOR_GET_CURRENT_WALLSCENE        0x28b        //get current scene
#define    MINOR_SWITCH_WALLSCENE            0x28c        //switch scene
#define    MINOR_SIP_LOGIN                    0x28d        //SIP login
#define MINOR_VOIP_START                0x28e        //VOIP start
#define MINOR_VOIP_STOP                    0x28f        //VOIP stop
#define MINOR_WIN_TOP                   0x290       //move video wall window to top layer 
#define MINOR_WIN_BOTTOM                0x291       //move video wall window to bottom layer
#define MINOR_SET_USER_ADD_CFG                0x292    //add user
#define MINOR_SET_USER_MODF_CFG                0x293    //mod user
#define MINOR_SET_USER_DEL_CFG                0x294    //delete user

//Netra 2.2.2
#define MINOR_LOCAL_LOAD_HDISK          0x300            //Load hard disk          
#define MINOR_LOCAL_DELETE_HDISK        0x301            //Delete Hard disk

//KY2013 3.0.0
#define MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH    0X302 //Local main and auxiliary port switch
#define MINOR_LOCAL_HARD_DISK_CHECK                0x303 //Local hard disk check

//Netra3.1.0
#define MINOR_LOCAL_CFG_DEVICE_TYPE        0x310    //local cfg dev type
#define MINOR_REMOTE_CFG_DEVICE_TYPE    0x311    //remote cfg dev type
#define MINOR_LOCAL_CFG_WORK_HOT_SERVER    0x312    //local cfg work hot server
#define MINOR_REMOTE_CFG_WORK_HOT_SERVER    0x313    //remote cfg work hot server
#define MINOR_LOCAL_DELETE_WORK            0x314    //local delete work
#define MINOR_REMOTE_DELETE_WORK        0x315    //remote delete work
#define    MINOR_LOCAL_ADD_WORK            0x316    //local add work
#define MINOR_REMOTE_ADD_WORK            0x317    //remote add work
#define MINOR_LOCAL_IPCHEATMAP_OUTPUT   0x318   //local Ip cheatmap output
#define MINOR_LOCAL_IPCHEATFLOW_OUTPUT  0x319   //local Ip cheatflow output
#define MINOR_REMOTE_SMS_SEND           0x350    /*remote send sms*/
#define MINOR_LOCAL_SMS_SEND            0x351   /*local  send sms*/
#define MINOR_ALARM_SMS_SEND            0x352   
#define MINOR_SMS_RECV                  0x353    
#define MINOR_LOCAL_SMS_SEARCH          0x354  /*Local Search SMS*/
#define MINOR_REMOTE_SMS_SEARCH         0x355   /*Remote Search SMS*/
#define MINOR_LOCAL_SMS_READ            0x356   /*local read SMS*/
#define MINOR_REMOTE_SMS_READ           0x357   /*Remote read SMS*/
#define MINOR_REMOTE_DIAL_CONNECT       0x358   /*Remote Dial */
#define MINOR_REMOTE_DIAL_DISCONN       0x359   /*Remote Disconnect Dial*/
#define MINOR_LOCAL_ALLOWLIST_SET       0x35A   /*local Allow list CFG*/
#define MINOR_REMOTE_ALLOWLIST_SET      0x35B   /*Remote Allow list CFG*/
#define MINOR_LOCAL_DIAL_PARA_SET       0x35C   /*local Dial Alarm CFG*/
#define MINOR_REMOTE_DIAL_PARA_SET      0x35D   /*Remote Dial Alarm CFG*/
#define MINOR_LOCAL_DIAL_SCHEDULE_SET   0x35E   /*local dial schedule CFG*/
#define MINOR_REMOTE_DIAL_SCHEDULE_SET  0x35F   /*Remote dial schedule CFG*/
#define MINOR_PLAT_OPER                 0x360   /*plat operation*/
#define MINOR_REMOTE_CFG_POE_WORK_MODE  0x361   //Remote poe work mode cfg
#define MINOR_LOCAL_CFG_POE_WORK_MODE   0x362   //Local poe work mode cfg
#define MINOR_REMOTE_CFG_FACE_CONTRAST  0x363   //Remote face contrast cfg
#define MINOR_LOCAL_CFG_FACE_CONTRAST   0x364   //Local face contrast cfg
#define MINOR_REMOTE_CFG_ALLOWLIST_FACE_CONTRAST   0x365//Remote Allow list face contrast cfg
#define MINOR_LOCAL_CFG_ALLOWLIST_FACE_CONTRAST    0x366//Local Allow list face contrast cfg
#define MINOR_LOCAL_CHECK_TIME          0x367   //Local manual timing
#define MINOR_VCA_ONEKEY_EXPORT_PICTURE 0x368 //One key export picture
#define MINOR_VCA_ONEKEY_DELETE_PICTURE 0x369 //One key delete picture
#define MINOR_VCA_ONEKEY_EXPORT_VIDEO   0x36a //One key export video
#define MINOR_VCA_ONEKEY_DELETE_VIDEO   0x36b //One key delete video
#define MINOR_REMOTE_CFG_WIRELESS_DIALPARAM 0x36c /* Remote configuration of wireless dialing parameters*/
#define MINOR_LOCAL_CFG_WIRELESS_DIALPARAM  0x36d /*Local configuration of wireless dialing parameters*/
#define MINOR_REMOTE_CFG_WIRELESS_SMSPARAM  0x36e /*Remote configuration of wireless SMS*/
#define MINOR_LOCAL_CFG_WIRELESS_SMSPARAM   0x36f /*Local configuration of wireless SMS*/
#define MINOR_REMOTE_CFG_WIRELESS_SMSSElFHELP  0x370 /*Remote configuration of wireless SMS self-help configuration parameters*/
#define MINOR_LOCAL_CFG_WIRELESS_SMSSElFHELP   0x371 /*Local configuration of wireless SMS self-configuration parameters*/
#define MINOR_REMOTE_CFG_WIRELESS_NETFLOWPARAM 0x372 /*Remote configuration of wireless traffic*/
#define MINOR_LOCAL_CFG_WIRELESS_NETFLOWPARAM  0x373 /*Local configuration of wireless traffic*/

//0x400-0x1000 ACS operator type
#define MINOR_REMOTE_OPEN_DOOR          0x400   //remote open door 
#define MINOR_REMOTE_CLOSE_DOOR         0x401   //remote close door (controlled)
#define MINOR_REMOTE_ALWAYS_OPEN        0x402   //remote always open door (free)
#define MINOR_REMOTE_ALWAYS_CLOSE       0x403   //remote always close door (forbiden)
#define MINOR_REMOTE_CHECK_TIME         0x404   //remote check time 
#define MINOR_NTP_CHECK_TIME            0x405   //ntp check time 
#define MINOR_REMOTE_CLEAR_CARD         0x406   //remote clear card
#define MINOR_REMOTE_RESTORE_CFG        0x407   //remote restore configure 
#define MINOR_ALARMIN_ARM               0x408   //alarm in arm 
#define MINOR_ALARMIN_DISARM            0x409   //alarm in disarm
#define MINOR_LOCAL_RESTORE_CFG         0x40a   //local configure restore
#define MINOR_REMOTE_CAPTURE_PIC        0x40b  //remote capture picture
#define MINOR_MOD_NET_REPORT_CFG        0x40c   //modify net report cfg
#define MINOR_MOD_GPRS_REPORT_PARAM     0x40d   //modify GPRS report param
#define MINOR_MOD_REPORT_GROUP_PARAM    0x40e   //modify report group param
#define    MINOR_UNLOCK_PASSWORD_OPEN_DOOR  0x40f  //unlock password open door
#define MINOR_AUTO_RENUMBER              0x410  //auto renumber
#define MINOR_AUTO_COMPLEMENT_NUMBER     0x411  //auto complement number
#define MINOR_NORMAL_CFGFILE_INPUT          0x412   //normal cfg file input
#define MINOR_NORMAL_CFGFILE_OUTTPUT     0x413   //normal cfg file output
#define MINOR_CARD_RIGHT_INPUT              0x414   //card right input
#define MINOR_CARD_RIGHT_OUTTPUT          0x415   //card right output
#define MINOR_LOCAL_USB_UPGRADE             0x416   //local USB upgrade
#define MINOR_REMOTE_VISITOR_CALL_LADDER     0x417  //visitor call ladder
#define MINOR_REMOTE_HOUSEHOLD_CALL_LADDER   0x418  //household call ladder
#define MINOR_REMOTE_ACTUAL_GUARD            0x419  //remote actual guard
#define MINOR_REMOTE_ACTUAL_UNGUARD          0x41a  //remote actual unguard
#define MINOR_REMOTE_CONTROL_NOT_CODE_OPER_FAILED     0x41b   //remote control not code operate failed
#define MINOR_REMOTE_CONTROL_CLOSE_DOOR               0x41c   //remote control close door
#define MINOR_REMOTE_CONTROL_OPEN_DOOR                0x41d   //remote control open door
#define MINOR_REMOTE_CONTROL_ALWAYS_OPEN_DOOR         0x41e   //remote control always open door
#define MINOR_M1_CARD_ENCRYPT_VERIFY_OPEN             0x41f   //M1 card encrypt verify open
#define MINOR_M1_CARD_ENCRYPT_VERIFY_CLOSE            0x420   //M1 card encrypt verify close
#define MINOR_NFC_FUNCTION_OPEN        0x421  //NFC function open
#define MINOR_NFC_FUNCTION_CLOSE       0x422  //NFC function close
#define MINOR_OFFLINE_DATA_OUTPUT         0x423    //export
//
#define MINOR_CREATE_SSH_LINK                         0x42d     //ssh connected
#define MINOR_CLOSE_SSH_LINK                          0x42e     //ssh closed
#define MINOR_LOCAL_IMPORT_USERINFO         0x42f     
#define MINOR_LOCAL_EXPORT_USERINFO    0x430      
#define MINOR_CREATE_CERTIFICATE     0x431     
#define MINOR_UPLOAD_CERTIFICATE      0x432     
#define MINOR_DELETE_CERTIFICATE     0x433    
#define MINOR_COMSUME_ARM                          0x434    
#define MINOR_COMSUME_DISARM                       0x435      

#define MINOR_OPERATION_CUSTOM1        0x900  //operation custom 1
#define MINOR_OPERATION_CUSTOM2        0x901  //operation custom 2
#define MINOR_OPERATION_CUSTOM3        0x902  //operation custom 3
#define MINOR_OPERATION_CUSTOM4        0x903  //operation custom 4
#define MINOR_OPERATION_CUSTOM5        0x904  //operation custom 5
#define MINOR_OPERATION_CUSTOM6        0x905  //operation custom 6
#define MINOR_OPERATION_CUSTOM7        0x906  //operation custom 7
#define MINOR_OPERATION_CUSTOM8        0x907  //operation custom 8
#define MINOR_OPERATION_CUSTOM9        0x908  //operation custom 9
#define MINOR_OPERATION_CUSTOM10       0x909  //operation custom 10
#define MINOR_OPERATION_CUSTOM11       0x90a  //operation custom 11
#define MINOR_OPERATION_CUSTOM12       0x90b  //operation custom 12
#define MINOR_OPERATION_CUSTOM13       0x90c  //operation custom 13
#define MINOR_OPERATION_CUSTOM14       0x90d  //operation custom 14
#define MINOR_OPERATION_CUSTOM15       0x90e  //operation custom 15
#define MINOR_OPERATION_CUSTOM16       0x90f  //operation custom 16
#define MINOR_OPERATION_CUSTOM17       0x910  //operation custom 17
#define MINOR_OPERATION_CUSTOM18       0x911  //operation custom 18
#define MINOR_OPERATION_CUSTOM19       0x912  //operation custom 19
#define MINOR_OPERATION_CUSTOM20       0x913  //operation custom 20
#define MINOR_OPERATION_CUSTOM21       0x914  //operation custom 21
#define MINOR_OPERATION_CUSTOM22       0x915  //operation custom 22
#define MINOR_OPERATION_CUSTOM23       0x916  //operation custom 23
#define MINOR_OPERATION_CUSTOM24       0x917  //operation custom 24
#define MINOR_OPERATION_CUSTOM25       0x918  //operation custom 25
#define MINOR_OPERATION_CUSTOM26       0x919  //operation custom 26
#define MINOR_OPERATION_CUSTOM27       0x91a  //operation custom 27
#define MINOR_OPERATION_CUSTOM28       0x91b  //operation custom 28
#define MINOR_OPERATION_CUSTOM29       0x91c  //operation custom 29
#define MINOR_OPERATION_CUSTOM30       0x91d  //operation custom 30
#define MINOR_OPERATION_CUSTOM31       0x91e  //operation custom 31
#define MINOR_OPERATION_CUSTOM32       0x91f  //operation custom 32
#define MINOR_OPERATION_CUSTOM33       0x920  //operation custom 33
#define MINOR_OPERATION_CUSTOM34       0x921  //operation custom 34
#define MINOR_OPERATION_CUSTOM35       0x922  //operation custom 35
#define MINOR_OPERATION_CUSTOM36       0x923  //operation custom 36
#define MINOR_OPERATION_CUSTOM37       0x924  //operation custom 37
#define MINOR_OPERATION_CUSTOM38       0x925  //operation custom 38
#define MINOR_OPERATION_CUSTOM39       0x926  //operation custom 39
#define MINOR_OPERATION_CUSTOM40       0x927  //operation custom 40
#define MINOR_OPERATION_CUSTOM41       0x928  //operation custom 41
#define MINOR_OPERATION_CUSTOM42       0x929  //operation custom 42
#define MINOR_OPERATION_CUSTOM43       0x92a  //operation custom 43
#define MINOR_OPERATION_CUSTOM44       0x92b  //operation custom 44
#define MINOR_OPERATION_CUSTOM45       0x92c  //operation custom 45
#define MINOR_OPERATION_CUSTOM46       0x92d  //operation custom 46
#define MINOR_OPERATION_CUSTOM47       0x92e  //operation custom 47
#define MINOR_OPERATION_CUSTOM48       0x92f  //operation custom 48
#define MINOR_OPERATION_CUSTOM49       0x930  //operation custom 49
#define MINOR_OPERATION_CUSTOM50       0x931  //operation custom 50
#define MINOR_OPERATION_CUSTOM51       0x932  //operation custom 51
#define MINOR_OPERATION_CUSTOM52       0x933  //operation custom 52
#define MINOR_OPERATION_CUSTOM53       0x934  //operation custom 53
#define MINOR_OPERATION_CUSTOM54       0x935  //operation custom 54
#define MINOR_OPERATION_CUSTOM55       0x936  //operation custom 55
#define MINOR_OPERATION_CUSTOM56       0x937  //operation custom 56
#define MINOR_OPERATION_CUSTOM57       0x938  //operation custom 57
#define MINOR_OPERATION_CUSTOM58       0x939  //operation custom 58
#define MINOR_OPERATION_CUSTOM59       0x93a  //operation custom 59
#define MINOR_OPERATION_CUSTOM60       0x93b  //operation custom 60
#define MINOR_OPERATION_CUSTOM61       0x93c  //operation custom 61
#define MINOR_OPERATION_CUSTOM62       0x93d  //operation custom 62
#define MINOR_OPERATION_CUSTOM63       0x93e  //operation custom 63
#define MINOR_OPERATION_CUSTOM64       0x93f  //operation custom 64
#define MINOR_OPERATION_REALTIMEBROADCAST   0x940 
#define MINOR_OPERATION_PLANBROADCAST       0x941 

#define MINOR_SET_WIFI_PARAMETER               0x950
#define MINOR_EZVIZ_LOGIN                      0x951
#define MINOR_EZVIZ_LOGINOUT                   0x952
#define MINOR_LOCK_ADD                         0x953
#define MINOR_LOCK_DELETE                      0x954 
#define MINOR_LOCK_GET_STATUS                  0x955 
#define MINOR_LOCK_SET_TMP_PASSWORD            0x956 
#define MINOR_LOCK_SET_SILENT_MODE             0x957 
#define MINOR_LOCK_SET_LATE_WARNING            0x958  
#define MINOR_LOCK_IPC_ADD                     0x959 
#define MINOR_LOCK_IPC_REMOVE                  0x95a 
#define MINOR_LOCK_DETECTOR_ADD                0x95b 
#define MINOR_LOCK_DETECTOR_REMOVE             0x95c 
#define MINOR_LOCK_MESSAGE_REMINDING_OPEN      0x95d 
#define MINOR_LOCK_MESSAGE_REMINDING_CLOSE     0x95e 
#define MINOR_LOCK_SET_HEART_BEAT              0x95f 
#define MINOR_LOCK_REBOOT                      0x960 
#define MINOR_LOCK_CLEAR_USER                  0x961 
#define MINOR_LOCK_FORMAT                      0x962 
#define MINOR_LOCK_FINGER_CHANGE               0x963 
#define MINOR_LOCK_PASSWORD_CHANGE             0x964 
#define MINOR_LOCK_CARD_CHANGE                 0x965 
#define MINOR_LOCK_USER_CHANGE                 0x966 
#define MINOR_LOCK_SYSTEM_CHANGE               0x967 
#define MINOR_LOCK_CHANGE_ADD_UESR             0x968 
#define MINOR_LOCK_CHANGE_DEL_UESR             0x969 
#define MINOR_LOCK_CHANGE_CUSTOM_USER_NAME     0x96a 
#define MINOR_LOCK_CHANGE_REMOTE_DEVICE        0x96b 
#define MINOR_LOCK_CHANGE_ADD_FP               0x96c 
#define MINOR_LOCK_CHANGE_DEL_FP               0x96d 
#define MINOR_LOCK_CHANGE_ADD_PASSWORD         0x96e 
#define MINOR_LOCK_CHANGE_DEL_PASSWORD         0x96f
#define MINOR_LOCK_CHANGE_ADD_CARD             0x970
#define MINOR_LOCK_CHANGE_DEL_CARD             0x971
#define MINOR_LOCK_NETWORK_SWITCH              0x972 
#define MINOR_LOCK_CLEAR_NETWORK_DATA          0x973  
#define MINOR_LOCK_CLEAR_HOST_USER             0x974  
#define MINOR_LOCK_CLEAR_GUEST_USER            0x975  
#define MINOR_LOCK_CLEAN_ALL_REMOTE_DEVICE     0x976   
#define MINOR_LOCK_CLEAN_NORMAL_USER_FINGRT    0x977    
#define MINOR_LOCK_CLEAN_ALL_CARD              0x978    
#define MINOR_LOCK_CLEAN_ALL_PASSWORD          0x979   
#define MINOR_START_WIRELESSSERVER             0x97a    
#define MINOR_STOP_WIRELESSSERVER              0x97b    
#define MINOR_EMERGENCY_CARD_AUTH_NORMAL_CARD  0x97c
#define MINOR_CHANGE_ALWAYS_OPEN_RIGHT         0x97d
#define MINOR_LOCK_DOOR_BELL_EVENT             0x97e

//transfer display info publish device
#define MINOR_BACKUP_DATA                           0xc41  //data backup
#define MINOR_TRANSFER_DATA                         0xc42  //data transfer
#define MINOR_RESTORE_DATA                          0xc43  //data restore
#define MINOR_SET_INPUT_PLAN                        0xc44 //set terminal input plan
#define MINOR_TERMINAL_ADB                          0xc45//terminal adb config
#define MINOR_TERMINAL_VOLUME                       0xc46  //terminal volume config
#define MINOR_TERMINAL_LOGO                         0xc47 //terminal logo config
#define MINOR_TERMINAL_DEFAULT_SCHEDULE             0xc48 //default schedule config
#define MINOR_TERMINAL_PASSWORD                     0xc49 //terminal password
#define MINOR_TERMINAL_IP                           0xc4a//terminal ip config
#define MINOR_TERMINAL_RELATE_IPC                   0xc4b//terminal relate IPC
#define MINOR_TERMINAL_SERVER                       0xc4c//terminal server config
#define MINOR_TERMINAL_SADP                         0xc4d//terminal sadp config
#define MINOR_TERMINAL_TIMEZONE                     0xc4e//terminal timezone config
#define MINOR_TERMINAL_TEMP_PROTECT                 0xc4f//terminal temperature protect
#define MINOR_ADD_ORGANIZATION                      0xc50 //add organization
#define MINOR_DELETE_ORGANIZATION                   0xc51 //delete organization
#define MINOR_MODIFY_ORGANIZATION                   0xc52 //modify organization
#define MINOR_WEATHER_FACTORY                       0xc53 //weather factory 
#define MINOR_SADP_ENABLE                           0xc54 //sadp enable
#define MINOR_SSH_ENABLE                            0xc55 //SSH enable
#define MINOR_MODIFY_MATERIAL                       0xc56 //modify material 
#define MINOR_INSERT_CHARACTER                      0xc57 //insert character
#define MINOR_TERMINAL_BACKLIGHT                    0xc58 //config terminal backlight
#define MINOR_DOWNLOAD_MATERIAL_THUMBNAIL           0xc59//download Material Thumbnail
#define MINOR_UPLOAD_PROGRAM_THUMBNAIL              0xc5a//upload Program Thumbnail
#define MINOR_TDOWNLOAD_PROGRAM_THUMBNAIL           0xc5b//download Program Thumbnail
#define MINOR_BATCH_DELETE_SCHEDULE_PLAN            0xc5c//batch Delete SchedulePlan
#define MINOR_REPUBLISH                             0xc5d//rePublish
#define MINOR_CLEAR_TERMINAL_PLAY_INFO              0xc5e//clear PlayI nfo
#define MINOR_GET_TERMINAL_RESOLUTION               0xc5f//get Terminal Resolution
#define MINOR_SET_TERMINAL_RESOLUTION               0xc60//set Terminal Resolution
#define MINOR_GET_BATCH_TERMINAL_UPGRATE_PROGRESS   0xc61//get Batch Upgrade Progress
#define MINOR_GET_BATCH_PROGRESS                    0xc62//get Batch Progress
#define MINOR_GET_TEMPLATE                          0xc64//get template
#define MINOR_INIT_TEMPLATE                         0xc65//init template
#define MINOR_GET_TERMINAL_NTP_SERVERS              0xc66//get terminal ntp servers
#define MINOR_SET_TERMINAL_NTP_SERVERS              0xc67//set terminal ntp servers
#define MINOR_GET_RELEASE_DETAILS                   0xc68//get release details
#define MINOR_UPLOAD_TEMPLATE_THUMBNAIL             0xc69//upload template thumbnail
#define MINOR_DOWNLOAD_TEMPLATE_THUMBNAIL           0xc6a//download template thumbnail
#define MINOR_ADD_TEMPLATE                          0xc6b//add template
#define MINOR_DELETE_TEMPLATE                       0xc6c//delete template
#define MINOR_MODIFY_TEMPLATE                       0xc6d//modify template
#define MINOR_ADD_SCHEDULE_PLAN                     0xc6e//add schedule plan
#define MINOR_MODIFY_SCHEDULE_PLAN                  0xc6f//modify schedule plan
#define MINOR_CANCEL_SCHEDULE_RELEASE               0xc70//cancel schedule release
#define MINOR_GET_SCHEDULE                          0xc71//get schedule
#define MINOR_ADD_INSERT                            0xc72//add insert
#define MINOR_CANCEL_INSERT                         0xc73//cancel insert
#define MINOR_SWITCH_LANGUAGE                       0xc74//switch language
#define MINOR_SET_ADMIN_INITIAL_PASSWORD            0xc75//set admin initial password
#define MINOR_MODIFY_PORT                           0xc76//modify port
#define MINOR_MODIFY_STORAGE_PATH                   0xc77//modify storage path
#define MINOR_EXIT_PROGRAM                          0xc78//exit program
#define MINOR_MODULE_STARTUP_SUCCESS                0xc79//module startup success
#define MINOR_APPROVE_SCHEDULE                      0xc80  //schedule approve
#define MINOR_GENERAL_DATA_SEND                     0xc81  //general data send
#define MINOR_SET_SIGN_INTERFACE                    0xc82//set sign interface
#define MINOR_GET_SIGN_INTERFACE                    0xc83//get sign interface
#define MINOR_SET_SHOW_MODE                         0xc84//set show mode
#define MINOR_GET_SHOW_MODE                         0xc85//get show mode
#define MINOR_SET_SCREEN_DIRECTION                  0xc86//set screen direction
#define MINOR_GET_SCREEN_DIRECTION                  0xc87//get screen direction
#define MINOR_SET_LOCK_SCREEN                       0xc88//set lock screen
#define MINOR_GET_LOCK_SCREEN                       0xc89//get lock screen
#define MINOR_SET_FACE_DATA_LIB                     0xc8a//
#define MINOR_DELETE_FACE_DATA_LIB                  0xc8b//
#define MINOR_SET_SPEC_FACE_DATA_LIB                0xc8c//
#define MINOR_DELETE_SPEC_FACE_DATA_LIB             0xc8d//
#define MINOR_ADD_FACE_DATA                         0xc8e//
#define MINOR_SEARCH_FACE_DATA                      0xc8f//
#define MINOR_MODIFY_FACE_DATA                      0xc90//
#define MINOR_DELETE_FACE_DATA                      0xc91//
#define MINOR_DELETE_USERINFO_DETAIL                0xc92//
#define MINOR_ADD_USERINFO                          0xc93//
#define MINOR_MODIFY_USERINFO                       0xc94//
#define MINOR_DELETE_USERINFO                       0xc95//
#define MINOR_ADD_CARD_INFO                         0xc96//
#define MINOR_MODIFY_CARD_INFO                      0xc97//
#define MINOR_DELETE_CARD_INFO                      0xc98//
#define MINOR_SET_USER_RIGHT_WEEK                   0xc99//
#define MINOR_SET_USER_RIGHT_HOLIDAY                0xc9a//
#define MINOR_SET_USER_RIGHT_HOLIDAYGROUP           0xc9b//
#define MINOR_SET_USER_RIGHT_TEMPLATE               0xc9c//

//2012-03-05 ITC
#define MINOR_SET_TRIGGERMODE_CFG       0x1001  /*Set trigger configuration*/
#define MINOR_GET_TRIGGERMODE_CFG       0x1002  /*Get trigger configuration*/
#define MINOR_SET_IOOUT_CFG             0x1003  /*Set IO out configuration*/
#define MINOR_GET_IOOUT_CFG             0x1004  /*Get IO out configuration*/
#define MINOR_GET_TRIGGERMODE_DEFAULT   0x1005  /*Get trigger default configuration*/
#define MINOR_GET_ITCSTATUS             0x1006  /*Get status */
#define MINOR_SET_STATUS_DETECT_CFG     0x1007  /*Set status detect configuration*/
#define MINOR_GET_STATUS_DETECT_CFG     0x1008  /*Get status detect configuration*/
#define MINOR_SET_VIDEO_TRIGGERMODE_CFG 0x1009  /*Set video trigger configuration*/
#define MINOR_GET_VIDEO_TRIGGERMODE_CFG 0x100a  /*Get video trigger configuration*/

//2018-04-23 General gateway operation type log
#define    MINOR_ALARMHOST_GUARD     		0x1010    //Normal arm
#define    MINOR_ALARMHOST_UNGUARD 		0x1011    //Normal disarm
#define    MINOR_ALARMHOST_BYPASS 				0x1012    //Bypass
#define    MINOR_ALARMHOST_DURESS_ACCESS 			0x1013    //Duress access

#define    MINOR_ALARMHOST_RS485_PARAM               0x1018   //Modify RS485 config parameter
#define    MINOR_ALARMHOST_ALARM_OUTPUT 				0x1019    //Control alarm output
#define    MINOR_ALARMHOST_ACCESS_OPEN 				0x101a    //Control access open
#define    MINOR_ALARMHOST_ACCESS_CLOSE 				0x101b    //Control access close
#define    MINOR_ALARMHOST_SIREN_OPEN 				0x101c    //Control siren open
#define    MINOR_ALARMHOST_SIREN_CLOSE 				0x101d    //Control siren close
#define    MINOR_ALARMHOST_MOD_ZONE_CONFIG 			0x101e    //Modify defense area configuration
#define    MINOR_ALARMHOST_MOD_ALARMOUT_CONIFG 	0x101f    //Modify alarmout configuration
#define    MINOR_ALARMHOST_MOD_ANALOG_CONFIG 		0x1020    //Modify analog configuration
#define    MINOR_ALARMHOST_RS485_CONFIG 				0x1021    //Modify RS-485 configuration
#define    MINOR_ALARMHOST_PHONE_CONFIG 				0x1022    //Modify dialing configuration
#define    MINOR_ALARMHOST_ADD_ADMIN 				0x1023    //Add administrator
#define    MINOR_ALARMHOST_MOD_ADMIN_PARAM 		0x1024    //Modify password of administrator
#define    MINOR_ALARMHOST_DEL_ADMIN 					0x1025    //Delete administrator
#define    MINOR_ALARMHOST_ADD_NETUSER 				0x1026    //Add network user
#define    MINOR_ALARMHOST_MOD_NETUSER_PARAM 		0x1027    //Modify password of network user
#define    MINOR_ALARMHOST_DEL_NETUSER 				0x1028    //Delete network user
#define    MINOR_ALARMHOST_ADD_OPERATORUSER 		0x1029    //Add operator user
#define    MINOR_ALARMHOST_MOD_OPERATORUSER_PW 	0x102a    //Modify operator user password
#define    MINOR_ALARMHOST_DEL_OPERATORUSER 		0x102b    //Delete operator user
#define    MINOR_ALARMHOST_ADD_KEYPADUSER 		0x102c    //Add user of keyboard or card reader 	
#define    MINOR_ALARMHOST_DEL_KEYPADUSER 		0x102d    //Delete user of keyboard or card reader


#define    MINOR_ALARMHOST_MOD_HOST_CONFIG          0x1032    //Modify host configuration
#define    MINOR_ALARMHOST_RESTORE_BYPASS 			0x1033    //Bypass restore

#define    MINOR_ALARMHOST_ALARMOUT_OPEN 			0x1034    //Open alarm out
#define    MINOR_ALARMHOST_ALARMOUT_CLOSE 			0x1035    //Close alarm out
#define    MINOR_ALARMHOST_MOD_SUBSYSTEM_PARAM 	0x1036    //Mod subsystem config
#define    MINOR_ALARMHOST_GROUP_BYPASS 				0x1037    //Group bypass
#define    MINOR_ALARMHOST_RESTORE_GROUP_BYPASS 	0x1038    //Restore group bypass
#define    MINOR_ALARMHOST_MOD_GRPS_PARAM 			0x1039    //Mod gprs parameter

#define    MINOR_ALARMHOST_MOD_REPORT_MOD 			0x103b    //Mod report config
#define    MINOR_ALARMHOST_MOD_GATEWAY_PARAM 		0x103c    //Mod gateway config

#define    MINOR_STAY_ARM 	0x104c    //stay arm
#define    MINOR_QUICK_ARM 			0x104d    //quick arm
#define    MINOR_AUTOMATIC_ARM 		0x104e    //auto arm
#define    MINOR_AUTOMATIC_DISARM 		0x104f    //auto disarm
#define    MINOR_KEYSWITCH_ARM 	0x1050  //key switch arm
#define    MINOR_KEYSWITCH_DISARM	0x1051  //key switch disarm
#define    MINOR_CLEAR_ALARM	0x1052    //clear alarm
#define    MINOR_MOD_FAULT_CFG		0x1053  //mod fault config
#define    MINOR_MOD_EVENT_TRIGGER_ALARMOUT_CFG	0x1054  //mod event cause alarm out 
#define    MINOR_SEARCH_EXTERNAL_MODULE  0x1055 //search external module
#define    MINOR_REGISTER_EXTERNAL_MODULE 0x1056  //register external module
#define    MINOR_CLOSE_KEYBOARD_ALARM	0x1057 //close keyboard alarm
#define    MINOR_MOD_3G_PARAM		0x1058  //modify 3G parameter
#define    MINOR_MOD_PRINT_PARAM 0x1059  //modify printer parameter
#define    MINOR_ALARMHOST_SD_CARD_FORMAT		0x1060    //SD card format
#define MINOR_ALARMHOST_SUBSYSTEM_UPGRADE  0x1061 //subsystem upgrade

#define MINOR_PLAN_ARM_CFG     0x1062 //arm plan config
#define MINOR_PHONE_ARM         0x1063 //phone arm
#define MINOR_PHONE_STAY_ARM     0x1064 //phone stay arm
#define MINOR_PHONE_QUICK_ARM   0x1065 //phone quick arm
#define MINOR_PHONE_DISARM     0x1066 //phone disarm
#define MINOR_PHONE_CLEAR_ALARM     0x1067 //phone clear alarm
#define MINOR_ALLOWLIST_CFG     0x1068 //Allow list config
#define MINOR_TIME_TRIGGER_CFG    0x1069 //turn on/off trigger config
#define MINOR_CAPTRUE_CFG     0x106a //capture config
#define MINOR_TAMPER_CFG    0x106b //tamper config

#define MINOR_REMOTE_KEYPAD_UPGRADE    0x106c //Remote Keypad Upgrade
#define MINOR_ONETOUCH_AWAY_ARMING  0x106d //One-touch Away Arming 
#define MINOR_ONETOUCH_STAY_ARMING     0x106e //One-touch Stay Arming
#define MINOR_SINGLE_PARTITION_ARMING_OR_DISARMING  0x106f //Single Partition Arming/Disarming  
#define MINOR_CARD_CONFIGURATION   0x1070 //Card Configuration
#define MINOR_CARD_ARMING_OR_DISARMING   0x1071 //Card Arming/Disarming
#define MINOR_EXPENDING_NETCENTER_CONFIGURATION    0x1072 //Expending Network Center Configuration
#define MINOR_NETCARD_CONFIGURATION    0x1073 //Network Card Configuration
#define MINOR_DDNS_CONFIGURATION      0x1074 //DDNS Configuration
#define MINOR_RS485BUS_CONFIGURATION    0x1075 // RS-485 Bus Configuration
#define MINOR_RS485BUS_RE_REGISTRATION     0x1076 //RS-486 Bus Re-registration

#define MINOR_REMOTE_OPEN_ELECTRIC_LOCK 0x1077 //remote open electric lock
#define MINOR_REMOTE_CLOSE_ELECTRIC_LOCK 0x1078 //remote close electric lock
#define MINOR_LOCAL_OPEN_ELECTRIC_LOCK 0x1079 //local open electric lock
#define MINOR_LOCAL_CLOSE_ELECTRIC_LOCK 0x107a //local close electric lock
#define MINOR_OPEN_ALARM_LAMP      0x107b //open alarm lamp(remote)
#define MINOR_CLOSE_ALARM_LAMP      0x107c //close alarm lamp(remote)
    

#define MINOR_TEMPORARY_PASSWORD   0x107d //

#define MINOR_HIDDNS_CONFIG     0x1082 // 
#define MINOR_REMOTE_KEYBOARD_UPDATA   0x1083 //
#define MINOR_ZONE_ADD_DETECTOR      0x1084 //
#define MINOR_ZONE_DELETE_DETECTOR    0x1085 //
#define MINOR_QUERY_DETECTOR_SIGNAL   0x1086 //
#define MINOR_QUERY_DETECTOR_BATTERY  0x1087 //
#define MINOR_SET_DETECTOR_GUARD    0x1088 //
#define MINOR_SET_DETECTOR_UNGUARD   0x1089 //
#define MINOR_WIRELESS_CONFIGURATION     0x108a  //config wireless parameter
#define MINOR_OPEN_VOICE        0x108b //
#define MINOR_CLOSE_VOICE       0x108c //
#define MINOR_ENABLE_FUNCTION_KEY     0x108d //
#define MINOR_DISABLE_FUNCTION_KEY      0x108e //
#define MINOR_READ_CARD    0x108f //patrol read card
#define MINOR_START_BROADCAST     0x1090 //open broadcast
#define MINOR_STOP_BROADCAST   0x1091 //close broadcast
#define MINOR_REMOTE_ZONE_MODULE_UPGRADE   0x1092 //
#define MINOR_NETWORK_MODULE_EXTEND   0x1093 //network module params cfg
#define MINOR_ADD_CONTROLLER 	0x1094 //add controller user
#define MINOR_DELETE_CONTORLLER 	0x1095 //delete controller user
#define MINOR_REMOTE_NETWORKMODULE_UPGRADE    0x1096 //
#define MINOR_WIRELESS_OUTPUT_ADD   0x1097 //
#define MINOR_WIRELESS_OUTPUT_DEL    0x1098 //
#define MINOR_WIRELESS_REPEATER_ADD   0x1099 //
#define MINOR_WIRELESS_REPEATER_DEL    0x109a //
#define MINOR_PHONELIST_CFG     0x109b //
#define MINOR_RF_SIGNAL_CHECK   0x109c // 
#define MINOR_USB_UPGRADE   0x109d // 
#define MINOR_DOOR_TIME_REMINDER_CFG 0x109f //
#define MINOR_WIRELESS_SIREN_ADD    0x1100 //
#define MINOR_WIRELESS_SIREN_DEL    0x1101 //
#define MINOR_OUT_SCALE_OPEN    0x1102 //
#define MINOR_OUT_SCALE_CLOSE    0x1103 //

#define  MINOR_ALARMHOST_4G_MODULS_START  0x1108  //4G module start
#define  MINOR_ALARMHOST_4G_MODULS_STOP  0x1109  //4G module stop

#define  MINOR_EZVIZ_CLOUD_START   0x1110   //EZVIZ start
#define  MINOR_EZVIZ_CLOUD_STOP    0x1111   //EZVIZ stop
#define  MINOR_SIPUA_GRID_START    0x1112   //SIP grid start
#define  MINOR_SIPUA_GRID_STOP    0x1113    //SIP grid stop

#define MINOR_MODBUS_FILE_DOWNLOAD   0x1114  //download modbus file
#define MINOR_MODBUS_FILE_UPLOAD      0x1115  //upload modbus file

#define MINOR_RS485_DLL_FILE_DOWNLOAD   0x1116  //download RS485 protocol library file
#define MINOR_RS485_DLL_FLIE_UPLOAD   0x1117  //upload RS485 protocol library file
#define MINOR_TX1_REBOOT              0x1118   //TX1 system reboot

#define MINOR_LORA_PARAM                              0x1119   //LoRa Param
#define MINOR_GB28181_PLATE_CFG_PARAM                 0x111a   //GB28181 plate cfg param
#define MINOR_GB28181_SERVER_START                0x111b    //GB28181 server start
#define MINOR_GB28181_SERVER_STOP                0x111c    //GB28181 server stop
#define MINOR_WEB_AUTHENTICATION                 0x111d    //web authentication
#define MINOR_SADP_ENABLED                 0x111e    //SADP enabled
#define MINOR_HTTPS_ENABLED                 0x111f    //HTTPS enabled
#define MINOR_EZVIZ_PARAM_CFG               0x1120    //EZVIZ param configuration
#define MINOR_SET_MOTION_DETECTION_CFG      0x1121    //set motion detection cfg
#define MINOR_GET_MOTION_DETECTION_CFG      0x1122    //get motion detection cfg
#define MINOR_SET_SHELTER_ALARM_CFG         0x1123    //set shelter alarm cfg
#define MINOR_GET_SHELTER_ALARM_CFG         0x1124    //get shelter alarm cfg
#define MINOR_SET_VIDEO_LOSS_CFG            0x1125    //set video loss cfg
#define MINOR_GET_VIDEO_LOSS_CFG            0x1126    //get video loss cfg
#define MINOR_SET_ABNORMAL_CFG              0x1127    //set abnormal cfg
#define MINOR_GET_ABNORMAL_CFG              0x1128    //get abnormal cfg
#define MINOR_SET_ALARM_LINKAGE_CFG         0x1129    //set alarm linkage cfg
#define MINOR_GET_ALARM_LINKAGE_CFG         0x112a    //get alarm linkage cfg
#define MINOR_SET_NETWORK_CFG               0x112b    //set network cfg
#define MINOR_GET_NETWORK_CFG               0x112c    //get network cfg
#define MINOR_SET_VIDEO_MASK_CFG            0x112d    //set video mask cfg
#define MINOR_GET_VIDEO_MASK_CFG            0x112e    //get video mask cfg

#define MINOR_BASIC_OPERATION_CFG           0x112f    //basic operation
#define MINOR_DISPLAY_EFFECT_ADJUST_CFG     0x1130    //display effect adjust
#define MINOR_DISPLAY_PROPERTY_CFG          0x1131    //display property 
#define MINOR_SIGNAL_CABLE_CFG              0x1132    //signal cable
#define MINOR_BASIC_CFG                     0x1133    //basic cfg
#define MINOR_IMAGE_ADJUST_CFG              0x1134    //image adjust
#define MINOR_IMAGE_ENHANCE_CFG             0x1135    //image enhance
#define MINOR_NOSIGN_SCREEN_SAVER_CFG       0x1136    //no sign screen saver
#define MINOR_ADVANCED_OPERATION_CFG        0x1137    //advanced operation
#define MINOR_RECEIVE_CARD_CFG              0x1138    //receive card
#define MINOR_INPUT_SUPPORT_CFG             0x1139    //input support
#define MINOR_SYSTEM_MAINTAIN_CFG           0x113a    //system maintaion
#define MINOR_SYSTEM_TEST_CFG               0x113b    //system test
#define MINOR_JOINT_CFG                     0x113c    //joint cfg
#define MINOR_SHOW_MODE_CFG                 0x113d    //show mode cfg
#define MINOR_ADVANCED_IMAGE_CFG            0x113e    //advanced image
#define MINOR_SHELF_SIZE_CALIBRATION        0x1140    //shelf size calibration
#define MINOR_CARGO_SENSOR_CALIBRATION      0x1141    //cargo sensor calibration
#define MINOR_CARGO_PRODUCT_BIND_CFG        0x1142    //cargo product binding configuration

//2013-04-19 ITS
#define MINOR_LOCAL_ADD_CAR_INFO            0x2001  /*Local add car info*/
#define MINOR_LOCAL_MOD_CAR_INFO            0x2002  /*Local mode car info*/
#define MINOR_LOCAL_DEL_CAR_INFO            0x2003  /*Local delete car info*/
#define MINOR_LOCAL_FIND_CAR_INFO           0x2004  /*Local find car info*/
#define MINOR_LOCAL_ADD_MONITOR_INFO        0x2005  /*Local add monitor info*/
#define MINOR_LOCAL_MOD_MONITOR_INFO        0x2006  /*Local mode monitor info*/
#define MINOR_LOCAL_DEL_MONITOR_INFO        0x2007  /*Local delete monitor info*/
#define MINOR_LOCAL_FIND_MONITOR_INFO       0x2008  /*Local find monitor info*/
#define MINOR_LOCAL_FIND_NORMAL_PASS_INFO   0x2009  /*Local find normal pass info*/
#define MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO   0x200a  /*Local find abnormal pass info*/
#define MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO   0x200b  /*Local find pedestrian pass info*/
#define MINOR_LOCAL_PIC_PREVIEW             0x200c  /*Local picture preview*/
#define MINOR_LOCAL_SET_GATE_PARM_CFG           0x200d  /*Local set gate param configuration*/
#define MINOR_LOCAL_GET_GATE_PARM_CFG           0x200e  /*Local get gate param configuration*/
#define MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG     0x200f  /*Local set dataupload param configuration*/
#define MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG     0x2010  /*Local get dataupload param configuration*/
//2013-11-19 Log Type
#define MINOR_LOCAL_DEVICE_CONTROL                        0x2011      /*Local Device Control*/
#define MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO              0x2012      /*Add External Device Info */
#define MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO              0x2013      /*Modify External Device Info */
#define MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO              0x2014      /*Delete External Device Info */
#define MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO             0x2015      /*Find External Device Info */
#define MINOR_LOCAL_ADD_CHARGE_RULE                       0x2016      /*Add Charge rule */
#define MINOR_LOCAL_MOD_CHARGE_RULE                       0x2017      /*Modify Charge rule */
#define MINOR_LOCAL_DEL_CHARGE_RULE                       0x2018      /*Delete Charge rule */
#define MINOR_LOCAL_FIND_CHARGE_RULE                      0x2019      /*Find Charge rule */
#define MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO              0x2020      /*Normal Current Info */
#define MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT      0x2021      /*Normal Current Info Report */
#define MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO            0x2022      /*Abnormal Current Info */
#define MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT    0x2023      /*Abnormal Current Info Report */
#define MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO          0x2024      /*Pedesteian Current Info */
#define MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT  0x2025      /*Pedesteian Current Info Report*/
#define MINOR_LOCAL_FIND_CAR_CHARGEINFO                   0x2026      /*Find Car Charge Info */
#define MINOR_LOCAL_COUNT_CAR_CHARGEINFO                  0x2027      /*Count Car Charge Info */
#define MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT          0x2028      /*Export Car Charge Info Report */
#define MINOR_LOCAL_FIND_SHIFTINFO                        0x2029      /*Find Shift Info */
#define MINOR_LOCAL_FIND_CARDINFO                         0x2030      /*Find Card Info */
#define MINOR_LOCAL_ADD_RELIEF_RULE                       0x2031      /*Add Relief Rule*/
#define MINOR_LOCAL_MOD_RELIEF_RULE                       0x2032      /*Modify Relief Rule */
#define MINOR_LOCAL_DEL_RELIEF_RULE                       0x2033      /*Delete Relief Rule  */
#define MINOR_LOCAL_FIND_RELIEF_RULE                      0x2034      /*find Relief Rule */
#define MINOR_LOCAL_GET_ENDETCFG                          0x2035      /*local Get entrance control machine offline detection configuration */ 
#define MINOR_LOCAL_SET_ENDETCFG                          0x2036      /*local Set entrance control machine offline detection configuration*/
#define MINOR_LOCAL_SET_ENDEV_ISSUEDDATA                  0x2037      /*local setting entrance control machine issued card information */
#define MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA                  0x2038      /*local Delete entrance control machine issued card information*/

#define MINOR_REMOTE_DEVICE_CONTROL                       0x2101      /*Remote device control*/
#define MINOR_REMOTE_SET_GATE_PARM_CFG                    0x2102      /*Remote set gate param configuration*/
#define MINOR_REMOTE_GET_GATE_PARM_CFG                    0x2103      /*Remote get gate param configuration*/
#define MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG              0x2104      /*Remote set dataupload param configuration*/
#define MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG              0x2105      /*Remote get dataupload param configuration*/
#define MINOR_REMOTE_GET_BASE_INFO                        0x2106      /*Remote get base info*/
#define MINOR_REMOTE_GET_OVERLAP_CFG                      0x2107      /*Remote get overlap configuration*/              
#define MINOR_REMOTE_SET_OVERLAP_CFG                      0x2108      /*Remote set overlap configuration*/ 
#define MINOR_REMOTE_GET_ROAD_INFO                        0x2109      /*Remote get road info*/
#define MINOR_REMOTE_START_TRANSCHAN                      0x210a      /*Remote start transchan*/
#define MINOR_REMOTE_GET_ECTWORKSTATE                     0x210b      /*Remote get ect work state*/
#define MINOR_REMOTE_GET_ECTCHANINFO                      0x210c      /*Remote get ect channel info*/

//Remote control 2013-11-19
#define MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO             0x210d      /*Remote add external equipment information */
#define MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO             0x210e      /*Remote modify the external equipment information */
#define MINOR_REMOTE_GET_ENDETCFG                         0x210f      /*Remote obtain entrance control machine offline detection configuration */ 
#define MINOR_REMOTE_SET_ENDETCFG                         0x2110      /*Remote setup entrance control machine with off-line detection*/
#define MINOR_REMOTE_ENDEV_ISSUEDDATA                     0x2111      /*Remote setup entrance control machine issued card information */
#define MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA                 0x2112      /*Remote wipe out entrance control machine issued card information */

#define MINOR_REMOTE_ON_CTRL_LAMP           0x2115  /*Open remote control parking lights */       
#define MINOR_REMOTE_OFF_CTRL_LAMP          0x2116  /*Close remote control parking lights */
//Netra3.1.0
#define MINOR_SET_VOICE_LEVEL_PARAM         0x2117  /*set voice level param*/
#define MINOR_SET_VOICE_INTERCOM_PARAM      0x2118  /*set voice intercom param */
#define MINOR_SET_INTELLIGENT_PARAM         0x2119  /*intelligent param*/ 
#define MINOR_LOCAL_SET_RAID_SPEED          0x211a  /*set local raid speed*/
#define MINOR_REMOTE_SET_RAID_SPEED         0x211b /*set remote raid speed*/

//Nerta3.1.2
#define MINOR_REMOTE_CREATE_STORAGE_POOL    0x211c   //remote create Storage pool
#define MINOR_REMOTE_DEL_STORAGE_POOL       0x211d    //remote delete Storage pool

#define MINOR_REMOTE_DEL_PIC                0x2120   //remote delete pic 
#define MINOR_REMOTE_DEL_RECORD             0x2121   //remote delete record
#define MINOR_REMOTE_CLOUD_ENABLE           0x2123   //remote set cloud System enable
#define MINOR_REMOTE_CLOUD_DISABLE          0x2124   //remote set cloud System disable
#define MINOR_REMOTE_CLOUD_MODIFY_PARAM     0x2125   //remote modify cloud Storage param
#define MINOR_REMOTE_CLOUD_MODIFY_VOLUME    0x2126   //remote modift cloud Storage volume
#define MINOR_REMOTE_GET_GB28181_SERVICE_PARAM    0x2127  //Remote Get GB28181 Cfg
#define MINOR_REMOTE_SET_GB28181_SERVICE_PARAM    0x2128  //Remote Set GB28181 Cfg
#define MINOR_LOCAL_GET_GB28181_SERVICE_PARAM     0x2129  //local Get GB28181 Cfg
#define MINOR_LOCAL_SET_GB28181_SERVICE_PARAM     0x212a  //local Set GB28181 Cfg
#define MINOR_REMOTE_SET_SIP_SERVER               0x212b  //Remote Set SIP SERVER Cfg
#define MINOR_LOCAL_SET_SIP_SERVER                0x212c  //Local Set SIP SERVER Cfg
#define MINOR_LOCAL_BLOCKALLOWFILE_OUTPUT         0x212d  //Local output block allow file
#define MINOR_LOCAL_BLOCKALLOWFILE_INPUT          0x212e  //Local input block allow file
#define MINOR_REMOTE_BLOCKALLOWCFGFILE_OUTPUT     0x212f  //Remote output block allow file
#define MINOR_REMOTE_BLOCKALLOWCFGFILE_INPUT      0x2130  //Remote input block allow file


#define MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE        0x2200    //Remote create or mod view lib space
#define MINOR_REMOTE_DELETE_VIEWLIB_FILE            0x2201  //Remote delete view lib file
#define MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE            0x2202    //Remote download view lib file
#define MINOR_REMOTE_UPLOAD_VIEWLIB_FILE            0x2203    //Remote upload view lib file
#define MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE        0x2204    //local create or mod view lib space

#define MINOR_LOCAL_SET_DEVICE_ACTIVE   0x3000  //local activate device
#define MINOR_REMOTE_SET_DEVICE_ACTIVE  0x3001  //remote activate device
#define MINOR_LOCAL_PARA_FACTORY_DEFAULT    0x3002  //local parameter factory default
#define MINOR_REMOTE_PARA_FACTORY_DEFAULT   0x3003  //remote parameter factory default
#define MIMOR_REMOTE_DELETE_ALL_VERIFYORCAP_PICS  0x3004
#define MIMOR_LOCAL_DELETE_ALL_VERIFYORCAP_PICS   0x3005
#define MIMOR_REMOTE_DELETE_EVENTS_AT_SPECTIME    0x3006
#define MIMOR_LOCAL_DELETE_EVENTS_AT_SPECTIME     0x3007
#define MIMOR_REMOTE_OPEN_SUMMER_TIME             0x3008
#define MIMOR_LOCAL_OPEN_SUMMER_TIME              0x3009
#define MIMOR_REMOTE_CLOSE_SUMMER_TIME            0x3010
#define MIMOR_LOCAL_CLOSE_SUMMER_TIME             0x3011
#define MIMOR_REMOTE_EZVIZ_UNBIND                 0x3012
#define MIMOR_LOCAL_EZVIZ_UNBIND                  0x3013
#define MIMOR_ENTER_LOCALUI_BACKGROUND            0x3014
#define MIMOR_REMOTE_DELETE_FACEBASEMAP           0x3015
#define MIMOR_LOCAL_DELETE_FACEBASEMAP            0x3016


/*info publish server operation log*/
//minor type:
#define MINOR_UPLAOD_STATIC_MATERIAL                0x2401  //static material upload
#define MINOR_UPLOAD_DYNAMIC_MATERIAL               0x2402  //dynamic material upload
#define MINOR_DELETE_MATERIAL                       0x2403  //delete material
#define MINOR_DOWNLOAD_STATIC_MATERIAL              0x2404  //static material download
#define MINOR_COVER_STATIC_MATERIAL                 0x2405  //static material cover
#define MINOR_APPROVE_MATERIAL                      0x2406  //material approve
#define MINOR_UPLAOD_PROGRAM                        0x2407  //add program
#define MINOR_DOWNLOAD_PROGRAM                      0x2408  //get program
#define MINOR_DELETE_PROGRAM                        0x2409  //delete program
#define MINOR_MODIFY_PROGRAM                        0x240a  //program attribute modify
#define MINOR_APPROVE_PRAGRAM                       0x240b  //program approve
#define MINOR_UPLAOD_SCHEDULE                       0x240c  //add schedule
#define MINOR_DOWNLOAD_SCHEDULE                     0x240d  //get schedule
#define MINOR_DELETE_SCHEDULE                       0x240e  //delete schedule
#define MINOR_MODIFY_SCHEDULE                       0x240f  //modify schedule attribute
#define MINOR_RELEASE_SCHEDULE                      0x2410  //publish schedule
#define MINOR_ADD_TERMINAL                          0x2411  //add terminal
#define MINOR_DELETE_TERMINAL                       0x2412  //delete terminal
#define MINOR_MODIFY_TERMIANL_PARAM                 0x2413  //set terminal param           
#define MINOR_MODIFY_TERMIANL_PLAY_PARAM            0x2414  //set terminal play parma
#define MINOR_ADD_TERMIANL_GROUP                    0x2415  //add terminal group
#define MINOR_MODIFY_TERMINAL_GROUP_PARAM           0x2416  //modify terminal pram
#define MINOR_DELETE_TERMIANL_GROUP                 0x2417  //delete terminal group
#define MINOR_TERMINAL_PLAY_CONTROL                 0x2418  //terminal play control
#define MINOR_TERMINAL_ON_OFF_LINE                  0x2419  //terminal on and off line
#define MINOR_SET_SWITCH_PLAN                       0x241a  //set terminal switch on plan
#define MINOR_SET_VOLUME_PLAN                       0x241b  //set terminal volume plan
#define MINOR_TERMINAL_SCREENSHOT                   0x241c  //terminal screenshot
#define MINOR_SYSTEM_TIME_CFG                       0x241d      //system timeing
#define MINOR_ADD_USER_CFG                          0x241e    //add user information
#define MINOR_DEL_USER_CFG                          0x241f    //delete user information
#define MINOR_REMOTE_MANAGE_HDD                     0x2420   //remote manage HDD
#define MINOR_TERMINAL_UPDATE_START                 0x2421   //terminal update
#define MINOR_SVR_RESTORE_DEFAULT_PARAM             0x2422   //server remote restore default
#define MINOR_SVR_REMOTE_RESTORE_FACTORY            0x2423   //server remote restore factory
#define MINOR_SVR_REMOTE_REBOOT                     0x2424   //server remote reboot
#define MINOR_SVR_MODIFY_NETWORK_PARAM              0x2425   //server network parameter modified
#define MINOR_SVR_SOFTWARE_UPGRADE                  0x2426     //server software upgrade



#define MINOR_REMOTE_CONFERENCE_CONFIG             0x2501  //MCU conference config
#define MINOR_REMOTE_TERMINAL_CONFIG               0x2502  //MCU terminal config
#define MINOR_REMOTE_GROUP_CONFIG                  0x2503  //MCU group config
#define MINOR_REMOTE_CONFERENCE_CTRL               0x2504  //MCU conference config
#define MINOR_REMOTE_TERMINAL_CTRL                 0x2505  //MCU terminal control
#define MINOR_ADD_VIDEOWALLSCENE        0x2506        //add videowall scene
#define MINOR_DEL_VIDEOWALLSCENE        0x2507        //delete videowall scene
#define MINOR_SAVE_VIDEOWALLSCENE       0x2508        //save videowall scene
#define MINOR_UPLOAD_SCENECFGFILE       0x2509        //upload scene config file
#define MINOR_DOWNLOAD_SCENECFGFILE     0x250a        //download scene config file


//NVR
#define MINOR_LOCAL_RESET_LOGIN_PASSWORD           0x2600    /* local reset login password*/ 
#define MINOR_REMOTE_RESET_LOGIN_PASSWORD          0x2601    /* remote reset login password*/
#define MINOR_LOCAL_FACE_BASE_CREATE        0x2602    /* local face base creat*/ 
#define MINOR_REMOTE_FACE_BASE_CREATE       0x2603    /* remote face base creat*/
#define MINOR_LOCAL_FACE_BASE_MODIFY        0x2604    /* local face base mod*/ 
#define MINOR_REMOTE_FACE_BASE_MODIFY      0x2605    /*remote face base mod*/
#define MINOR_LOCAL_FACE_BASE_DELETE        0x2606    /* local face base del*/ 
#define MINOR_REMOTE_FACE_BASE_DELETE       0x2607    /* remote face base del*/
#define MINOR_LOCAL_FACE_DATA_APPEND        0x2608    /* local face data append*/ 
#define MINOR_REMOTE_FACE_DATA_APPEND       0x2609    /*remote face data append*/
#define MINOR_LOCAL_FACE_DATA_SEARCH       0x2610    /* local face data search*/ 
#define MINOR_REMOTE_FACE_DATA_SEARCH       0x2611    /*remote face data search*/
#define MINOR_LOCAL_FACE_DATA_ANALYSIS        0x2612    /*local face data analysis*/ 
#define MINOR_REMOTE_FACE_DATA_ANALYSIS       0x2613    /*remote face data analysis*/
#define MINOR_LOCAL_FACE_DATA_EDIT            0x2614    /* local face data edit*/ 
#define MINOR_REMOTE_FACE_DATA_EDIT           0x2615    /* remote face data edit*/

#define MINOR_LOCAL_FACE_DATA_DELETE          0x2616    /* local face data delete*/ 
#define MINOR_REMOTE_FACE_DATA_DELET          0x2617    /* remote face data delete*/

#define MINOR_LOCAL_VCA_ANALYSIS_CFG          0x2618    /* local vca analysis config*/ 
#define MINOR_REMOTE_VCA_ANALYSIS_CFG         0x2619    /* remote vca analysis config*/

#define MINOR_LOCAL_FACE_BASE_IMPORT          0x261a    /* local face base import*/ 
#define MINOR_LOCAL_FACE_BASE_EXPORT          0x261b    /* local face base export*/
#define MINOR_REMOTE_CLUSTER_MODE_CONFIG      0x261c    /* remote cluster mode config*/
#define MINOR_LOCAL_CLUSTER_MODE_CONFIG       0x261d    /* local cluster mode config*/
#define MINOR_REMOTE_CLUSTER_NETWORK_CONFIG   0x261e    /* remote cluster network config*/
#define MINOR_LOCAL_CLUSTER_NETWORK_CONFIG    0x261f    /* local cluster network config*/
#define MINOR_REMOTE_CLUSTER_ADD_DEVICE       0x2620    /* remote cluster add device*/
#define MINOR_LOCAL_CLUSTER_ADD_DEVICE        0x2621    /* local cluster add device*/
#define MINOR_REMOTE_CLUSTER_DEL_DEVICE       0x2622    /* remote cluster del device*/
#define MINOR_LOCAL_CLUSTER_DEL_DEVICE        0x2623    /* local cluster add device*/
#define MINOR_REMOTE_HFPD_CFG                 0x2624    /* remote HFPD config*/
#define MINOR_REMOTE_FACE_CONTRAST_TASK       0x2625    /* remote face contrast task */
#define MINOR_REMOTE_LFPD_CFG                 0x2626  /* remote LFPD config*/
#define MINOR_REMOTE_IOTCFGFILE_INPUT          0x2627//remote input iot cfg file
#define MINOR_REMOTE_IOTCFGFILE_OUTPUT        0x2628//remote output iot cfg file
#define MINOR_LOCAL_IOT_ADD                     0x2629//local add iot channel
#define MINOR_REMOTE_IOT_ADD                    0x262a//remote add iot channel
#define MINOR_LOCAL_IOT_DEL                      0x262b//local delete iot channel
#define MINOR_REMOTE_IOT_DEL                    0x262c//remote delete iot channel
#define MINOR_LOCAL_IOT_SET                      0x262d//local set iot channel
#define MINOR_REMOTE_IOT_SET                    0x262e//remote set iot channel
#define MINOR_LOCAL_IOTCFGFILE_INPUT            0x262f //local input iot cfg file
#define MINOR_LOCAL_IOTCFGFILE_OUTPUT          0x2630//local output iot cfg file
#define MINOR_LOCAL_VAD_CFG                    0x2631  /* Local voice activity detection configuration*/
#define MINOR_REMOTE_VAD_CFG                   0x2632  /* Remote voice activity detection configuration*/
#define MINOR_LOCAL_ADDRESS_FILTER_CONFIG     0x2633    /* Local address filtering configuration*/ 
#define MINOR_REMOTE_ADDRESS_FILTER_CONFIG    0x2634    /* Remote address filtering configuration*/
#define MINOR_LOCAL_POE_CFG                   0x2635    /*Local POE configuration*/ 
#define MINOR_REMOTE_POE_CFG                   0x2636    /*Remote POE configuration*/
#define MINOR_LOCAL_RESET_CHANNEL_PASSWORD        0x2637    /*Resets the channel password locally*/ 
#define MINOR_REMOTE_RESET_CHANNEL_PASSWORD       0x2638    /*Resetting the channel password remotely*/
#define MINOR_LOCAL_SSD_UPGRADE_START                   0x2639    /*Local SSD file system upgrade starts*/ 
#define MINOR_LOCAL_SSD_UPGRADE_STOP                    0x2640    /*Local SSD file system upgrade stop*/
#define MINOR_REMOTE_SSD_UPGRADE_START                   0x2641    /*Remote SSD file system upgrade starts*/ 
#define MINOR_REMOTE_SSD_UPGRADE_STOP                    0x2642    /*Remote SSD file system upgrade stop*/
#define MINOR_LOCAL_SSD_FORMAT_START                   0x2643    /*Local SSD file system format starts*/ 
#define MINOR_LOCAL_SSD_FORMAT_STOP                    0x2644    /*Local SSD file system format stop*/
#define MINOR_REMOTE_SSD_FORMAT_START                   0x2645    /*Remote SSD file system format starts*/ 
#define MINOR_REMOTE_SSD_FORMAT_STOP                    0x2646    /*Remote SSD file system format stop*/
#define MINOR_LOCAL_AUTO_SWITCH_CONFIG                  0x2647    /* Local Auto Switch Config*/ 
#define MINOR_REMOTE_AUTO_SWITCH_CONFIG                 0x2648    /* Remote Auto Switch Config*/

#define MINOR_LOCAL_SSD_INITIALIZATION_START            0x264a    /* Local SSD initialization start*/ 
#define MINOR_LOCAL_SSD_INITIALIZATION_END              0x264b    /* Local SSD initialization end*/
#define MINOR_REMOTE_SSD_INITIALIZATION_START           0x264c    /* Remote SSD initialization start*/
#define MINOR_REMOTE_SSD_INITIALIZATION_END             0x264d    /* Remote SSD initialization end*/

//AI Platform
#define MINOR_REMOTE_AI_MODEL_ADD    0x2650//model add
#define MINOR_REMOTE_AI_MODEL_QUERY    0x2651//model query
#define MINOR_REMOTE_AI_MODEL_DELETE    0x2652//model delete
#define MINOR_REMOTE_AI_MODEL_UPDATE    0x2653//model update
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_ADD    0x2654//picture polling task add
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_QUERY    0x2655//picture polling task query
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_DELETE    0x2656//picture polling task delete
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_MODIFY    0x2657//picture polling task modify
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_ADD    0x2658//video polling task add
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_QUERY    0x2659//video polling task query
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_DELETE    0x265A//video polling task delete
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_MODIFY    0x265B//video polling task modify
#define MINOR_REMOTE_AI_PICTURE_TASK_ADD    0x265C//picture task add
#define MINOR_REMOTE_AI_PICTURE_TASK_QUERY    0x265D//picture task query
#define MINOR_REMOTE_AI_PICTURE_TASK_DELETE    0x265E//picture task delete
#define MINOR_REMOTE_AI_PICTURE_TASK_MODIFY    0x265F//picture task modify
#define MINOR_REMOTE_AI_VIDEO_TASK_ADD    0x2660//video task add
#define MINOR_REMOTE_AI_VIDEO_TASK_QUERY    0x2661//video task add
#define MINOR_REMOTE_AI_VIDEO_TASK_DELETE    0x2662//video task delete
#define MINOR_REMOTE_AI_VIDEO_TASK_MODIFY    0x2663//video task modify
#define MINOR_REMOTE_AI_RULE_CONFIG   0x2664//AI Rule Configuration

#define MINOR_REMOTE_LOG_STORAGE_CONFIG 0x2665// Log Storage Config
#define MINOR_REMOTE_LOG_SERVER_CONFIG 0x2666//Log server parameter configuration

#define MINOR_REMOTE_RESET_IPC_PASSWORD   0x2670//NVR reset IPC password

#define MINOR_LOCAL_EZVIZ_OPERATION 0x2671 //local EZVIZ operation
#define MINOR_REMOTE_EZVIZ_OPERATION 0x2672 //remote EZVIZ operation

#define MINOR_EZVIZ_BITSTREAM_PARAMATERS_CONFIG 0x2673 /* Configuration of EZVIZ bitstream paramaters*/
#define MINOR_EZVIZ_ALARM_PARAMATERS_CONFIG 0x2674 /* Configuration of EZVIZ alarm paramaters*/
#define MINOR_EZVIZ_UPGRADE          0x2675 /* EZVIZ Upgrade*/
#define MINOR_EZVIZ_REGISTER         0x2676 /* EZVIZ Register*/
#define MINOR_EZVIZ_LOCAL_PARAMATERS_CONFIG    0x2677 /* Configuration of EZVIZ local paramaters*/
#define MINOR_EZVIZ_REMOTE_PARAMATERS_CONFIG   0x2678 /* Configuration of EZVIZ remote paramaters*/

#define MINOR_STOP_SOUND                0x2700   /*stop sound*/
#define MINOR_SELF_CHECK                0x2701   /*self check*/
#define MINOR_DUTY_CHECK                0x2702   /*duty check*/
#define MINOR_SWITCH_SIMPLE_WORKMODE    0x2703   /*switch simple workmode*/
#define MINOR_SWITCH_NORMAL_WORKMODE    0x2704   /*switch normal workmode*/

#define MINOR_LOCAL_SSD_OPERATE_START         0x2705    /* local Upgrade SSD Operate Start */ 
#define MINOR_LOCAL_SSD_OPERATE_STOP           0x2706    /* local Upgrade SSD Operate Stop*/
#define MINOR_REMOTE_SSD_OPERATE_START        0x2707    /* remote Upgrade SSD Operate Start*/ 
#define MINOR_REMOTE_SSD_OPERATE_STOP         0x2708    /* remote Upgrade SSD Operate Stop*/


/*Additional Log Info*/
//Main Type
#define MAJOR_INFORMATION                0x4     /*Extra Info*/
//Hypo- Type
#define MINOR_HDD_INFO                  0xa1 //HD info*/
#define MINOR_SMART_INFO                0xa2 //SMART info*/
#define MINOR_REC_START                 0xa3 //Start record*/
#define MINOR_REC_STOP                  0xa4 //Stop record */
#define MINOR_REC_OVERDUE                0xa5 //Record overdue*/
#define MINOR_LINK_START                0xa6 //start to link device
#define MINOR_LINK_STOP                    0xa7 //stop to link device
#define MINOR_NET_DISK_INFO                0xa8 //Network hard disk info
#define MINOR_RAID_INFO                 0xa9 //raid Info
#define MINOR_RUN_STATUS_INFO           0xaa //run status info

//Netra3.0.0
#define MINOR_SPARE_START_BACKUP        0xab   /*Spare start backup*/
#define MINOR_SPARE_STOP_BACKUP            0xac   /*Spare stop backup*/
#define MINOR_SPARE_CLIENT_INFO         0xad   /*Spare client infomation*/
#define MINOR_ANR_RECORD_START            0xae   /*ANR record start*/
#define MINOR_ANR_RECORD_END            0xaf   /*ANR record end*/
#define MINOR_ANR_ADD_TIME_QUANTUM        0xb0    /*ANR add time quantum*/
#define MINOR_ANR_DEL_TIME_QUANTUM        0xb1    /*ANR del time quantum*/

#define MINOR_PIC_REC_START             0xb3 //start snapshot     
#define MINOR_PIC_REC_STOP              0xb4 //stop snapshot 
#define MINOR_PIC_REC_OVERDUE           0xb5 //delete delayed picture

//Netra3.1.0
#define  MINOR_CLIENT_LOGIN             0xb6   /*login serice success*/
#define  MINOR_CLIENT_RELOGIN            0xb7   /*relogin serice*/
#define  MINOR_CLIENT_LOGOUT            0xb8   /*logout serice s*/
#define  MINOR_CLIENT_SYNC_START        0xb9   /*record sync start */
#define  MINOR_CLIENT_SYNC_STOP            0xba   /*record sync stop*/
#define  MINOR_CLIENT_SYNC_SUCC            0xbb   /*record sync success*/
#define  MINOR_CLIENT_SYNC_EXCP            0xbc   /*record sync excption*/
#define  MINOR_GLOBAL_RECORD_ERR_INFO   0xbd   /*global record err info*/
#define  MINOR_BUFFER_STATE             0xbe   /*The state of the buffer logging*/
#define  MINOR_DISK_ERRORINFO_V2        0xbf   /*Disk error details V2*/
#define  MINOR_CS_DATA_EXPIRED          0xc0   //cloud storage data out of date
#define  MINOR_PLAT_INFO                0xc1   //plat operation info
#define  MINOR_DIAL_STAT                0xc2   /*dial statues*/
#define  MINOR_UNLOCK_RECORD            0xc3   //unlock Record
#define  MINOR_VIS_ALARM                0xc4   //VIS Alarm
#define  MINOR_TALK_RECORD              0xc5   //talk Record
#define MINOR_ACCESSORIES_MESSAGE       0xc6 //Accessories plate information 
#define MINOR_KMS_EXPAMSION_DISK_INSERT 0xc7// KMS Expansion disc insert 
#define MINOR_IPC_CONNECT               0xc8//  IPC connect information
#define MINOR_INTELLIGENT_BOARD_STATUS  0xc9//  Intelligent board status
#define MINOR_IPC_CONNECT_STATUS        0xca//  IPC connect status
#define MINOR_AUTO_TIMING               0xcb  //Automatic correcting time 
#define MINOR_EZVIZ_OPERATION           0xcc   //Fluorite running state 
#define MINOR_CLUSTER_DEVICE_ONLINE     0xcd   //cluster device online
#define MINOR_CLUSTER_MGR_SERVICE_STARTUP 0xce   //cluster management service start up
#define MINOR_CLUSTER_BUSINESS_TRANSFER 0xcf   //cluster business transfer
#define MINOR_CLUSTER_STATUS            0xd0   //cluster status
#define MINOR_CLUSTER_CS_STATUS            0xd1   //cluster cs nvr send status to CM failed 
#define MINOR_CLUSTER_CM_STATUS            0xd2   //CM role change
#define MINOR_VOICE_START_DETECTED         0xd3  /*Voice start detected*/
#define MINOR_VOICE_END_DETECTED           0xd4  /*Voice end detected*/
#define MINOR_DOUBLE_VERIFICATION_PASS     0xd5  /*Double verification pass*/
#define MINOR_WIRELESS_RUNNING_STATUS      0xd6  /*Wireless running status*/
#define MINOR_SYSTEM_DATA_SYNCHRONIZATION  0xd7  /*System data synchronization*/
#define MINOR_HD_FORMAT_START   0xd8  /*Hard disk format start*/
#define MINOR_HD_FORMAT_STOP   0xd9  /*Hard disk format end*/

//802.1x
#define MINOR_802_1X_AUTH_SUCC          0x320   /*802.1x auth success*/
#define MINOR_802_1X_AUTH_FAIL          0x321   /*802.1x auth fail*/
//0x400-0x4ff 
#define MINOR_LIVE_DETECT_OPEN         0x400    //open live detection
#define MINOR_LIVE_DETECT_CLOSE        0x401    //close live detection
#define MINOR_CLEAR_DATA_COLLECTION    0x402    //clear data collection
#define MINOR_DELETE_DATA_COLLECTION   0x403    //delete data collection
#define MINOR_EXPORT_DATA_COLLECTION   0x404    //export data collection
#define MINOR_CARD_LEN_CONFIG          0x405    //config card len
#define MINOR_DATA_BASE_INIT_FAILED   0x406    //init db failed
#define MINOR_DATA_BASE_PATCH_UPDATE   0x407    //patch update failed
#define MINOR_PSAM_CARD_INSERT         0x408    //Psam insert
#define MINOR_PSAM_CARD_REMOVE         0x409    //Psam remove
#define MINOR_HARD_FAULT_REBOOT                0x40a  //hardfault reboot
#define MINOR_PSAM_CARD_OCP                    0x40b  //Psam OCP
#define MINOR_STACK_OVERFLOW                   0x40c      //stack overflow
#define MINOR_PARM_CFG                         0x40d  
#define MINOR_CLR_USER                         0x40e
#define MINOR_CLR_CARD                         0x40f
#define MINOR_CLR_FINGER_BY_READER             0x410
#define MINOR_CLR_FINGER_BY_CARD               0x411
#define MINOR_CLR_FINGER_BY_EMPLOYEE_ON        0x412
#define MINOR_DEL_FINGER                       0x413
#define MINOR_CLR_WEEK_PLAN                    0x414
#define MINOR_SET_WEEK_PLAN                    0x415
#define MINOR_SET_HOLIDAY_PLAN                 0x416
#define MINOR_CLR_HOLIDAY_PLAN                 0x417
#define MINOR_SET_HOLIDAY_GROUP                0x418
#define MINOR_CLR_HOLIDAY_GROUP                0x419
#define MINOR_CLR_TEMPLATE_PLAN                0x41a
#define MINOR_SET_TEMPLATE_PLAN                0x41b
#define MINOR_ADD_CARD                         0x41c
#define MINOR_MOD_CARD                         0x41d
#define MINOR_ADD_FINGER_BY_CARD               0x41e
#define MINOR_ADD_FINGER_BY_EMPLOYEE_NO        0x41f
#define MINOR_MOD_FINGER_BY_CARD               0x420
#define MINOR_MOD_FINGER_BY_EMPLOYEE_NO        0x421
#define MINOR_IMPORT_USER_LIST                 0x422
#define MINOR_USB_LOGIN                        0x423
#define MINOR_USB_LOGOUT                       0x424
#define MINOR_ISAPI_HTTP_LOGIN                 0x425
#define MINOR_ISAPI_HTTP_LOGOUT                0x426
#define MINOR_ISAPI_HTTPS_LOGIN                0x427
#define MINOR_ISAPI_HTTPS_LOGOUT               0x428
#define MINOR_ISUP_ONLINE                      0x429
#define MINOR_ISUP_OFFLINE                     0x42a
#define MINOR_FP_ISSUE_REC                     0x42b
#define MINOR_FACE_ISSUE_REC                   0x42c
#define MINOR_ADD_IRIS                             0x42d  
#define MINOR_MODIFY_IRIS                          0x42e  
#define MINOR_DELETE_EMPLOYEE_IRIS                 0x42f   
#define MINOR_DELETE_WHOLE_IRIS                    0x430   
#define MINOR_MODIFY_IRIS_CFG                      0x431  
#define MINOR_ADD_USER_INFO                    0x432
#define MINOR_MODIFY_USER_INFO                 0x433
#define MINOR_CLR_USER_INFO                    0x434
#define MINOR_CLR_CARD_BY_CARD_OR_EMPLOYEE     0x435 
#define MINOR_CLR_ALL_CARD                     0x436
#define MINOR_SIM_CARD_INSERT                  0x437
#define MINOR_SIM_CARD_PULLOUT                 0x438
#define MINOR_FINGERPRINT_RECOGNITION_OPEN     0x439
#define MINOR_FINGERPRINT_RECOGNITION_CLOSE    0x43a
#define MINOR_FACE_RECOGNITION_OPEN            0x43b
#define MINOR_FACE_RECOGNITION_CLOSE           0x43c
#define MINOR_RESET_ONLINE_READER              0x43d
#define MINOR_CLEAR_IRIS_PICTURE               0x43e

/*event*/
//major event
#define MAJOR_EVENT                             0x5     /*event*/
//minor type 
#define MINOR_LEGAL_CARD_PASS                   0x01    //legal card pass
#define MINOR_CARD_AND_PSW_PASS                 0x02    //swipe and password pass 
#define MINOR_CARD_AND_PSW_FAIL                 0x03    //swipe and password fail
#define MINOR_CARD_AND_PSW_TIMEOUT              0x04    //swipe and password timeout 
#define MINOR_CARD_AND_PSW_OVER_TIME            0x05    //swipe and password over time 
#define MINOR_CARD_NO_RIGHT                     0x06    //card no right 
#define MINOR_CARD_INVALID_PERIOD               0x07    //invalid period 
#define MINOR_CARD_OUT_OF_DATE                  0x08    //card out of date
#define MINOR_INVALID_CARD                      0x09    //invalid card 
#define MINOR_ANTI_SNEAK_FAIL                   0x0a    //anti sneak fail 
#define MINOR_INTERLOCK_DOOR_NOT_CLOSE          0x0b    //interlock door doesn't close 
#define MINOR_NOT_BELONG_MULTI_GROUP            0x0c    //card no belong multi group 
#define MINOR_INVALID_MULTI_VERIFY_PERIOD       0x0d    // invalid multi verify period 
#define MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL     0x0e    //have no super right  in multi verify mode
#define MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL    0x0f    //have no remote right in multi verify mode
#define MINOR_MULTI_VERIFY_SUCCESS              0x10    // success in multi verify mode 
#define MINOR_LEADER_CARD_OPEN_BEGIN            0x11    // leader card begin to open 
#define MINOR_LEADER_CARD_OPEN_END              0x12    // leader card end to open 
#define MINOR_ALWAYS_OPEN_BEGIN                 0x13    // always open begin 
#define MINOR_ALWAYS_OPEN_END                   0x14    //always open end 
#define MINOR_LOCK_OPEN                         0x15    //lock open 
#define MINOR_LOCK_CLOSE                        0x16    //lock close 
#define MINOR_DOOR_BUTTON_PRESS                 0x17    //press door open button
#define MINOR_DOOR_BUTTON_RELEASE               0x18    //release door open button 
#define MINOR_DOOR_OPEN_NORMAL                  0x19    //door open normal 
#define MINOR_DOOR_CLOSE_NORMAL                 0x1a    //door close normal 
#define MINOR_DOOR_OPEN_ABNORMAL                0x1b    //open door abnormal 
#define MINOR_DOOR_OPEN_TIMEOUT                 0x1c    //open door timeout 
#define MINOR_ALARMOUT_ON                       0x1d    //alarm out turn on 
#define MINOR_ALARMOUT_OFF                      0x1e    //alarm out turn off 
#define MINOR_ALWAYS_CLOSE_BEGIN                0x1f    //always close begin 
#define MINOR_ALWAYS_CLOSE_END                  0x20    //always close end                          
#define MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN     0x21    //need remote open in multi verify mode 
#define MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS  0x22  //superpasswd verify success in multi verify mode 
#define MINOR_MULTI_VERIFY_REPEAT_VERIFY        0x23    //repeat verify in multi verify mode 
#define MINOR_MULTI_VERIFY_TIMEOUT               0x24    //timeout in multi verify mode 
#define MINOR_DOORBELL_RINGING                  0x25    //doorbell ringing
#define MINOR_FINGERPRINT_COMPARE_PASS          0x26    //fingerprint compare pass
#define MINOR_FINGERPRINT_COMPARE_FAIL          0x27    //fingerprint compare fail
#define MINOR_CARD_FINGERPRINT_VERIFY_PASS              0x28    //card and fingerprint verify pass
#define MINOR_CARD_FINGERPRINT_VERIFY_FAIL              0x29    //card and fingerprint verify fail
#define MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT           0x2a    //card and fingerprint verify timeout
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS       0x2b    //card and fingerprint and passwd verify pass
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL       0x2c    //card and fingerprint and passwd verify fail
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT    0x2d    //card and fingerprint and passwd verify timeout
#define MINOR_FINGERPRINT_PASSWD_VERIFY_PASS            0x2e    //fingerprint and passwd verify pass
#define MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL            0x2f    //fingerprint and passwd verify fail
#define MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT         0x30    //fingerprint and passwd verify timeout
#define MINOR_FINGERPRINT_INEXISTENCE                   0x31    //fingerprint inexistence
#define MINOR_CARD_PLATFORM_VERIFY                      0x32    //card platform verify
#define MINOR_CALL_CENTER                               0x33    //call center
#define MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN       0x34    //fire relay turn on door always open
#define MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL    0x35    //fire relay recover door recover normal
#define MINOR_FACE_AND_FP_VERIFY_PASS                   0x36    //face and finger print verify pass
#define MINOR_FACE_AND_FP_VERIFY_FAIL                   0x37    //face and finger print verify fail
#define MINOR_FACE_AND_FP_VERIFY_TIMEOUT                0x38    //face and finger print verify timeout
#define MINOR_FACE_AND_PW_VERIFY_PASS                   0x39    //face and password verify pass
#define MINOR_FACE_AND_PW_VERIFY_FAIL                   0x3a    //face and password verify fail
#define MINOR_FACE_AND_PW_VERIFY_TIMEOUT                0x3b    //face and password verify timeout
#define MINOR_FACE_AND_CARD_VERIFY_PASS                 0x3c    //face and card verify pass
#define MINOR_FACE_AND_CARD_VERIFY_FAIL                 0x3d    //face and card verify fail
#define MINOR_FACE_AND_CARD_VERIFY_TIMEOUT              0x3e    //face and card verify timeout
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS            0x3f    //face and password and finger print verify pass
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL            0x40    //face and password and finger print verify fail
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT         0x41    //face and password and finger print verify timeout
#define MINOR_FACE_CARD_AND_FP_VERIFY_PASS              0x42    //face and card and finger print verify pass
#define MINOR_FACE_CARD_AND_FP_VERIFY_FAIL              0x43    //face and card and finger print verify fail
#define MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT           0x44    //face and card and finger print verify timeout
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS             0x45    //employee and finger print verify pass
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL             0x46    //employee and finger print verify fail
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT          0x47    //employee and finger print verify timeout
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS      0x48    //employee and finger print and password verify pass
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL      0x49    //employee and finger print and password verify fail
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT   0x4a    //employee and finger print and password verify timeout
#define MINOR_FACE_VERIFY_PASS                          0x4b    //face verify pass
#define MINOR_FACE_VERIFY_FAIL                          0x4c    //face verify fail
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS           0x4d    //employee no and face verify pass
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL           0x4e    //employee no and face verify fail
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT        0x4f    //employee no and face verify time out
#define MINOR_FACE_RECOGNIZE_FAIL                       0x50    //face recognize fail
#define MINOR_FIRSTCARD_AUTHORIZE_BEGIN                    0x51    //first card authorize begin
#define MINOR_FIRSTCARD_AUTHORIZE_END                    0x52    //first card authorize end
#define MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT                0x53    //door lock input short circuit
#define MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT                0x54    //door lock input broken circuit
#define MINOR_DOORLOCK_INPUT_EXCEPTION                    0x55    //door lock input exception
#define MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT            0x56    //door contact input short circuit
#define MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT            0x57    //door contact input broken circuit
#define MINOR_DOORCONTACT_INPUT_EXCEPTION                0x58    //door contact input exception
#define MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT            0x59    //open button input short circuit
#define MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT            0x5a    //open button input broken circuit
#define MINOR_OPENBUTTON_INPUT_EXCEPTION                0x5b    //open button input exception
#define MINOR_DOORLOCK_OPEN_EXCEPTION                    0x5c    //door lock open exception
#define MINOR_DOORLOCK_OPEN_TIMEOUT                        0x5d    //door lock open timeout
#define MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE            0x5e    //first card open without authorize
#define MINOR_CALL_LADDER_RELAY_BREAK                   0x5f    //call ladder relay break
#define MINOR_CALL_LADDER_RELAY_CLOSE                   0x60    //call ladder relay close
#define MINOR_AUTO_KEY_RELAY_BREAK                      0x61    //auto key relay break
#define MINOR_AUTO_KEY_RELAY_CLOSE                      0x62    //auto key relay close
#define MINOR_KEY_CONTROL_RELAY_BREAK                   0x63    //key control relay break
#define MINOR_KEY_CONTROL_RELAY_CLOSE                   0x64    //key control relay close
#define MINOR_EMPLOYEENO_AND_PW_PASS                    0x65    //minor employee no and password pass
#define MINOR_EMPLOYEENO_AND_PW_FAIL                    0x66    //minor employee no and password fail
#define MINOR_EMPLOYEENO_AND_PW_TIMEOUT                 0x67    //minor employee no and password timeout
#define MINOR_HUMAN_DETECT_FAIL                         0x68    //human detect fail
#define MINOR_PEOPLE_AND_ID_CARD_COMPARE_PASS           0x69    //the comparison with people and id card success
#define MINOR_PEOPLE_AND_ID_CARD_COMPARE_FAIL           0x70    //the comparison with people and id card failed
#define MINOR_CERTIFICATE_BLOCKLIST                     0x71    //block list
#define MINOR_LEGAL_MESSAGE                             0x72    //legal message
#define MINOR_ILLEGAL_MESSAGE                           0x73    //illegal messag
#define MINOR_DOOR_OPEN_OR_DORMANT_FAIL                 0x75    //door open or dormant fail
#define MINOR_AUTH_PLAN_DORMANT_FAIL                    0x76    //auth plan dormant fail
#define MINOR_CARD_ENCRYPT_VERIFY_FAIL                  0x77    //card encrypt verify fail
#define MINOR_SUBMARINEBACK_REPLY_FAIL                  0x78    //submarineback reply fail
#define MINOR_DOOR_OPEN_OR_DORMANT_OPEN_FAIL            0x82    //door open or dormant open fail
#define MINOR_HEART_BEAT                                0x83    //heart beat event
#define MINOR_DOOR_OPEN_OR_DORMANT_LINKAGE_OPEN_FAIL    0x84    //door open or dormant linkage open fail 
#define MINOR_TRAILING                                  0x85    //trailing
#define MINOR_REVERSE_ACCESS                            0x86    //reverse access
#define MINOR_FORCE_ACCESS                              0x87    //force access
#define MINOR_CLIMBING_OVER_GATE                        0x88    //climbing over gate
#define MINOR_PASSING_TIMEOUT                           0x89    //passing timeout
#define MINOR_INTRUSION_ALARM                           0x8a    //intrusion alarm
#define MINOR_FREE_GATE_PASS_NOT_AUTH                   0x8b    //free gate pass not auth
#define MINOR_DROP_ARM_BLOCK                            0x8c    //drop arm block
#define MINOR_DROP_ARM_BLOCK_RESUME                     0x8d    //drop arm block resume
#define MINOR_LOCAL_FACE_MODELING_FAIL                  0x8e   //device upgrade with module failed
#define MINOR_STAY_EVENT                                0x8f    //stay event
#define MINOR_PASSWORD_MISMATCH                         0x97    //password mismatch
#define MINOR_EMPLOYEE_NO_NOT_EXIST                     0x98    //employee no not exist
#define MINOR_COMBINED_VERIFY_PASS                      0x99    //combined verify pass
#define MINOR_COMBINED_VERIFY_TIMEOUT                   0x9a    //combined verify timeout
#define MINOR_VERIFY_MODE_MISMATCH                      0x9b    //verify mode mismatch
#define MINOR_ORCODE_VERIFY_PASS                        0x9c    //QR code verify pass
#define MINOR_ORCODE_VERIFY_FAIL                        0x9d    //QR code verify fail
#define MINOR_HOUSEHOLDER_AUTHORIZE_PASS                0x9e    //house holder authorize pass
#define MINOR_BLUETOOTH_VERIFY_PASS                     0x9f    //bluetooth verify pass
#define MINOR_BLUETOOTH_VERIFY_FAIL                     0xa0    //bluetooth verify fail

#define MINOR_PASSPORT_VERIFY_FAIL                      0xa1    //passport info verify failed
#define MINOR_INFORMAL_MIFARE_CARD_VERIFY_FAIL          0xa2   //informal mifare card verify failed
#define MINOR_CPU_CARD_ENCRYPT_VERIFY_FAIL              0xa3   //CPU card encrypt verify failed
#define MINOR_NFC_DISABLE_VERIFY_FAIL                   0xa4   //NFC disable verify failed

#define MINOR_LORA_MODULE_ONLINE                        0xa5    //LoRa module online
#define MINOR_LORA_MODULE_OFFLINE                       0xa6    //LoRa module offline
#define MINOR_MQTT_STATUS                               0xa7    //Mqtt status

#define MINOR_EM_CARD_RECOGNIZE_NOT_ENABLED             0xa8   //em card recognize not enabled
#define MINOR_M1_CARD_RECOGNIZE_NOT_ENABLED             0xa9   //m1 card recognize not enabled
#define MINOR_CPU_CARD_RECOGNIZE_NOT_ENABLED            0xaa   //cpu card recognize not enabled
#define MINOR_ID_CARD_RECOGNIZE_NOT_ENABLED             0xab   //id card recognize not enabled
#define MINOR_CARD_SET_SECRET_KEY_FAIL                  0xac   //card set secret key fail
#define MINOR_LOCAL_UPGRADE_FAIL                        0xad   //local upgrade fail
#define MINOR_REMOTE_UPGRADE_FAIL                       0xae   //remote upgrade fail
#define MINOR_REMOTE_EXTEND_MODULE_UPGRADE_SUCC         0xaf   //remote extend module upgrade succ
#define MINOR_REMOTE_EXTEND_MODULE_UPGRADE_FAIL         0xb0   //remote extend module upgrade fail
#define MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_SUCC   0xb1   //remote finger print module upgrade succ
#define MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_FAIL   0xb2   //remote fimger print module upgrade fail
#define MINOR_PASSWD_VERIFY_PASS                        0xb5   //passwd verify pass
#define MINOR_COMSUME_TIMEOUT                     0xb6   
#define MINOR_REFUND_TIMEOUT                       0xb7  
#define MINOR_COMSUME_AMOUNT_OVERLIMIT         0xb8  
#define MINOR_COMSUME_TIMES_OVERLIMIT            0xb9   
#define MINOR_USER_COMSUME_ENSURE_TIMEOUT      0xba 
#define MINOR_BLOCKLIST_REACH_THRESHOLD        0xbb  
#define MINOR_DESFIRE_CARD_ENCRYPT_VERIFY_FAIL          0xbc   
#define MINOR_DESFIRE_CARD_RECOGNIZE_NOT_ENABLED        0xbd   
#define MINOR_IRIS_VERIFY_PASS              0xbe
#define MINOR_IRIS_VERIFY_FAIL              0xbf
#define MINOR_IRIS_BIOASSAY_FAIL            0xc0
#define MINOR_FULL_STAFF                    0xc1
#define MINOR_ATTENDANCE_RECORD_EXCEED_THRESHOLD   0xc2
#define MINOR_DYNAMICCODE_VERIFY_INVALID           0xc3
#define MINOR_MEETING_NO_SIGNIN             0xc4  
#define MINOR_MEETING_SIGNIN                0xc5  
#define MINOR_MEETING_LATE                  0xc6  

#define MINOR_INTERLOCK_SERVER_FAILED_RESPONSE 0xc9
#define MINOR_FINGERPRINT_DISENABELD_VERIFY_FAIL 0xca 
#define MINOR_FACE_DISENABELD_VERIFY_FAIL 0xcb 
#define MINOR_MONITOR_OPEN_DOOR 0xcc
#define MINOR_READER_FACTORY_RESET 0xcd
#define MINOR_READER_ID_CONFLICT 0xce
#define MINOR_FELICA_CARD_RECOGNIZE_NOT_ENABLED        0xcf
#define MINOR_PROPERTY_EXCEPTION_VERIFY_FAIL           0xd0
#define MINOR_MEETING_NO_PERSON             0xd1
#define MINOR_MEETING_NOT_START             0xd2
#define MINOR_MEETING_SIGNEDIN              0xd3

#define MINOR_EVENT_CUSTOM1                         0x500  //event custom 1
#define MINOR_EVENT_CUSTOM2                         0x501  //event custom 2
#define MINOR_EVENT_CUSTOM3                         0x502  //event custom 3
#define MINOR_EVENT_CUSTOM4                         0x503  //event custom 4
#define MINOR_EVENT_CUSTOM5                         0x504  //event custom 5
#define MINOR_EVENT_CUSTOM6                         0x505  //event custom 6
#define MINOR_EVENT_CUSTOM7                         0x506  //event custom 7
#define MINOR_EVENT_CUSTOM8                         0x507  //event custom 8
#define MINOR_EVENT_CUSTOM9                         0x508  //event custom 9
#define MINOR_EVENT_CUSTOM10                        0x509  //event custom 10
#define MINOR_EVENT_CUSTOM11                        0x50a  //event custom 11
#define MINOR_EVENT_CUSTOM12                        0x50b  //event custom 12
#define MINOR_EVENT_CUSTOM13                        0x50c  //event custom 13
#define MINOR_EVENT_CUSTOM14                        0x50d  //event custom 14
#define MINOR_EVENT_CUSTOM15                        0x50e  //event custom 15
#define MINOR_EVENT_CUSTOM16                        0x50f  //event custom 16
#define MINOR_EVENT_CUSTOM17                        0x510  //event custom 17
#define MINOR_EVENT_CUSTOM18                        0x511  //event custom 18
#define MINOR_EVENT_CUSTOM19                        0x512  //event custom 19
#define MINOR_EVENT_CUSTOM20                        0x513  //event custom 20
#define MINOR_EVENT_CUSTOM21                        0x514  //event custom 21
#define MINOR_EVENT_CUSTOM22                        0x515  //event custom 22
#define MINOR_EVENT_CUSTOM23                        0x516  //event custom 23
#define MINOR_EVENT_CUSTOM24                        0x517  //event custom 24
#define MINOR_EVENT_CUSTOM25                        0x518  //event custom 25
#define MINOR_EVENT_CUSTOM26                        0x519  //event custom 26
#define MINOR_EVENT_CUSTOM27                        0x51a  //event custom 27
#define MINOR_EVENT_CUSTOM28                        0x51b  //event custom 28
#define MINOR_EVENT_CUSTOM29                        0x51c  //event custom 29
#define MINOR_EVENT_CUSTOM30                        0x51d  //event custom 30
#define MINOR_EVENT_CUSTOM31                        0x51e  //event custom 31
#define MINOR_EVENT_CUSTOM32                        0x51f  //event custom 32
#define MINOR_EVENT_CUSTOM33                        0x520  //event custom 33
#define MINOR_EVENT_CUSTOM34                        0x521  //event custom 34
#define MINOR_EVENT_CUSTOM35                        0x522  //event custom 35
#define MINOR_EVENT_CUSTOM36                        0x523  //event custom 36
#define MINOR_EVENT_CUSTOM37                        0x524  //event custom 37
#define MINOR_EVENT_CUSTOM38                        0x525  //event custom 38
#define MINOR_EVENT_CUSTOM39                        0x526  //event custom 39
#define MINOR_EVENT_CUSTOM40                        0x527  //event custom 40
#define MINOR_EVENT_CUSTOM41                        0x528  //event custom 41
#define MINOR_EVENT_CUSTOM42                        0x529  //event custom 42
#define MINOR_EVENT_CUSTOM43                        0x52a  //event custom 43
#define MINOR_EVENT_CUSTOM44                        0x52b  //event custom 44
#define MINOR_EVENT_CUSTOM45                        0x52c  //event custom 45
#define MINOR_EVENT_CUSTOM46                        0x52d  //event custom 46
#define MINOR_EVENT_CUSTOM47                        0x52e  //event custom 47
#define MINOR_EVENT_CUSTOM48                        0x52f  //event custom 48
#define MINOR_EVENT_CUSTOM49                        0x530  //event custom 49
#define MINOR_EVENT_CUSTOM50                        0x531  //event custom 50
#define MINOR_EVENT_CUSTOM51                        0x532  //event custom 51
#define MINOR_EVENT_CUSTOM52                        0x533  //event custom 52
#define MINOR_EVENT_CUSTOM53                        0x534  //event custom 53
#define MINOR_EVENT_CUSTOM54                        0x535  //event custom 54
#define MINOR_EVENT_CUSTOM55                        0x536  //event custom 55
#define MINOR_EVENT_CUSTOM56                        0x537  //event custom 56
#define MINOR_EVENT_CUSTOM57                        0x538  //event custom 57
#define MINOR_EVENT_CUSTOM58                        0x539  //event custom 58
#define MINOR_EVENT_CUSTOM59                        0x53a  //event custom 59
#define MINOR_EVENT_CUSTOM60                        0x53b  //event custom 60
#define MINOR_EVENT_CUSTOM61                        0x53c  //event custom 61
#define MINOR_EVENT_CUSTOM62                        0x53d  //event custom 62
#define MINOR_EVENT_CUSTOM63                        0x53e  //event custom 63
#define MINOR_EVENT_CUSTOM64                        0x53f  //event custom 64

#define MINOR_LOCK_FINGER_OPEN_DOOR          0x600    
#define MINOR_LOCK_PASSWORD_OPEN_DOOR        0x601    
#define MINOR_LOCK_CARD_OPEN_DOOR            0x602    
#define MINOR_LOCK_CENTER_OPEN_DOOR          0x603    
#define MINOR_LOCK_APP_OPEN_DOOR             0x604   
#define MINOR_LOCK_KEY_OPEN_DOOR             0x605   
#define MINOR_LOCK_REMOTE_DEVICE_OPEN_DOOR   0x606    
#define MINOR_LOCK_TMP_PASSWORD_OPEN_DOOR    0x607    
#define MINOR_LOCK_BLUETOOTH_OPEN_DOOR       0x608 
#define MINOR_LOCK_MULTI_OPEN_DOOR          0x609 

//2018-04-23 General gateway event type log
#define   MINOR_ALARMHOST_SCHOOLTIME_IRGI_B   0x1001     //B code timing
#define   MINOR_ALARMHOST_SCHOOLTIME_SDK     0x1002     //SDK timing
#define   MINOR_ALARMHOST_SCHOOLTIME_SELFTEST    0x1003   //Scheduled self-test timing
#define  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALINSERT   0x1004  //subSystem abnormal insert 
#define  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALPULLOUT   0x1005  //subSystem abnormal pull out

#define  MINOR_ALARMHOST_AUTO_ARM    0x1006  //auto arm
#define  MINOR_ALARMHOST_AUTO_DISARM    0x1007  //auto disarm
#define  MINOR_ALARMHOST_TIME_TIGGER_ON    0x1008  //turn on tigger on time
#define  MINOR_ALARMHOST_TIME_TIGGER_OFF   0x1009  //turn off tigger on time
#define  MINOR_ALARMHOST_AUTO_ARM_FAILD    0x100a  //auto arm failed
#define  MINOR_ALARMHOST_AUTO_DISARM_FAILD    0x100b  //auto disarm failed
#define  MINOR_ALARMHOST_TIME_TIGGER_ON_FAILD   0x100c  //turn on tigger on time failed
#define  MINOR_ALARMHOST_TIME_TIGGER_OFF_FAILD    0x100d  //turn off tigger on time failed
#define  MINOR_ALARMHOST_MANDATORY_ALARM    0x100e  //mandatory alarm
#define  MINOR_ALARMHOST_KEYPAD_LOCKED  0x100f  //keypad locked
#define  MINOR_ALARMHOST_USB_INSERT   0x1010  //USB insert 
#define  MINOR_ALARMHOST_USB_PULLOUT   0x1011 //USB pull out
#define  MINOR_ALARMHOST_4G_MODULS_ONLINE  0x1012  //4G module online
#define  MINOR_ALARMHOST_4G_MODULS_OFFLINE  0x1013  //4Gmodule offline

#define  MINOR_EZVIZ_CLOUD_ONLINE   0x1014   //EZVIZ on line
#define  MINOR_EZVIZ_CLOUD_OFFLINE    0x1015   //EZVIZ off line

#define  MINOR_SIPUA_GRID_ONLINE     0x1016   //SIP grid on line
#define  MINOR_SIPUA_GRID_OFFLINE    0x1017   //SIP grid off line

#define  MINOR_INTERNET_ACCESS_CONNECTED  0x1018   //Internet access connected
#define  MINOR_INTERNET_ACCESS_BREAK  0x1019  //Internet access break

#define  MINOR_WIRELESS_CONNECTED   0x101a  //Wireless connected
#define  MINOR_WIRELESS_BREAK     0x101b   //Wireless break
#define  MINOR_PORT_LINK_DOWN    0x101c  //port network link down
#define  MINOR_PORT_LINK_UP    0x101d  //port network link up
#define  MINOR_POE_PORT_POWER_ON    0x101e  //POE port power on
#define  MINOR_POE_PORT_POWER_OFF    0x101f  //POE port power off
#define  MINOR_POE_TOTAL_POWER_MAX    0x1020  //POE total power to poe-max
#define  MINNOR_POE_TOTAL_POWER_RESUME   0x1021  //POE total power resume
#define  MINNOR_CARGO_ITEMS   0x1022  //cargo items

typedef enum tagALARMHOST_MAJOR_TYPE
{
    MAJOR_ALARMHOST_ALARM = 1,
    MAJOR_ALARMHOST_EXCEPTION,
    MAJOR_ALARMHOST_OPERATION,
    MAJ0R_ALARMHOST_EVENT
}ALARMHOST_MAJOR_TYPE;

typedef enum tagALARMHOST_MINOR_TYPE
{
    // Alarm 
    MINOR_SHORT_CIRCUIT = 0x01,      // Short circuit alarm
    MINOR_BROKEN_CIRCUIT,           // Broken circuit alarm
    MINOR_ALARM_RESET,              // Alarm reset 
    MINOR_ALARM_NORMAL,                // Alarm resumes to normal
    MINOR_PASSWORD_ERROR,            // Password error(consecutive times for password error)
    MINOR_ID_CARD_ILLEGALLY,        // Illegal proximity card ID
    MINOR_KEYPAD_REMOVE,            // Keypad tamper
    MINOR_KEYPAD_REMOVE_RESTORE,    // Keypad tamper reset
    MINOR_DEV_REMOVE,                // Device tamper
    MINOR_DEV_REMOVE_RESTORE,        // Device tamper reset
    MINOR_BELOW_ALARM_LIMIT1,        // Analog lower than alarm limit 1
    MINOR_BELOW_ALARM_LIMIT2,        // Analog lower than alarm limit 2
    MINOR_BELOW_ALARM_LIMIT3,        // Analog lower than alarm limit 3
    MINOR_BELOW_ALARM_LIMIT4,        // Analog lower than alarm limit 4
    MINOR_ABOVE_ALARM_LIMIT1,        // Analog higher than alarm limit 1
    MINOR_ABOVE_ALARM_LIMIT2,        // Analog higher than alarm limit 2
    MINOR_ABOVE_ALARM_LIMIT3,        // Analog higher than alarm limit 3
    MINOR_ABOVE_ALARM_LIMIT4,        // Analog higher than alarm limit 4
    MINOR_URGENCYBTN_ON,            // Urgency button on
    MINOR_URGENCYBTN_OFF,            // Urgency button off
    MINOR_VIRTUAL_DEFENCE_BANDIT,            //Virtual zone bandit
    MINOR_VIRTUAL_DEFENCE_FIRE,                //virtual zone fire
    MINOR_VIRTUAL_DEFENCE_URGENT,            //virtual zone urgent
    MINOR_ALARMHOST_MOTDET_START,            //start move detection
    MINOR_ALARMHOST_MOTDET_STOP,            //stop move detection
    MINOR_ALARMHOST_HIDE_ALARM_START,        //start hide alarm
    MINOR_ALARMHOST_HIDE_ALARM_STOP,        //stop hide alarm
    MINOR_ALARMHOST_UPS_ALARM,                //UPS alarm
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM, //electricity meter alarm
    MINOR_ALARMHOST_SWITCH_POWER_ALARM,      //switch power alarm
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,      //gas detect system alarm
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM, //transformer temprature alarm
    MINOR_ALARMHOST_TEMP_HUMI_ALARM,            //temprature&huminity sensor alarm
    MINOR_ALARMHOST_UPS_ALARM_RESTORE,    //UPS alarm restore
    MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE, //electricity meter alarm restore
    MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,      //switch power alarm restore
    MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,      //gas detect system alarm restore
    MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE, //transformer temprature alarm restore
    MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,          //temprature&huminity sensor alarm restore
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,            //water level sensor alarm
    MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,    //water level sensor alarm restore
    MINOR_ALARMHOST_DUST_NOISE_ALARM,                    //dust and noise alarm
    MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,            //dust and noise alarm restore
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,            //environmental logger alarm
    MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,    //environmental logger alarm restore

    MINOR_ALARMHOST_TRIGGER_TAMPER,                //trigger tamper
    MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,                //trigger tamper restore
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM,            //emergency call help alarm
    MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM_RESTORE,    //emergency call help alarm restore
    MINOR_ALARMHOST_CONSULTING_ALARM,                     //consult alarm
    MINOR_ALARMHOST_CONSULTING_ALARM_RESTORE,             //consult alarm restore
    MINOR_ZONE_MODULE_REMOVE,            // zone module remove
    MINOR_ZONE_MODULE_RESET,    // zone module reset

    MINOR_ALARM_WIND_SPEED_ALARM,
    MINOR_ALARM_WIND_SPEED_ALARM_RESTORE,
    MINOR_ALARM_GENERATE_OUTPUT_ALARM,
    MINOR_ALARM_GENERATE_OUTPUT_RESTORE,
    MINOR_ALARM_SOAK_ALARM,
    MINOR_ALARM_SOAK_ALARM_RESTORE,
    MINOR_ALARM_SOLAR_POWER_ALARM,
    MINOR_ALARM_SOLAR_POWER_ALARM_RESTORE,
    MINOR_ALARM_SF6_ALARM,
    MINOR_ALARM_SF6_ALARM_RESTORE,
    MINOR_ALARM_WEIGHT_ALARM,
    MINOR_ALARM_WEIGHT_ALARM_RESTORE,
    MINOR_ALARM_WEATHER_ALARM,
    MINOR_ALARM_WEATHER_ALARM_RESTORE,
    MINOR_ALARM_FUEL_GAS_ALARM,
    MINOR_ALARM_FUEL_GAS_ALARM_RESTORE,
    MINOR_ALARM_FIRE_ALARM,
    MINOR_ALARM_FIRE_ALARM_RESTORE,

    MINOR_WIRELESS_OUTPUT_MODULE_REMOVE,            // wireless output module remove
    MINOR_WIRELESS_OUTPUT_MODULE_RESET,    // wireless output module reset
    MINOR_WIRELESS_REPEATER_MODULE_REMOVE,            // wireless repeater module remove
    MINOR_WIRELESS_REPEATER_MODULE_RESET,    // wireless repeater module reset
    MINOR_WIRELESS_SIREN_MODULE_REMOVE,            // wireless siren module remove
    MINOR_WIRELESS_SIREN_MODULE_RESET,    // wireless siren module reset
    MINOR_SOUND_INTENSITY_RISE,         // sound intensity rise
    MINOR_SOUND_INTENSITY_RISE_RESET,   // sound intensity rise reset
    MINOR_SOUND_INTENSITY_DROP,         // sound intensity drop
    MINOR_SOUND_INTENSITY_DROP_RESET,   // sound intensity drop reset
    MINOR_AUDIO_INPUT_EXCEPTION,        // audio input exception
    MINOR_AUDIO_INPUT_EXCEPTION_RESET,  // audio input exception reset
	MINOR_FACE_DETECTION_ALARM,    // face detection alarm
    MINOR_FACE_DETECTION_ALARM_RESTORE,    // face detection alarm reset

    // Exception
    MINOR_POWER_ON = 0x01,        // Power on
    MINOR_POWER_OFF,                // Power off
    MINOR_WDT_RESET,                // WDT reset
    MINOR_LOW_BATTERY_VOLTAGE,        // Low battery voltage
    MINOR_AC_LOSS,                    // AC loss
    MINOR_AC_RESTORE,                // AC restore
    MINOR_RTC_EXCEPTION,            // RTC real-time clock exception
    MINOR_NETWORK_CONNECT_FAILURE,    // Network is disconnected
    MINOR_NETWORK_CONNECT_RESTORE,    // Network connection restore
    MINOR_TEL_LINE_CONNECT_FAILURE,    // Telephone line is disconnected
    MINOR_TEL_LINE_CONNECT_RESTORE,    // Telephone line restore
    MINOR_EXPANDER_BUS_LOSS,        // Expansion bus module dropped
    MINOR_EXPANDER_BUS_RESTORE,        // Expansion bus module restore
    MINOR_KEYPAD_BUS_LOSS,            // Keyboard bus module dropped
    MINOR_KEYPAD_BUS_RESTORE,        // Keyboard bus module restore 
    MINOR_SENSOR_FAILURE,            // Analog sensor failure
    MINOR_SENSOR_RESTORE,            // Analog sensor restore
    MINOR_RS485_CONNECT_FAILURE,    // RS485 channel is disconnected
    MINOR_RS485_CONNECT_RESTORE,    // RS485 channel disconnection restore
    MINOR_BATTERT_VOLTAGE_RESTORE,  // Battery voltage resume to normal 
    MINOR_WIRED_NETWORK_ABNORMAL,    // network abnormal
    MINOR_WIRED_NETWORK_RESTORE,    // network restore
    MINOR_GPRS_ABNORMAL,            // GPRS abnormal
    MINOR_GPRS_RESTORE,                // GPRS restore
    MINOR_3G_ABNORMAL,                // 3G abnormal
    MINOR_3G_RESTORE,                // 3G restore
    MINOR_SIM_CARD_ABNORMAL,        // SIM Card abnormal
    MINOR_SIM_CARD_RESTORE,            // SIM Card restore
    MINOR_ALARMHOST_VI_LOST,        // video lost
    MINOR_ALARMHOST_ILLEGAL_ACCESS,    // illegnal access
    MINOR_ALARMHOST_HD_FULL,        // hard disk full
    MINOR_ALARMHOST_HD_ERROR,        // hard disk error
    MINOR_ALARMHOST_DCD_LOST,        // MODEM lost
    MINOR_ALARMHOST_IP_CONFLICT,    // IP  conflict
    MINOR_ALARMHOST_NET_BROKEN,        // network broken
    MINOR_ALARMHOST_REC_ERROR,      // record error
    MINOR_ALARMHOST_VI_EXCEPTION,   // video exception
    MINOR_ALARMHOST_FORMAT_HDD_ERROR, //format hard disk error
    MINOR_ALARMHOST_USB_ERROR,        //USB connect error
    MINOR_ALARMHOST_USB_RESTORE,    //USB connect restore
    MINOR_ALARMHOST_PRINT_ERROR,    //printer error
    MINOR_ALARMHOST_PRINT_RESTORE,    //printer restore
    MINOR_SUBSYSTEM_COMMUNICATION_ERROR, //subsystem communication error
    MINOR_ALARMHOST_IPC_NO_LINK,        //IPC connection failed 
    MINOR_ALARMHOST_IPC_IP_CONFLICT,//IPC IP conflict
    MINOR_ALARMHOST_VI_MISMATCH,    //Video format error.
    MINOR_ALARMHOST_MCU_RESTART,    //MCU restart
    MINOR_ALARMHOST_GPRS_MODULE_FAULT,                     //GPRS Module Fault
    MINOR_ALARMHOST_TELEPHONE_MODULE_FAULT,                 //Telephone Module Fault
    MINOR_ALARMHOST_WIFI_ABNORMAL,
    MINOR_ALARMHOST_WIFI_RESTORE,
    MINOR_ALARMHOST_RF_ABNORMAL,
    MINOR_ALARMHOST_RF_RESTORE,
    MINOR_ALARMHOST_DETECTOR_ONLINE,
    MINOR_ALARMHOST_DETECTOR_OFFLINE,
    MINOR_ALARMHOST_DETECTOR_BATTERY_NORMAL,
    MINOR_ALARMHOST_DETECTOR_BATTERY_LOW,
    MINOR_ALARMHOST_DATA_TRAFFIC_OVERFLOW,
    MINOR_ZONE_MODULE_LOSS,
    MINOR_ZONE_MODULE_RESTORE,
    MINOR_ALARMHOST_WIRELESS_OUTPUT_LOSS,   //wireless output module loss
    MINOR_ALARMHOST_WIRELESS_OUTPUT_RESTORE,   //wireless output module restore
    MINOR_ALARMHOST_WIRELESS_REPEATER_LOSS,   //wireless repeater loss
    MINOR_ALARMHOST_WIRELESS_REPEATER_RESTORE,   //wireless repeater restore
    MINOR_TRIGGER_MODULE_LOSS,            // trigger module loss
    MINOR_TRIGGER_MODULE_RESTORE,        // trigger module restore
    MINOR_WIRELESS_SIREN_LOSS,            // wireless siren loss
    MINOR_WIRELESS_SIREN_RESTORE,    // wireless siren  restore
    MINOR_ALARMHOST_WIRELESS_RS485_LOSS, //wireless RS485 module loss
    MINOR_ALARMHOST_WIRELESS_RS485_RESTORE, //wireless RS485 module loss restore


    // Operation
    MINOR_GUARD = 0x01,        // Normal arm
    MINOR_UNGUARD,                    // Normal disarm
    MINOR_BYPASS,                    // Bypass
    MINOR_DURESS_ACCESS,            // Duress access
    MINOR_ALARMHOST_LOCAL_REBOOT,    // Local reboot
    MINOR_ALARMHOST_REMOTE_REBOOT,    // Remote reboot
    MINOR_ALARMHOST_LOCAL_UPGRADE,    // Local upgrade
    MINOR_ALARMHOST_REMOTE_UPGRADE,    // Remote upgrade
    MINOR_RECOVERY_DEFAULT_PARAM,    // Recovery default parameter
    MINOR_ALARM_OUTPUT,                // Control alarm output 
    MINOR_ACCESS_OPEN,                // Control access open
    MINOR_ACCESS_CLOSE,                // Control access close
    MINOR_SIREN_OPEN,                // Control siren open
    MINOR_SIREN_CLOSE,                // Control siren close
    MINOR_MOD_ZONE_CONFIG,              // Modify defense area configuration
    MINOR_MOD_ALARMOUT_CONIFG,        // Control alarmout configuration
    MINOR_MOD_ANALOG_CONFIG,        // Modify analog configuration
    MINOR_RS485_CONFIG,                // Modify RS-485 configuration
    MINOR_PHONE_CONFIG,                // Modify dialing configuration
    MINOR_ADD_ADMIN,                // Add administrator
    MINOR_MOD_ADMIN_PARAM,            // Modify password of administrator
    MINOR_DEL_ADMIN,                // Delete administrator
    MINOR_ADD_NETUSER,                // Add network user
    MINOR_MOD_NETUSER_PARAM,        // Modify password of network user
    MINOR_DEL_NETUSER,                // Delete network user
    MINOR_ADD_OPERATORUSER,            // Add operator user
    MINOR_MOD_OPERATORUSER_PW,        // Add operator user
    MINOR_DEL_OPERATORUSER,            // Add operator user
    MINOR_ADD_KEYPADUSER,            // Add user of keyboard or card reader    
    MINOR_DEL_KEYPADUSER,            // Delete user of keyboard or card reader
    MINOR_REMOTEUSER_LOGIN,            // Remote login
    MINOR_REMOTEUSER_LOGOUT,        // Remote logout
    MINOR_REMOTE_GUARD,                // Remotely fortify
    MINOR_REMOTE_UNGUARD,            // Remotely cancel fortification
    MINOR_MOD_HOST_CONFIG,          // Modify host configuration
    MINOR_RESTORE_BYPASS,            // Bypass restore
    MINOR_ALARMOUT_OPEN,            // Open alarm out
    MINOR_ALARMOUT_CLOSE,            // Close alarm out
    MINOR_MOD_SUBSYSTEM_PARAM,        // Mod subsystem config
    MINOR_GROUP_BYPASS,                // Group bypass
    MINOR_RESTORE_GROUP_BYPASS,        // Restore group bypass
    MINOR_MOD_GRPS_PARAM,            // Mod gprs parameter
    MINOR_MOD_NET_REPORT_PARAM,        // Mod net report config
    MINOR_MOD_REPORT_MOD,            // Mod report config
    MINOR_MOD_GATEWAY_PARAM,        // Mod gateway config
    MINOR_ALARMHOST_REMOTE_START_REC,        // Start remote record
    MINOR_ALARMHOST_REMOTE_STOP_REC,        // Stop remote record
    MINOR_ALARMHOST_START_TRANS_CHAN,        // Start trans channel
    MINOR_ALARMHOST_STOP_TRANS_CHAN,        // Stop trans channel
    MINOR_ALARMHOST_START_VT,                // Start voice intercom
    MINOR_ALARMHOST_STOP_VTM,                // Stop voice intercom
    MINOR_ALARMHOST_REMOTE_PLAYBYFILE,        // Remote playback by file name
    MINOR_ALARMHOST_REMOTE_PLAYBYTIME,      // Remote playback by time
    MINOR_ALARMHOST_REMOTE_PTZCTRL,            // Remote PTZ control
    MINOR_ALARMHOST_REMOTE_FORMAT_HDD,      // Remote Format hard disk
    MINOR_ALARMHOST_REMOTE_LOCKFILE,        // Remote lock file
    MINOR_ALARMHOST_REMOTE_UNLOCKFILE,      // Remote unlock file
    MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // Remote Import config file
    MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // Remote Export config file
    MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // Remote Export record file

    MINOR_ALARMHOST_STAY_ARM,                        //stay arm
    MINOR_ALARMHOST_QUICK_ARM,                        //quick arm
    MINOR_ALARMHOST_AUTOMATIC_ARM,                    //auto arm
    MINOR_ALARMHOST_AUTOMATIC_DISARM,                //auto disarm
    MINOR_ALARMHOST_KEYSWITCH_ARM,                    //key switch arm
    MINOR_ALARMHOST_KEYSWITCH_DISARM,                //key switch disarm
    MINOR_ALARMHOST_CLEAR_ALARM,                    //clear alarm
    MINOR_ALARMHOST_MOD_FAULT_CFG,                    //mod fault config
    MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,    //mod event cause alarm out 
    MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,            //search external module
    MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,        //register external module
    MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,            //close keyboard alarm
    MINOR_ALARMHOST_MOD_3G_PARAM,                    //modify 3G parameter
    MINOR_ALARMHOST_MOD_PRINT_PARAM, //modify printer parameter
    MINOR_SD_CARD_FORMAT,        //SD card format
    MINOR_SUBSYSTEM_UPGRADE,        //subsystem upgrade

    MINOR_ALARMHOST_PLAN_ARM_CFG,    //arm plan config 
    MINOR_ALARMHOST_PHONE_ARM,        //phone arm
    MINOR_ALARMHOST_PHONE_STAY_ARM,    //phone stay arm
    MINOR_ALARMHOST_PHONE_QUICK_ARM,//phone quick arm
    MINOR_ALARMHOST_PHONE_DISARM,    //phone disarm
    MINOR_ALARMHOST_PHONE_CLEAR_ALARM,    //phone clear alarm
    MINOR_ALARMHOST_ALLOWLIST_CFG,    //allow list config
    MINOR_ALARMHOST_TIME_TRIGGER_CFG,            //turn on/off trigger config
    MINOR_ALARMHOST_CAPTRUE_CFG,                //capture config
    MINOR_ALARMHOST_TAMPER_CFG,                //tamper config

    MINOR_ALARMHOST_REMOTE_KEYPAD_UPGRADE,               //Remote Keypad Upgrade
    MINOR_ALARMHOST_ONETOUCH_AWAY_ARMING,                //One-touch Away Arming
    MINOR_ALARMHOST_ONETOUCH_STAY_ARMING,                //One-touch Stay Arming
    MINOR_ALARMHOST_SINGLE_PARTITION_ARMING_OR_DISARMING,    //Single Partition Arming/Disarming 
    MINOR_ALARMHOST_CARD_CONFIGURATION,         //Card Configuration
    MINOR_ALARMHOST_CARD_ARMING_OR_DISARMING,         //Card Arming/Disarming
    MINOR_ALARMHOST_EXPENDING_NETCENTER_CONFIGURATION,         //Expending Network Center Configuration
    MINOR_ALARMHOST_NETCARD_CONFIGURATION,         //Network Card Configuration
    MINOR_ALARMHOST_DDNS_CONFIGURATION,         //DDNS Configuration
    MINOR_ALARMHOST_RS485BUS_CONFIGURATION,        // RS-485 Bus Configuration
    MINOR_ALARMHOST_RS485BUS_RE_REGISTRATION,            //RS-486 Bus Re-registration

    MINOR_ALARMHOST_REMOTE_OPEN_ELECTRIC_LOCK,    //remote open electric lock
    MINOR_ALARMHOST_REMOTE_CLOSE_ELECTRIC_LOCK,    //remote close electric lock
    MINOR_ALARMHOST_LOCAL_OPEN_ELECTRIC_LOCK,    //local open electric lock
    MINOR_ALARMHOST_LOCAL_CLOSE_ELECTRIC_LOCK,    //local close electric lock
    MINOR_ALARMHOST_OPEN_ALARM_LAMP,            //open alarm lamp(remote)
    MINOR_ALARMHOST_CLOSE_ALARM_LAMP,            //close alarm lamp(remote)


    MINOR_ALARMHOST_TEMPORARY_PASSWORD,
    MINOR_ALARMHOST_ONEKEY_AWAY_ARM,
    MINOR_ALARMHOST_ONEKEY_STAY_ARM,
    MINOR_ALARMHOST_SINGLE_ZONE_ARM,
    MINOR_ALARMHOST_SINGLE_ZONE_DISARM,
    MINOR_ALARMHOST_HIDDNS_CONFIG,
    MINOR_ALARMHOST_REMOTE_KEYBOARD_UPDATA,
    MINOR_ALARMHOST_ZONE_ADD_DETECTOR,
    MINOR_ALARMHOST_ZONE_DELETE_DETECTOR,
    MINOR_ALARMHOST_QUERY_DETECTOR_SIGNAL,
    MINOR_ALARMHOST_QUERY_DETECTOR_BATTERY,
    MINOR_ALARMHOST_SET_DETECTOR_GUARD,
    MINOR_ALARMHOST_SET_DETECTOR_UNGUARD,
    MINOR_ALARMHOST_SET_WIFI_PARAMETER,
    MINOR_ALARMHOST_OPEN_VOICE,
    MINOR_ALARMHOST_CLOSE_VOICE,
    MINOR_ALARMHOST_ENABLE_FUNCTION_KEY,
    MINOR_ALARMHOST_DISABLE_FUNCTION_KEY,
    MINOR_ALARMHOST_READ_CARD,            //patrol read card
    MINOR_ALARMHOST_START_BROADCAST,             //open broadcast
    MINOR_ALARMHOST_STOP_BROADCAST,               //close broadcast
    MINOR_ALARMHOST_REMOTE_ZONE_MODULE_UPGRADE,
    MINOR_ALARMHOST_NETWORK_MODULE_EXTEND,    //network module params cfg
    MINOR_ALARMHOST_ADD_CONTROLLER,		//add controller user
    MINOR_ALARMHOST_DELETE_CONTORLLER,		//delete controller user
    MINOR_ALARMHOST_REMOTE_NETWORKMODULE_UPGRADE,
    MINOR_ALARMHOST_WIRELESS_OUTPUT_ADD,
    MINOR_ALARMHOST_WIRELESS_OUTPUT_DEL,
    MINOR_ALARMHOST_WIRELESS_REPEATER_ADD,
    MINOR_ALARMHOST_WIRELESS_REPEATER_DEL,
    MINOR_ALARMHOST_PHONELIST_CFG,
    MINOR_ALARMHOST_RF_SIGNAL_CHECK,
    MINOR_ALARMHOST_USB_UPGRADE,
    MINOR_ALARMHOST_DOOR_TIME_REMINDER_CFG,
    MINOR_ALARMHOST_WIRELESS_SIREN_ADD,
    MINOR_ALARMHOST_WIRELESS_SIREN_DEL,
    MINOR_ALARMHOST_OUT_SCALE_OPEN,
    MINOR_ALARMHOST_OUT_SCALE_CLOSE,

    MINOR_ALARMHOST_TIME_ZONE_CFG,
    MINOR_ALARMHOST_NTP_START_AND_PARAMETERS_CFG,
    MINOR_ALARMHOST_DST_START_AND_PARAMETERS_CFG,
    MINOR_ALARMHOST_DEVINFO_CFG,
    MINOR_ALARMHOST_VIDEO_OVERLAP_CFG,
    MINOR_ALARMHOST_SSH_CFG,
    MINOR_ALARMHOST_PASSWORD_MANAGE_CFG,
    MINOR_ALARMHOST_RESTORE_DEFAULT_PARAMETERS,
    MINOR_ALARMHOST_RESTORECOMPLETELY_DEFAULT_PARAMETERS,
    MINOR_ALARMHOST_AUDIO_AUTO_DETECT_CFG,
    MINOR_ALARMHOST_AUDIO_MANUAL_DETECT_CFG,
    MINOR_ALARMHOST_NET_PARAMETERS_CFG,
    MINOR_ALARMHOST_MTU_CFG,
    MINOR_ALARMHOST_PORT_CFG,
    MINOR_ALARMHOST_DEFAULT_ROUTER_CFG,
    MINOR_ALARMHOST_DNS_PARAMETERS_CFG,
    MINOR_ALARMHOST_UNPNP_PARAMETERS_CFG,
    MINOR_ALARMHOST_SIP_PARAMETERS_CFG,
    MINOR_ALARMHOST_FLOW_LIMIT_CFG,
    MINOR_ALARMHOST_APN_PARAMETERS_CFG,
    MINOR_ALARMHOST_MESSAGE_TELEPHONENO_CFG,
    MINOR_ALARMHOST_EZVIZ_PARAMATERS_CFG,
    MINOR_ALARMHOST_ISUP_PARAMATERS_CFG,
    MINOR_ALARMHOST_SIP_SWITCH_CFG,
    MINOR_ALARMHOST_INFO_UPLOAD_TO_PLATFORM_CFG,
    MINOR_ALARMHOST_ONVIF_CONTROL,
    MINOR_ALARMHOST_ONVIF_USER_ADD,
    MINOR_ALARMHOST_ONVIF_USER_MOD,
    MINOR_ALARMHOST_ONVIF_USER_DELETE,
    MINOR_ALARMHOST_TIME_OF_BELLS_CFG,
    MINOR_ALARMHOST_CALL_WAITTIME_CFG,
    MINOR_ALARMHOST_PROMPT_PARAMATERS_CFG,
    MINOR_ALARMHOST_MUTEPLAN_PARAMATERS_CFG,
    MINOR_ALARMHOST_SD_PARTITION_CFG,
    MINOR_ALARMHOST_AUDIO_PARAMETERS_CFG,
    MINOR_ALARMHOST_VOICETALK_AUDIO_ENCODING_CFG,
    MINOR_ALARMHOST_RECORD_PLAN_PARAMETERS_CFG,
    MINOR_ALARMHOST_RECORD_ADVANCE_PARAMETERS_CFG,
    MINOR_ALARMHOST_PICTURE_PLAN_PARAMETERS_CFG,
    MINOR_ALARMHOST_PICTURE_ADVANCE_PARAMETERS_CFG,
    MINOR_ALARMHOST_AUDIO_EXCEPTION_PARAMETERS_CFG,
    MINOR_ALARMHOST_PATROL_CARD_CFG,
    MINOR_ALARMHOST_VOICE_VOLUME_CFG,
    MINOR_ALARMHOST_VOICE_MODE_CFG,
    MINOR_ALARMHOST_AUDIO_OR_MATERIALS_UPLOAD,
    MINOR_ALARMHOST_AUDIO_OR_MATERIALS_DELETE,
    MINOR_ALARMHOST_ALARM_LAMP_FLASH_TIME_CFG,
    MINOR_ALARMHOST_ALARM_LAMP_FLASH_PLAN_CFG,
    MINOR_ALARMHOST_FRONT_END_VIDEO_PARAMETERS_CFG,
    MINOR_ALARMHOST_WDR_CFG,
    MINOR_ALARMHOST_BPFRAME_CFG,
    MINOR_ALARMHOST_PASSWORD_RESET_CFG,
    MINOR_ALARMHOST_ACCOUNT_LOCK,
    MINOR_ALARMHOST_ACCOUNT_UNLOCK,
    MINOR_ALARMHOST_START_LIVEVIEW_REMOTELY,
    MINOR_ALARMHOST_STOP_LIVEVIEW_REMOTELT,
    MINOR_ALARMHOST_TELEPHONE_CENTER_SETTINGS,
    MINOR_ALARMHOST_NATIONAL_STANDARD_CFG,
    MINOR_ALARMHOST_SUPPLEMENTLIGHT_CFG,
    MINOR_ALARMHOST_FACESNAP_CFG,
    MINOR_ALARMHOST_PUBLISHMANAGE_CFG,
    MINOR_ALARMHOST_KEYDIAL_CFG,
    MINOR_ALARMHOST_VOICETALK_SILENT_CFG,
    MINOR_ALARMHOST_START_VIDEO_PROTECT,
    MINOR_ALARMHOST_START_AUDIO_PROTECT,
    MINOR_ALARMHOST_START_MANUAL_ANSWER,
    MINOR_ALARMHOST_START_LOG_SERVER,
    MINOR_ALARMHOST_ADD_CARD,
    MINOR_ALARMHOST_DELETE_CARD,
	MINOR_ALARMHOST_MOTION_DETECTION_CFG,
    MINOR_ALARMHOST_VIDEO_BLOCK_CFG,
    MINOR_ALARMHOST_FACE_DETECTION_CFG,
    MINOR_ALARMHOST_LOG_BACKUP,


    MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = 0xf0,        //local activate device
    MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = 0xf1,        //remote activate device
    MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = 0xf2,    //local parameter factory default
    MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = 0xf3,    //remote parameter factory default

    MINOR_ADD_IPC = 0xf4,       //IPC add
    MINOR_MODIFY_IPC = 0xf5,    //IPC modify
    MINOR_DELETE_IPC = 0xf6,    //IPC delete
    MINOR_SYS_CHECK_START = 0xf7,  //sys check start
    MINOR_SYS_CHECK_STOP = 0xf8,  //sys check stop   
    MINOR_SYS_CHECK_FINISH = 0xf9, //sys check finish
    MINOR_DEVICE_TAMPER_CFG = 0xfa, //device tamper cfg
	MINOR_ALARMHOST_INDICATORLIGHT_CFG = 0xfb, //indicator light cfg
    MINOR_ALARMHOST_WIRELESSBUTTON_CFG = 0xfc, //wireless button cfg
    MINOR_ALARMHOST_IRCUTFILTER_CFG = 0xfd, //ircutfilter cfg
    MINOR_ALARMHOST_KEYWORD_AUDIO_RECOGNITION_CFG = 0xfe, //keyword audio recognition cfg

	
    // Event 
    MINOR_SCHOOLTIME_IRGI_B = 0x01,        // B code timing
    MINOR_SCHOOLTIME_SDK,                // SDK timing
    MINOR_SCHOOLTIME_SELFTEST,            // Scheduled self-test timing
    MINOR_SUBSYSTEM_ABNORMALINSERT,        //subSystem abnormal insert
    MINOR_SUBSYSTEM_ABNORMALPULLOUT,        //subSystem abnormal pullout

    MINOR_AUTO_ARM,                //auto arm
    MINOR_AUTO_DISARM,            //auto disarm
    MINOR_TIME_TIGGER_ON,                        //turn on tigger on time
    MINOR_TIME_TIGGER_OFF,                        //turn off tigger on time
    MINOR_AUTO_ARM_FAILD,            //auto arm failed
    MINOR_AUTO_DISARM_FAILD,        //auto disarm failed
    MINOR_TIME_TIGGER_ON_FAILD,                        //turn on tigger on time failed
    MINOR_TIME_TIGGER_OFF_FAILD,                        //turn off tigger on time failed
    MINOR_MANDATORY_ALARM,                //mandatory alarm
    MINOR_KEYPAD_LOCKED,            //keypad locked
    MINOR_USB_INSERT,
    MINOR_USB_PULLOUT,
    MINOR_KEYPAD_UNLOCK,            //keypad unlocked
}ALARMHOST_MINOR_TYPE;
/*
If the main type of the log is MAJOR_OPERATION=03 (Operation) And Sub type is
MINOR_LOCAL_CFG_PARM=0x52 (local configuration)
MINOR_REMOTE_GET_PARM=0x76 (remote get configuration)
MINOR_REMOTE_CFG_PARM=0x77 (remote set configuration)
dwParaType:  is valid,  and the relative definition is listed as below:
*/
#define PARA_VIDEOOUT      0x1
#define PARA_IMAGE          0x2
#define PARA_ENCODE          0x4
#define PARA_NETWORK      0x8
#define PARA_ALARM          0x10
#define PARA_EXCEPTION      0x20
#define PARA_DECODER      0x40    /*Decoder*/
#define PARA_RS232          0x80
#define PARA_PREVIEW      0x100
#define PARA_SECURITY      0x200
#define PARA_DATETIME      0x400
#define PARA_FRAMETYPE      0x800    /*Frame Type*/
#define PARA_DETECTION    0x1000   //Detection config
#define PARA_VCA_RULE     0x1001   //Rules of conduct 
#define PARA_VCA_CTRL     0x1002   //Intelligent control information configured
#define PARA_VCA_PLATE      0x1003   //  License Plate Recognition

#define PARA_CODESPLITTER 0x2000 /*spitter code parameter*/
//2010- 01- 22 
#define PARA_RS485          0x2001            /* RS485 config info*/
#define PARA_DEVICE          0x2002            /* Device config info*/
#define PARA_HARDDISK      0x2003            /* HD config info */
#define PARA_AUTOBOOT      0x2004            /* Auto-reboot info*/
#define PARA_HOLIDAY      0x2005            /* Holiday info*/            
#define PARA_IPC          0x2006            /* IPC channel info */

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64

typedef enum tagCharEncodeType
{
    ENUM_MEM_CHAR_ENCODE_ERR = -1,         //Error   
    ENUM_MEM_CHAR_ENCODE_NO = 0,          //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN = 1,          //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK = 2,          //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,          //BIG5
    ENUM_MEM_CHAR_ENCODE_JP = 4,          //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR = 5,          //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,          //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1 = 7,    //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
    ENUM_MEM_CHAR_ENCODE_UNICODE = 8,       //Unicode
}CHAR_ENCODE_TYPE;

//Time correction structure
typedef struct
{
    DWORD dwYear;             //Year
    DWORD dwMonth;             //Month
    DWORD dwDay;             //Day
    DWORD dwHour;             //Hour
    DWORD dwMinute;         //Minute
    DWORD dwSecond;         //Second
}NET_DVR_TIME, *LPNET_DVR_TIME;

typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE    byISO8601;      
    WORD wMilliSec;
    char    cTimeDifferenceH;  		
    char    cTimeDifferenceM;         
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct tagNET_DVR_TIME_SEARCH
{
    WORD     wYear;
    BYTE    byMonth;
    BYTE     byDay;
    BYTE     byHour;
    BYTE     byMinute;
    BYTE     bySecond;
    char cTimeDifferenceH;        //The time difference between with the international standard time (hours), - 12 ... + 14
    char cTimeDifferenceM;        //The time difference between with the international standard time (minutes),-30, 0, 30, 45
    BYTE     byLocalOrUTC;      //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    WORD     wMillisecond;
}NET_DVR_TIME_SEARCH, *LPNET_DVR_TIME_SEARCH;

typedef struct tagNET_DVR_TIME_SEARCH_COND
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byLocalOrUTC;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    WORD wMillisecond;      
    char cTimeDifferenceH;   //The time difference between with the international standard time (hours), - 12 ... + 14
    char cTimeDifferenceM;   //The time difference between with the international standard time (minutes),-30, 0, 30, 45
}NET_DVR_TIME_SEARCH_COND, *LPNET_DVR_TIME_SEARCH_COND;


typedef struct tagNET_DVR_TIME_V50
{
    WORD 		wYear;		
    BYTE		byMonth;   
    BYTE 		byDay;		
    BYTE 		byHour;		
    BYTE 		byMinute;	
    BYTE 		bySecond;	
    BYTE   	    byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    WORD  	    wMillisecond;       
    char cTimeDifferenceH;   //time difference with UTC(HOUR)
    char cTimeDifferenceM;   //time difference with UTC(MINUTE)
}NET_DVR_TIME_V50, *LPNET_DVR_TIME_V50;

typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME, *LPNET_DVR_CALIBRATE_TIME;

/*
IP Address
*/
typedef struct
{
    char    sIpV4[16];                         //IPv4 Address 
    BYTE    byIPv6[128];                     //Reserved 
}NET_DVR_IPADDR, *LPNET_DVR_IPADDR;

typedef union tagNET_DVR_IPADDR_UNION
{
    char    szIPv4[16];                        //IPv4 Address 
    char    szIPv6[256];                        //IPv4 Address 
}NET_DVR_IPADDR_UNION, *LPNET_DVR_IPADDR_UNION;

//Log Info (9000extended) 
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //Main type 1- alarm;  2- abnormal;  3- operation;  0xff- all 
    DWORD    dwMinorType;     //Hypo- Type 0- all; 
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr; //remote host IP
    DWORD    dwParaType; //parameter type,  for 9000 series MINOR_START_VT/MINOR_STOP_VT,  channel of the voice talking
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;

//Log Info
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //MMain type 1- alarm;  2- abnormal;  3- operation;  0xff- all 
    DWORD    dwMinorType; //Hypo- Type 0- all; 
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    char    sRemoteHostAddr[16]; //remote host IP
    DWORD    dwParaType; //parameter type
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
}NET_DVR_LOG, *LPNET_DVR_LOG;

typedef struct tagNET_DVR_FIND_LOG_COND
{
    DWORD            dwSelectMode;  // 0-all;1-with type;2-with time;3-with time and type;
    DWORD            dwMainType;	
    DWORD            dwSubType;	
    NET_DVR_TIME_V50 struStartTime; 
    NET_DVR_TIME_V50 struEndTime;   
    BOOL 		     bOnlySmart;    
    BYTE             byRes[128];
}NET_DVR_FIND_LOG_COND, *LPNET_DVR_FIND_LOG_COND;


typedef struct
{
    NET_DVR_TIME_V50 	struLogTime;  
    DWORD               dwMajorType;     //MMain type 1- alarm;  2- abnormal;  3- operation;  0xff- all 
    DWORD               dwMinorType; //Hypo- Type 0- all; 
    BYTE                sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE                sNetUser[MAX_NAMELEN]; //user ID for network operation
    NET_DVR_IPADDR      struRemoteHostAddr; //remote host IP
    DWORD               dwParaType; //parameter type
    DWORD               dwChannel; //channel number
    DWORD               dwDiskNumber; //HD number
    DWORD               dwAlarmInPort; //alarm input port
    DWORD               dwAlarmOutPort; //alarm output port
    DWORD               dwInfoLen;
    char                sInfo[LOG_INFO_LEN];
    BYTE                byRes[128];
}NET_DVR_LOG_V50, *LPNET_DVR_LOG_V50;

/************************DVR Log end***************************/

/*************************************************
Parameters configuration structure (_V30 is for 9000)
**************************************************/

/////////////////////////////////////////////////////////////////////////
#define    MAX_TIMESIGN_LEN    32 //Custom Set Time Sign Info Length
typedef  struct tagNET_DVR_TIMESIGN_CFG
{
    DWORD  dwSize;
    BYTE  byCustomSetTimeSign[MAX_TIMESIGN_LEN/*32*/];//Custom Set Time Sign
    BYTE  byRes[96];
}NET_DVR_TIMESIGN_CFG, *LPNET_DVR_TIMESIGN_CFG;

typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX, *LPNET_DVR_TIME_EX;

//Time Segment (Sub structure) 
typedef struct
{
    //Start
    BYTE byStartHour;
    BYTE byStartMin;
    //End
    BYTE byStopHour;
    BYTE byStopMin;
}NET_DVR_SCHEDTIME, *LPNET_DVR_SCHEDTIME;

/*Handling way of Alarm & Exception*/
#define NOACTION            0x0                /*Don't Respond*/
#define WARNONMONITOR        0x1                /*Warning on Monitor*/
#define WARNONAUDIOOUT        0x2                /*Audio Warning*/
#define UPTOCENTER            0x4                /*Upload to center*/
#define TRIGGERALARMOUT        0x8                /*Trigger Alarm Output*/
#define TRIGGERCATPIC        0x10            /*capture picture and E-mail*/
#define SEND_PIC_FTP        0x200           /*capture picture and upload to ftp*/

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{
    DWORD   dwHandleType;        //Way to handle,  result of operation OR    
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x4000: allow light alarm*/
    /*0x10000: SMS alarm*/
    /*0x20000: indicator light alarm*/
    DWORD   dwMaxRelAlarmOutChanNum; //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40];  //Trigger an alarm channel ,  Encountered 0xffffffff follow-up without alarm trigger channel  
    BYTE    byRes[64];
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

//Handle Alarm & Exception
typedef struct  tagNET_DVR_HANDLEEXCEPTION_V40
{
    DWORD   dwHandleType;        //Way to handle,  result of operation OR   
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x80:  alarm trigger recording (currently only PCNVR support)*/
    /*0x100: alarm trigger PTZ preset point (currently only PCNVR support)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x400: virtual intersecting detection of linkage focus mode (provides a configuration item, the original equipment automatically) IPC5.1.0*/
    /*0x800: PTZ track linkage*/
    /*0x1000:capture jpeg and update to cloud*/
    /*0x2000:short message alarm*/
    /*0x4000:white light alarm*/
    /*0x8000:audio alarm*/
    DWORD  dwMaxRelAlarmOutChanNum;        //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD  dwRelAlarmOutChanNum;           //The actual number of alarm out channels set
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //Trigger an alarm channel ,  Encountered 0xffffffff follow-up without alarm trigger channel
    BYTE    byWhiteLightDurationTime;//White Light Duration Time(1-60s)
    BYTE    byBrightness;//brightness,range:0-100,default:50
    BYTE    byAudioType;//Audio type
    BYTE    byTimes;//Audio alarm times, range:0-9,default:2, 0xff-continue
    BYTE    byRes[60];
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;

typedef struct
{
    DWORD    dwHandleType;     /*Way to handle,  result of operation OR*/
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x2000:sms alarm*/
    BYTE byRelAlarmOut[MAX_ALARMOUT_V30];
    //Alarm out channel,  1 means trigger this channel
}NET_DVR_HANDLEEXCEPTION_V30, *LPNET_DVR_HANDLEEXCEPTION_V30;

//Handle Alarm & Exception  (sub structure) 
typedef struct
{
    DWORD    dwHandleType;             /*Way to handle,  result of operation OR*/
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    BYTE byRelAlarmOut[MAX_ALARMOUT];  //Alarm out channel,  1 means trigger this channel
}NET_DVR_HANDLEEXCEPTION, *LPNET_DVR_HANDLEEXCEPTION;

//DVR Device Parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];    //DVR Name
    DWORD dwDVRID;                 //DVR ID for IR Control //V1.4 (0- 99) ,  V1.5 (0- 255) 
    DWORD dwRecycleRecord;         //cycle Record, 0: No cycle;  1: cycle
    //The variable below is read only
    BYTE sSerialNumber[SERIALNO_LEN];     //SN
    DWORD dwSoftwareVersion;             //software version, high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwSoftwareBuildDate;             //build date, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;         //DSP software version,  high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwDSPSoftwareBuildDate;         // DSP software build date, 0xYYYYMMDD
    DWORD dwPanelVersion;                 // Front panel version,  high 16 bits is main version,  low 16 bits is hypo- version
    DWORD dwHardwareVersion;     //Hardware version,  high 16 bits is main version,  low 16 bits is hypo- version
    BYTE byAlarmInPortNum;         //Number of alarm input
    BYTE byAlarmOutPortNum;     //Number of alarm output
    BYTE byRS232Num;             //Number of DVR RS232 ports
    BYTE byRS485Num;             //Number of DVR RS485 ports
    BYTE byNetworkPortNum;         //Number of network ports
    BYTE byDiskCtrlNum;         //Number of DVR hardware controllers
    BYTE byDiskNum;             //DVR Hard disk number
    BYTE byDVRType;             //DVR Model,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;             //DVR channel number
    BYTE byStartChan;             //First channel's No. e.g.,  DVS- 1, DVR -  1
    BYTE byDecordChans;         //Number of decoding channels
    BYTE byVGANum;                 //Number of VGA ports
    BYTE byUSBNum;                 //Number of USB ports
    BYTE byAuxoutNum;             //Number of AUX ports
    BYTE byAudioNum;             //Number of audio ports
    BYTE byIPChanNum;             //Maximum number of IP channels
}NET_DVR_DEVICECFG, *LPNET_DVR_DEVICECFG;

/*
Network structure  (9000)
*/
typedef struct
{
    NET_DVR_IPADDR    struDVRIP;               //DVR IP address
    NET_DVR_IPADDR    struDVRIPMask;             //DVR IP Mask
    DWORD    dwNetInterface;                    //Network port,  1- 10MBase- T, 2- 10MBase- T full duplex,  3- 100MBase- TX, 4- 100M full duplex,  5- 10M/100M adaptive
    WORD    wDVRPort;                         //Port
    WORD    wMTU;                             //MTU,  1500 by default
    BYTE    byMACAddr[MACADDR_LEN];         //MAC address
    BYTE    byEthernetPortNo;               //Ethernet port: 0 - invalid, 1 - port 0, 2- port 1 and so on,  (read-only)
    BYTE    byRes[1];
}NET_DVR_ETHERNET_V30, *LPNET_DVR_ETHERNET_V30;

/*
Network data structure (Sub structure)
*/
typedef struct
{
    char sDVRIP[16];              //DVR IP address
    char sDVRIPMask[16];          //DVR IP Mask
    DWORD dwNetInterface;         //Network interface: 1- 10MBase- T, 2- 10MBase- T full duplex, 3- 100MBase- TX, 4- 100M full duplex, 5- 10M/100M adaptive
    WORD wDVRPort;                   //Port
    BYTE byMACAddr[MACADDR_LEN];  //Mac address
}NET_DVR_ETHERNET;

//pppoe structure
typedef struct
{
    DWORD    dwPPPOE;                                         //0- disable, 1- enable
    BYTE    sPPPoEUser[NAME_LEN];                             //PPPoE user name
    char    sPPPoEPassword[PASSWD_LEN];                     //PPPoE password
    NET_DVR_IPADDR    struPPPoEIP;                             //PPPoE IP address
}NET_DVR_PPPOECFG, *LPNET_DVR_PPPOECFG;

//Network Configure Structure  (9000DVR extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];     //Network Port
    NET_DVR_IPADDR    struRes1[2];                             //Reserved
    NET_DVR_IPADDR    struAlarmHostIpAddr;                     //IP address of Alarm Host 
    BYTE    byRes2[4];                                         //Reserved 
    WORD    wAlarmHostIpPort;                                 //Port of Alarm Host 
    BYTE    byUseDhcp;                                      //Enable DHCP or not 0xff- invalid 0- disable 1- enable
    BYTE    byIPv6Mode;                                     //IPv6 allocation, 0 - route bulletin, 1 - manually set, 2 - Enable DHCP-assigned
    NET_DVR_IPADDR    struDnsServer1IpAddr;                     //IP address of DNS 1
    NET_DVR_IPADDR    struDnsServer2IpAddr;                     //IP address of DNS 2
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                     //IP address or domain name of analysis server
    WORD    wIpResolverPort;                                 //Port of IP analysis server
    WORD    wHttpPortNo;                                     //HTTP port 
    NET_DVR_IPADDR    struMulticastIpAddr;                     //Multicast group address 
    NET_DVR_IPADDR    struGatewayIpAddr;                         //Gateway address 
    NET_DVR_PPPOECFG struPPPoE;
    BYTE    byEnablePrivateMulticastDiscovery;              //Private Multicast Discovery,0~Default,1~Enable,2-Disable
    BYTE    byEnableOnvifMulticastDiscovery;                //Onvif Multicast Discovery,0~Default,1~Enable,2-Disable
    BYTE    byEnableDNS; //DNS Atuo enable, 0-Res,1-open, 2-close
    BYTE    byRes[61];
} NET_DVR_NETCFG_V30, *LPNET_DVR_NETCFG_V30;

//Netcard Configure Structure
typedef struct
{
    NET_DVR_IPADDR struDVRIP;                  /*Network card IP address */
    NET_DVR_IPADDR struDVRIPMask;              /*Network card IP address mask*/
    DWORD dwNetInterface;                      /*Network port,  1- 10MBase- T 2- 10MBase- T full duplex  3- 100MBase- TX 4- 100M full duplex  5- 10M/100M adaptive*/
    BYTE byCardType;  //Network card type,0-Normal network card,1-internal network card ,2-external network card
    BYTE    byEnableDNS; //DNS Auto Enabled,0 - res, 1 - open, 2 - close
    WORD wMTU;                                  /*MTU,  1500 by default*/
    BYTE byMACAddr[MACADDR_LEN];              /*Mac address*/
    BYTE byEthernetPortNo;               //Ethernet port: 0 - invalid, 1 - port 0, 2- port 1 and so on,  (read-only)
    BYTE bySilkScreen;        //silk-screen information,0-invalid, 1-GE1, 2-GE2, 3-G1, 4-G2, (read-only)
    BYTE byUseDhcp;                          /* Enable DHCP or not 0xff- invalid 0- disable 1- enable*/
    BYTE byRes3[3];                             /*Reserved*/
    NET_DVR_IPADDR struGatewayIpAddr;          /*Gateway address*/
    NET_DVR_IPADDR struDnsServer1IpAddr;      /*IP address of DNS 1*/
    NET_DVR_IPADDR struDnsServer2IpAddr;      /*IP address of DNS 2*/
}NET_DVR_ETHERNET_MULTI, *LPNET_DVR_ETHERNET_MULTI;

//Multi Netcard Configure Structure
typedef struct
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;           /* Default route, 0:  struEtherNet[0], 1:  struEtherNet[1] */
    BYTE   byNetworkCardNum;         //Network card sum
    BYTE   byWorkMode;   //Work mode,0-normal multi network card mode,1-internal and external network isolation mode
    BYTE   byRes;
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD];  /* Network Port*/
    NET_DVR_IPADDR         struManageHost1IpAddr;        /* Manage host 1 IP */
    NET_DVR_IPADDR         struManageHost2IpAddr;        /* Manage host 2 IP */
    NET_DVR_IPADDR           struAlarmHostIpAddr;          /* Alarm host IP 1 */
    WORD wManageHost1Port;      /* Manage host 1 port */
    WORD wManageHost2Port;      /* Manage host 2 port */
    WORD wAlarmHostIpPort;      /* Alarm host port */
    BYTE  byIpResolver[MAX_DOMAIN_NAME];      /* IP address or domain name of analysis serve */
    WORD wIpResolverPort;                    /* Port of IP analysis server */
    WORD wDvrPort;                            //DVR port ,  default 8000 
    WORD wHttpPortNo;                        /* HTTP port */
    WORD wDvrPort2; //DVR port 2
    BYTE byRes2[4];
    NET_DVR_IPADDR   struMulticastIpAddr;          /* Multicast group address */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE byRes3[24];
}NET_DVR_NETCFG_MULTI, *LPNET_DVR_NETCFG_MULTI;

//Network Configure Structure
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET struEtherNet[MAX_ETHERNET];         /* Network Port */
    char sManageHostIP[16];         //IP address of remote management host
    WORD wManageHostPort;         //Port of remote management Host
    char sIPServerIP[16];        //Address of IPServer
    char sMultiCastIP[16];      //Multicast group address
    char sGatewayIP[16];            //Gateway address
    char sNFSIP[16];             //IP address of NFS host
    BYTE sNFSDirectory[PATHNAME_LEN]; //NFS directory
    DWORD dwPPPOE;                 //0- disable, 1- enable
    BYTE sPPPoEUser[NAME_LEN];     //PPPoE username
    char sPPPoEPassword[PASSWD_LEN]; // PPPoE password
    char sPPPoEIP[16];             //PPPoE IP address  (read only) 
    WORD wHttpPort;                 //HTTP port
}NET_DVR_NETCFG, *LPNET_DVR_NETCFG;

//Network Configure Structure(V50)
typedef struct tagNET_DVR_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];        //Network Port
    NET_DVR_IPADDR    struRes1[2];                            /*reserve*/
    NET_DVR_IPADDR    struAlarmHostIpAddr;                    /* IP address of remote management host */
    BYTE    byRes2[4];                                        /* reserve */
    WORD    wAlarmHostIpPort;                                /* Port of remote management Host */
    BYTE    byUseDhcp;                                      /* Whether to enable the DHCP 0xff- invalid 0- enabled 1- not enabled */
    BYTE    byIPv6Mode;                                        //IPv6 allocation, 0- routing announcement, 1- manually, 2- enable DHCP allocation 
    NET_DVR_IPADDR    struDnsServer1IpAddr;                    /* IP address of the domain name server 1  */
    NET_DVR_IPADDR    struDnsServer2IpAddr;                    /* IP address of the domain name server 2  */
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                    /* IP parse server domain name or IP address */
    WORD    wIpResolverPort;                                /* Parsing IP server port number */
    WORD    wHttpPortNo;                                    /* HTTP port number  */
    NET_DVR_IPADDR    struMulticastIpAddr;                    /* Multicast group address */
    NET_DVR_IPADDR    struGatewayIpAddr;                        /* Gateway address  */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE    byEnablePrivateMulticastDiscovery;                //Private multicast search, 0- default, 1- enabled, 2 - disabled 
    BYTE    byEnableOnvifMulticastDiscovery;                //Onvif multicast search, 0- default, 1- enabled, 2 - disabled 
    WORD    wAlarmHost2IpPort;                                /* Alarm host 2 port */
    NET_DVR_IPADDR    struAlarmHost2IpAddr;                    /* Alarm host 2 IP addresses */
    BYTE    byEnableDNS; //DNS Enabled, 0-close,1-open 
    BYTE    byRes[599];
}NET_DVR_NETCFG_V50, *LPNET_DVR_NETCFG_V50;

//sip 
typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //Enable auto login,0-disable,1-enable
    BYTE byLoginStatus;  //login status,0-not login,1-logined
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP server IP
    WORD wServerPort;    //SIP server port
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //user name
    BYTE byPassWord[PASSWD_LEN]; //user password
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //device name
    WORD wLocalPort;     //local port
    BYTE byLoginCycle;   //login cycle,1-99min
    BYTE byType;//0-IP/IPV6,1-domain name
    BYTE byDomainName[MAX_DOMAIN_NAME]; //domain name
    BYTE byRes[64];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

typedef struct tagNET_DVR_SIP_CFG_V50
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //Enable auto login,0-disable,1-enable
    BYTE byLoginStatus;   //login status,0-not login,1-logined
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP server IP
    WORD wServerPort;     //SIP server port
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //user name
    BYTE byPassWord[PASSWD_LEN];//user password
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN];  //device name
    WORD wLocalPort;     //local port
    BYTE byLoginCycle;   //login cycle,1-99min
    BYTE byRes3;
    BYTE bySIPServerDomain[MAX_DOMAIN_NAME];  //sip server domain 
    NET_DVR_IPADDR stuSTUNServerIP;  // STUN server IP
    BYTE bySTUNServerDomain[MAX_DOMAIN_NAME];  //STUN server domain
    WORD wSTUNServerPort;    // STUN server port 
    BYTE byRes4[2];
    NET_DVR_IPADDR stuProxyServerIP;  //proxy server IP
    BYTE byProxyServerDomain[MAX_DOMAIN_NAME];  //proxy server domain
    WORD wProxyServerPort;    // proxy server port
    BYTE byNetWork; //network type
    BYTE byRes5;
    BYTE byCalledTargetName[NET_SDK_MAX_CALLEDTARGET_NAME];//called target name
    BYTE byRes[224];
}NET_DVR_SIP_CFG_V50, *LPNET_DVR_SIP_CFG_V50;

typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //default ring,[1-6]
    BYTE  byRingVolume;  //ring volume,[0-9]
    BYTE  byInputVolume; //input ring volume,[0-6]
    BYTE  byOutputVolume; //output ring volume[0-9]
    WORD  wRtpPort;  //Rtp port
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //preview delay time,0-30s
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG, *LPNET_DVR_IP_VIEW_DEVCFG;

typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;
    BYTE  byAudioEncPri1; //audio encode priority1,0-G722,1-G711_U,2-G711_A, 5-MPEG2,6-G726,7-AAC
    BYTE  byAudioEncPri2; //audio encode priority2,0-G722,1-G711_U,2-G711_A, 5-MPEG2,6-G726,7-AAC
    WORD  wAudioPacketLen1; //audio encode packet len1
    WORD  wAudioPacketLen2; //audio encode packet len2
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG, *LPNET_DVR_IP_VIEW_AUDIO_CFG;

typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize;
    BYTE  byEnableAutoResponse; //enable auto-response,0-disable,1-enable
    BYTE  byAudoResponseTime; //auto-response time,0-30s
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //enable alarm number1,0-disable,1-enable
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //alarm number1
    BYTE  byEnableAlarmNumber2; //alarm number2,0-diable,1-enable
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //alarm number2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG, *LPNET_DVR_IP_VIEW_CALL_CFG;
//Channel Image structure

typedef struct
{
    DWORD     dwMaxRecordChanNum;
    DWORD     dwCurRecordChanNum;
    DWORD     dwRelRecordChan[MAX_CHANNUM_V30];
    BYTE       byRes[64];
} NET_DVR_RECORDCHAN, *LPNET_DVR_RECORDCHAN;

//Motion detection structure (sub structure)  (9000 extended) 
typedef struct
{
    BYTE byMotionScope[64][96];                                     /*Motion detection area, 0- 96 bits stand for 64 lines and there are 96*64 small areas,  1- - it is motion detection area, 0- - not*/
    BYTE byMotionSensitive;                                         /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byEnableHandleMotion;                                         /* Process motion alarm  0- No 1- Yes*/
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;                 /* The way to process */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*Guard time*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];                             /* Channel triggered to record*/
}NET_DVR_MOTION_V30, *LPNET_DVR_MOTION_V30;

//Motion detection structure (sub structure) 
typedef struct
{
    BYTE byMotionScope[18][22];     /*motion detection area,  22*18 blocks in total,  1- - it's motion detection area,  0- - not*/
    BYTE byMotionSensitive;         /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byEnableHandleMotion;     /* process motion detection or not */
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;     /* method to process alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM];                 //Channel triggered to record*/
}NET_DVR_MOTION, *LPNET_DVR_MOTION;


typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/

    DWORD   dwHandleType;           /* Way to handle the alarm */
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40];
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*alarm Time*/
    BYTE  byRes[64];
}NET_DVR_HIDEALARM_V40, *LPNET_DVR_HIDEALARM_V40; //Tamper Alarm  

//Tamper Alarm  (sub structure)  (9000 extended)   area size:  704*576
typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;     /* Way to handle alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
}NET_DVR_HIDEALARM_V30, *LPNET_DVR_HIDEALARM_V30;

//Tamper Alarm  (sub structure)  area size:  704*576
typedef struct
{
    DWORD dwEnableHideAlarm;                 /* Enable tamper alarm or not , 0- disable, 1- low sensitivity 2- Middle 3- High*/
    WORD wHideAlarmAreaTopLeftX;             /* X- coordinate of tamper area */
    WORD wHideAlarmAreaTopLeftY;             /* Y- coordinate of tamper area */
    WORD wHideAlarmAreaWidth;                 /* Width of tampered area */
    WORD wHideAlarmAreaHeight;                 /* Height of tampered area*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;     /* Way to handle the alarm */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
}NET_DVR_HIDEALARM, *LPNET_DVR_HIDEALARM;

//Signal Lost Alarm (sub structure)  (9000 extended) 
typedef struct
{
    BYTE byEnableHandleVILost;     /* Respond the alarm or not */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;     /* Way to respond*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
}NET_DVR_VILOST_V30, *LPNET_DVR_VILOST_V30;

//Signal Lost Alarm (sub structure) 
typedef struct
{
    BYTE byEnableHandleVILost;     /* Respond the alarm or not */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;     /* Way to respond*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
}NET_DVR_VILOST, *LPNET_DVR_VILOST;

//Tampered Area (sub structure) 
typedef struct
{
    WORD wHideAreaTopLeftX;                 /* X- coordinate of tamper area */
    WORD wHideAreaTopLeftY;                 /* Y- coordinate of tamper area */
    WORD wHideAreaWidth;                 /* Width of tampered area */
    WORD wHideAreaHeight;                 /* Height of tampered area*/
}NET_DVR_SHELTER, *LPNET_DVR_SHELTER;

typedef struct
{
    BYTE byBrightness;       /*Brightness, 0- 255*/
    BYTE byContrast;         /*contrast, 0- 255*/
    BYTE bySaturation;       /*Saturation, 0- 255*/
    BYTE byHue;                 /*Hue, 0- 255*/
}NET_DVR_COLOR, *LPNET_DVR_COLOR;

typedef struct
{
    BYTE byRed;
    BYTE byGreen;
    BYTE byBlue;
    BYTE byRes;        //res
}NET_DVR_RGB_COLOR, *LPNET_DVR_RGB_COLOR;

//Point
typedef struct tagNET_VCA_POINT
{
    float fX;                                 //X axis coordinate,  0.000~1
    float fY;                                 //Y axis coordinate,  0.000~1
}NET_VCA_POINT, *LPNET_VCA_POINT;

//Video Structure (9000 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE  byReservedData[64]; /*Reserved*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST_V30 struVILost;
    NET_DVR_VILOST_V30 struRes;         /*Reserved*/
    //Motion detection
    NET_DVR_MOTION_V30 struMotion;
    //Tamper alarm
    NET_DVR_HIDEALARM_V30 struHideAlarm;
    //Tampered Area 704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;         // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0: XXXX- XX- XX Year Month Day */
    /* 1: XX- XX- XXXX Month Day Year */
    /* 2: XXXXYearXXNonthXXDay */
    /* 3: XXMonthXXDayXXXXYear */
    /* 4: XX- XX- XXXX Day Month Year*/
    /* 5: XXDayXXMonthXXXXYear */
    /* 6: xx/xx/xxxx(Month/Day/Year) */
    /* 7: xxxx/xx/xx(Year/Month/Day) */
    /* 8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE byHourOSDType;                 /* : 24- Hour system, 12- Hour system */
    BYTE byFontSize;
    BYTE byOSDColorType;    //0-auto(black or white);1-custom;2-outline
    BYTE byAlignment;//0- adaptive, 1- right aligned 2- left aligned, 3 - gb model, 4-all right aligned, 5-all left aligned
    BYTE byOSDMilliSecondEnable;//OSD MilliSecond Enable
    NET_DVR_RGB_COLOR    struOsdColor;//OSD color
    DWORD dwBoundary; //boundary value
    NET_DVR_RGB_COLOR struOsdBkColor;
    BYTE byOSDBkColorMode;
    BYTE    byUpDownBoundary;//minimum characters of up-down boundary,character range[0,1,2],unused in global(byAlignment) mode
    BYTE    byLeftRightBoundary;//minimum characters of left-right boundary,character range[0,1,2],unused in global(byAlignment) mode
    BYTE    byAngleEnabled;// Angle information of OSD is superimposed,0~ not superimposed, 1- superimposed
    WORD    wTiltAngleTopLeftX;    /* The Tilt Angle information displays the x coordinate of the position*/
    WORD    wTiltAngleTopLeftY;  /* The Tilt Angle information displays the y coordinate of the position*/
    BYTE byRes[40];
}NET_DVR_PICCFG_V30, *LPNET_DVR_PICCFG_V30;

//Video Structure (SDK_V14 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE byBrightness;      /*0-255*/
    BYTE byContrast;        /*0-255*/
    BYTE bySaturation;      /*0-255 */
    BYTE byHue;                /*0-255*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST struVILost;
    //Motion Detection
    NET_DVR_MOTION struMotion;
    //Tamper Alarm
    NET_DVR_HIDEALARM struHideAlarm;
    //Tamper Area size:  704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable**/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;                 // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0:  XXXX- XX- XX Year/Month/Day */
    /* 1:  XX- XX- XXXX Month/Day/Year */
    /* 2:  XXXXYearXXNonthXXDay */
    /* 3:  XXMonthXXDayXXXXYear */
    /* 4:  XX- XX- XXXX Day Month Year*/
    /* 5:  XXDayXXMonthXXXXYear */
    /*6: xx/xx/xxxx(Month/Day/Year) */
    /*7: xxxx/xx/xx(Year/Month/Day) */
    /*8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE byHourOsdType;     //hour: 0- 24 hours, 1- am/pm
}NET_DVR_PICCFG_EX, *LPNET_DVR_PICCFG_EX;

//Video Structure (SDK_V14 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;     /* Read only,  Video Standard 1- NTSC 2- PAL*/
    BYTE byBrightness;      /*0-255*/
    BYTE byContrast;        /*0-255*/
    BYTE bySaturation;      /*0-255 */
    BYTE byHue;                /*0-255*/
    //Display Channel Name
    DWORD dwShowChanName;  // Display channel name or not, 0- no, 1- display size = 704*576
    WORD wShowNameTopLeftX;                 /* X- coordinate of display position */
    WORD wShowNameTopLeftY;                 /* Y- coordinate of display position  */
    //Signal lost Alarm
    NET_DVR_VILOST struVILost;
    //Motion Detection
    NET_DVR_MOTION struMotion;
    //Tamper Alarm
    NET_DVR_HIDEALARM struHideAlarm;
    //Tamper Area size:  704*576
    DWORD dwEnableHide;         /* Enable Tamper Alarm , 0- disable, 1- enable*/
    WORD wHideAreaTopLeftX;                 /* X- coordinate of tampered area*/
    WORD wHideAreaTopLeftY;                 /* Y- coordinate of tampered area */
    WORD wHideAreaWidth;                 /* Width of tampered area */
    WORD wHideAreaHeight;                 /* Height of tampered area */
    //OSD
    DWORD dwShowOsd;                 // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD wOSDTopLeftX;                 /* X- coordinate of OSD */
    WORD wOSDTopLeftY;                 /* Y- coordinate of OSD*/
    BYTE byOSDType;                     /* OSD Type  (format of Year/Month/Day)  */
    /* 0:  XXXX- XX- XX Year/Month/Day */
    /* 1:  XX- XX- XXXX Month/Day/Year */
    /* 2:  XXXXYearXXNonthXXDay */
    /* 3:  XXMonthXXDayXXXXYear */
    /* 4:  XX- XX- XXXX Day Month Year*/
    /* 5:  XXDayXXMonthXXXXYear */
    /*6: xx/xx/xxxx(Month/Day/Year) */
    /*7: xxxx/xx/xx(Year/Month/Day) */
    /*8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE byDispWeek;                 /* display Week */
    BYTE byOSDAttrib;                 /* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    char reservedData2;
}NET_DVR_PICCFG, *LPNET_DVR_PICCFG;

typedef enum _BITRATE_ENCODE_INDEX_
{
    BITRATE_ENCODE_def = 0,
    BITRATE_ENCODE_8kps = 1,
    BITRATE_ENCODE_16kps = 2,
    BITRATE_ENCODE_32kps = 3,
    BITRATE_ENCODE_64kps = 4,
    BITRATE_ENCODE_128kps = 5,
    BITRATE_ENCODE_192kps = 6,
    BITRATE_ENCODE_40kps = 7,
    BITRATE_ENCODE_48kps = 8,
    BITRATE_ENCODE_56kps = 9,
    BITRATE_ENCODE_80kps = 10,
    BITRATE_ENCODE_96kps = 11,
    BITRATE_ENCODE_112kps = 12,
    BITRATE_ENCODE_144kps = 13,
    BITRATE_ENCODE_160kps = 14,
    BITRATE_ENCODE_224kps = 15,
    BITRATE_ENCODE_256kps = 16,
    BITRATE_ENCODE_320kps = 17
}BITRATE_ENCODE_INDEX;

//Encoding Parameters (Sub Strut)  (9000 extended) 
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio,  when it stands for compression parameters,  the highest bit stands for whether adopt encoding parameters
    /*Resolution 0-DCIF                 1-CIF,                     2-QCIF,                 3-4CIF,
            4-2CIF                                                 6-QVGA(320*240),        7-QQVGA(160*120),
            12-384*288                  13-576*576,
            16-VGA(640*480),          17-UXGA(1600*1200),      18-SVGA(800*600),       19-HD720p(1280*720),
            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,
            24-1920*1920,               27-HD1080i,
            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,
            32-2448*1200,               33-2448*800,               34-XGA(1024*768),    35-SXGA(1280*1024),
            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),
            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,
            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,
            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,
            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
            56-2304*1296                57-WXGA(1280*800),         58-1600*600,            59-1600*900,
            60-2752*2208,                61-retain,                 62-4000*3000,           63-4096*2160,
            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
            72-160*128,                 73-324*240,                74-324*256,             75-336*256,
            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216,
            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
            100-3392*2008,,             101-4000*3080,             102-960*720,            103-1024*1536,
            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
            108-2800*2100,              109-4088*4088,             110-4000*3072           111-960*1080(1080p Lite)
            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
            120-480*768,                121-768*480,               122-320*512,             123-512*320,
            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
            132-2720*1192,              133-3MP(1920*1536/2048*1536),                     134-5MP(2560*1944),
            135-2560*960,               136-2064*1544              137-4096*1200,
            138-3840*1080               139-2720*800               140-512*232             141-704*200,
            142-512*152,                143-2048*896               144-2048*600            145-1280*376,
            146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
            150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
            154-480*720,                155-800*450,               156-480*270,            157-2560*1536,
            160-3264*2448,              161-288*320,               162-144*176,            163-480*640,
            164-240*320,                165-120*160,               166-576*720,            167-720*1280,
            168-576*960,                169-2944*1656,             170-432*240,            171-2160*3840,
            172-1080*1920,              173-7008*1080,             174-3504*540,           175-1752*270,
            176-876*135,                177-4096*1440,             178-4096*1080,          179-1536*864,
            180-180*240,                181-360*480,               182-540*720,            183-720*960,
            184-960*1280,               185-1080*1440,
            186-3200*1800,              187-1752*272,              188-872*136,            189-1280*1440,
            190-3520*544,               191-1728*256,              192-864*128,            193-5470*3684,
            194-2560*750,               195-1600*480,              196-1024*300,           197-848*480,
            198-8160*3616,				199-8160*2304,             200-4064*2560,          201-1400*1050,
            202-2688*1512,              203-704*288,               204-1560*656,           205-3072*1280,
            206-4320*1808,              207-6120*2560,              208-1280*960,          209-3000*3000,
            210-2032*3616,              211-7680*4320,             212-5760*3240,          213-3264*1836,
            214-2712*1536,              215-1080*720(occupied untested), 216-360x640(occupied untested),
            217-1440*812,               218-8160*2416,              219-5760*1712,          220-4080*1200,          
            221-6144*2560,              222-1568*656,               223-4096*1808,          224-2720*1200,
            225-2896*848,               226-2048*608,               227-3840*1120,          228-2720*784,
            229-1920*560,               230-1360*400,               231-704*208,            232-496*144,
            233-352*128,                234-512*240,                235-512*160,            236-368*128,
            237-256*128,                238-2048*592,               239-1456*416,           240-1024*304,
            241-1280*368,               242-912*256,                243-640*192,            244-252*112(not use),
            245-576*704[P]/480*704[N]   254- exceed flag,when the value is 254, please get value from NET_DVR_MULTI_STREAM_COMPRESSIONCFG->dwResolution
            0xff-Auto(use current resolution)
            256-3888*1696                257-2784*1200               258-496*224              259-352*160
            260-912*400                  261-640*288                 262-1456*640             263-1024*448
            264-2896*1280                265-2544*1080               266-2736*768             267-1920*544
            268-3840*1696                269-2880*848                270-5424*2400            271-5520*1600
            272-848*376                  273-912*272                 274-1360*600             275-1456*432
            276-2736*1200                277-5760*1696               278-8160*2400            279-5520*2400
            280-4608*2592                281-4944*3280               282-6016*4008            283-720*480
            284-3200*2400                285-2784*800                286-1968*848             287-1392*608
            288-2736*1184                289-1920*848                290-2560*2880            291-1944*1212
            292-1920*2400                293-384*384                 294-768*768              295-4800*2688
            296-6480*1080                297-8640*1440               298-4800*800             299-6720*1200
            300-3600*600                 301-4800*840                302-2400*400             303-3072*540
            304-1440*810                 305-1920*320                306-2688*480             307-1440*240
            308-4800*1792                309-3360*1264               310-2304*880             311-3840*1440
            312-2688*1008                313-1824*704                314-1248*496             315-1920*720
            316-1344*496                 317-912*336                 318-1280*480             319-864*336
            320-576*224                  321-2704*1008               322-1904*704             323-1808*672
            324-1264*464                 325-944*336                 326-2400*1344            327-2032*1440
            328-4064*1792                329-304*112                 330-960*360              331-672*240
            332-464*160                  333-896*336                 334-624*224              335-640*240
            336-448*160                  337-4976*1452               338-1968*560             339-2736*784
            340-3888*1136                341-6120*1800               342-4320*1280            343-3056*896
            344-1776*528                 345-1392*400                346-7256*1520            347-512*288
            348-1936*1210                349-640*400                  350-2688*1792           351-2464*2056
            352-2720*1600                353-4800*1600               354-3600*1200            355-not define
            356-2400*800                 357-1200*400                358-4096*3008            359-7680*4096
            360-1080*1520                361-6656*3744               362-5120*1400            363-2560*704
            364-2688*3040                365-1280*352                366-3376*1008            367-1688*504
            368-5120*1440                369-1920*2160               370-4080*1808            371-4080*1152
            372-2688*3888                373-3840*2880               374-2464*3520            375-4416*1696
            376-1408*540                 377-3456*1080               378-1728*540             379-704*1152
            380-1408*1152                381-5120*2880               382-720*576              383-3984*1168
            384-1920*1440                385-3840*4096               386-1920*536             387-1536*432
            388-3072*864                 389-1440*1080               390-720*540              391-960*544
            392-720*544                  393-5430*3054               394-8000*6000            395-6560*3690
            */
    BYTE byResolution;
    BYTE byBitrateType;         //Bitrate Type 0: VBR, 1: CBR
    BYTE byPicQuality;         //Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    /*video bit rate 0- reserved 1- 16K 2- 32K 3- 48k 4- 64K 5- 80K 6- 96K 7- 128K 8- 160k 9- 192K 10- 224K 11- 256K 12- 320K
    13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K  24-3072K 25-4096K 26-8192K 27-16384K
    if The highest bit (31 bit)  is 1,  it stands for user defined bit rate,  0- 30 is the value of bit rate*/
    DWORD dwVideoBitrate;
    DWORD dwVideoFrameRate; //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20; 14- 15;  15- 18;  16- 22; 
    //17-25;18-30;19-35;20-40;21-45;22-50;23-55;24-60,25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,33-8.3,0xfffffffe-auto
    WORD  wIntervalFrameI;  //interval of I frame
    BYTE  byIntervalBPFrame;//0- BBP frame;  1- BP frame;  2- P frame only(2006-08-11 Add single P frame).
    BYTE  byres1;           //reserve
    BYTE  byVideoEncType;   //Video Code Type:  0-private h264,1-standard H264,2-standard MPEG4,7-M-JPEG,8-MPEG2,9-SVAC, 10-Standard h265, 0xfe- auto,0xff-invalid 
    BYTE  byAudioEncType;   //Audio Code Type:  0- G722; 1- G711_U; 2- G711_A;5-MP2L2;6-G726;7-AAC,8-PCM;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;
    BYTE  byVideoEncComplexity; //Video encode complexity, 0-low,1-middle,2-high
    BYTE  byEnableSvc; //0 - do not enable the SVC function; 1 - enable SVC function; 2-Auto SVC
    BYTE  byFormatType; //video format type,1-original,2-RTP,3-PS,4-TS,5-private,6-FLV,7-ASF,8-3GP,9-RTP+PS(GB28181),0xff-Invalid
    BYTE  byAudioBitRate; // audioBitRate refer to BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;    //stream smoothing 1~100(1-(Clear),..., 100-(Smooth))
    BYTE  byAudioSamplingRate;//AudioSamplingRate 0-default,1-16kHZ, 2-32kHZ,3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;//bit0:High performance code: 0-Close,1-Open;bit1 Low Bit Rate:0-Close,1-Open
    BYTE  byDepthMapEnable;// Depth Map Enable,0-Close,1-Open
    WORD  wAverageVideoBitrate;// Average Video Bitrate
}NET_DVR_COMPRESSION_INFO_V30, *LPNET_DVR_COMPRESSION_INFO_V30;

//Encoding Parameters  (9000 extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;     //Record,  corresponding to 8000's normal
    NET_DVR_COMPRESSION_INFO_V30 struRes;                     //Reserved char reserveData[28]; 
    NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;        //Encoding parameters triggered by Events
    NET_DVR_COMPRESSION_INFO_V30 struNetPara;                //network transfer
}NET_DVR_COMPRESSIONCFG_V30, *LPNET_DVR_COMPRESSIONCFG_V30;

//Encoding Parameters (Sub Strut) 
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio,  when it stands for compression parameters,  the hightest bit stands for whether adopt encoding parameters
    BYTE byResolution;       //Resolution 0- DCIF 1- CIF,  2- QCIF,  3- 4CIF,  4- 2CIF,  5- 2QCIF (352X144)  (for Mobile DVR) 
    BYTE byBitrateType;         //Bit rate type 0: VBR, 1: CBR, 2:LBR
    BYTE  byPicQuality;         //Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    DWORD dwVideoBitrate;      /*video bit rate 0- reserved 1- 16K (reserved)  2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 
								13 - 384K 14 - 448K 15 - 512K 16 - 640K 17 - 768K 18 - 896K 19 - 1024K 20 - 1280K 21 - 1536K 22 - 1792K 23 - 2048K
								24 - 2560K 25 - 3072K 26 - 4096K 27 - 5120K 28 - 6144K 29 - 7168K 30 - 8192K */
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20; 
}NET_DVR_COMPRESSION_INFO, *LPNET_DVR_COMPRESSION_INFO;

//Encoding Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara;  //Record triggered by events
    NET_DVR_COMPRESSION_INFO struNetPara;     //Network transfer (reserved) 
}NET_DVR_COMPRESSIONCFG, *LPNET_DVR_COMPRESSIONCFG;

//Encoding Parameters (Sub Strut)  (extended)  Add I Frame interval
typedef struct
{
    BYTE byStreamType;         //Stream type 0- video,  1- video&audio, 
    BYTE byResolution;          //Resolution 0- DCIF 1- CIF,  2- QCIF,  3- 4CIF,  4- 2CIF,  5- 2QCIF (352X144)  (for Mobile DVR) 
    BYTE byBitrateType;         //Bit rate type 0: VBR, 1: CBR, 2:LBR
    BYTE  byPicQuality;         //Image Quality 0- best 1- much better 2- better 3- Normal 4- worse 5- worst
    DWORD dwVideoBitrate;      //video bit rate 0- reserved 1- 16K (reserved)  2- 32K 3- 48k 4- 64K 5- 80K 6- 96K 7- 128K 8- 160k 9- 192K 10- 224K 11- 256K 12- 320K
    // 13- 384K 14- 448K 15- 512K 16- 640K 17- 768K 18- 896K 19- 1024K 20- 1280K 21- 1536K 22- 1792K 23- 2048K
    //if The highest bit (31 bit)  is 1,  it stands for user defined bit rate,  0- 30 is the value of bit rate (MIN- 32K MAX- 8192K) 
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20, 14- 15,  15- 18,  16- 22; 
    WORD  wIntervalFrameI;   //I Frame interval
    //2006- 08- 11 Add single P frame
    BYTE  byIntervalBPFrame; //0- BBP frame;  1- BP frame;  2- P frame only.
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX, *LPNET_DVR_COMPRESSION_INFO_EX;

//Encoding Parameters  (extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara;  //Record
    NET_DVR_COMPRESSION_INFO_EX struNetPara;     //Network Transfer
}NET_DVR_COMPRESSIONCFG_EX, *LPNET_DVR_COMPRESSIONCFG_EX;


//Parameters Configure of Recording in Time segment  (Sub Strut) 
typedef struct
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;     //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,  6:  Intelligent Record,10-PIR,11-wireless,12-callhelp,13-all,14-Intelligent Transportation,15-NULL,16-Field dection,17-audio Exception
    char reservedData[3];
}NET_DVR_RECORDSCHED, *LPNET_DVR_RECORDSCHED;

//Record All- day 
typedef struct
{
    WORD wAllDayRecord;                 /* Enable record all- day or not; 0- disable, 1- enable*/
    BYTE byRecordType;                 //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,  6:  Intelligent Record,10-PIR,11-wireless,12-callhelp,13-motion|alarm|PIR|wireless|callhelp,14-Intelligent Transportation, 20-face detection
    char reservedData;
}NET_DVR_RECORDDAY, *LPNET_DVR_RECORDDAY;

//Recording Parameters  (9000 extended) 
typedef struct
{
    DWORD    dwSize;
    DWORD    dwRecord;                           /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                     /* post record time  0- 5Seconds,  1- 10Seconds,  2- 30Seconds,  3- 1 Minutes,  4- 2Minutes, ,  5- 5Minutes, ,  6- 10Minutes, */
    DWORD    dwPreRecordTime;                 /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff */
    DWORD    dwRecorderDuration;                 /*  */
    BYTE    byRedundancyRec;                  /*Redundancy record to backup important data: 0/1*/
    BYTE    byAudioRec;                         /*Record audio or not*/
    BYTE    byStreamType;                    /* 0-main stream,1-sub stream,2-main&sub 3-stream3*/
    BYTE    byPassbackRecord;
    WORD    wLockDuration;
    BYTE    byRecordBackup;
    BYTE     bySVCLevel;    //SVC frame type:0-no frame,1-half frame 2-three fourths frame
    BYTE    byRecordManage;   //record manage 0-enable, 1-disable
    BYTE    byExtraSaveAudio;
    BYTE   byIntelligentRecord; //open smart record 0-no 1-yes
    BYTE    byReserve;
}NET_DVR_RECORD_V30, *LPNET_DVR_RECORD_V30;


//Parameters Configure of Recording in Time segment  (Sub Strut) 
typedef struct
{
    NET_DVR_SCHEDTIME  struRecordTime;
    //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,
    //6: Intelligent Record,10: PIR, 11: wireless,12: callhelp, 13: Event all, 
    //14: Intelligent Transportation, 15: NULL, 16: Field dection, 17: audio Exception
    //18: Sence Exception Detection, 
    //19: Smart Detection(Traverse Plane Dection|Field Dection|audio Exception Dection|Sence Exception Detection|Face detection), 
    //20: face detection
    BYTE byRecordType;
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

//Record All- day
typedef struct
{
    BYTE byAllDayRecord;/* Enable record all- day or not; 0- disable, 1- enable*/
    //0: Time Record, 1: Motion detection, 2: Alarm record, 3: Motion|alarm, 4: Motion&Alarm,  5: Triggered by Commands,
    //6: Intelligent Record,10: PIR, 11: wireless,12: callhelp, 13: Event all, 
    //14: Intelligent Transportation, 15: NULL, 16: Field dection, 17: audio Exception
    //18: Sence Exception Detection, 
    //19: Smart Detection(Traverse Plane Dection|Field Dection|audio Exception Dection|Sence Exception Detection|Face detection), 
    //20: face detection
    BYTE byRecordType;
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct
{
    DWORD    dwSize;
    DWORD    dwRecord;                           /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY_V40    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                     /* post record time  0- 5Seconds,  1- 10Seconds,  2- 30Seconds,  3- 1 Minutes,  4- 2Minutes, ,  5- 5Minutes, ,  6- 10Minutes, */
    DWORD    dwPreRecordTime;                 /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff */
    DWORD    dwRecorderDuration;                 /*  */
    BYTE    byRedundancyRec;                  /*Redundancy record to backup important data: 0/1*/
    BYTE    byAudioRec;                         /*Record audio or not*/
    BYTE    byStreamType;                    /* 0-main stream,1-sub stream,2-main&sub,3-stream3*/
    BYTE    byPassbackRecord;
    WORD    wLockDuration;
    BYTE    byRecordBackup;
    BYTE     bySVCLevel;    //SVC frame type:0-no frame,1-half frame 2-three fourths frame
    BYTE    byRecordManage;
    BYTE    byExtraSaveAudio;
    BYTE   byIntelligentRecord; //open smart record 0-no 1-yes
    BYTE    byRes[125];
}NET_DVR_RECORD_V40, *LPNET_DVR_RECORD_V40;

//Recording Parameters
typedef struct
{
    DWORD dwSize;
    DWORD dwRecord;       /*Record or not 0- not 1- Record*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;         /* Pre- record time*/
    DWORD dwPreRecordTime;     /* Pre- record time 0- disable 1- 5Seconds 2- 10Seconds 3- 15Seconds 4- 20Seconds 5- 25Seconds 6- 30Seconds 7- 0xffffffff  (A.F.A.P) */
}NET_DVR_RECORD, *LPNET_DVR_RECORD;

//PTZ protocol structure configuration
typedef struct
{
    DWORD dwType;                /*Type value of decoder,  increase from 1 by degrees*/
    BYTE  byDescribe[DESC_LEN];  /*Description of decoder,  same with 8000*/
}NET_DVR_PTZ_PROTOCOL;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_PTZ_PROTOCOL struPtz[PTZ_PROTOCOL_NUM]; /*200 PTZ protocols in total*/
    DWORD   dwPtzNum;            /*Number of valid PTZ protocol, Start from 0*/
    BYTE    byRes[8];
}NET_DVR_PTZCFG, *LPNET_DVR_PTZCFG;

typedef struct tagNET_DVR_SERIALSTART_V40
{
    DWORD  dwSize;
    DWORD  dwSerialType;
    BYTE   bySerialNum;
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40, *LPNET_DVR_SERIALSTART_V40;


typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;
    DWORD     dwBaudRate;
    BYTE     byDataBit;
    BYTE     byStopBit;
    BYTE     byParity;
    BYTE     byFlowcontrol;
    WORD     wDecoderType;
    WORD     wDecoderAddress;
    BYTE     bySetPreset[MAX_PRESET_V30];
    BYTE     bySetCruise[MAX_CRUISE_V30];
    BYTE     bySetTrack[MAX_TRACK_V30];
    BYTE     bySerialNO;
    BYTE     byWorkMode;
    BYTE     byRes[254];
}NET_DVR_DECODERCFG_V40, *LPNET_DVR_DECODERCFG_V40;

typedef	struct tagNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO
{
    float fMaxTemperature;
    float fMinTemperature;
    float fAverageTemperature;
    NET_VCA_POINT struHighestPoint; 
    NET_VCA_POINT struLowestPoint; 
    BYTE  byIsFreezedata;
    BYTE  byRes[15];
}NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO, *LPNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO;

#define IPC_PROTOCOL_NUM      50   //max number of IP camera protocol

//PTZ protocol structure configuration
typedef struct tagNET_DVR_PROTO_TYPE
{
    DWORD dwType;                /*Type value of IP camera protocol,  increase from 0 by degrees*/
    BYTE  byDescribe[DESC_LEN];  /*Description of IP camera protocol,  same with 8000*/
}NET_DVR_PROTO_TYPE, *LPNET_DVR_PROTO_TYPE;

typedef struct
{
    DWORD   dwSize;
    DWORD   dwProtoNum;            /*Number of valid PTZ protocol, Start from 0*/
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM]; /*200 PTZ protocols in total*/
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST, *LPNET_DVR_IPC_PROTO_LIST;

//PTZ protocol V41
typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;
    DWORD   dwProtoNum;  /*Number of valid PTZ protocol, Start from 0*/
    BYTE    *pBuffer;    //protocol buffer , there are dwProtoNum INTER_PROTO_TYPE structure   
    DWORD   dwBufferLen; //bufffer length
    BYTE    byRes[32];
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

/***************************PTZ Protocol (end) ******************************/

//PTZ configuration  (9000 extended) 
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;   //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k; 
    BYTE byDataBit;     //Data bit 0- 5Seconds, 1- 6bit, 2- 7bit, 3- 8bit; 
    BYTE byStopBit;     //Stop bit 0- 1bit, 1- 2bit; 
    BYTE byParity;      //Parity 0- No parity, 1- odd, 2- even; 
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    WORD wDecoderType;  //Decoder Type,  corresponding to PTZ list
    WORD wDecoderAddress;               //Decoder address: 0 -  255
    BYTE bySetPreset[MAX_PRESET_V30]; //Configure Preset or not, 0- No, 1- Yes
    BYTE bySetCruise[MAX_CRUISE_V30]; //Configure Cruise or not:  0- No, 1- Yes 
    BYTE bySetTrack[MAX_TRACK_V30];   //Configure Track or not, 0- No, 1- Yes
}NET_DVR_DECODERCFG_V30, *LPNET_DVR_DECODERCFG_V30;

//PTZ decoder configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;   //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k; 
    BYTE byDataBit;     //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit; 
    BYTE byStopBit;     //Stop bit 0- 1bit, 1- 2bit; 
    BYTE byParity;      //Parity 0- No parity, 1- odd, 2- even; 
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware

    WORD wDecoderType;       //Decoder Type,  0- YouLi, 1- LiLin- 1016, 2- LiLin- 820, 3- Pelco- p, 4- DM DynaColor, 5- HD600, 6- JC- 4116, 7- Pelco- d WX, 8- Pelco- d PICO
    WORD wDecoderAddress;      //Decoder Address: 0 -  255
    BYTE bySetPreset[MAX_PRESET];         //Configure Preset or not, 0- No, 1- Yes
    BYTE bySetCruise[MAX_CRUISE];         //Configure Cruise or not:  0- No, 1- Yes 
    BYTE bySetTrack[MAX_TRACK];         //Configure Track or not, 0- No, 1- Yes
}NET_DVR_DECODERCFG, *LPNET_DVR_DECODERCFG;

//ppp parameters configuration (Sub Struct) 
typedef struct
{
    NET_DVR_IPADDR struRemoteIP;     //Remote IP
    NET_DVR_IPADDR struLocalIP;     //Local IP
    char sLocalIPMask[16];             //Local Mask
    BYTE sUsername[NAME_LEN];         //Username 
    BYTE sPassword[PASSWD_LEN];     //Password 
    BYTE byPPPMode;                 //PPP mode,  0- active, 1- passive
    BYTE byRedial;                     //Callback or not : 0- No, 1- Yes
    BYTE byRedialMode;                 //Callback, 0- user specified, 1- preseted number
    BYTE byDataEncrypt;             //Encrypt Data , 0- No, 1- Yes
    DWORD dwMTU;                     //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];    //Telephone number
}NET_DVR_PPPCFG_V30, *LPNET_DVR_PPPCFG_V30;

//ppp parameters configuration (Sub Struct) 
typedef struct
{
    char sRemoteIP[16];             //Remote IP
    char sLocalIP[16];                 //Local IP
    char sLocalIPMask[16];             //Local Mask
    BYTE sUsername[NAME_LEN];         //Username 
    BYTE sPassword[PASSWD_LEN];     //Password 
    BYTE byPPPMode;                 //PPP mode,  0- active, 1- passive
    BYTE byRedial;                     //Callback or not : 0- No, 1- Yes
    BYTE byRedialMode;                 //Callback, 0- user specified, 1- preset number
    BYTE byDataEncrypt;             //Encrypt Data , 0- No, 1- Yes
    DWORD dwMTU;                     //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];    //Telephone number
}NET_DVR_PPPCFG, *LPNET_DVR_PPPCFG;

//RS232 Configuration (9000 extended) 
typedef struct
{
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k; 
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit; 
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit; 
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even; 
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    DWORD dwWorkMode;   //Word mode, 0- 232 for PPP dial, 1- 232 for parameter control, 2- for transparent channel 3- ptz mode 4-Alarm mode 5-Matrix control,
    //6-Screen control, 7-Direct connect, 8-Keyboard control 9-Monitor control 10-PTZ control

}NET_DVR_SINGLE_RS232;

typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k; 
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit; 
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit; 
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even; 
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    BYTE byVirtualSerialPort;  // Virtual Serial Port
    BYTE byRes[3];
}NET_DVR_USB_RS232, *LPNET_DVR_USB_RS232;

//RS232 Configuration (9000 extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*note: this structure has change*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30, *LPNET_DVR_RS232CFG_V30;

//RS232 Configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate; //Baud rate (bps) , 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6- 1200, 7- 2400, 8- 4800, 9- 9600, 10- 19200,  11- 38400, 12- 57600, 13- 76800, 14- 115.2k; 
    BYTE byDataBit;   //Data bit 0- 5bit, 1- 6bit, 2- 7bit, 3- 8bit; 
    BYTE byStopBit;   //Stop bit 0- 1bit, 1- 2bit; 
    BYTE byParity;    //Parity 0- No parity, 1- odd, 2- even; 
    BYTE byFlowcontrol; //Flow control:  0- None, 1- software , 2- Hardware
    DWORD dwWorkMode;   //Word mode, 0- 232 for PPP dial, 1- 232 for parameter control, 2- for transparent channel
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG, *LPNET_DVR_RS232CFG;


typedef struct
{
    DWORD dwEnablePresetChan;
    DWORD dwPresetPointNo;
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct
{
    DWORD dwEnableCruiseChan;
    DWORD dwCruiseNo;
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct
{
    DWORD dwEnablePtzTrackChan;
    DWORD dwPtzTrackNo;
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_COND
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22-humanRecognition
    23- faceContrast
    */
    WORD    byEventType;
    BYTE    byRes[2];
    DWORD   dwChannel;
    BYTE    byRes1[128];
}NET_DVR_PTZ_NOTIFICATION_COND, *LPNET_DVR_PTZ_NOTIFICATION_COND;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_CFG
{
    DWORD   dwSize;
    DWORD   dwEnablePresetChanNum;  //The number of points currently enabled preset 
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Enable the preset point information (PTZ) associated linkage type 
    DWORD   dwEnableCruiseChanNum;  //The current enabled channel number of the cruise 
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Enable the cruise function channel information (PTZ) associated linkage type 
    DWORD   dwEnablePtzTrackChanNum;  //The current enabled holder channel number of the track 
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Call holder track channel information (PTZ) associated linkage type 
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION_CFG, *LPNET_DVR_PTZ_NOTIFICATION_CFG;


typedef struct tagNET_DVR_PTZ_NOTIFICATION
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection,
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22- humanRecognition
    */
    WORD    byEventType;
    BYTE    byRes[62];
    DWORD   dwEnablePresetChanNum;  //The number of points currently enabled preset 
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Enable the preset point information (PTZ) associated linkage type 
    DWORD   dwEnableCruiseChanNum;  //The current enabled channel number of the cruise 
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Enable the cruise function channel information (PTZ) associated linkage type 
    DWORD   dwEnablePtzTrackChanNum;  //The current enabled holder channel number of the track 
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Call holder track channel information (PTZ) associated linkage type 
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION, *LPNET_DVR_PTZ_NOTIFICATION;

#define NET_SDK_MAX_EVENT_NUM 64  //Maximum number of supported combined events

//Alarm Input Configuration
typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    //Name
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byInputType;                //Input type, 0 - switch 1 - semaphore 
    DWORD   dwHandleType;        //The way to handle alarm   
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    /*0x2000:SMS alarm*/
    DWORD   dwMaxRelAlarmOutChanNum; //Max RelAlarm Out Chan Num (read Only)
    DWORD   dwRelAlarmOutChanNum;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //Alarm Out Chan No.
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//alarm Time

    DWORD   dwMaxRecordChanNum;
    DWORD   dwCurRecordChanNum;
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];
    DWORD   dwMaxEnablePtzCtrlNun;
    DWORD   dwEnablePresetChanNum;  //enable preset Num
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //Call preset Info
    BYTE    byPresetDurationTime[MAX_CHANNUM_V40];//Preset point time range 0-20s, the default 10s. 
    BYTE    byRes2[4];
    DWORD   dwEnableCruiseChanNum;  //enable Cruise Num
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //Cruise Info
    DWORD   dwEnablePtzTrackChanNum;  //Track Num
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //Track No
    WORD   wEventType[NET_SDK_MAX_EVENT_NUM/*64*/]; /*Composite event types, each bit corresponding to an event type*/
    BYTE    byRes[128];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

//Alarm Input Configuration (9000 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];     //Name 
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byInputType;                //Input type, 0 - switch 1 - semaphore 
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;     //The way to handle alarm 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM_V30];         //Channel triggered to record,  1- - trigger
    BYTE byEnablePreset[MAX_CHANNUM_V30];         //Call preset or not 0- No, 1- Yes
    BYTE byPresetNo[MAX_CHANNUM_V30];             //Preset No. One alarm input can trigger several presets,  0xff- disable
    BYTE byRes2[192];                             //Reserved
    BYTE byEnableCruise[MAX_CHANNUM_V30];         //Call Cruise or not 0- No, 1- Yes
    BYTE byCruiseNo[MAX_CHANNUM_V30];             //Cruise No.
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];     //Call Track or not 0- No, 1- Yes
    BYTE byPTZTrack[MAX_CHANNUM_V30];             //Track No. 
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30, *LPNET_DVR_ALARMINCFG_V30;

//Alarm Input Configuration
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];     //Name 
    BYTE byAlarmType;                 //Alarm Type, 0: normally open, 1: normally close
    BYTE byAlarmInHandle;             //Handle alarm or not 0- No 1- Yes
    BYTE byChannel;                 //Intelligent recognition channel triggered by alarm input
    BYTE byRes;
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType; //The way to handle alarm 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT]; //Guard time
    BYTE byRelRecordChan[MAX_CHANNUM];         //Channel triggered to record,  1- - trigger
    BYTE byEnablePreset[MAX_CHANNUM];         //Call preset or not 0- No, 1- Yes
    BYTE byPresetNo[MAX_CHANNUM];             //Preset No. One alarm input can trigger several presets,  set 0xff to disable
    BYTE byEnableCruise[MAX_CHANNUM];         //Call Cruise or not 0- No, 1- Yes
    BYTE byCruiseNo[MAX_CHANNUM];             //Cruise No.
    BYTE byEnablePtzTrack[MAX_CHANNUM];     //Call Track or not 0- No, 1- Yes
    BYTE byPTZTrack[MAX_CHANNUM];             //Track No. 
}NET_DVR_ALARMINCFG, *LPNET_DVR_ALARMINCFG;

typedef struct
{
    WORD    wPicSize;
    WORD    wPicQuality; 
    BYTE    byPicTackleMode;
    BYTE   byRes[11];
}NET_DVR_PUSHJPEGPARA, *LPNET_DVR_PUSHJPEGPARA;


#define    COM_PUSHALARM        0x1200    
#define    COM_PUSHALARM_V30    0x1201   
typedef struct tagNET_DVR_PUSHALARMINFO
{
    DWORD dwAlarmType;
    DWORD dwAlarmInputNumber;
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];
    DWORD dwChannel[MAX_CHANNUM];
    DWORD dwDiskNumber[MAX_DISKNUM];
    BYTE byDeviceID[NAME_LEN];
    BYTE byRes[4];
}NET_DVR_PUSHALARMINFO, *LPNET_DVR_PUSHALARMINFO;

typedef struct
{
    DWORD dwAlarmType;
    DWORD dwAlarmInputNumber;
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];
    BYTE byChannel[MAX_CHANNUM_V30];
    BYTE byDiskNumber[MAX_DISKNUM_V30];
    BYTE byDeviceID[NAME_LEN];
    BYTE byRes[7];
}NET_DVR_PUSHALARMINFO_V30, *LPNET_DVR_PUSHALARMINFO_V30;

typedef struct tagNET_DVR_MB_AUTOWORKPARA
{

    BYTE    byCurPowerCtrlType;   /*parent start control type 0:  reserved,  1:  delay shutdown,  2:  auto start and shutdown*/
    BYTE    byRes[3];
    NET_DVR_SCHEDTIME    struWorkTime[MAX_DAYS][2];
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

//analogy input Configuration
typedef struct tagNet_DVR_ANALOG_ALARMINCFG
{
    DWORD     dwSize;
    BYTE        byEnableAlarmHandle; //Handle alarm or not 0- No 1- Yes
    BYTE        byRes1[3];
    BYTE        byAlarmInName[NAME_LEN]; //Name 
    WORD        wAlarmInUpper; //The analog input voltage under limit,The actual value*10,[0~360]
    WORD        wAlarmInLower; //The analog input voltage upper limit,The actual value*10,[0~360] 
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    //The way to handle alarm 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Guard time
    BYTE        byRelRecordChan[MAX_CHANNUM_V30]; //Channel triggered to record
    BYTE        byRes2[100];
}NET_DVR_ANALOG_ALARMINCFG, *LPNET_DVR_ANALOG_ALARMINCFG;


typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    DWORD dwAlarmType;              /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                        11- Vca scene change 12-Array exception 13 resolution dismatch,14-alloc decode resource fail,15-VCA detect,19-audio input lost, 20-record on,21-record off,22-vehicle detection exception, 23-pulse alarm,24-face lib disk alarm,25-face lib change,26-face picture change,28-camera angle anomaly,34-abnormal reboot*/
    NET_DVR_TIME_EX struAlarmTime;    //alarm Time
    union
    {
        BYTE    byUnionLen[116];
        struct
        {
            DWORD    dwAlarmInputNo;
            DWORD    dwTrigerAlarmOutNum;
            DWORD    dwTrigerRecordChanNum;
        }struIOAlarm;    // sensor alarm 
        struct
        {
            DWORD    dwAlarmChanNum;
            DWORD    dwPicLen;//Jpeg
            BYTE     byPicURL; //0-Binary1-URL
            BYTE    byTarget; // 0-not distinguish,1-hunman,2-vehicle
            BYTE    byRes1[2]; //
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
            char*  pDataBuff;
#else
            char*   pDataBuff;
            BYTE  byRes3[4];
#endif
        }struAlarmChannel;    // dwAlarmType is 2,3,6,9,10,13 or 28 Effective
        struct
        {
            DWORD    dwAlarmHardDiskNum;    /*it stands for Hard Disk,  dwDiskNumber*/
        }struAlarmHardDisk;/*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
        struct
        {
            BYTE       bySubAlarmType;  //alarm type,1-delay record; 
            BYTE       byRes1[3]; //res
            NET_DVR_TIME_EX  struRecordEndTime; //record end 
        }struRecordingHost;  //record host alarm
        struct
        {
            float          fVoltageValue;//Power supply voltage, unit V, accurate to 0.1
            BYTE           byVoltageAlarmType;  //Power supply voltage alarm type, 0-power supply voltage is too high, 1-power supply voltage is too low
            BYTE       byRes1[3]; //res
        }struVoltageInstable;  //dwAlarmType = 31 is valid

        struct
        {
            float      fTemperature;//The temperature sensor, accurate to one decimal places
            DWORD      dwCustomInfoLength; //The custom information length
            BYTE*      pCustomInfo; //custom information
            BYTE       byType;  //PTLocking type 1-pan 2-tilt
            BYTE       byDeicingEnabled;  // Deicing enabled 0-close 1-open
            BYTE       byRes2[2]; //
            DWORD      dwChannel; //
        }struPTLocking;  //PTLocking dwAlarmType=32 is valid

        struct
        {
            BYTE       byExceptionType;	//Exception type, 0-reserved, 1-log storage exception, 2-log disk full
        }struLogException;  //Valid when dwalarmtype = 33, log exception information

        struct
        {
            NET_DVR_TIME_EX struAlarmTime;    //Restart time, device local time 
            BYTE            byExceptionType;  //Restart specific type 0-reserved 1-thread 2-NO stream 
            BYTE            byRes1[3];        //res
        }struAbnormalReboot;  //Valid when dwAlarmType=34, abnormalReboot

    }uStruAlarm;
    DWORD*  pRes;    //res
    BYTE   byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char   cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char   cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE    byRes;
    WORD    wDevInfoIvmsChannel; //Add transmission channel number 
    BYTE   byRes2[2];
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

//Upload Alarm Information(256 NVR extended)
typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER     struAlarmFixedHeader;
    DWORD*                        pAlarmData;
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

//Upload Alarm Information  (9000 extended) 
typedef struct
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                       11- Vca scene change 12-Array exception 13 resolution dismatch,14-alloc decode resource fail,15-VCA detect, 16-POE power supply abnormal alarm,17-Flash anomaly ,18-Disk full load anomaly,19-audio input lost, 20-record on, 21-record off,22-vehicle detection exception, 23-pulse alarm,24-face lib disk alarm,25-face lib change,26-face picture change,28-camera angle anomaly
                       ,29-battery low,30-Lack of SD card*/
    DWORD dwAlarmInputNumber; /*Alarm input Port*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30]; /*State of Alarm output channel, 1- - Triggered*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30]; /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
    BYTE byChannel[MAX_CHANNUM_V30]; /*If the dwAlarmType is 2, 3 , 6,14, 19 or 28 it stands for channel, dwChannel[0] is the first channel*/
    BYTE byDiskNumber[MAX_DISKNUM_V30]; /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
}NET_DVR_ALARMINFO_V30, *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;
    DWORD  dwExceptionCase;   //alarm reason   0-net exception
    NET_DVR_IPADDR  struDeviceIP;    //Device IP
    BYTE    byRes[256];
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception*/
    DWORD dwAlarmInputNumber; /*Alarm input Port*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT]; /*State of Alarm output channel, 1- - Triggered*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM]; /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
    DWORD dwChannel[MAX_CHANNUM]; /*If the dwAlarmType is 2, 3 or 6, it stands for channel, dwChannel[0] is the first channel*/
    DWORD dwDiskNumber[MAX_DISKNUM]; /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
}NET_DVR_ALARMINFO, *LPNET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IP Camera Parameter
/* IP Device */
//extended ipc connection functions,  support add IPC domain name

#define  DEV_ID_LEN           32    
typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;                     //Valid status for IP device
    BYTE byProType;                 //Protocol type,  0- private (default) ,  1-  Panasonic,  2-  SONY
    BYTE byEnableQuickAdd;          //0-  does not support quick adding of IP device;  1-   enable quick adding of IP device
    //Quick add of device IP and protocol,  fill in the other parameters as system default 
    BYTE byCameraType;    //Channel access camera type
    BYTE sUserName[NAME_LEN];         //user name
    BYTE sPassword[PASSWD_LEN];     //Password
    BYTE byDomain[MAX_DOMAIN_NAME]; //Domain name of the device
    NET_DVR_IPADDR struIP;             //IP
    WORD wDVRPort;                      //Port number
    BYTE  szDeviceID[DEV_ID_LEN];  //Device ID 
    BYTE byEnableTiming;  //0- retention, 1- disable NVR to automatic timing for IPC, 2- enable NVR to automatic timing for IPC
    BYTE byCertificateValidation;//Certificate authentication
    // byCertificateValidation:bit0:0- certificate validation is not enabled 1- certificate validation is enabled
    // byCertificateValidation:bit1:0- no default communication port 1- enable default communication port
}NET_DVR_IPDEVINFO_V31, *LPNET_DVR_IPDEVINFO_V31;

typedef struct
{
    DWORD dwEnable;                 /* Enable this device */
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    NET_DVR_IPADDR struIP;             /* IP address */
    WORD wDVRPort;                      /* Port */
    BYTE byRes[34];                 /* Reserved */
}NET_DVR_IPDEVINFO, *LPNET_DVR_IPDEVINFO;

/* IP Channel parameters */
typedef struct
{
    BYTE byEnable;                     //0- Failed to connect IP device; 1- Successfully; 
    BYTE byIPID;                     //ID of IP device,  low 8 bit 
    BYTE byChannel;                 //Channel No. 
    BYTE byIPIDHigh;                //ID of IP device,  high 8 bit 
    BYTE byTransProtocol;            //Trans Protocol Type 0-TCP/auto (Determined by the device),1-UDP 2-Multicast 3-only TCP 4-auto
    BYTE byGetStream;         /* Whether to get stream,0-yes,1-no*/
    BYTE byres[30];                    /* Reserved */
} NET_DVR_IPCHANINFO, *LPNET_DVR_IPCHANINFO;

/* Struct of connecting IP device*/
typedef struct
{
    DWORD dwSize;                                          /* Structure Size */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];     /* IP Device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];         /* Enable analog channel or not, channel 1 (low bit)  to channel 32 (high bit) , 0- invalid;  1- valid */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];   /* IP Channel */
}NET_DVR_IPPARACFG, *LPNET_DVR_IPPARACFG;

typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;                                          /* Structure size */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE]; /* IP device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];         /* Enable/disable analog channels,  stands for channel 1- 32 ,  0- disable;  1- enable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];      /* IP channel*/
}NET_DVR_IPPARACFG_V31, *LPNET_DVR_IPPARACFG_V31;

typedef  struct tagNET_DVR_IPSERVER_STREAM
{
    BYTE    byEnable;   //Is enable
    BYTE    byRes[3];
    NET_DVR_IPADDR struIPServer;   //IPServer Address
    WORD  wPort;                   //IPServer port
    WORD  wDvrNameLen;             //DVR Name Length
    BYTE   byDVRName[NAME_LEN];    //DVR Name
    WORD  wDVRSerialLen;           //Serial Length
    WORD  byRes1[2];               //reserved
    BYTE   byDVRSerialNumber[SERIALNO_LEN];    //DVR Serial
    BYTE   byUserName[NAME_LEN];               //DVR User name
    BYTE   byPassWord[PASSWD_LEN];             //DVR User password
    BYTE    byChannel;                         //DVR channel
    BYTE   byRes2[11];              //Reserved
}NET_DVR_IPSERVER_STREAM, *LPNET_DVR_IPSERVER_STREAM;

/*the configuration of stream server*/
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE    byValid;            //Is enable
    BYTE    byRes1[3];
    NET_DVR_IPADDR  struDevIP;  //stream server IP    
    WORD    wDevPort;            //stream server Port    
    BYTE    byTransmitType;        //Protocol: 0-TCP, 1-UDP
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG, *LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

//device information
typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP address
    WORD     wDVRPort;                 //DVR PORT
    BYTE     byChannel;                //Channel
    BYTE    byTransProtocol;        //Transmit protocol:0-TCP,1-UDP
    BYTE    byTransMode;            //Stream mode: 0-mian stream 1-sub stream
    BYTE    byFactoryType;            /*IPC factory type*/
    BYTE    byDeviceType; //Device type(Used by videoplatfom VCA card),1-decoder(use decode channel No. or display channel depends on byVcaSupportChanMode in videoplatform ability struct),2-coder
    BYTE    byDispChan;//Display channel No. used by VCA configuration
    BYTE    bySubDispChan;//Display sub channel No. used by VCA configuration
    BYTE    byResolution;    //Resolution: 1-CIF 2-4CIF 3-720P 4-1080P 5-500w used by big screen controler
    BYTE    byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];    //Device domain name
    BYTE    sUserName[NAME_LEN];    //Remote device user name
    BYTE    sPassword[PASSWD_LEN];    //Remote device password
}NET_DVR_DEV_CHAN_INFO, *LPNET_DVR_DEV_CHAN_INFO;

typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD                                dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG, *LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   //Is Enable.
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;   //Stream server IP
    WORD   wStreamServerPort;           //Stream server Port   
    BYTE   byStreamServerTransmitType;  //Stream protocol
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;      //IPserver IP
    WORD   wIPServerPort;               //IPserver Port
    BYTE   byRes3[2];
    BYTE   sDVRName[NAME_LEN];     //DVR Name
    WORD   wDVRNameLen;            //DVR Name Len
    WORD   wDVRSerialLen;          //Serial Len
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    //Serial number
    BYTE   sUserName[NAME_LEN];   //the user name which is used to login DVR.
    BYTE   sPassWord[PASSWD_LEN]; //the password which is used to login DVR.
    WORD   wDVRPort;        //DVR port
    BYTE   byRes4[2];
    BYTE   byChannel;       //channel
    BYTE   byTransProtocol; //protocol 
    BYTE   byTransMode;     //transform mode
    BYTE   byFactoryType;   //The type of factory who product the device.
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

#define MAX_LICENSE_LEN_EX                    32        //Max. length of the license number
typedef    struct
{
    DWORD    dwSize;
    NET_DVR_TIME_EX    strStartTime;  //start time 
    NET_DVR_TIME_EX    strStopTime;  //end time 
    char     sLicense[MAX_LICENSE_LEN_EX/*32*/];    //vechial number
    // area index 0-res,1-(Europe Region),2-(Russian Region),3-(EU&CIS) ,4-(Middle East),0xff-all
    DWORD      dwChannel;
    BYTE      byRegion;
    BYTE      byRes[127];
}NET_DVR_VEHICLE_INFO_COND, *LPNET_DVR_VEHICLE_INFO_COND;

typedef  struct
{
    DWORD     dwSize;
    DWORD     dwIndex;//index    
    BYTE    byDeviceID[DEVICE_ID_LEN/*48*/];    //device num
    BYTE    byBelieve;//,0-100    
    BYTE    byDir;//derection,0-none,1-reverse,2-positive,3-unknown
    BYTE    byLineID;//
    BYTE    byRes1;
    NET_DVR_TIME_EX  struSnapTime;//snap time
    char    sLicense[MAX_LICENSE_LEN_EX/*32*/];        //vehicle num
    BYTE    byMonitoringSiteID[MONITORSITE_ID_LEN /*48*/];    //
    BYTE    byCountry; // conutry index,COUNTRY_INDEX(no support"COUNTRY_ALL = 0xff, //ALL ")
    BYTE    byMatchingResult;//match result:0-res,1-allowlist,2-blocklist,3-otherlist
    BYTE    byArea;                         //Area of  The United Arab Emirates, refer to EMI_AREA
    BYTE    byPlateType;                    //Plate Type, refer to VCA_PLATE_TYPE
    char    sDeviceName[NAME_LEN/*32*/];    //Device Name
    BYTE  	byPlateColor;						//Plate Color,VCA_PLATE_COLOR
    BYTE  	byPlateSize;						//Plate Size,0~unknown,1~long,2~short
    BYTE    byRes2[2];
    char    sPlateCategory[MAX_CATEGORY_LEN/*8*/];		//Plate Category
    char    sPlateImageURL[URL_LEN_V40/*256*/];         //Plate Image URL
    char    sEffectiveTime[ISO_8601_LEN/*32*/];    //Plate Effective Time, ISO8601 time, 2009-11-14T15:27Z
    BYTE    byRes[176];
}NET_DVR_VEHICLE_INFO_CFG, *LPNET_DVR_VEHICLE_INFO_CFG;

#define URL_LEN     240   //URL length
typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable;
    BYTE    strURL[URL_LEN];
    BYTE    byTransPortocol; // transport protocol type  0-tcp  1-UDP
    WORD    wIPID;  //Device ID,wIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE    byChannel;  //channel NO.
    BYTE    byRes[7];
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef  struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;   //Is enable
    BYTE    byRes[3];
    BYTE    byDDNSDomain[64];    // hiDDNS domain
    WORD    wPort;                   //IPServer port
    WORD    wAliasLen;               //Alias Length
    BYTE    byAlias[NAME_LEN];         //Alias
    WORD    wDVRSerialLen;           //Serial Length
    BYTE    byRes1[2];               //reserved
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    //DVR Serial
    BYTE    byUserName[NAME_LEN];               //DVR User name
    BYTE    byPassWord[PASSWD_LEN];             //DVR User passward
    BYTE    byChannel;                          //DVR channel
    BYTE    byRes2[11];              //Reserved
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;                /* Enable */
    BYTE    byRes1;
    WORD    wIPID;                  //IP ID
    DWORD     dwChannel;                //channel
    BYTE    byTransProtocol;        //Trans protocol,0-TCP,1-UDP, 2-multicast, 3-rtsp, 0xff-auto (auto)
    BYTE    byTransMode;            //Trans mode 0-main, 1-sub
    BYTE    byFactoryType;            /*Factory type*/
    BYTE    byRes;
    BYTE    strURL[URL_LEN/*240*/];   /*RTSP protocol fetch stream URL (valid only for RTSP protocol)*/
}NET_DVR_IPCHANINFO_V40, *LPNET_DVR_IPCHANINFO_V40;

// Brainare CVR
#define MAX_ID_COUNT    256
#define MAX_STREAM_ID_COUNT    1024
#define STREAM_ID_LEN   32
#define PLAN_ID_LEN  32

#define LEN_32                    32
#define LEN_31                    31
#define DEVICE_NO_LEN  24
#define MAX_VOLUMENAME_LEN 32   //volume name lenth
#define MAX_VAG_CHANNO_LEN  32  

#define MAX_STREAM_ID_NUM    30

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{
    BYTE    byEnable;
    BYTE    byLocalBackUp; //enable local backup 0-disable ,1-enable
    BYTE    byRes[2];
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byAddress[MAX_DOMAIN_NAME];  //Encoder IP or domain name, the device needs to resolve Analytical methods exist for the letters and there '.' Is considered to be the domain name, IP address otherwise
    WORD    wPort;
    BYTE    byRes1[122];
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;


// Stream info
typedef struct tagNET_DVR_STREAM_INFO
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID
    DWORD dwChannel;                //Relation channel, 0xffffffff: not related
    BYTE  byRes[32];
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;


typedef union tagNET_DVR_GET_STREAM_UNION
{
    NET_DVR_IPCHANINFO      struChanInfo;         //Get stream from Device.
    NET_DVR_IPSERVER_STREAM struIPServerStream;  //Get stream from Device which register the IPServer
    NET_DVR_PU_STREAM_CFG   struPUStream;         //Get stream from stream server.
    NET_DVR_DDNS_STREAM_CFG struDDNSStream;      //Get stream by IPserver and stream server.
    NET_DVR_PU_STREAM_URL   struStreamUrl;        //get stream through stream server by url.
    NET_DVR_HKDDNS_STREAM struHkDDNSStream;   //get stream through hiDDNS
    NET_DVR_IPCHANINFO_V40 struIPChan; //Get stream from device(Extend)
}NET_DVR_GET_STREAM_UNION, *LPNET_DVR_GET_STREAM_UNION;

typedef enum
{
    NET_SDK_IP_DEVICE = 0,
    NET_SDK_STREAM_MEDIA,
    NET_SDK_IPSERVER,
    NET_SDK_DDNS_STREAM_CFG,
    NET_SDK_STREAM_MEDIA_URL,
    NET_SDK_HKDDNS,
    NET_SDK_IP_DEVICE_ADV,
    NET_SDK_IP_DEVICE_V40,
    NET_SDK_RTSP
}GET_STREAM_TYPE;

typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //the type of gettin stream:0-Get stream from Device, 1-Get stream fram stream server, 
    //2-Get stream from Device which register the IPServer, 3.Get stream by IPserver and stream server
    //4-get stream by url,5-hkDDNS,6-Get stream from Device,NET_DVR_IPCHANINFO_V40,7- Get Stream by Rtsp Protocal 
    BYTE    byRes[3];        //reserved
    NET_DVR_GET_STREAM_UNION uGetStream;    //the union of different getting stream type.
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;


typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;                        //Size
    DWORD        dwGroupNum;                    //The number of group    
    DWORD      dwAChanNum;                    //The number of simulate channel
    DWORD      dwDChanNum;                  //the number of IP channel
    DWORD      dwStartDChan;                //the begin NO. of IP channel
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    //Is simulate channel enable? represent by bit
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      //IP device
    NET_DVR_STREAM_MODE  struStreamMode[MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 //reserved
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;


typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;    //type
    NET_DVR_TIME   struTime;  //time
    BYTE       byRes[32];     //reserved
    DWORD      dwNumber;      //number
    WORD       *pNO;
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

/* Alarm output channel */
typedef struct
{
    BYTE byIPID;                     /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    BYTE byAlarmOut;                 /* Alarm output NO. */
    BYTE byRes[18];                 /* Reserved */
}NET_DVR_IPALARMOUTINFO, *LPNET_DVR_IPALARMOUTINFO;

/* IP Alarm output configuration */
typedef struct
{
    DWORD dwSize;                                                 /*struct size */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP alarm output */
}NET_DVR_IPALARMOUTCFG, *LPNET_DVR_IPALARMOUTCFG;


/* Alarm output parameters */
typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;                    /* ID of IP device,  the range:  1 to MAX_IP_DEVICE*/
    DWORD dwAlarmOut;                /* Alarm Out NO. */
    BYTE  byRes[32];                /* Reserved */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40;

/* Alarm input parameters */
typedef struct
{
    BYTE byIPID;                     /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    BYTE byAlarmIn;                 /* Alarm input NO. */
    BYTE byRes[18];                 /* Reserved */
}NET_DVR_IPALARMININFO, *LPNET_DVR_IPALARMININFO;

/* IP Alarm input configuration */
typedef struct
{
    DWORD dwSize;                                              /*struct size */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];  /* IP alarm input */
}NET_DVR_IPALARMINCFG, *LPNET_DVR_IPALARMINCFG;

/* IP Alarm input configuration */
typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;                    /* ID of IP device,  the range:  1 to MAX_IP_DEVICE */
    DWORD dwAlarmIn;                /* Alarm input NO. */
    BYTE  byRes[32];
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;
    DWORD   dwCurIPAlarmInNum;
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40;


//IP Camera alarm info
typedef struct
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];             /* IP Device */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                 /* Enable analog channel or not, 0- Enable;  1- Disable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];              /* IP Channel */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];     /* IP Alarm input */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];  /* IP Alarm output */
}NET_DVR_IPALARMINFO, *LPNET_DVR_IPALARMINFO;

//IPC configuration change alarm  (Extended for 9000_1.1) 
typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];         /* IP device*/
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                 /* Enable/ disable analog channel,  0-  disable;  1- enable */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];              /* IP channel */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];     /* IP alarm input */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];  /* IP alarm output */
}NET_DVR_IPALARMINFO_V31, *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];     //IP device
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];               //Enable analog channel or not: 0- disable, 1- enable
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];            //IP channel
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    //IP alarm input 
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; //IP alarm output   
    BYTE                    byRes[20];                          //Reserved
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;

typedef enum _HD_STAT_
{
    HD_STAT_OK = 0,   /* Normal */
    HD_STAT_UNFORMATTED = 1,   /* Raw */
    HD_STAT_ERROR = 2,   /* Error */
    HD_STAT_SMART_FAILED = 3,   /* SMART State */
    HD_STAT_MISMATCH = 4,   /* Unmatched */
    HD_STAT_IDLE = 5,   /* Sleep*/
    NET_HD_STAT_OFFLINE = 6,   /* Net Disk is off line */
    HD_RIADVD_EXPAND = 7,   /* riad virtual disk expand */
    HD_STAT_REPARING = 10,  /* disk is repairing */
    HD_STAT_FORMATING = 11,  /* disk is formating */
}HD_STAT;

//Configuration of local Hard Disk
typedef struct
{
    DWORD dwHDNo;          /*Hard Disk No.  (0~MAX_DISKNUM_V30- 1)  */
    DWORD dwCapacity;      /*Capacity (Read only) */
    DWORD dwFreeSpace;     /*Free space (Read only) */
    DWORD dwHdStatus;      /*Disk status (Read only)  0- Normal,  1- Raw,  2- Error,  3- SMART State,  4- Unmatched,  5- Sleep*/
    /* 6 - network hard disk is not online 7 - the virtual disk scalable 10 - hard drive being repaired*/
    /* 11 - hard disk is formatted 12 - hard drive is waiting for formatting 13 - hard uninstalled */
    /*14 - the local hard disk does not exist 15 - (network hard drive being deleted),16-locked*/
    BYTE  byHDAttr;        /*0- Default,  1- Redundancy;  2- Read only, , 3- backup, use for CVR,4-NotRW*/
    BYTE  byHDType;           /*0- Local HD,1-ESATA HD,2-NAS HD,3-iSCSI HD 4-Array Virtual Disk,5-SD card,,6-minSAS*/
    BYTE  byDiskDriver;    //The value means its ANSC character, added for IVMS device
    BYTE  byRes1;
    DWORD dwHdGroup;       //Disk Group  (1- MAX_HD_GROUP) 
    BYTE  byRecycling;       //  0:no reuse,1:reuse
    BYTE  bySupportFormatType;    /*only supports byHDType=5(SD card);
                                  bySupportFormatType=0, the device will format the hard disk with its default type.
                                  bySupportFormatType: bit0:0 - representative does not support FAT32 format type, 1 - on behalf of the support;
                                  bySupportFormatType: bit1:0 - representative does not support corruption format type, 1 - on behalf of the support;*/
    BYTE  byFormatType;         /* 0- device default format type,1- specify FAT32 format (byHDType=5(SD card),2- specify EXT4 format (byHDType=5(SD card))*/
    BYTE  byRes2;
    DWORD  dwStorageType;    //by bit 0-not support      none 0-support
    // dwStorageType & 0x1 for common record
    // dwStorageType & 0x2  for drawframe record
    // dwStorageType & 0x4  for picture

    DWORD dwPictureCapacity;  //Hard picture capacity (not set) Unit: MB
    DWORD dwFreePictureSpace; //Remaining the pictures space (not set), unit: MB
    BYTE  byRes3[104];
}NET_DVR_SINGLE_HD, *LPNET_DVR_SINGLE_HD;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;                               //Number of Disk (Read only)
    NET_DVR_SINGLE_HD struHDInfo[MAX_DISKNUM_V30]; //Reboot Device to take effect
}NET_DVR_HDCFG, *LPNET_DVR_HDCFG;

//Configuration of local Hard Disk
typedef struct
{
    DWORD dwHDNo;         /*Hard Disk No.  (0~MAX_DISKNUM_V30- 1)  */
    DWORD dwCapacity;     /*Capacity (Read only) */
    DWORD dwFreeSpace;    /*Free space (Read only) */
    DWORD dwHdStatus;     /*Disk status (Read only)  0- Normal,  1- Raw,  2- Error,  3- SMART State,  4- Unmatched,  5- Sleep*/
    /* 6 - network hard disk is not online 7 - the virtual disk scalable 10 - hard drive being repaired*/
    /* 11 - hard disk is formatted 12 - hard drive is waiting for formatting 13 - hard uninstalled */
    /*14 - the local hard disk does not exist 15 - (network hard drive being deleted),16-locked, 17-Warning (at any time may become bad disc),
    18-Bad disk (hard disk have been damaged), 19-Hidden disk (abnormal was kicked out of array and a bad sectors, for example), 20-Unauthorized (not testing, need to test the disk in the CVR)
    21-Not formatted on the recording host*/
    BYTE  byHDAttr;       /*0- Default,  1- Redundancy;  2- Read only, , 3- backup, use for CVR,4-NotRW*/
    BYTE  byHDType;          /*0- Local HD,1-ESATA HD,2-NAS HD,3-iSCSI HD 4-Array Virtual Disk,5-SD card,,6-minSAS*/
    BYTE  byDiskDriver;   //The value means its ANSC character, added for IVMS device
    BYTE  byGenusGruop;  //Genus group: 0 - retention, 1- array, 2 - storage pool, 3 - array play set, 4 - an uninitialized, 5 - invalid disk, 6 - regional hot standby, 7 - global hot standby, read-only 
    DWORD dwHdGroup;      //Disk Group  (1- MAX_HD_GROUP)
    BYTE  byRecycling;   //  0:no reuse,1:reuse
    BYTE  bySupportFormatType;    /*only supports byHDType=5(SD card);
                                  bySupportFormatType=0, the device will format the hard disk with its default type.
                                  bySupportFormatType: bit0:0 - representative does not support FAT32 format type, 1 - on behalf of the support;
                                  bySupportFormatType: bit1:0 - representative does not support corruption format type, 1 - on behalf of the support;*/
    BYTE  byFormatType;         /* 0- device default format type,1- specify FAT32 format (byHDType=5(SD card),2- specify EXT4 format (byHDType=5(SD card))*/
    BYTE  byRes2;
    DWORD  dwStorageType;    //by bit 0-not support      none 0-support
    // dwStorageType & 0x1 for common record
    // dwStorageType & 0x2  for drawframe record
    // dwStorageType & 0x4  for picture

    DWORD dwPictureCapacity; //Hard picture capacity (not set) Unit: MB
    DWORD dwFreePictureSpace; //Remaining the pictures space (not set), unit: MB
    BYTE  byDiskLocation[NET_SDK_DISK_LOCATION_LEN/*16*/];//Hard disk location, read-only 
    BYTE  bySupplierName[NET_SDK_SUPPLIER_NAME_LEN/*32*/];//Supplier name, read-only 
    BYTE  byDiskModel[NET_SDK_DISK_MODEL_LEN /*64*/];//Drive model, read-only 
    char  szHDLocateIP[SDK_MAX_IP_LEN];//HDD IP
    BYTE  byRes3[80];
}NET_DVR_SINGLE_HD_V50, *LPNET_DVR_SINGLE_HD_V50;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;          /*Number of Disk (Read only)*/
    NET_DVR_SINGLE_HD_V50 struHDInfoV50[MAX_DISKNUM_V30];
    BYTE  byRes[128];
}NET_DVR_HDCFG_V50, *LPNET_DVR_HDCFG_V50;

typedef struct tagNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO
{
    DWORD  dwSize;
    BYTE  byHDVolumeNo;      /*Hard disk volume ID (not set)*/
    BYTE  byType;       /*Hard disk volume type: 0-video volume 1-archive volume 2-file volume 3-picture volume */
    BYTE  byRes1[2];
    DWORD  dwCapacity;     /*Hard disk volume capacity, unit MB (not set)*/
    DWORD  dwFreeSpace;    /*Hard disk volume the remaining space, the unit MB (not set) */
    BYTE  byHDVolumeName[NET_SDK_DISK_VOLUME_LEN/*36*/];  /*Hard disk volume name (not set)*/
    BYTE  byLoopCover;    /*Whether circulation coverage: 0 - acyclic coverage, 1 - cycle cover (hard disk volume after full cycle cover the old video)*/
    BYTE  byRes[63];
}NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO, *LPNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO;

typedef struct tagNET_DVR_HARD_DISK_VOLUME_INFO
{
    DWORD  dwSize;
    DWORD  dwHDVolumeCount;      //Number of Volume (Read only)
    NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO struSingleVolumeInfo[NET_SDK_MAX_DISK_VOLUME/*33*/];    /*single disk volume information*/
    BYTE  byRes[128];
}NET_DVR_HARD_DISK_VOLUME_INFO, *LPNET_DVR_HARD_DISK_VOLUME_INFO;


//Local Disk Group Configuration
typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD     dwHDGroupNo;       /*Group NO. (Read only)  1- MAX_HD_GROUP*/
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40];  /*Corresponding Channel of HD Group,*/
    BYTE       byRes[64];
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD      dwSize;
    DWORD     dwMaxHDGroupNum;           /*Total groups (Read only) */
    DWORD     dwCurHDGroupNum;       /*Cur groups (Read only) */
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //Reboot Device to take effect
    BYTE       byRes[128];
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;


//Local Disk Group Configuration
typedef struct
{
    DWORD dwHDGroupNo;        /*Group NO. (Read only)  1- MAX_HD_GROUP*/
    BYTE byHDGroupChans[MAX_CHANNUM_V30];  /*Corresponding Channel of HD Group,  0- Not record in this group, 1- Record in this group*/
    BYTE byRes[8];
}NET_DVR_SINGLE_HDGROUP, *LPNET_DVR_SINGLE_HDGROUP;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDGroupCount;         /*Total groups (Read only) */
    NET_DVR_SINGLE_HDGROUP struHDGroupAttr[MAX_HD_GROUP]; //Reboot Device to take effect
}NET_DVR_HDGROUP_CFG, *LPNET_DVR_HDGROUP_CFG;


//Display Scale Configuration
typedef struct
{
    DWORD dwSize;
    DWORD dwMajorScale;     /* Main Screen  0- No Scale, 1- Scale*/
    DWORD dwMinorScale;     /* AUX Screen   0- No Scale, 1- Scale*/
    DWORD dwRes[2];
}NET_DVR_SCALECFG, *LPNET_DVR_SCALECFG;



//DVR Alarm output (9000 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];     /* Name */
    DWORD dwAlarmOutDelay;             /* Alarm Duration (- 1- - Stop manually)  */
    //0- 5 Sec, 1- 10Sec, 2- 30Sec, 3- 1Min, 4- 2Min, 5- 5Min, 6- 10Min, 7- Stop Manually,8-1Sec,9-2Sec,10-3Sec,11-4Sec
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /* Time Segment for Alarm output */
    BYTE byAlarmOutHandle;            /* 0 deal,1 not deal*/
    BYTE byNormalSatus;            /* 0-open 1-cloae*/
    BYTE byRes[14];
}NET_DVR_ALARMOUTCFG_V30, *LPNET_DVR_ALARMOUTCFG_V30;

//DVR Alarm output
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];     /* Name */
    DWORD dwAlarmOutDelay;     /* Alarm Duration (- 1- - Stop manually)  */
    //0- 5Sec, 1- 10Sec, 2- 30Sec, 3- 1Min, 4- 2Min, 5- 5Min, 6- 10Min, 7- Stop Manually
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];  /* Time Segment for Alarm output */
}NET_DVR_ALARMOUTCFG, *LPNET_DVR_ALARMOUTCFG;

//DVR Local Preview (9000 extended) 
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber; //Mode of preview channels, 0- 1 window, 1- 4 windows, 2- 9 windows, 3- 16 windows, 0xff:  largest
    BYTE byEnableAudio; //Preview audio, 0- No, 1- Yes
    WORD wSwitchTime; //duration to switch, 0- disable, 1- 5s, 2- 10s, 3- 20s, 4- 30s, 5- 60s, 6- 120s, 7- 300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30]; //Order to switch,  lSwitchSeq[i]==0xff- not used
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30, *LPNET_DVR_PREVIEWCFG_V30;
//DVR Local Preview 
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber; //Number of preview channels, 0- 1 window, 1- 4 windows, 2- 9 windows, 3- 16 windows, 0xff:  largest
    BYTE byEnableAudio; //Preview audio, 0- No, 1- Yes
    WORD wSwitchTime; //duration to switch, 0- disable, 1- 5s, 2- 10s, 3- 20s, 4- 30s, 5- 60s, 6- 120s, 7- 300s
    BYTE bySwitchSeq[MAX_WINDOW]; //Order to switch,  lSwitchSeq[i] 0xff- not used
}NET_DVR_PREVIEWCFG, *LPNET_DVR_PREVIEWCFG;

//DVR video output
typedef struct
{
    WORD wResolution;                                 /* Resolution */
    WORD wFreq;                                     /* Refresh rate */
    DWORD dwBrightness;                             /* Brightness */
}NET_DVR_VGAPARA;

/*
* MATRIX Output Configuration
*/
typedef struct
{
    WORD    wOrder[MAX_ANALOG_CHANNUM];         /* Preview order,  0xff means this channel is disabled */
    WORD    wSwitchTime;                         /* Time to witch */
    BYTE    res[14];
}NET_DVR_MATRIXPARA_V30, *LPNET_DVR_MATRIXPARA_V30;

typedef struct
{
    WORD wDisplayLogo;                         /* Display Channel No. */
    WORD wDisplayOsd;                         /* Display Time */
}NET_DVR_MATRIXPARA;

typedef struct
{
    BYTE byVideoFormat;                     /* Video Standard, 0- PAL, 1- NTSC */
    BYTE byMenuAlphaValue;                     /* the contrast between Menu and background image */
    WORD wScreenSaveTime;                     /* Screen Saver 0- Never, 1- 1Min, 2- 2Min, 3- 5Min, 4- 10Min, 5- 20Min, 6- 30Min */
    WORD wVOffset;                             /* Offset of video output */
    WORD wBrightness;                         /* Brightness*/
    BYTE byStartMode;                         /* Video output mode (0: Menu, 1: Preview) */
    BYTE byEnableScaler;                    /* Enable Scale  (0- Disable,  1- Enable) */
}NET_DVR_VOOUT;

//DVR Video output  (9000 extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];                     /* VGA Parameter */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];         /* MATRIX Parameter */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30, *LPNET_DVR_VIDEOOUT_V30;

//DVR Video Output
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];     /* VGA Parameter */
    NET_DVR_MATRIXPARA struMatrixPara;         /* MATRIX Parameter */
}NET_DVR_VIDEOOUT, *LPNET_DVR_VIDEOOUT;



//Single User Parameters (Sub Struct)  (256NVR  extended) 
typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    BYTE byLocalRight[MAX_RIGHT];     /* Local privilege */
    /*
    array 0:  local PTZ control
    array 1:  local manual record
    array 2:  local playback
    array 3:  local configuration
    array 4:  local log & status query
    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  local parameter check
    array 7:  local analog & IP camera management
    array 8:  local backup
    array 9:  local shut down/reboot
    */

    BYTE byRemoteRight[MAX_RIGHT]; /* remote privilege settings */
    /*
    array 0:  remote PTZ control
    array 1:  remote manual record
    array 2:  remote playback
    array 3:  remote configuration
    array 4:  remote log & status query
    array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  remote start voice talk
    array 7:  remote preview
    array 8: remote alarm upload to center,  alarm output
    array 9: remote control local output
    array 10: remote serial port control
    array 11:  remote parameter query
    array 12:  remote analog & IP camera management
    array 13:  remote shut down/reboot
    */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* remote preview channel No., Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* local record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* remote record channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* local playback channel ,Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* remote record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* local PTZ channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* remote PTZ channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* local backup channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    NET_DVR_IPADDR struUserIP;         /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
    BYTE byPriority;                 /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
    Low-Default privileges including local/remote playback,  log & status query,  reboot/shut down.
    Mid-Include local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
    High-Administrator
    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes1[2];
    BYTE    byPublishRight[MAX_RIGHT];  //Information release proprietary rights
    /*An array of 0: material audit jurisdiction*/
    /*An array of 1: program audit authority*/
    /*An array of 2: schedule audit jurisdiction*/
    /*Array 3: upload material privileges*/
    /*An array of 4: new program permissions*/
    /*An array of 5: new schedule*/
    /*An array of 6: information broadcast rights*/
    /*An array of 7: terminal management authority*/
    /*An array of 8: business intelligence*/
    BYTE    byRes[84];
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;

typedef struct tagNET_DVR_USER_INFO_V51
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    BYTE byLocalRight[MAX_RIGHT];     /* Local privilege */
    /*
    array 0:  local PTZ control
    array 1:  local manual record
    array 2:  local playback
    array 3:  local configuration
    array 4:  local log & status query
    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  local parameter check
    array 7:  local analog & IP camera management
    array 8:  local backup
    array 9:  local shut down/reboot
    array 10:  local preview
    */

    BYTE byRemoteRight[MAX_RIGHT]; /* remote privilege settings */
    /*
    array 0:  remote PTZ control
    array 1:  remote manual record
    array 2:  remote playback
    array 3:  remote configuration
    array 4:  remote log & status query
    array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  remote start voice talk
    array 7:  remote preview
    array 8: remote alarm upload to center,  alarm output
    array 9: remote control local output
    array 10: remote serial port control
    array 11:  remote parameter query
    array 12:  remote analog & IP camera management
    array 13:  remote shut down/reboot
    */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* remote preview channel No., Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* local record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* remote record channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* local playback channel ,Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* remote record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* local PTZ channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* remote PTZ channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* local backup channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* local preview channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    NET_DVR_IPADDR struUserIP;         /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
    BYTE byPriority;                 /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
    Low-Default privileges including local/remote playback,  log & status query,  reboot/shut down.
    Mid-Include local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
    High-Administrator
    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes1[2];
    BYTE    byPublishRight[MAX_RIGHT];  //Information release proprietary rights
    /*An array of 0: material audit jurisdiction*/
    /*An array of 1: program audit authority*/
    /*An array of 2: schedule audit jurisdiction*/
    /*Array 3: upload material privileges*/
    /*An array of 4: new program permissions*/
    /*An array of 5: new schedule*/
    /*An array of 6: information broadcast rights*/
    /*An array of 7: terminal management authority*/
    /*An array of 8: business intelligence*/
    DWORD    dwPasswordValidity;   //Password validity, only the administrator user can modify, unit: day, fill in 0 means permanent effective
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //keypad password
    BYTE    byUserOperateType;    //user operate type:1-network user,2-keypad user,3-network user+keypad user
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V51, *LPNET_DVR_USER_INFO_V51;

typedef struct  tagNET_DVR_USER_V51
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V51 struUser[MAX_USERNUM_V30];
    char    sloginPassword[PASSWD_LEN/*16*/];
    BYTE     byRes[240];
}NET_DVR_USER_V51, *LPNET_DVR_USER_V51;

typedef struct tagNET_DVR_USER_INFO_V52
{
    BYTE    sUserName[NAME_LEN/*32*/];            /* Username */
    BYTE    sPassword[PASSWD_LEN/*16*/];            /* Password */
    BYTE    byLocalRight[MAX_RIGHT/*32*/];    /* Local privilege */
    /*
    array 0:  local PTZ control
    array 1:  local manual record
    array 2:  local playback
    array 3:  local configuration
    array 4:  local log & status query
    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  local parameter check
    array 7:  local analog & IP camera management
    array 8:  local backup
    array 9:  local shut down/reboot
    array 10:  local preview
    */
    BYTE    byRemoteRight[MAX_RIGHT/*32*/];/* remote privilege settings */
    /*
    array 0:  remote PTZ control
    array 1:  remote manual record
    array 2:  remote playback
    array 3:  remote configuration
    array 4:  remote log & status query
    array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  remote start voice talk
    array 7:  remote preview
    array 8: remote alarm upload to center,  alarm output
    array 9: remote control local output
    array 10: remote serial port control
    array 11:  remote parameter query
    array 12:  remote analog & IP camera management
    array 13:  remote shut down/reboot
    */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* remote preview channel No., Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* local record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* remote record channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* local playback channel ,Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* remote record channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* local PTZ channel ,  Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* remote PTZ channel , Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* local backup channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* local preview channel, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* local double verification playback, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwLocalDoubleVerificationBackupRight[MAX_CHANNUM_V40/*512*/];            /* local double verification backup, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    DWORD    dwNetDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* remote double verification playback, Front to back order, met 0xFFFFFFFF follow-up are invalid*/
    NET_DVR_IPADDR    struUserIP;                /* User IP  (0 stands for no IP restriction)  */
    BYTE     byMACAddr[MACADDR_LEN/*6*/];    /* MAC */
    BYTE     byPriority;                /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
    Low-Default privileges including local/remote playback,  log & status query,  reboot/shut down.
    Mid-Include local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
    High-Administrator
    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes1[2];
    BYTE    byPublishRight[MAX_RIGHT];  //Information release proprietary rights
    /*An array of 0: material audit jurisdiction*/
    /*An array of 1: program audit authority*/
    /*An array of 2: schedule audit jurisdiction*/
    /*Array 3: upload material privileges*/
    /*An array of 4: new program permissions*/
    /*An array of 5: new schedule*/
    /*An array of 6: information broadcast rights*/
    /*An array of 7: terminal management authority*/
    /*An array of 8: business intelligence*/
    DWORD    dwPasswordValidity;   //Password validity, only the administrator user can modify, unit: day, fill in 0 means permanent effective
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //keypad password
    BYTE    byUserOperateType;    //user operate type:1-network user,2-keypad user,3-network user+keypad user
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V52, *LPNET_DVR_USER_INFO_V52;

typedef struct  tagNET_DVR_USER_V52
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V52 struUser[MAX_USERNUM_V30/*32*/];
    char    sloginPassword[PASSWD_LEN/*16*/];
    BYTE     byRes[240];
}NET_DVR_USER_V52, *LPNET_DVR_USER_V52;


//Single User Parameters (Sub Struct)  (9000 extended) 
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    BYTE byLocalRight[MAX_RIGHT];     /* Local privilege */
    /*
    array 0:  local PTZ control
    array 1:  local manual record
    array 2:  local playback
    array 3:  local configuration
    array 4:  local log & status query
    array 5:  local advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  local parameter check
    array 7:  local analog & IP camera management
    array 8:  local backup
    array 9:  local shut down/reboot
    */

    BYTE byRemoteRight[MAX_RIGHT]; /* remote privilege settings */
    /*
    array 0:  remote PTZ control
    array 1:  remote manual record
    array 2:  remote playback
    array 3:  remote configuration
    array 4:  remote log & status query
    array 5:  remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6:  remote start voice talk
    array 7:  remote preview
    array 8: remote alarm upload to center,  alarm output
    array 9: remote control local output
    array 10: remote serial port control
    array 11:  remote parameter query
    array 12:  remote analog & IP camera management
    array 13:  remote shut down/reboot
    */
    BYTE byNetPreviewRight[MAX_CHANNUM_V30];         /* remote preview channel ,  0- enable,  1- disable*/
    BYTE byLocalPlaybackRight[MAX_CHANNUM_V30];         /* local playback channel ,  0- enable,  1- disable*/
    BYTE byNetPlaybackRight[MAX_CHANNUM_V30];         /* remote playback channel ,  0- enable,  1- disable*/
    BYTE byLocalRecordRight[MAX_CHANNUM_V30];         /* local record channel ,  0- enable,  1- disable*/
    BYTE byNetRecordRight[MAX_CHANNUM_V30];         /* remote record channel ,  0- enable,  1- disable*/
    BYTE byLocalPTZRight[MAX_CHANNUM_V30];         /* local PTZ channel ,  0- enable,  1- disable*/
    BYTE byNetPTZRight[MAX_CHANNUM_V30];             /* remote PTZ channel ,  0- enable,  1- disable*/
    BYTE byLocalBackupRight[MAX_CHANNUM_V30];         /* local backup channel ,  0- enable,  1- disable*/
    NET_DVR_IPADDR struUserIP;         /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
    BYTE byPriority;                 /* Priority settings ,  0xff-  disable ,  0- low,  1- Mid,  2- High */
    /*
    Low-Default privileges including local/remote playback,  log & status query,  reboot/shut down.
    Mid-Include local/remote PTZ control,  manual record,  voice talk,  playback,  log & status query,  reboot/shut down,  log backup and remote preview.
    High-Administrator
    */
    BYTE    byAlarmOnRight;         // Alarm In guard privileges
    BYTE    byAlarmOffRight;        // Alarm In unguard privileges
    BYTE    byBypassRight;          // Alarm In bypass privileges
    BYTE    byRes[14];
}NET_DVR_USER_INFO_V30, *LPNET_DVR_USER_INFO_V30;

//Single User Parameters (SDK_V15extended)  (Sub Structure) 
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    DWORD dwLocalRight[MAX_RIGHT];     /* privilege */
    /*
    array 0- local PTZ control
    array 1- local manual record
    array 2- local playback
    array 3- local configuration
    array 4- local log & status query
    array 5- local advanced settings  (upgrade,  format,  reboot,  shut down)
    */
    DWORD dwLocalPlaybackRight;         /*  local playback channel. 1 bit0 - -  channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];     /* privilege */
    /*
    array 0- remote  PTZ control
    array 1- remote manual record
    array 2- remote playback
    array 3- remote configuration
    array 4- remote log & status query
    array 5- remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6- remote start voice talk
    array 7- remote preview
    array 8- remote alarm upload to center,  alarm output
    array 9- remote control local output
    array 10- remote serial port control
    */
    DWORD dwNetPreviewRight;         /* remote preview channel number,  bit0 - -  channel 1*/
    DWORD dwNetPlaybackRight;         /* remote playback channel number,  bit0 - -  channel 1*/
    char sUserIP[16];                 /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
}NET_DVR_USER_INFO_EX, *LPNET_DVR_USER_INFO_EX;

//Single User Parameters (Sub Structure) 
typedef struct
{
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];     /* Password */
    DWORD dwLocalRight[MAX_RIGHT];     /* privilege */
    /*
    array 0- local PTZ control
    array 1- local manual record
    array 2- local playback
    array 3- local configuration
    array 4- local log & status query
    array 5- local advanced settings  (upgrade,  format,  reboot,  shut down)
    */
    DWORD dwRemoteRight[MAX_RIGHT]; /* privilege */
    /*
    array 0- remote  PTZ control
    array 1- remote manual record
    array 2- remote playback
    array 3- remote configuration
    array 4- remote log & status query
    array 5- remote advanced settings  (upgrade,  format,  reboot,  shut down)
    array 6- remote start voice talk
    array 7- remote preview
    array 8- remote alarm upload to center,  alarm output
    array 9- remote control local output
    array 10- remote serial port control
    */
    char sUserIP[16];                 /* User IP  (0 stands for no IP restriction)  */
    BYTE byMACAddr[MACADDR_LEN];     /* MAC */
}NET_DVR_USER_INFO, *LPNET_DVR_USER_INFO;


//DVR User Parameters (256 NVR extended)
typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V40, *LPNET_DVR_USER_V40;
typedef struct  tagNET_DVR_USER_V50
{
    DWORD dwSize;
    DWORD dwMaxUserNum;
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];
    char    sloginPassword[PASSWD_LEN/*16*/];
    BYTE     byRes[240];
}NET_DVR_USER_V50, *LPNET_DVR_USER_V50;
//DVR User Parameters (9000extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_V30 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V30, *LPNET_DVR_USER_V30;

//DVR User Parameters (SDK_V15extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX, *LPNET_DVR_USER_EX;

//DVR User Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER, *LPNET_DVR_USER;

//DVR Exception Parameters (256NVR extended)
typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize;
    DWORD             dwMaxGroupNum;
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];
    BYTE                byRes[128];
}NET_DVR_EXCEPTION_V40, *LPNET_DVR_EXCEPTION_V40;

//DVR Exception Parameters (9000extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*array 0-  hard disk is full,  1-  hard disk error,  2-  signal lost,  3-  network link is broken,  4- illegal access,  5-  input/output video standard not match,  6- overspeed Car (for mobile DVR) ,  7- record exception 8-raid exception 9-resolusion mismatch 10-speed exceed 11-spare exception\
    12-temperature abnormal, 13-subsystem abnormal, 14-fan abnormal, , 15-POE Power Exception,17-Abnormal Voltage Fluctuation of Power Supply  18-PTLocking*/
}NET_DVR_EXCEPTION_V30, *LPNET_DVR_EXCEPTION_V30;

//DVR Exception Parameters
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*array 0-  hard disk is full,  1-  hard disk error,  2-  signal lost,  3-  network link is broken,  4- illegal access,  5-  input/output video standard not match,  6- overspeed Car (for mobile DVR) */
}NET_DVR_EXCEPTION, *LPNET_DVR_EXCEPTION;

//Channel State (9000 extended) 
typedef struct
{
    BYTE byRecordStatic;  //whether the channel is in recording,  0-  no,  1-  yes
    BYTE bySignalStatic;  //video signal status,  0-  normal,  1-  lost
    BYTE byHardwareStatic; //the channel hardware status,  0-  normal,  1-  abnormal,  e.g. DSP is not work
    BYTE byRes1;         //Reserved
    DWORD dwBitRate;     //actual bit rate
    DWORD dwLinkNum;     //connected client number
    NET_DVR_IPADDR struClientIP[MAX_LINK]; //client IP referred to NET_DVR_IPADDR
    DWORD dwIPLinkNum; //if the current channel is set as IPC channel,  then this parameter represents the current connected IP channel number.
    BYTE byExceedMaxLink;   // 0-less than 6 link, 1 more than 6 link
    BYTE byRes[3];
    DWORD dwAllBitRate;      //All Bit Rate
    DWORD dwChannelNo;    //cur chanNo, 0xffffffff  is  invalid
}NET_DVR_CHANNELSTATE_V30, *LPNET_DVR_CHANNELSTATE_V30;

//Channel State
typedef struct
{
    BYTE byRecordStatic;        //Whether the channel is in recording,  0-  no,  1-  yes
    BYTE bySignalStatic;        //Video signal status,  0-  normal,  1-  lost
    BYTE byHardwareStatic;      //The channel hardware status,  0-  normal,  1-  abnormal,  e.g. DSP is not work
    char reservedData;             //Reserved
    DWORD dwBitRate;             //Actual bit rate
    DWORD dwLinkNum;             //Connected client number
    DWORD dwClientIP[MAX_LINK]; //Client IP
}NET_DVR_CHANNELSTATE, *LPNET_DVR_CHANNELSTATE;

//Hard Disk Status
typedef struct
{
    DWORD dwVolume; //Capacity
    DWORD dwFreeSpace; //Free Space
    DWORD dwHardDiskStatic;  //HD status: 0- active; 1- sleep mode; 2- abnormal;  3-  sleep mode error, 4-not format, 5- can't connect(net disk) 6- being formating.,7-Hard disk is full(when unopened loop coverage),8-other exception
}NET_DVR_DISKSTATE, *LPNET_DVR_DISKSTATE;

//DVR Work State (256 NVR extended)
typedef struct tagNET_DVR_WORKSTATE_V40
{
    DWORD   dwSize;
    DWORD   dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//chan Status
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/];
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/];
    DWORD   dwLocalDisplay;         //Local display status,  0-  normal,  1- abnormal
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];//Audio channel status,  0- unused;  1- on using; 0xff- invalid
    BYTE    byRes1[2];
    float    fHumidity;    //0.0 ~ 100.0
    float    fTemperature;    //-20.0 ~ 90.0
    BYTE    byRes[116];
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40;


typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize;
    BYTE    byFindHardByCond; /*0-find all Hard */
    BYTE    byFindChanByCond;  /*0-find All Chan,and The dwFindChanNum is invalid, else The dwFindChanNum is valid*/
    BYTE    byRes1[2];
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/]; /*To find the hard disk No. , according to the values, the values of the order, met 0xFFFFFFFF that subsequent invalid */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/]; /*To find the Chan No. ,according to the values,,according to the values, the values of the order, met 0xFFFFFFFF that subsequent invalid */
    BYTE     byRes[64];
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

//DVR Work State (9000 extended) 
typedef struct
{
    DWORD dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //channel status  as NET_DVR_CHANNELSTATE
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //alarm input status,  0-  no alarm,  1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30];  //alarm output status,  0- no output,  1- alarm output
    DWORD  dwLocalDisplay; //Local display status,  0-  normal,  1- abnormal
    BYTE  byAudioChanStatus[MAX_AUDIO_V30]; //Audio channel status,  0- unused;  1- on using; 0xff- invalid
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30, *LPNET_DVR_WORKSTATE_V30;

//DVR Status Structure 
typedef struct
{
    DWORD dwDeviceStatic;      //the device's status,  0-  normal,  1-  the occupancy of CPU is too high,  more than 85%,  2- hardware error,  e.g. the serial ports do not work
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM]; //channel status  as NET_DVR_CHANNELSTATE
    BYTE  byAlarmInStatic[MAX_ALARMIN];             //alarm input status,  0-  no alarm,  1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT];         //alarm output status,  0- no output,  1- alarm output
    DWORD  dwLocalDisplay;                         //Local display status,  0-  normal,  1- abnormal
}NET_DVR_WORKSTATE, *LPNET_DVR_WORKSTATE;



/************************ Alarm-host log searching begin************************************************/
typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;        // Major type
    WORD            wMinorType;        // Minor type 
    NET_DVR_TIME    struStartTime;    // Start time 
    NET_DVR_TIME    struEndTime;    // End time
    BYTE            byRes[8];        // Reserved
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME    struLogTime;                // Log time
    BYTE            sUserName[NAME_LEN];        // Operator user
    NET_DVR_IPADDR    struIPAddr;                 // Operator IP address
    WORD            wMajorType;                 // Major type 
    WORD            wMinorType;                 // Minor type
    WORD            wParam;                        // Operation parameter
    BYTE            byRes[10];
    DWORD            dwInfoLen;                    // Length of description information
    char            sInfo[LOG_INFO_LEN];        // Description information
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

/************************* Alarm-host log searching end***********************************************/

//Alarm output state (9000 extended) 
typedef struct
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30, *LPNET_DVR_ALARMOUTSTATUS_V30;

//Alarm output state
typedef struct
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS, *LPNET_DVR_ALARMOUTSTATUS;

//Transaction Info
typedef struct
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];     //Device name
    DWORD dwChannelNumer;     //Channel name
    BYTE CardNumber[32];     //Credit Card No.
    char cTradeType[12];     //Transaction type    
    DWORD dwCash;             //Transaction money 
}NET_DVR_TRADEINFO, *LPNET_DVR_TRADEINFO;


//Special for ATM
/****************************ATM (begin) ***************************/
#define NCR                0
#define DIEBOLD            1
#define WINCOR_NIXDORF    2
#define SIEMENS            3
#define OLIVETTI        4
#define FUJITSU            5
#define HITACHI            6
#define SMI                7
#define IBM                8
#define BULL            9
#define YiHua            10
#define LiDe            11
#define GDYT            12
#define Mini_Banl        13
#define GuangLi            14
#define DongXin            15
#define ChenTong        16
#define NanTian            17
#define XiaoXing        18
#define GZYY            19
#define QHTLT            20
#define DRS918            21
#define KALATEL            22
#define NCR_2            23    
#define NXS                24


/*Frame Type*/
typedef struct
{
    BYTE code[12];         /* code */
}NET_DVR_FRAMETYPECODE;

//ATM Parameters
typedef struct
{
    DWORD dwSize;
    char sATMIP[16];                             /* ATM IP */
    DWORD dwATMType;                             /* ATM Type*/
    DWORD    dwInputMode;                         /* 0-  network listening 1- network receive; 2-directly input via serial port; 3-input ATM command via serial port*/
    DWORD    dwFrameSignBeginPos;                 /* the start position of Message flag*/
    DWORD    dwFrameSignLength;                     /* the length of Message flag */
    BYTE    byFrameSignContent[12];             /* the content of Message flag */
    DWORD    dwCardLengthInfoBeginPos;             /* offset of credit card No. length information */
    DWORD    dwCardLengthInfoLength;             /* the length of the card length information */
    DWORD    dwCardNumberInfoBeginPos;             /* Start position of the card number information */
    DWORD    dwCardNumberInfoLength;             /* Length of the card number information */
    DWORD    dwBusinessTypeBeginPos;             /* the offset of operation type information */
    DWORD    dwBusinessTypeLength;                 /* the length of the operation type */
    NET_DVR_FRAMETYPECODE    frameTypeCode[10];     /* type */
}NET_DVR_FRAMEFORMAT, *LPNET_DVR_FRAMEFORMAT;

typedef struct
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struATMIP;                   
    DWORD    dwATMType;                          
    DWORD    dwInputMode;                     
    DWORD    dwFrameSignBeginPos;             
    DWORD    dwFrameSignLength;                
    BYTE     byFrameSignContent[12];         
    DWORD    dwCardLengthInfoBeginPos;           
    DWORD    dwCardLengthInfoLength;        
    DWORD    dwCardNumberInfoBeginPos;            
    DWORD    dwCardNumberInfoLength;              
    DWORD    dwBusinessTypeBeginPos;        
    DWORD    dwBusinessTypeLength;         
    NET_DVR_FRAMETYPECODE    frameTypeCode[10];   
    WORD     wATMPort;                    
    WORD     wProtocolType;                      
    BYTE     byRes[24];
}NET_DVR_FRAMEFORMAT_V30, *LPNET_DVR_FRAMEFORMAT_V30;

//SDK_V31 ATM
/*1.1.1.18    Structure of package filter*/
typedef struct    tagNET_DVR_FILTER
{
    BYTE                    byEnable;             //0,  disable;  1,  enable
    BYTE                    byMode;             //0, ASCII; 1, HEX    
    BYTE                    byFrameBeginPos;    //begin position of target text  
    BYTE                    byRes;           //Reserved
    BYTE                     byFilterText[16];     //filter text
    BYTE                    byRes2[12];         //Reserved
}NET_DVR_FILTER, *LPNET_DVR_FILTER;

//Package structure of starting flag
typedef struct    tagNET_DVR_IDENTIFICAT
{
    BYTE                    byStartMode;         //start mode: 0, ASCII; 1, HEX
    BYTE                    byEndMode;             //end mode:  0, ASCII; 1, HEX
    BYTE                    byRes[2];           //Reserved
    NET_DVR_FRAMETYPECODE    struStartCode;         //start code
    NET_DVR_FRAMETYPECODE    struEndCode;         //end code
    BYTE                    byRes1[12];         //Reserved
}NET_DVR_IDENTIFICAT, *LPNET_DVR_IDENTIFICAT;

typedef struct    tagNET_DVR_PACKAGE_LOCATION/* package information position*/
{
    BYTE                     byOffsetMode;             /* 0, token (character flag mode) ; 1, fix (fix mode) */
    BYTE                    byRes1[3];                 // Reserved
    DWORD                      dwOffsetPos;             /*Used when mode is 1,  offset size*/
    NET_DVR_FRAMETYPECODE    struTokenCode;             /*Flag bit*/
    BYTE                    byMultiplierValue;         /*number of Flags*/
    BYTE                    byEternOffset;             /*extern offset*/
    BYTE                    byCodeMode;             /*0, ASCII; 1, HEX*/
    BYTE                     byRes2[9];                 //Reserved
}NET_DVR_PACKAGE_LOCATION, *LPNET_DVR_PACKAGE_LOCATION;


typedef struct    tagNET_DVR_PACKAGE_LENGTH//package length
{
    BYTE                    byLengthMode;             //length mode:  0,  variable;  1,  fixed ; 2, gotten from package (Used when setting the card number length ) 
    BYTE                    byRes1[3];              // Reserved
    DWORD                      dwFixLength;             //Used when mode is 1,  fixed length
    DWORD                    dwMaxLength;            //Maximum length  byLengthMode is 0 
    DWORD                    dwMinLength;            //Minimum length  byLengthMode is 0
    BYTE                    byEndMode;                 //Terminator:  0, ASCII; 1, HEX    
    BYTE                    byRes2[3];              //Reserved
    NET_DVR_FRAMETYPECODE    struEndCode;             //Terminator with variable length
    DWORD                    dwLengthPos;             //Used when length mode is 2,  card length position in the package
    DWORD                    dwLengthLen;             //Used when length mode is 2,  length of the card number length
    BYTE                    byRes3[8];              // Reserved
}NET_DVR_PACKAGE_LENGTH, *LPNET_DVR_PACKAGE_LENGTH;

typedef struct    tagNET_DVR_OSD_POSITION//OSD overlay position
{
    BYTE                    byPositionMode;         //Mode,  0:  not display,  1: Custom
    BYTE                    byRes1[3];              // Reserved
    DWORD                     dwPosX;                 //X- coordinator,  used when position mode is custom
    DWORD                    dwPosY;                 //Y- coordinator,  used when position mode is custom
    BYTE                    byRes2[8];              //Reserved
}NET_DVR_OSD_POSITION, *LPNET_DVR_OSD_POSITION;

typedef struct    tagNET_DVR_DATE_FORMAT//date display format
{
    BYTE                    byMonth;                 //Month, 0-mm; 1-mmm; 2-mmmm                            
    BYTE                     byDay;                     //Day, 0-dd;                                     
    BYTE                     byYear;                 //Year, 0-yy; 1-yyyy    
    BYTE                    byDateForm;             //0-5,  permutations and combinations of year, month, day
    BYTE                    byRes[20];              // Reserved
    char                    chSeprator[4];             //separator
    char                    chDisplaySeprator[4];     //display separator
    BYTE                    byDisplayForm;             //0-5, permutations and combinations of 3 items
    BYTE                    res[27];                // Reserved
}NET_DVR_DATE_FORMAT, *LPNET_DVR_DATE_FORMAT;
typedef struct    tagNET_DVRT_TIME_FORMAT//time display format
{
    BYTE                    byTimeForm;             //1. HH MM SS; 0. HH MM
    BYTE                     byRes1[23];             // Reserved
    BYTE                    byHourMode;             //0, 12; 1, 24 
    BYTE                    byRes2[3];              // Reserved
    char                    chSeprator[4];          //package separator,  reserved
    char                    chDisplaySeprator[4];     //display separator
    BYTE                    byDisplayForm;             //0~5,  permutations and combinations  of 3 items
    BYTE                    byRes3[3];              // Reserved
    BYTE                    byDisplayHourMode;         //0-12;  1- 24 
    BYTE                    byRes4[19];             // Reserved
}NET_DVR_TIME_FORMAT, *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{
    BYTE                    byChannel[64]; //overlay channel,  Set 1 to display,  set 0 to hide
    DWORD                    dwDelayTime;             //overlay delay time
    BYTE                    byEnableDelayTime;         //enable or disable. Overlay delay is enabled,  in the absence of withdrawal card command 
    BYTE                    byRes[11];           // Reserved
}NET_DVR_OVERLAY_CHANNEL, *LPNET_DVR_OVERLAY_CHANNEL;

// Structure of Trading action
typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; // location of package
    NET_DVR_OSD_POSITION        struOsdPosition;     // OSD overlay position
    NET_DVR_FRAMETYPECODE        struActionCode;         //codes of trading type
    NET_DVR_FRAMETYPECODE        struPreCode;         //character before overlaying
    BYTE                    byActionCodeMode;         //codes of trading type. 0, ASCII; 1, HEX
    BYTE                    byRes[7];                // Reserved
}NET_DVR_ATM_PACKAGE_ACTION, *LPNET_DVR_ATM_PACKAGE_ACTION;

//  Date info of ATM package
typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; // Position of date
    NET_DVR_DATE_FORMAT            struDateForm;         //date display mode
    NET_DVR_OSD_POSITION        struOsdPosition;     // OSD overly position
    BYTE                        res[8];              // Reserved
}NET_DVR_ATM_PACKAGE_DATE, *LPNET_DVR_ATM_PACKAGE_DATE;


//Time info of ATM package
typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{
    NET_DVR_PACKAGE_LOCATION    location;         // Position of time
    NET_DVR_TIME_FORMAT            struTimeForm;     //display mode
    NET_DVR_OSD_POSITION        struOsdPosition; // OSD overly position
    BYTE                        byRes[8];         // Reserved
}NET_DVR_ATM_PACKAGE_TIME, *LPNET_DVR_ATM_PACKAGE_TIME;


//other info of  ATM package (Card SN.,  Transaction amount,  Transaction SN.) 
typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;  //Position info
    NET_DVR_PACKAGE_LENGTH    struPackageLength;         //length Info
    NET_DVR_OSD_POSITION        struOsdPosition;     //overlay position
    NET_DVR_FRAMETYPECODE        struPreCode;         //character before overlaying
    BYTE                    res[8];                     //Reserved
}NET_DVR_ATM_PACKAGE_OTHERS, *LPNET_DVR_ATM_PACKAGE_OTHERS;


//User- defined Protocol
typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;   //Package Flag
    NET_DVR_FILTER             struFilter;  //Filter settings
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara;  // Settings of overlay card number 
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE];  //Settings of overlay trade action, 0- 9: InCard,  OutCard,  OverLay,  SetTime,  GetStatus,  Query,  WithDraw,  Deposit,  ChanPass,  Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara;  //Settings of overlay Transaction amount
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara;  //Settings of overlay trade SN
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan;  //Settings of overlay channel
    NET_DVR_ATM_PACKAGE_DATE   struRes1;  //Settings of overlay data,  reserved
    NET_DVR_ATM_PACKAGE_TIME   struRes2;  //Settings of overlay time,  reserved
    BYTE                       byRes3[124];         //Reserved
}NET_DVR_ATM_USER_DEFINE_PROTOCOL, *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{
    DWORD                        dwSize;                 //structure size
    BYTE                        byEnable;                 /*0:  Enable,  1:  Disable*/
    BYTE                        byInputMode;             /*Input mode:  0- Network Listen,  1- Network Protocol,  2- Serial Listen,  3- Serial Protocol*/
    BYTE                        byRes1[34];              //Reserved 
    NET_DVR_IPADDR                struAtmIp;                 /*ATM IP,  used in network listen mode */
    WORD                        wAtmPort;                 /* Get port by card number,  Network Protocol mode or Serial server port mode*/
    BYTE                        byRes2[2];               // Reserved
    DWORD                        dwAtmType;                 /*ATM protocol type,  get from NET_DVR_ATM_PROTOCOL,  using user- defined protocol when the type is user_defined*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol;  //User- defined protocol,  using this definition when the ATM protocol is user- defined.
    BYTE                        byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30, *LPNET_DVR_ATM_FRAMEFORMAT_V30;

//ATM protocol type
typedef enum _ATM_PROTO_TYPE_
{
    ATM_PROTO_NCR = 0,//NCR
    ATM_PROTO_DIEBOLD = 1,//DIEBOLD
    ATM_PROTO_WINCOR_NIXDORF = 2,//WINCOR-NIXDORF
    ATM_PROTO_SIEMENS = 4,//SIEMENS
    ATM_PROTO_OLIVETTI = 5,//OLIVETTI
    ATM_PROTO_FUJITSU = 6,//FUJITSU
    ATM_PROTO_HITACHI = 7,//HITACHI
    ATM_PROTO_SMI = 8,//SMI
    ATM_PROTO_BULL = 9,//BULL
    ATM_PROTO_YIHUA = 10,//YIHUA
    ATM_PROTO_LIDE = 11,//LIDE
    ATM_PROTO_GDYT = 12,//GDYT
    ATM_PROTO_MINI_BANL = 13,//Mini-Banl
    ATM_PROTO_GUANGLI = 14,//GUANGLI
    ATM_PROTO_DONGXIN = 15,//DONGXIN
    ATM_PROTO_CHENTONG = 16,//CHENTONG
    ATM_PROTO_NANTIAN = 17,//NANTIAN
    ATM_PROTO_XIAOXING = 18,//XIAOXING
    ATM_PROTO_GZYY = 19,//GZYY
    ATM_PROTO_QHTLT = 20,//QHTLT
    ATM_PROTO_DRS918 = 21,//DRS918 
    ATM_PROTO_KALATEL = 22,//KALATEL 
    ATM_PROTO_NCR_2 = 23,//NCR_2
    ATM_PROTO_NXS = 24,//NXS
    ATM_PROTO_ICBC = 25,//ICBC
    ATM_PROTO_PSBC = 26,//PSBC
    ATM_PROTO_CUSTOM = 1025//CUSTOM
}ATM_PROTO_TYPE;

typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType;  //ATM protocol type,  index SN,  and 1025 is for user- defined.
    char chDesc[ATM_DESC_LEN];  //Simple description of ATM protocol
}NET_DVR_ATM_PROTO_TYPE, *LPNET_DVR_ATM_PROTO_TYPE;  //Data structure of protocol information

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM Protocol List
{
    DWORD                  dwAtmProtoNum;    // Number of protocol 
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM];  //protocol list info
}NET_DVR_ATM_PROTO_LIST, *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList;  // Description of Network Listen protocol
    NET_DVR_ATM_PROTO_LIST struSerialListenList;  //Description of Serial Listen protocol
    NET_DVR_ATM_PROTO_LIST struNetProtoList;      //Description of Network protocol
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;    //Description of Serial Protocol
    NET_DVR_ATM_PROTO_TYPE struCustomProto;         //User- defined protocol
}NET_DVR_ATM_PROTOCOL, *LPNET_DVR_ATM_PROTOCOL;
//SDK_V31

/*****************************DS- 6001D/F (begin) ***************************/
//DS- 6001D Decoder
typedef struct
{
    BYTE byEncoderIP[16];         //Server IP that decoder connected
    BYTE byEncoderUser[16];         //Server Username that decoder connected
    BYTE byEncoderPasswd[16];     //Server Password that decoder connected
    BYTE bySendMode;             //Server Connection Mode that decoder connected
    BYTE byEncoderChannel;         //Server Channel No. that decoder connected
    WORD wEncoderPort;             //Server Port that decoder connected
    BYTE reservedData[4];         //Reserved
}NET_DVR_DECODERINFO, *LPNET_DVR_DECODERINFO;

typedef struct
{
    BYTE byEncoderIP[16];         //Server IP that decoder connected
    BYTE byEncoderUser[16];         //Server Username that decoder connected
    BYTE byEncoderPasswd[16];     //Server Password that decoder connected
    BYTE byEncoderChannel;         //Server Channel No. that decoder connected
    BYTE bySendMode;             //Server Connection Mode that decoder connected
    WORD wEncoderPort;             //Server Port that decoder connected
    DWORD dwConnectState;         //Server State that decoder connected
    BYTE reservedData[4];         //Reserved
}NET_DVR_DECODERSTATE, *LPNET_DVR_DECODERSTATE;

/*Definition of Decoder Control Code */
#define NET_DEC_STARTDEC        1
#define NET_DEC_STOPDEC            2
#define NET_DEC_STOPCYCLE        3
#define NET_DEC_CONTINUECYCLE    4

/*Channel Connected Configuration*/
typedef struct
{
    char sDVRIP[16];                 /* DVR IP Address */
    WORD wDVRPort;                      /* Ports */
    BYTE sUserName[NAME_LEN];         /* Username */
    BYTE sPassword[PASSWD_LEN];         /* Password */
    BYTE byChannel;                     /* Channel No. */
    BYTE byLinkMode;                 /* Connection Mode */
    BYTE byLinkType;                 /* Stream for Connection  0- Main Stream 1- Sub Stream */
}NET_DVR_DECCHANINFO, *LPNET_DVR_DECCHANINFO;

/*Configuration of Each Decoding Channel*/
typedef struct
{
    BYTE    byPoolChans;             /*Switch channel number on each decoder channel,  range from 0- 4*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE    byEnablePoll;             /*enable switching or not:  0-  disable 1-  enable*/
    BYTE    byPoolTime;                 /*switching interval:  1- 10 sec;  2-  15 sec;  3-  20 sec;  4-  30 sec;   5-  45 sec;  6-  1min;  7-  2min;  8-  5min */
}NET_DVR_DECINFO, *LPNET_DVR_DECINFO;

/*Decoder Configuration*/
typedef struct
{
    DWORD    dwSize;
    DWORD    dwDecChanNum;          /*Number of decoding channels*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG, *LPNET_DVR_DECCFG;

//2005- 08- 01
/* Transparent Channel of Decoder */
typedef struct
{
    DWORD dwEnableTransPort;     /* Enable transparent channel or not:  0-  disable;  1-  enable*/
    char sDecoderIP[16];         /* DVR IP */
    WORD wDecoderPort;             /* Port number */
    WORD wDVRTransPort;             /* Configuration DVR output serial port:  1-  232;  2-  485 */
    char cReserve[4];
}NET_DVR_PORTINFO, *LPNET_DVR_PORTINFO;

typedef struct
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM];  /* Array 0- - 232;  Array 1- - 485 */
}NET_DVR_PORTCFG, *LPNET_DVR_PORTCFG;

/* Remote Playback */
typedef struct
{
    DWORD dwSize;
    char sDecoderIP[16];         /* DVR IP*/
    WORD wDecoderPort;             /* Port */
    WORD wLoadMode;                 /* Playback Mode 1- by name 2- by time */
    union
    {
        BYTE byFile[100];         /* File Name */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];     /* Username for playback*/
            BYTE sPassword[PASSWD_LEN];     /* Password */
            NET_DVR_TIME struStartTime;     /* Start time of playback by time mode*/
            NET_DVR_TIME struStopTime;     /* End time */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE, *LPNET_DVR_PLAYREMOTEFILE;

/*Decoder Channel Status Structure */
typedef struct
{
    DWORD dwWorkType;         /*Work mode:  1-  switching;  2-  dynamic connect to decoder;  3-  playback by file;  4-  playback by time*/
    char sDVRIP[16];         /*Connected device IP*/
    WORD wDVRPort;             /*Connected port number*/
    BYTE byChannel;             /*Channel number */
    BYTE byLinkMode;         /*Connection mode */
    DWORD    dwLinkType;         /*Connection stream type:  0-  main stream;  1-  sub stream*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];     /*Username*/
            BYTE sPassword[PASSWD_LEN];     /* Password */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD    dwChannel;
            BYTE    sUserName[NAME_LEN];     /*Username*/
            BYTE    sPassword[PASSWD_LEN];     /* Password */
            NET_DVR_TIME struStartTime;         /* Start position for playback by time */
            NET_DVR_TIME struStopTime;         /* End position for playback by time */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS, *LPNET_DVR_DECCHANSTATUS;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS, *LPNET_DVR_DECSTATUS;
/*****************************DS- 6001D/F (end) ***************************/

//Single Character Struct  (Sub Struct) 
typedef struct
{
    WORD wShowString;                 //enable text overlay on preview image:  0- disable;  1- enable. The display area ranges totally 704*576 ,  with single character size as 32*32
    WORD wStringSize;                 /* text length,  no more than 44 text character */
    WORD wShowStringTopLeftX;         /* top left X axis position for text overlay*/
    WORD wShowStringTopLeftY;         /* top left Y axis position for text overlay */
    char sString[44];                 /* overlay text content*/
}NET_DVR_SHOWSTRINGINFO, *LPNET_DVR_SHOWSTRINGINFO;

//Text Overlay  (9000extended) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];                 /* Content for display */
}NET_DVR_SHOWSTRING_V30, *LPNET_DVR_SHOWSTRING_V30;

//Text Overlay extended (8 lines) 
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];                 /* Content for display  */
}NET_DVR_SHOWSTRING_EX, *LPNET_DVR_SHOWSTRING_EX;

//Text Overlay 
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];                 /* Content for display  */
}NET_DVR_SHOWSTRING, *LPNET_DVR_SHOWSTRING;

/****************************DS9000 added Structure (begin) ******************************/

/*
EMAIL Parameters Struct
*/
typedef struct
{
    DWORD        dwSize;
    BYTE        sAccount[NAME_LEN];                 /* Email Account*/
    BYTE        sPassword[MAX_EMAIL_PWD_LEN];             /*Password */
    struct
    {
        BYTE    sName[NAME_LEN];                 /* sender name */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];         /* sender address */
    }struSender;
    BYTE        sSmtpServer[MAX_EMAIL_ADDR_LEN];     /* SMTP server */
    BYTE        sPop3Server[MAX_EMAIL_ADDR_LEN];     /* POP3 server */
    struct
    {
        BYTE    sName[NAME_LEN];                 /* receiver Name */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];         /* receiver address */
    }struReceiver[3];                             /* support up to 3 receivers */
    BYTE        byAttachment;                     /* with attached snapshot or not */
    BYTE        bySmtpServerVerify;                 /* Enable Email server authentication:  1- enable;  0- disable */
    BYTE        byMailInterval;                  /* mail interval 0- 2s,  1- 3s,  2- 4s. 3- 5s*/
    BYTE        byEnableSSL;                     //enable ssl
    WORD        wSmtpPort;                         //gmail default 465,  else default 25     
    BYTE        byEnableTLS;                    /*enable TLS*/
    BYTE        byStartTLS;                     /*Start TLS*/
    BYTE        byRes[72];                        /*res*/
} NET_DVR_EMAILCFG_V30, *LPNET_DVR_EMAILCFG_V30;

/*
DVR Cruise Structure
*/
typedef struct
{
    DWORD     dwSize;
    BYTE    byPresetNo[CRUISE_MAX_PRESET_NUMS];         /* Preset No. */
    BYTE     byCruiseSpeed[CRUISE_MAX_PRESET_NUMS];     /* Cruise Speed */
    WORD    wDwellTime[CRUISE_MAX_PRESET_NUMS];         /* Dwell time */
    BYTE    byEnableThisCruise;                         /* Enable this cruise */
    BYTE    res[15];
}NET_DVR_CRUISE_PARA, *LPNET_DVR_CRUISE_PARA;
/****************************DS9000 Added (end) ******************************/


//Time
typedef struct
{
    DWORD dwMonth;         //Month 0- 11 for 1- 12 month
    DWORD dwWeekNo;         //Week 0-  First Week 1- Second Week 2- Third Week 3- Fourth Week 4- last Week
    DWORD dwWeekDate;     //Day 0- Sun 1- Mon 2- Tue 3- Wed 4- Thu 5- Fri 6- Sat
    DWORD dwHour;         //begin/end hour,  begin hour ranges from 0- 23,  and end hour ranges from 1- 23
    DWORD dwMin;         //begin/stop minutes ranges from 0- 59
}NET_DVR_TIMEPOINT;

//Time Zone & DST 
typedef struct
{
    DWORD dwSize;
    DWORD dwZoneIndex; //Use cTimeDifferenceH or cTimeDifferenceM in NET_DVR_NTPPARA
    BYTE byRes1[12];             //Reserved
    DWORD dwEnableDST;         //enable DST,  0- disable;  1- enable
    BYTE byDSTBias;             //DST bias;  30min,  60min,  90min,  120min,  count with minute
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;     //DST start time
    NET_DVR_TIMEPOINT struEndPoint;         //DST stop time
}NET_DVR_ZONEANDDST, *LPNET_DVR_ZONEANDDST;



//Image Quality
typedef struct
{
    /*Note:  If encoding resolution is VGA, it supports grabbing 0=CIF,  1=QCIF,  2=D1 image.
    But if encoding resolution is 3=UXGA (1600x1200) ,  4=SVGA (800x600) ,  5=HD720p (1280x720) ,  6=VGA,  7=XVGA,  and 8=HD900p it only support grabbing image with current resolution*/
    /*
       0-CIF,           1-QCIF,           2-D1,         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720),
       6-VGA,           7-XVGA,           8-HD900p,     9-HD1080,     10-2560*1920,
       11-1600*304,     12-2048*1536,     13-2448*2048,  14-2448*1200, 15-2448*800,
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576,
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    55-3072*2048,
       64-3840*2160,     70-2560*1440,      75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       161-288*320,   162-144*176,   163-480*640,
       164-240*320,      165-120*160,       166-576*720,   167-720*1280,  168-576*960,
       180-180*240,      181-360*480,       182-540*720,    183-720*960,  184-960*1280,
       185-1080*1440     215-1080*720(occupied untested),  216-360x640(occupied untested),
       245-576*704[P]/480*704[N](occupied untested)
       500-384*288,
       0xff-Auto(Use resolution of current stream)
       */
    WORD    wPicSize;
    WORD    wPicQuality; /* 0 -  the best,  1 -  better,  2 -  average;  */
}NET_DVR_JPEGPARA, *LPNET_DVR_JPEGPARA;

//Region
typedef struct tagNET_VCA_RECT
{
    float fX;                //X axis coordinate of the upper-left,  0.000~1
    float fY;                //Y axis coordinate of the upper-left,  0.000~1
    float fWidth;            //Region width,  0.000~1
    float fHeight;           //Region height,  0.000~1
}NET_VCA_RECT, *LPNET_VCA_RECT;

typedef struct tagNET_DVR_JPEGPICTURE_WITH_APPENDDATA
{
    DWORD   dwSize;
    DWORD   dwChannel;
    DWORD   dwJpegPicLen;
    char    *pJpegPicBuff;
    DWORD   dwJpegPicWidth;  
    DWORD   dwJpegPicHeight; 
    DWORD   dwP2PDataLen;
    char    *pP2PDataBuff;   
    BYTE    byIsFreezedata;//0-no 1-yes
    BYTE    byRes1[3];
    DWORD   dwVisiblePicLen;//Visible picture length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char    *pVisiblePicBuff;//Visible picture pointer
#else
    char    *pVisiblePicBuff;//Visible picture pointer
    BYTE    byRes2[4];
#endif 
    NET_VCA_RECT struThermalValidRect;//Thermal picture effective region
    NET_VCA_RECT struVisibleValidRect;//Visible picture effective region
    BYTE    byRes[208];
}NET_DVR_JPEGPICTURE_WITH_APPENDDATA, *LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA;

typedef  struct
{
    NET_DVR_JPEGPARA  struParam;
    BYTE   byPicFormat;            // The equipment at 0 - Jpeg image format 
    BYTE   byCapturePicType;        // Equipment, scratching figure type 0 - equipment general figure, 1 - eagle eye calibration images ,3-fish circle picture, 4-HD capture
    BYTE   bySceneID;              //0-not support,1-scene1, 2-scene2 .....
    BYTE   byRes[253];
}NET_DVR_PICPARAM_V50, *LPNET_DVR_PICPARAM_V50;

/* aux video out parameter */
//AUX Output Parameter
typedef struct
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                        /* 0-main video output;  1-aux1 video output;  2-aux2 video output;  3-aux3 video output;  4-aux4 video output*/
    DWORD dwAlarmChanSwitchTime;                 /* : 1Sec -  10: 10Sec */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];             /* aux output switch time:  0-  no switch;  1- 5sec; 2- 10sec; 3- 20sec; 4- 30sec; 5- 60sec; 6- 120sec; 7- 300sec*/
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];     /* aux output preview sequence,  0xff means not preview the camera */
}NET_DVR_AUXOUTCFG, *LPNET_DVR_AUXOUTCFG;


//ntp
typedef struct
{
    BYTE sNTPServer[64];    /* Domain Name or IP address of NTP server */
    WORD wInterval;          /* adjust time interval (hours)  */
    BYTE byEnableNTP;     /* enable NPT client 0- no, 1- yes*/
    signed char cTimeDifferenceH;  /* Difference with Standard Time  (Hour) :  ranges from - 12... +13 */
    signed char cTimeDifferenceM; /* Difference with Standard Time  (Minute) */
    BYTE res1;
    WORD wNtpPort;          /* ntp server port (9000 added) ,  123 is default*/
    BYTE res2[8];
}NET_DVR_NTPPARA, *LPNET_DVR_NTPPARA;

//DDNS
typedef struct
{
    BYTE sUsername[NAME_LEN];   /* DDNS Username*/
    BYTE sPassword[PASSWD_LEN]; /*Password */
    BYTE sDomainName[64];        /* Domain name */
    BYTE byEnableDDNS;             /*Enable DDNS 0- disable, 1- enable*/
    BYTE res[15];
}NET_DVR_DDNSPARA, *LPNET_DVR_DDNSPARA;


typedef struct
{
    BYTE byHostIndex;                     /* 0- private DNS (Reserved)  1- Dyndns 2- PeanutHull 3- xw3322  */
    BYTE byEnableDDNS;                     /*enable DDNS:  0- disable;  1- enable*/
    WORD wDDNSPort;                         /* DDNS port */
    BYTE sUsername[NAME_LEN];             /* DDNS Username*/
    BYTE sPassword[PASSWD_LEN];             /* DDNS Password */
    BYTE sDomainName[MAX_DOMAIN_NAME];     /* DVR domain name*/
    BYTE sServerName[MAX_DOMAIN_NAME];     /* DDNS server domain name or IP */
    BYTE byRes[16];
}NET_DVR_DDNSPARA_EX, *LPNET_DVR_DDNSPARA_EX;

//9000extended
typedef struct
{
    BYTE byEnableDDNS;
    BYTE byHostIndex; /*0-IPServer 1-Dyndns 2-PeanutHull,3- NO-IP, 4- hiDDNS*/
    BYTE byRes1[2];
    struct
    {
        BYTE sUsername[NAME_LEN];             /* DDNS Username*/
        BYTE sPassword[PASSWD_LEN];         /* Password */
        BYTE sDomainName[MAX_DOMAIN_NAME];     /* DVR domain name */
        BYTE sServerName[MAX_DOMAIN_NAME];     /* DDNS server domain name or IP*/
        WORD wDDNSPort;                     /* Port */
        WORD    wCountryID;                    //Country ID,Only byHostIndex is 4 effective, 0 represents the default
        BYTE byStatus;                         /*DDNS status(ro),0-Meaningless,1-connAddrSrvfail\
        2-solveAddrMesFail,3-connHeartSrvfail,4-solveHeartMesFail, 5-connHostSrvfail,6-solveHostMesFail,7-registHostSuccess\
        8-registHostFail,9-sendHeartSuccess, 10-noDNSSrv,  11-DomainConflict,12-serviceException,13-needAuthentication\
        14-invalidAlias, 15-disable*/
        BYTE byRes[7];
    } struDDNS[MAX_DDNS_NUMS];
    BYTE byRes2[16];
}NET_DVR_DDNSPARA_V30, *LPNET_DVR_DDNSPARA_V30;

//email
typedef struct
{
    BYTE sUsername[64];   /* Email Account */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];    /* email */
    BYTE sEventMailAddr1[64];   /* email for upload Alarm/Exception */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA, *LPNET_DVR_EMAILPARA;

//Network Parameter
typedef struct
{
    DWORD  dwSize;
    char  sDNSIp[16];                 /* DNS Server IP */
    NET_DVR_NTPPARA  struNtpClientParam;       /* NTP Parameters */
    NET_DVR_DDNSPARA struDDNSClientParam;      /* DDNS Parameters */
    BYTE res[464];             /* Reserved */
}NET_DVR_NETAPPCFG, *LPNET_DVR_NETAPPCFG;

//nfs Structure Configuration
typedef struct
{
    char sNfsHostIPAddr[16];
    BYTE sNfsDirectory[PATHNAME_LEN];         // PATHNAME_LEN = 128
}NET_DVR_SINGLE_NFS, *LPNET_DVR_SINGLE_NFS;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG, *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{
    DWORD dwSize;                   // Structure size
    WORD wVrmPort;                  // VRM listening port
    BYTE byEnable;                  // Enable ISCSI storage or not
    BYTE byRes[69];                 // Reserved
    NET_DVR_IPADDR struVrmAddr;     // VRM IP address, 16-bit
    char chNvtIndexCode[64];        //nvt index Code 
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;

//Cruise Point Configuration (for private IP Speed Dome) 
typedef struct
{
    BYTE    PresetNum;     //Preset
    BYTE    Dwell;         //Dwell time
    BYTE    Speed;         //Speed
    BYTE    Reserve;     //Reserved
}NET_DVR_CRUISE_POINT, *LPNET_DVR_CRUISE_POINT;

typedef struct
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];             //32 points in total
}NET_DVR_CRUISE_RET, *LPNET_DVR_CRUISE_RET;

/************************************Multi- Channel Decoder (begin) ***************************************/
typedef struct
{
    DWORD    dwSize;
    char    sFirstDNSIP[16];
    char    sSecondDNSIP[16];
    char    sRes[32];
}NET_DVR_NETCFG_OTHER, *LPNET_DVR_NETCFG_OTHER;

typedef struct
{
    char     sDVRIP[16];                 /* DVR IP */
    WORD     wDVRPort;                  /* Port */
    BYTE     byChannel;                 /* Channel No. */
    BYTE    byTransProtocol;             /* Network Protocol 0- TCP,  1- UDP */
    BYTE    byTransMode;                 /* Stream Type 0 -  Main Stream 1 -  Sub Stream*/
    BYTE    byRes[3];
    BYTE    sUserName[NAME_LEN];             /* DVR login user name */
    BYTE    sPassword[PASSWD_LEN];             /* DVR login Password */
}NET_DVR_MATRIX_DECINFO, *LPNET_DVR_MATRIX_DECINFO;

//Dynamic Decoding
typedef struct
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /*Info of Dynamic Decoding Channel*/
}NET_DVR_MATRIX_DYNAMIC_DEC, *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct
{
    DWORD     dwSize;
    DWORD   dwIsLinked;          /* Network link status tag,  0:  Sleep,  1:  linking,  2:  linked,  3:  decoding */
    DWORD   dwStreamCpRate;      /* Stream copy rate,  X kbits/second */
    char    cRes[64];         /* Reserved */
}NET_DVR_MATRIX_DEC_CHAN_STATUS, *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /* Decode channel information  */
    DWORD    dwDecState;     /* 0- dynamic decode 1-  switch decode 2- playback by time 3- playback by file */
    NET_DVR_TIME StartTime;         /* start time for playback by time mode,  */
    NET_DVR_TIME StopTime;         /* stop time for playback by time mode */
    char    sFileName[128];         /* file name for playback by file mode */
}NET_DVR_MATRIX_DEC_CHAN_INFO, *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

//Channel Connected Configuration 2007- 11- 05
typedef struct
{
    DWORD dwEnable;                     /*0- Disable 1- Enable*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;         /* Info of switching decoding channel */
}NET_DVR_MATRIX_DECCHANINFO, *LPNET_DVR_MATRIX_DECCHANINFO;

//2007- 11- 05 Configuration for each channel
typedef struct
{
    DWORD    dwSize;
    DWORD    dwPoolTime;             /*Switch interval */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO, *LPNET_DVR_MATRIX_LOOP_DECINFO;

//2007- 12- 22
typedef struct
{
    BYTE    baudrate;          /* baud rate */
    BYTE    databits;         /* Data bit */
    BYTE    stopbits;         /* Stop bit*/
    BYTE    parity;             /* Parity digit */
    BYTE    flowcontrol;     /* Flow control */
    BYTE    res[3];
}TTY_CONFIG, *LPTTY_CONFIG;

typedef struct
{
    BYTE byTranChanEnable;     /* Open current transparent channel or not 0:  close 1:  open */
    /*
    There is a 232 interface and a 485 interface on the decoder,  which can all be set as transparent channel,  device number can be distributed as below:
    0 -  RS485; 1 -  RS232 Console
    */
    BYTE    byLocalSerialDevice;             /* Local serial device */
    /*
    *    Remote output serial device
    *    1- RS232
    *    2- RS485
    */
    BYTE    byRemoteSerialDevice;             /* Remote output serial device */
    BYTE    res1;                             /* Reserved */
    char    sRemoteDevIP[16];                 /* Remote Device IP */
    WORD    wRemoteDevPort;                     /* Remote Net Communication Port */
    BYTE    res2[2];                         /* Reserved */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct
{
    DWORD dwSize;
    BYTE     by232IsDualChan;  /* Set full- duplex 232 transparent channel,  set value ranges from 1 to MAX_SERIAL_NUM */
    BYTE    by485IsDualChan;  /* Set full- duplex 485 transparent channel,  set value ranges from 1 to MAX_SERIAL_NUM */
    BYTE    res[2];     /* Reserved */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM]; /*Support to create transparent channel number up to MAX_SERIAL_NUM*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007- 12- 24 Merry Christmas Eve...
typedef struct
{
    DWORD    dwSize;
    char    sDVRIP[16];             /* DVR IP */
    WORD    wDVRPort;             /* Port */
    BYTE    byChannel;             /* Channel Port */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];         /* Username */
    BYTE    sPassword[PASSWD_LEN];         /* Password */
    DWORD    dwPlayMode;        /* 0- by file 1-  by time*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

/* Commands for playing file*/
#define NET_DVR_PLAYSTART        1//Start play
#define NET_DVR_PLAYSTOP        2//Stop play
#define NET_DVR_PLAYPAUSE        3//Pause
#define NET_DVR_PLAYRESTART        4//Restore
#define NET_DVR_PLAYFAST        5//Play Faster
#define NET_DVR_PLAYSLOW        6//Play Slower
#define NET_DVR_PLAYNORMAL        7//Normal Speed
#define NET_DVR_PLAYSTARTAUDIO    9//Open Audio
#define NET_DVR_PLAYSTOPAUDIO    10//Close Audio
#define NET_DVR_PLAYSETPOS        12//Change playing progress
#define NET_DVR_RESETBUFFER	    37  //reset matrix decode buffer(remote playback file)

typedef struct
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;         /* Command of Play*/
    DWORD    dwCmdParam;         /* Parameter of Command*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;         /* Current file length  */
    DWORD dwCurMediaFilePosition;     /* Current file position */
    DWORD dwCurMediaFileDuration;     /* Current file duration */
    DWORD dwCurPlayTime;             /* Current playback time  */
    DWORD dwCurMediaFIleFrames;         /* Current playback frame number  */
    DWORD dwCurDataType;             /* Current stream type,  19- file header,  20-  stream data,  21- end */
    BYTE res[72];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE    byDevAddress[MAX_DOMAIN_NAME];    /*Dev ip*/
    WORD    wDevPort;       //dev Port
    BYTE     byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];    /*DDNS Domain*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];    /*Dev Address*/
    BYTE byDdnsType; //Domain Server type,0-IPServer 1-Dyndns 2-PeanutHull,//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //Dev Port
    WORD wDdnsPort; //Dev Server Port
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;



typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD    dwSize;
    DWORD    dwDecChannel;  //Decode Channal NUM
    BYTE    byAddressType;  //Device Address Type,0-IP,1-DDNS
    BYTE    byChannelType;  //Channal Type,0-Normal Channal,1-Zero Channal,2-Stream ID
    BYTE    byres[2];
    BYTE    sUserName[NAME_LEN];        /* user */
    BYTE    sPassword[PASSWD_LEN];        /* password */
    DWORD    dwChannel;            /* Device Channal */
    BYTE    byStreamId[STREAM_ID_LEN];  //Stream ID
    DWORD    dwPlayMode;       /* 0-Play by name 1-play by time*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;

    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime;
        char sFileName[128];
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50
{
    DWORD   dwSize;
    DWORD   dwDecChannel;
    BYTE    byAddressType;
    BYTE    byChannelType;
    BYTE    byStreamEncrypt;//stream encrypt enabled, 0-not support,1-support
	BYTE	byRes1[1];
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN];
    DWORD   dwChannel;
    BYTE    byStreamId[STREAM_ID_LEN];
    DWORD   dwPlayMode;
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime;
        BYTE sFileName[128];
    }unionPlayBackInfo;
    NET_DVR_PU_STREAM_URL struURL;
    BYTE    sStreamPassword[STREAM_PASSWD_LEN];//stream password
    BYTE    byRes2[116];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V50, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50;

typedef struct tagNET_DVR_DISPLAY_EFFECT_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR  struColor;
    BYTE byRes[32];
}NET_DVR_DISPLAY_EFFECT_CFG, *LPNET_DVR_DISPLAY_EFFECT_CFG;

//Multi- channels Decoder new
typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD    wTransProtol;         //Transfer Protocol, 0- TCP,  1- UDP,  2- MCAST
    WORD    wPassivePort;         //UDP port. When TCP,  use default value
    NET_DVR_IPADDR  struMcastIP; //Multicast address,  invalid when using TCP or UDP, 
    BYTE    byStreamType; /* play mode: REAL_TIME_STREAM (1) real-time, RECORD_STREAM (2) record */
    BYTE    byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE, *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30
{
    BYTE byTranChanEnable;     /*Transparent Channel State:  0- Close,  1- Open */
    /*
    *    Multi- channel Decoder has 1 RS485 port and 1 RS232 Port,  both of them can be transparent channel. Device Number is :
    *    0 -  RS485
    *    1 -  RS232 Console
    */
    BYTE    byLocalSerialDevice;             /* Local serial device */
    /*
    *    Remote Serial Output Port:  one RS232 and one RS485
    *    1 -  RS232
    *    2 -  RS485
    */
    BYTE    byRemoteSerialDevice;             /* Remote output serial device */
    BYTE    res1;                             /* Reserved */
    // char    sRemoteDevIP[16];                 /* Remote Device IP */
    NET_DVR_IPADDR  struRemoteDevIP;
    WORD    wRemoteDevPort;                 /* Remote Net Communication Port */
    BYTE  byIsEstablished;     /* Establish Transparent channel: 0- Failure,  1- Success*/
    BYTE    res2;                     /* Reserved */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE      byUsername[NAME_LEN];          /* 32BYTES */
    BYTE       byPassword[PASSWD_LEN];      /* 16BYTES */
    DWORD   dwLocalSerialNo;
    DWORD   dwRemoteSerialNo;
    BYTE    byRes3[8];
}NET_DVR_MATRIX_TRAN_CHAN_INFO_V30, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG
{
    DWORD   dwSize;
    BYTE     by232IsDualChan;  /* Set this RS232 transparent channel as Duplex: 1 ~ MAX_SERIAL_NUM*/
    BYTE    by485IsDualChan;  /* Set this RS485 transparent channel as Duplex: 1 ~ MAX_SERIAL_NUM */
    BYTE    vyRes[2];     /* Reserved */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*Support MAX_SERIAL_NUM Transparent channels simultaneously*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;


typedef struct
{
    DWORD                                dwEnable;     /*0- Disable,  1- Enable*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO         struDevChanInfo;         /* Loop Decoding channel info */
}NET_DVR_MATRIX_CHAN_INFO_V30, *LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;         /*Loop Interval*/
    NET_DVR_MATRIX_CHAN_INFO_V30    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30, *LPNET_DVR_MATRIX_LOOP_DECINFO_V30;


typedef struct tagDEC_MATRIX_CHAN_INFO
{
    DWORD    dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;     /*Streaming Media Server Config*/
    NET_DVR_DEV_CHAN_INFO               struDevChanInfo;         /*Decoding Channel Info  */
    DWORD    dwDecState;         /*  0- Dynamic Decoding,  1- Loop Decoding 2- Playback by time,  3- Playback by file */
    NET_DVR_TIME StartTime;         /* Start time of playback by time */
    NET_DVR_TIME StopTime;             /* End time of playback by time */
    char    sFileName[128];         /* File name for playback by file */
    DWORD   dwGetStreamMode;     /*Fetch Stream Mode: 1- Positive, 2- Passive*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE    byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30, *LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

#define MAX_RESOLUTIONNUM    64 //Max resolution number
typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];      /*Window Mode of VGA*/
    BYTE  byBNCWindowMode[4];            /*Window Mode of BNC*/
    BYTE  byDspNums;
    BYTE  byHDMINums; //HDMI display channel number  ( start from 25) 
    BYTE  byDVINums; //DVI display channel number  (start from 29) 
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM]; //resolution enable, 1: enable, 0: unenable
    BYTE  byHDMIWindowMode[4][8]; //Window-split mode supported by HDMI
    BYTE  byDVIWindowMode[4][8]; //Window-split mode supported by DVI
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY, *LPNET_DVR_MATRIX_ABILITY;
//Upload Logo
typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD        dwCorordinateX;     //X- coordinate for logo display 
    DWORD        dwCorordinateY;     //Y- coordinate for logo display 
    WORD        wPicWidth; //Picture width
    WORD        wPicHeight; //Picture height
    BYTE        byRes1[4];
    BYTE        byFlash;   //Flash or not:  1- Flash,  0- Not flash
    BYTE        byTranslucent;  //Translucence or not:  1- Yes,  0- NO
    BYTE        byRes2[6];                 //Reserved
    DWORD        dwLogoSize; //LOGO size including BMP file head
}NET_DVR_DISP_LOGOCFG, *LPNET_DVR_DISP_LOGOCFG;

/*Encoding Format*/
#define NET_DVR_ENCODER_UNKOWN         0 /*Unknown Format*/
#define NET_DVR_ENCODER_H264         1 /*private H264*/
#define NET_DVR_ENCODER_S264         2 /*Standard H264*/
#define NET_DVR_ENCODER_MPEG4         3 /*MPEG4*/
#define NET_DVR_ORIGINALSTREAM         4 /*Original Stream*/
#define NET_DVR_PICTURE                 5 /*Picture*/
#define NET_DVR_ENCODER_MJPEG         6
#define NET_DVR_ENCODER_MPEG2         7
#define NET_DVR_ENCODER_H265         8

#define NET_DVR_ENCODER_SVAC    9
#define NET_DVR_ENCODER_SMART264                   10/*Smart 264*/
#define NET_DVR_ENCODER_SMART265                   11/*Smart 265*/

/* Encapsulation Format */
#define NET_DVR_STREAM_TYPE_UNKOWN   0   /*Unknown Format*/
#define NET_DVR_STREAM_TYPE_PRIVT    1   /*private Format*/
#define NET_DVR_STREAM_TYPE_TS         7   /* TS */
#define NET_DVR_STREAM_TYPE_PS         8   /* PS */
#define NET_DVR_STREAM_TYPE_RTP         9   /* RTP */
#define NET_DVR_STREAM_TYPE_ORIGIN   10  //ORIGIN

/*State of decoding channel*/
typedef struct
{
    BYTE  byDecodeStatus;     /*Status:  0- Disabled,  1- Enabled*/
    BYTE  byStreamType;     /*Stream Type*/
    BYTE  byPacketType;     /*Encapsulation Type*/
    BYTE  byRecvBufUsage;     /*Usage of receiving buffer*/
    BYTE  byDecBufUsage;     /*Usage of decoding buffer*/
    BYTE  byFpsDecV;         /*video decoding frame*/
    BYTE  byFpsDecA;         /*audio decoding frame*/
    BYTE  byCpuLoad;         /*DSP CPU usage*/
    BYTE  byRes1[4];         //Reserved
    DWORD dwDecodedV;         /*Decoded Video Frame*/
    DWORD dwDecodedA;         /*Decoded Audio Frame*/
    WORD  wImgW;             /*Current Image size*/
    WORD  wImgH;
    BYTE  byVideoFormat;    /*inputted Video standard:  1- PAL,  2- NTSC*/
    BYTE  byRes2[3];
    DWORD  dwDecChan;       /*only valid for gettting all*/
    BYTE  byRes3[20];
}NET_DVR_MATRIX_CHAN_STATUS, *LPNET_DVR_MATRIX_CHAN_STATUS;

/*Status of Display Channel*/
#define NET_DVR_MAX_DISPREGION  16        /*Maximum display regions of each display channel*/


//resolution
typedef enum
{
    /*VGA*/
    VGA_NOT_AVALIABLE,
    VGA_THS8200_MODE_SVGA_60HZ,     // (800*600) 
    VGA_THS8200_MODE_SVGA_75HZ,     // (800*600) 
    VGA_THS8200_MODE_XGA_60HZ,      // (1024*768) 
    VGA_THS8200_MODE_XGA_75HZ,      // (1024*768) 
    VGA_THS8200_MODE_SXGA_60HZ,     // (1280*1024) 
    VGA_THS8200_MODE_720P_60HZ,     // (1280*720) 
    VGA_THS8200_MODE_1080I_60HZ,    // (1920*1080) 
    VGA_THS8200_MODE_1080P_30HZ,    // (1920*1080) 
    VGA_THS8200_MODE_UXGA_30HZ,    // (1600*1200) 
    /*HDMI*/
    HDMI_SII9134_MODE_XGA_60HZ,     // (1024*768) 
    HDMI_SII9134_MODE_SXGA_60HZ,    // (1280*1024) 
    HDMI_SII9134_MODE_SXGA2_60HZ,   // (1280*960) 
    HDMI_SII9134_MODE_720P_60HZ,    // (1280*720)     
    HDMI_SII9134_MODE_720P_50HZ,    // (1280*720)         
    HDMI_SII9134_MODE_1080I_60HZ,   // (1920*1080) 
    HDMI_SII9134_MODE_1080I_50HZ,   // (1920*1080)     
    HDMI_SII9134_MODE_1080P_25HZ,   // (1920*1080) 
    HDMI_SII9134_MODE_1080P_30HZ,   // (1920*1080) 
    HDMI_SII9134_MODE_1080P_50HZ,   // (1920*1080) 
    HDMI_SII9134_MODE_1080P_60HZ,   // (1920*1080) 
    HDMI_SII9134_MODE_UXGA_60HZ,    // (1600*1200) 
    /*DVI*/
    DVI_SII9134_MODE_XGA_60HZ,         // (1024*768) 
    DVI_SII9134_MODE_SXGA_60HZ,     // (1280*1024) 
    DVI_SII9134_MODE_SXGA2_60HZ,    // (1280*960) 
    DVI_SII9134_MODE_720P_60HZ,     // (1280*720)     
    DVI_SII9134_MODE_720P_50HZ,     // (1280*720)         
    DVI_SII9134_MODE_1080I_60HZ,    // (1920*1080) 
    DVI_SII9134_MODE_1080I_50HZ,    // (1920*1080) 
    DVI_SII9134_MODE_1080P_25HZ,    // (1920*1080) 
    DVI_SII9134_MODE_1080P_30HZ,    // (1920*1080) 
    DVI_SII9134_MODE_1080P_50HZ,    // (1920*1080) 
    DVI_SII9134_MODE_1080P_60HZ,    // (1920*1080) 
    DVI_SII9134_MODE_UXGA_60HZ      // (1600*1200) 
}VGA_MODE;

//low frame per second
#define           LOW_DEC_FPS_1_2                51
#define           LOW_DEC_FPS_1_4                52
#define           LOW_DEC_FPS_1_8                53
#define           LOW_DEC_FPS_1_16               54

/*Video Standard*/
typedef enum
{
    VS_NON = 0,
    VS_NTSC = 1,
    VS_PAL = 2
}VIDEO_STANDARD;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{
    DWORD    dwSize;
    BYTE    byAudio;             /*Enable Audio, 0- No, 1- Yes*/
    BYTE    byAudioWindowIdx;       /*child window of enabled audio*/
    BYTE     byVgaResolution;       /*VGA resolution*/
    BYTE    byVedioFormat;          /*Video Standard,  1: NTSC, 2: PAL, 0- NON*/
    DWORD    dwWindowMode;         /*Windows layout mode gotten from Capability Set:  1, 2, 4, 9, 16 windows*/
    BYTE    byJoinDecChan[MAX_WINDOWS]; /*Decoding channel associated by each display window*/
    BYTE    byEnlargeStatus;           /*0: Enlarge, 1: not enlarge*/
    BYTE    byEnlargeSubWindowIndex; //Sub Window Index
    union
    {
        BYTE byRes[16];
        struct
        {
            /*Decoding sub system's slot number of the display window's corresponding decoding channel number*/
            BYTE     byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE     byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*diff union, 0- video platform integrated decoder, 1-others*/
    BYTE        byUnionType;
    BYTE        byScale; /*show mode,0-real,1-zoom(BNC)*/
}NET_DVR_VGA_DISP_CHAN_CFG, *LPNET_DVR_VGA_DISP_CHAN_CFG;

/*Status of Display Channel*/
#define NET_DVR_MAX_DISPREGION 16 /*Maximum display regions of each display channel*/
typedef struct
{
    BYTE  byDispStatus;           /*Display Status: 0- No Display, 1- Enabled*/
    BYTE  byBVGA;                 /*0- BNC, 1- VGA,  2- HDMI, 3- DVI*/
    BYTE  byVideoFormat;         /*Video Standard: 1- PAL,  2- NTSC*/
    BYTE  byWindowMode;         /*Current window Layout*/
    BYTE  byJoinDecChan[MAX_WINDOWS];         /*Decoding channel of each region*/
    BYTE  byFpsDisp[NET_DVR_MAX_DISPREGION];  /*Display frame rate of each region*/
    BYTE  byRes2[32];
}NET_DVR_DISP_CHAN_STATUS, *LPNET_DVR_DISP_CHAN_STATUS;

#define MAX_DECODECHANNUM   32//Maximum number of decoding channel
#define MAX_DISPCHANNUM   24//Maximum number of display channel
/*Decoder Status*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM];  /*Status of decoding channel*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];   /*Status of display channel*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];          /*Status of Alarm input*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];        /*Status of Alarm output*/
    BYTE byAudioInChanStatus;           /*Status of intercom*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS, *LPNET_DVR_DECODER_WORK_STATUS;

//2009- 12- 1 Add passive decode play control
typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;         /* play command*/
    DWORD    dwCmdParam;         /* command parameter */
    BYTE    byRes[16]; //Reverse
}NET_DVR_PASSIVEDECODE_CONTROL, *LPNET_DVR_PASSIVEDECODE_CONTROL;

#define        PASSIVE_DEC_PAUSE                1    /*passive decode pause (only file stream valid) */
#define        PASSIVE_DEC_RESUME                2    /*passive decode resume (only file stream valid) */
#define     PASSIVE_DEC_FAST                  3   /*passive decode fast (only file stream valid) */
#define     PASSIVE_DEC_SLOW                4   /*passive decode slow (only file stream valid) */
#define     PASSIVE_DEC_NORMAL              5   /*passive decode normal*/
#define     PASSIVE_DEC_ONEBYONE              6   /*passive decode one by one (reserved) */
#define     PASSIVE_DEC_AUDIO_ON             7   /*passive decode open audio*/
#define     PASSIVE_DEC_AUDIO_OFF            8      /*passive decode close audio*/
#define        PASSIVE_DEC_RESETBUFFER            9   /*reset buffer */

//2009- 12- 16 scale control
typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{
    DWORD    dwSize;
    BYTE    byDecChanScaleStatus; /*decode channel scale control, 1: scale display, 0: real display*/
    BYTE    byDecodeDelay;//Decoding delay: 0- default, 1- most real-time, 2- more real-time, 3- real-time and fluency, 4- more fluency, 5- most fluency, 0xff- automatically adjust     
    BYTE    byEnableSpartan;//motion fluency,0-off,1-on
    BYTE    byLowLight;      //low light, 0-close, 1-8 means low light level, the level is larger ,the power is bigger
    BYTE    byNoiseReduction; //3D reduce noise, 0-close, 1-open, 2-auto 
    BYTE    byDefog;         //consumption, 0-close 1-7 means level, the larger, the more power
    BYTE    byEnableVcaDec;    //decode show vca information,0-close,1-open
    BYTE    byEnableAudio; //open audio, 0-invalid, 1-open, 2-close
    DWORD   dwAllCtrlType;    //all window control type,valid for setting,each bit reference to one operation
    //dwAllCtrlType & 0x01, switch for vca decoding
    BYTE    byVolume; //volume,[0-100]
    BYTE    byRes[55];
}NET_DVR_MATRIX_DECCHAN_CONTROL, *LPNET_DVR_MATRIX_DECCHAN_CONTROL;

/************************************Decoder (end) ***************************************/

typedef struct tagNET_DVR_PANORAMA_LINKAGE
{
    DWORD            dwSize;
    BYTE             byEnable;//0- off, 1- turned on
    BYTE             byRes[127];
}NET_DVR_PANORAMA_LINKAGE, *LPNET_DVR_PANORAMA_LINKAGE;


typedef struct
{    /* 12 bytes */
    DWORD    dwSize;
    char    sUserName[32];
    char     sPassWord[32];
    char     sFromName[32];             /* Sender */
    char     sFromAddr[48];             /* Sender address */
    char     sToName1[32];             /* Receiver1 */
    char     sToName2[32];             /* Receiver2 */
    char     sToAddr1[48];             /* Receiver address1 */
    char     sToAddr2[48];             /* Receiver address2 */
    char    sEmailServer[32];         /* Email server address */
    BYTE    byServerType;             /* Email server type:  0- SMTP,  1- POP,  2- IMTP...*/
    BYTE    byUseAuthen;             /* Email server authentication method:  1- enable,  0- disable */
    BYTE    byAttachment;             /* enable attachment */
    BYTE    byMailinterval;         /* mail interval 0- 2s,  1- 3s,  2- 4s. 3- 5s*/
} NET_DVR_EMAILCFG, *LPNET_DVR_EMAILCFG;

typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;     // Time Record
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;     //  Triggered by events
}NET_DVR_COMPRESSIONCFG_NEW, *LPNET_DVR_COMPRESSIONCFG_NEW;

//Position info of Speed Dome
typedef struct
{
    WORD wAction; //invalid 
    WORD wPanPos; //pan position
    WORD wTiltPos; //tilt position
    WORD wZoomPos; //zoom position
}NET_DVR_PTZPOS, *LPNET_DVR_PTZPOS;

//PTZ Scope Structure 
typedef struct
{
    WORD wPanPosMin; //min pan position
    WORD wPanPosMax; //max pan position
    WORD wTiltPosMin; //min tilt position
    WORD wTiltPosMax; //max tilt position
    WORD wZoomPosMin; //min zoom factor
    WORD wZoomPosMax; //max zoom factor
}NET_DVR_PTZSCOPE, *LPNET_DVR_PTZSCOPE;

//rtsp Configuration (Special for IP camera) 
typedef struct
{
    DWORD dwSize;          //Length
    WORD  wPort;           //rtsp Port
    BYTE  byReserve1[40];   //Reserved
    WORD  wRtspsPort;     //rtsps Port
    BYTE  byReserve[12];
}NET_DVR_RTSPCFG, *LPNET_DVR_RTSPCFG;


/********************************Interface Parameters Structure (begin) *********************************/

//NET_DVR_Login () 
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    BYTE byAlarmInPortNum;                 //DVR Alarm input
    BYTE byAlarmOutPortNum;             //DVR Alarm Output
    BYTE byDiskNum;                     //DVR Number of Hard Disk
    BYTE byDVRType;                     //DVR Type,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;                     //DVR Number of Channel
    BYTE byStartChan;                     //The first Channel No. E.g. DVS- 1, DVR- 1
}NET_DVR_DEVICEINFO, *LPNET_DVR_DEVICEINFO;

//NET_DVR_Login_V30 () 
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];    //SN
    BYTE byAlarmInPortNum;                 //Number of Alarm input
    BYTE byAlarmOutPortNum;                 //Number of Alarm Output
    BYTE byDiskNum;                         //Number of Hard Disk
    BYTE byDVRType;                         //DVR Type,  1: DVR 2: ATM DVR 3: DVS ......
    BYTE byChanNum;                         //Number of Analog Channel
    BYTE byStartChan;                     //The first Channel No. E.g. DVS- 1, DVR- 1
    BYTE byAudioChanNum;                 //Number of Audio Channel
    BYTE byIPChanNum;                     //Maximum number of IP Channel  low
    BYTE byZeroChanNum;             //Zero channel encoding number//2010- 01- 16
    BYTE byMainProto;             //Main stream transmission protocol 0- private,  1- rtsp,2-both private and rtsp
    BYTE bySubProto;                 //Sub stream transmission protocol 0- private,  1- rtsp,2-both private and rtsp
    BYTE bySupport;         //Ability, the 'AND' result by bit: 0- not support;  1- support
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  get compression configuration ability
    //bySupport & 0x8,  multi network adapter
    //bySupport & 0x10, support remote SADP
    //bySupport & 0x20  support Raid card
    // bySupport & 0x40 support IPSAN directory search
    BYTE bySupport1;        // Ability expand, the 'AND' result by bit: 0- not support;  1- support
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2,support distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension 
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    //bySupport1 & 0x40, support delay preview
    //bySuppory1 & 0x80 support NET_DVR_IPPARACFG_V40, in addition  support  License plate of the new alarm information
    BYTE bySupport2;        // Ability expand, the 'AND' result by bit: 0- not support;  1- support
    //bySupport & 0x1, decoder support get stream by URL
    //bySupport2 & 0x2,  support FTPV40
    //bySupport2 & 0x4,  support ANR
    //bySupport2 & 0x20, support get single item of device status
    //bySupport2 & 0x40,  support stream encryt
    WORD wDevType;              //device type
    BYTE bySupport3;        //Support  epresent by bit, 0 - not support 1 - support 
    //bySupport3 & 0x1- support batch config stream compress  
    //bySupport3 & 0x8  support use delay preview parameter when delay preview
    //bySupport3 & 0x10 support the interface of getting alarmhost main status V40
    BYTE byMultiStreamProto;//support multi stream, represent by bit, 0-not support ;1- support; bit1-stream 3 ;bit2-stream 4, bit7-main stream, bit8-sub stream
    BYTE byStartDChan;        //Start digital channel
    BYTE byStartDTalkChan;    //Start digital talk channel
    BYTE byHighDChanNum;        //Digital channel number high
    BYTE bySupport4;        //Support  epresent by bit, 0 - not support 1 - support
    //bySupport4 0x02 whether support NetSDK(NET_DVR_STDXMLConfig) tranfer form data
    //bySupport4 & 0x4 whether support video wall unified interface
    // bySupport4 & 0x80 Support device upload center alarm enable
    BYTE byLanguageType;    // support language type by bit,0-support,1-not support  
    //  byLanguageType 0 -old device
    //  byLanguageType & 0x1 support chinese
    //  byLanguageType & 0x2 support english
    BYTE byVoiceInChanNum;   //voice in chan num 
    BYTE byStartVoiceInChanNo; //start voice in chan num
    BYTE  bySupport5;  //0-no support,1-support,bit0-muti stream
    //bySupport5 &0x01support wEventTypeEx 
    //bySupport5 &0x04support sence expend
    BYTE  bySupport6;
    BYTE  byMirrorChanNum;    //mirror channel num,<it represents direct channel in the recording host>
    WORD  wStartMirrorChanNo;  //start mirror chan
    BYTE bySupport7;        //Support  epresent by bit, 0 - not support 1 - support 
    //bySupport7 & 0x1- supports INTER_VCA_RULECFG_V42 extension    
    // bySupport7 & 0x2  Supports HVT IPC mode expansion
    // bySupport7 & 0x04  Back lock time
    // bySupport7 & 0x08  Set the pan PTZ position, whether to support the band channel
    // bySupport7 & 0x10  Support for dual system upgrade backup
    // bySupport7 & 0x20  Support OSD character overlay V50
    // bySupport7 & 0x40  Support master slave tracking (slave camera)
    // bySupport7 & 0x80  Support message encryption 
    BYTE  byRes2;
}NET_DVR_DEVICEINFO_V30, *LPNET_DVR_DEVICEINFO_V30;

typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //the device support lock function,this byte assigned by SDK.when bySupportLock is 1,dwSurplusLockTime and byRetryLoginTime is valid 
    BYTE  byRetryLoginTime;        //retry login times
    BYTE  byPasswordLevel;      //PasswordLevel,0-invalid,1-default password,2-valid password,3-risk password,
    //4- the administrator creates an ordinary user to set the password for him/her, and the ordinary user shall be prompted to "please modify the initial login password" after correctly logging into the device. In the case of no modification, the user will be reminded every time he/she logs in; 
    //5- when the password of an ordinary user is modified by the administrator, the ordinary user needs to be prompted "please reset the login password" after correctly logging into the device again. If the password is not modified, the user will be reminded of each login;
    //6- the administrator creates an installer/operator user and sets password for him/her,  then need prompt "please change initial password" after the user login in the device. If the password is not modified, it can't operate other actions except for changing password
    BYTE  byProxyType;  //Proxy Type,0-not use proxy, 1-use socks5 proxy, 2-use EHome proxy
    DWORD dwSurplusLockTime;    //surplus locked time
    BYTE  byCharEncodeType;     //character encode type
    BYTE  bySupportDev5;//Support v50 version of the device parameters, device name and device type name length is extended to 64 bytes 
    BYTE  bySupport;  // capability set extension, bit and result: 0- no support, 1- support
    // bySupport & 0x1:0 - Reserved
    // bySupport & 0x2:0 - does not support changes to report 1- support change escalation
    BYTE  byLoginMode; //loginmodel 0-Private 1-ISAPI
    DWORD dwOEMCode;
    int iResidualValidity;
    BYTE  byResidualValidity;
    BYTE  bySingleStartDTalkChan;
    BYTE  bySingleDTalkChanNums;
    BYTE  byPassWordResetLevel;
    BYTE  bySupportStreamEncrypt;
    BYTE  byMarketType;
    BYTE  byRes2[238];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

//sdk Network environment,  for update
typedef enum _SDK_NET_ENV
{
    LOCAL_AREA_NETWORK = 0,
    WIDE_AREA_NETWORK
}SDK_NETWORK_ENVIRONMENT;

//Display Mode
typedef enum
{
    NORMALMODE = 0,
    OVERLAYMODE
}DISPLAY_MODE;

//Send Mode
typedef enum
{
    PTOPTCPMODE = 0,
    PTOPUDPMODE,
    MULTIMODE,
    RTPMODE,
    RESERVEDMODE
}SEND_MODE;

//Grub Mode
typedef enum
{
    BMP_MODE = 0,         //BMP Mode
    JPEG_MODE = 1        //JPEG Mode 
}CAPTURE_MODE;

//Real time Audio mode
typedef enum
{
    MONOPOLIZE_MODE = 1, //exclusive mode
    SHARE_MODE = 2     //shared mode
}REALSOUND_MODE;

//Preview via software decoding
typedef struct
{
    LONG  lChannel; //channel no.
    LONG  lLinkMode; //If 31st bit is 0,  it means connect main stream,  is 1 means sub stream. Bit 0~bit 30 are used for link mode:  0:  TCP mode,  1:  UDP mode,  2:  Multi- play mode,  3:  RTP mode,4-RTP/RTSP,5-RSTP/HTTP
    HWND  hPlayWnd; // the play window's handle;  set NULL to disable preview
    char* sMultiCastIP;  //Multicast group
    BYTE byProtoType; //0-private protocol,1-RTSP protocol
    BYTE byRes[3];
}NET_DVR_CLIENTINFO, *LPNET_DVR_CLIENTINFO;

typedef struct tagNET_DVR_PREVIEWINFO{
    LONG    lChannel;         // Channel no.
    DWORD    dwStreamType;    // Stream type 0-main stream,1-sub stream,2-third stream,3-forth stream,4-fifth stream,5-sixth stream,7-seventh stream,8-eighth stream,9-ninth stream,10-tenth stream
    DWORD    dwLinkMode;        // Protocol type: 0-TCP, 1-UDP, 2-Muticast, 3-RTP,4-RTP/RTSP, 5-RSTP/HTTP
    HWND    hPlayWnd;        // Play window's handle;  set NULL to disable preview
    DWORD bBlocked;          //If data stream requesting process is blocked or not: 0-no, 1-yes  
    //if true, the SDK Connect failure return until 5s timeout  , not suitable for polling to preview.
    DWORD bPassbackRecord; //0- not enable  ,1 enable
    BYTE byPreviewMode;    // Preview mode 0-normal preview,2-delay preview
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//Stream ID
    BYTE byProtoType; //0-private,1-RTSP,2-SRTP
    BYTE byRes1;
    BYTE byVideoCodingType;
    DWORD dwDisplayBufNum; //soft player display buffer size(number of frames), range:1-50, default:1 
    BYTE byNPQMode;  //0-direct connect 1-by SMS
    BYTE byRecvMetaData;  //wwhether to recieve metadataCapability is GET /ISAPI/System/capabilities, and  DeviceCap.SysCap.isSupportMetadata is true
    BYTE byDataType;    //0-stream data,1-audio data
    BYTE byRes[213];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;

//
typedef struct tagNET_DVR_PREVIEWINFO_SPECIAL
{
    char sURL[1024]; //instance:rtsp://admin:abcd12345@10.7.37.2:554/Streaming/Channels/101?transportmode=unicast
    DWORD dwLinkMode;//0:TCP,1:UDP,2-mcast,3-RTP,4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;
    DWORD bBlocked;
    DWORD dwDisplayBufNum;
    BYTE byRes[64];
}NET_DVR_PREVIEWINFO_SPECIAL, *LPNET_DVR_PREVIEWINFO_SPECIAL;

//SDK information (9000 added) 
typedef struct
{
    DWORD dwTotalLoginNum;         //current login user operation number
    DWORD dwTotalRealPlayNum;     //current real play operation number
    DWORD dwTotalPlayBackNum;     //current playback or download operation number
    DWORD dwTotalAlarmChanNum;     //current alarm channel operation number
    DWORD dwTotalFormatNum;         //current HDD format operation number
    DWORD dwTotalFileSearchNum;     //current files search operation number
    DWORD dwTotalLogSearchNum;     //current logs search operation number
    DWORD dwTotalSerialNum;         //current transparent series port operation number
    DWORD dwTotalUpgradeNum;     //current upgrading operation number
    DWORD dwTotalVoiceComNum;     //current network voice communication operation number
    DWORD dwTotalBroadCastNum;     //current network broadcast voice communication operation number
    DWORD dwTotalListenNum;         //current net listen operation number
    DWORD dwEmailTestNum;        //current E- mail test operation number
    DWORD dwBackupNum;           //current backup  operation number
    DWORD dwTotalInquestUploadNum;  //current inquest upload operation number
    DWORD dwRes[6];
}NET_DVR_SDKSTATE, *LPNET_DVR_SDKSTATE;

//SDK Ability Information  (9000 added) 
typedef struct
{
    DWORD dwMaxLoginNum;         //maximum login user operation number MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;         //maximum realplay operation number WATCH_NUM
    DWORD dwMaxPlayBackNum;         //maximum playback or download operation number WATCH_NUM
    DWORD dwMaxAlarmChanNum;     //maximum alarm channel operation number ALARM_NUM
    DWORD dwMaxFormatNum;         //maximum HDD format operation number SERVER_NUM
    DWORD dwMaxFileSearchNum;     //maximum files search operation number SERVER_NUM
    DWORD dwMaxLogSearchNum;     //maximum logs search operation number SERVER_NUM
    DWORD dwMaxSerialNum;         //maximum transparent series port operation number SERVER_NUM
    DWORD dwMaxUpgradeNum;         //maximum current upgrading operation number SERVER_NUM
    DWORD dwMaxVoiceComNum;         //maximum network voice communication operation number SERVER_NUM
    DWORD dwMaxBroadCastNum;     //maximum network broadcast voice communication operation number MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL, *LPNET_DVR_SDKABL;

//Alarm Device Infor
typedef struct
{
    BYTE byUserIDValid;                  /* Whether userID is valid,  0- invalid 1- valid. */
    BYTE bySerialValid;                  /* Whether serial number is valid,  0- invalid 1- valid.  */
    BYTE byVersionValid;                 /* Whether version number is valid,  0- invalid 1- valid. */
    BYTE byDeviceNameValid;              /* Whether device name is valid,  0- invalid 1- valid. */
    BYTE byMacAddrValid;                 /* Whether MAC address is valid,  0- invalid 1- valid. */
    BYTE byLinkPortValid;                /* Whether login port number is valid,  0- invalid 1- valid. */
    BYTE byDeviceIPValid;                /* Whether device IP is valid,  0- invalid 1- valid.*/
    BYTE bySocketIPValid;                /* Whether socket IP is valid,  0- invalid 1- valid. */
    LONG lUserID;                        /* NET_DVR_Login () effective when establishing alarm upload channel*/
    BYTE sSerialNumber[SERIALNO_LEN];     /* Serial number. */
    DWORD dwDeviceVersion;                 /* Version number,  2 high byte means the major version,  2 low byte means the minor version*/
    char sDeviceName[NAME_LEN];             /* Device name. */
    BYTE byMacAddr[MACADDR_LEN];         /* MAC address */
    WORD wLinkPort;                      /* link port */
    char sDeviceIP[128];                 /* IP address */
    char sSocketIP[128];                 /* alarm push- mode socket IP address. */
    BYTE byIpProtocol;                   /* IP protocol:  0- IPV4;  1- IPV6. */
    BYTE byRes1[2];
    BYTE bJSONBroken;                   //JSON Broken flag 0-not transmit 1-transmit
    WORD wSocketPort;
    BYTE byRes2[6];
}NET_DVR_ALARMER, *LPNET_DVR_ALARMER;

//Display Area Parameter of Hardware Decoding (Sub Structure) 
typedef struct
{
    long bToScreen;
    long bToVideoOut;
    long nLeft;
    long nTop;
    long nWidth;
    long nHeight;
    long nReserved;
}NET_DVR_DISPLAY_PARA, *LPNET_DVR_DISPLAY_PARA;

//Preview Parameter of Hardware Decoding
typedef struct
{
    LONG lChannel; // Channel No.
    LONG lLinkMode;  //0-  TCP;  1-  UDP;  2-  Multicast;  3-  RTP;  4-  PPPoE;  5-  128k;  6-  256k;  7-  384k;  8-  512k
    char* sMultiCastIP;
    NET_DVR_DISPLAY_PARA struDisplayPara;
}NET_DVR_CARDINFO, *LPNET_DVR_CARDINFO;

//Record Parameters
typedef struct
{
    char sFileName[100]; // File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
}NET_DVR_FIND_DATA, *LPNET_DVR_FIND_DATA;

//Record Parameters (9000) 
typedef struct
{
    char sFileName[100]; //File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
    char sCardNum[32];
    BYTE byLocked; //9000 DVR supports this, 1- file is locked, 0- file is Normal
    BYTE byFileType;   //File Type:  0:  scheduled record,  1:  Motion detection,  2:  alarm record,  3:  motion detection| alarm,  4:  motion detection & alarm 5:  command trigger,  6:  manually record
    //9-VCA alarm,10-PIR alarm,11-wireless alarm,12-callhelp alarm,14-Intelligent Transportation
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30, *LPNET_DVR_FINDDATA_V30;

typedef struct
{
    char sFileName[100];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struStopTime;
    DWORD dwFileSize;
    char sCardNum[32];
    BYTE byLocked;
    BYTE byFileType;
    BYTE byQuickSearch;
    BYTE byRes;
    DWORD dwFileIndex;
    BYTE byStreamType;
    BYTE byRes1[127];
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;


typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP;
    WORD wPort;
    BYTE byRes[2];
}NET_DVR_ADDRESS, *LPNET_DVR_ADDRESS;

//link type
typedef enum _NET_DVR_LINK_KIND_
{
    ENUM_LINK_PREVIEW = 1, //preview
    ENUM_LINK_PLAYBACK,   //playback, download
    ENUM_LINK_VOICEPLAY   //audiotalk
}NET_DVR_LINK_KIND;

//link addr
typedef struct tagNET_DVR_LINK_ADDR
{
    NET_DVR_IPADDR_UNION      uLocalIP;    //IP of client
    WORD                      wLocalPort[10];   //port of client
    BYTE                      byLocalPortNum;   //port num of client
    BYTE                      byRes1[3];
    NET_DVR_IPADDR_UNION      uDevIP;        //IP of device
    WORD                      wDevPort[10];     //port of device
    BYTE                      byDevPortNum;     //port num of device
    BYTE                      byRes2[3];
    BYTE                      byRes[80];
}NET_DVR_LINK_ADDR, *LPNET_DVR_LINK_ADDR;

typedef struct tagNET_DVR_FINDDATA_V50
{
    char sFileName[100];
    NET_DVR_TIME_SEARCH   struStartTime;
    NET_DVR_TIME_SEARCH   struStopTime;
    NET_DVR_ADDRESS struAddr; //address of vedio pieces , used by cluster playback
    DWORD   dwFileSize; //file size  //if byBigFileType==1, this is useless
    BYTE    byLocked; //is file locked?1-locked;0-unlock
    BYTE   byFileType; //file type ,same with V40
    BYTE   byQuickSearch; //0- normal,1- fast(calendar)query
    BYTE  byStreamType; //stream type:0- main stream,1- sub-stream,2- third stream
    DWORD  dwFileIndex; //file index
    char  sCardNum[32]; //card number
    DWORD  dwTotalLenH; // forbig file search,dataLength the high 32bit
    DWORD  dwTotalLenL; // forbig file search,dataLength the low 32bit
    BYTE    byBigFileType; //0-normal segment search, 1-bigFile Search
    BYTE    byRes[247];
}NET_DVR_FINDDATA_V50, *LPNET_DVR_FINDDATA_V50;

//Record Parameters (with Card No.) 
typedef struct
{
    char sFileName[100]; //File Name
    NET_DVR_TIME struStartTime; //Start time of the file
    NET_DVR_TIME struStopTime; //End time of the file
    DWORD dwFileSize; //File size
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD, *LPNET_DVR_FINDDATA_CARD;


//Record Query Condition
typedef struct
{
    LONG lChannel; //channel number
    DWORD dwFileType; /*file record mode: 0xff - all,  0 - scheduled record,  1 - Motion detection,  2 - alarm record,  3:  motion detection| alarm,
                                      4 - motion detection & alarm, 5 - command trigger,  6 - manually record,7-VCA record,10-PIR alarm,11-wireless alarm,12-callhelp alarm,13-all Event alarm,14-Intelligent Transportation*/
    DWORD dwIsLocked; //whether file is locked,  0- normal;  1- locked;  0xff- all
    DWORD dwUseCardNo; //whether card no. is used
    BYTE sCardNumber[32]; //card no.
    NET_DVR_TIME struStartTime; //start time
    NET_DVR_TIME struStopTime; //end time
}NET_DVR_FILECOND, *LPNET_DVR_FILECOND;

// PTZ Image Zooming  (Special for private Speed dome) 
typedef struct
{
    int xTop;      //x coordinate of the origination point of the pane
    int yTop;      //y coordinate of the origination point of the pane
    int xBottom;   //x coordinate of the end point of the pane
    int yBottom;   //y coordinate of the end point of the pane
    int bCounter;  //reserve
}NET_DVR_POINT_FRAME, *LPNET_DVR_POINT_FRAME;

//audio encode type
typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;    //AudioTalk Code Type 0-G722.1; 1-G711_U; 2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM;9-G722.1.C;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;16-ADPCM
    BYTE  byAudioSamplingRate;//audio sample rate 0-default,1-16kHZ,2-32kHZ,3-48kHZ,4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// audio bitrate see BITRATE_ENCODE_INDEX
    BYTE  byres[4];//
    BYTE  bySupport;//bySupport Bit0- mp2l2 data is random length 
}NET_DVR_COMPRESSION_AUDIO, *LPNET_DVR_COMPRESSION_AUDIO;

//2009- 7- 22
#define IW_ESSID_MAX_SIZE                         32
#define WIFI_WEP_MAX_KEY_COUNT                     4
#define WIFI_WEP_MAX_KEY_LENGTH                     33
#define WIFI_WPA_PSK_MAX_KEY_LENGTH                 63
#define WIFI_WPA_PSK_MIN_KEY_LENGTH                 8
#define WIFI_MAX_AP_COUNT                         20
#define WIFI_WPA_PSK_MAX_HEXKEY_LENGTH           68   //WPA Hex Key Len

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;                         /* 0- mange mode; 1 ad- hoc mode, plz refer to NICMODE */
    DWORD  dwSecurity;            /*0 - not encrypted;  1 wep encrypted;  2 wpa- psk; 3 wpa- Enterprise; 4-WPA2_PSK;refer to WIFISECURITY*/
    DWORD  dwChannel;             /*1-11,  stands for 11 channels*/
    DWORD  dwSignalStrength;     /* Signal strength, 0 (lowest)- 100 (highest)*/
    DWORD  dwSpeed;                /* Signal speed, unit: 0.01mbps*/
}NET_DVR_AP_INFO, *LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;         /*Wireless AP number, should be less than 20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST, *LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{
    char    sIpAddress[16];                 /*IP*/
    char    sIpMask[16];                     /*Sub net mask*/
    BYTE    byMACAddr[MACADDR_LEN];         /*Physical address, read-only*/
    BYTE    byCloseWifi;        //whether close wifi,0-not close,1-close
    BYTE    bRes;
    DWORD    dwEnableDhcp;                 /*DHCP: 0-disable;  1- enable*/
    DWORD    dwAutoDns;                     /*Get DNS automatically after enable DHCP: 0-disable;  1-enable;  for cable network, DHCP will be set as 'get DNS automatically' mode*/
    char    sFirstDns[16];                          /*Preferred DNS*/
    char    sSecondDns[16];                      /*Alternate DNS*/
    char    sGatewayIpAddr[16];                  /*Network Gateway*/
    BYTE    bRes2[8];
}NET_DVR_WIFIETHERNET, *LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;         /*WIFI port*/
    char sEssid[IW_ESSID_MAX_SIZE];      /*SSID*/
    DWORD dwMode;       /* 0- mange  mode; 1 ad- hoc mode*/
    DWORD dwSecurity;  /*0- no encryption; 1- wep encryption; 2 wpa- psk;3-WPA_ENTPRISE;4-WPA2_PSK,5-WPA2_ENTPRISE  */
    union
    {
        struct
        {
            DWORD dwAuthentication; /*0 - open mode;  1- share mode*/
            DWORD dwKeyLength; /* 0 - 64 bit;  1-  128bit;  2- 152 bit*/
            DWORD dwKeyType; /*0-HEX;  1-ASCI */
            DWORD dwActive; /*0- index: 0- - - 3 stands for the KEY mode*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct
        {
            DWORD dwKeyLength; /*8~ 63 ASCII characters*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2:0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//64bit WPA Hex Key 
            BYTE byKeyType;//Key Type
            BYTE byRes[7];
        }wpa_psk;
        struct
        {
            BYTE byEncryptType;  /*encry type,0-AES, 1-TKIP*/
            BYTE byAuthType; //auth type 0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byAuthType; //inter auth type,0-PAP,1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity[NAME_LEN]; //anony identity
                    BYTE byUserName[NAME_LEN];
                    BYTE byPassword[NAME_LEN];
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterpris mode
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byAuthType; //inter auth type,0-PAP,1-MSCHAPV2
                    BYTE byPeapVersion; //PEAP version,0-version0,1-version1
                    BYTE byPeapLabel; //PEAP label,0-old label,1-new label
                    BYTE byAnonyIdentity[NAME_LEN]; //anony identity
                    BYTE byUserName[NAME_LEN];
                    BYTE byPassword[NAME_LEN];
                    BYTE byRes[44];
                }EAP_PEAP; //WPA-enterprise/WPA2-enterpris mode
                struct
                {
                    BYTE byEapolVersion; //EAPOL version,0-version1,1-version2
                    BYTE byRes1[3];
                    BYTE byIdentity[NAME_LEN]; //idetity
                    BYTE byPrivateKeyPswd[NAME_LEN];
                    BYTE byRes[76];
                }EAP_TLS;
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterpris mode
    }key;
}NET_DVR_WIFI_CFG_EX, *LPNET_DVR_WIFI_CFG_EX;

//WIFI configuration structure
typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG, *LPNET_DVR_WIFI_CFG;

//wifi connection status
typedef     struct  tagNET_DVR_WIFI_CONNECT_STATUS
{
    DWORD        dwSize;
    BYTE        byCurStatus;    //1-connected,2-unconnected,3-connecting
    BYTE        byRes1[3];
    DWORD        dwErrorCode;    // valid when byCurStatus=2,1-username or password error,2-the router is nonexistent,3-unknown error
    BYTE        byRes[244];
}NET_DVR_WIFI_CONNECT_STATUS, *LPNET_DVR_WIFI_CONNECT_STATUS;

//WIFI working mode
typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode;  /*0- auto switch mode;  1- cable network*/
}NET_DVR_WIFI_WORKMODE, *LPNET_DVR_WIFI_WORKMODE;


//Structure parameters  
#define VCA_MAX_POLYGON_POINT_NUM        10        //Support polygon with up to 10 coordinates
#define MAX_RULE_NUM                    8        //Max. rule number
#define MAX_RULE_NUM_V42                16       //Max. rule number Expansion
#define MAX_TARGET_NUM                    30        //Max. target number
#define MAX_CALIB_PT                     6        //Max. calibration number
#define MIN_CALIB_PT                     4        //Min. calibration number
#define MAX_TIMESEGMENT_2                2        //Max. time periods number
#define DATA_INDEX_LEN                  64      //Data Index
#define MAX_DEV_DATAINDEX_LEN           64      //Device data index length
#define MAX_TRAFFIC_PICTURE_NUM         8      //Traffic Picture Num
#define MAX_LICENSE_LEN                    16        //Max. length of the license number
#define MAX_CARDNO_LEN                  48      //Max. Card No. 2013-11-04
#define MAX_DEBUGCMD_LEN                1024    //Debug CMD Len
#define MAX_DEBUGINFO_LEN               1400    //Debug Info Len
#define MAX_OPERATE_INDEX_LEN           32      //Max. Operate Index 2014-03-03
#define MAX_PLATE_NUM                    3        //license plate number
#define MAX_MASK_REGION_NUM                4       //Max. 4 mask area
#define MAX_SEGMENT_NUM                    6       //Max. segment number for camera calibration
#define MIN_SEGMENT_NUM                    3       //Min. segment number for camera calibration
#define MAX_REL_SNAPCHAN_NUM            3       //Max. relate snap channel number
#define MAX_PIC_SWITCH_STORAGE_SERVER   64      //Max. Storage Server Picture Type 
#define MAX_INFO_SWITCH_STORAGE_SERVER  64      //Max. Storage Server Add Info Type 
#define RTMP_URL_LEN                    128     //RTMP URL Len
#define MAX_ID_LEN_128                  128     //ID Len 128
#define MAX_VEHICLE_ID_LEN              32      //Max length of  vehicle ID 
#define LEN_PROPERTY                    128
//Intelligent config info
#define MAX_VCA_CHAN  16//Max. intelligent channel number
typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;     //enable or disable intelligent function
    BYTE   byVCAType;       //intelligent analysis mode, VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //include intelligent info in video stream
    BYTE   byMode;          //VCA_CHAN_MODE_TYPE for ATM intelligent analysis,TFS_CHAN_MODE_TYPE for TFS intelligent analysis
    BYTE   byControlType;   //control type,0-no,1-yes
    // byControlType &1 enable snap
    BYTE   byPicWithVCA;   //Alarm drawings superimposed target information (the target frame)
    BYTE   byRes[2];        //Reserved as 0 
}NET_VCA_CTRLINFO, *LPNET_VCA_CTRLINFO;

//Intelligent config info structure
typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN];      //Config info, array 0 is corresponding to the 1st channel of the system
    BYTE byRes[16];
}NET_VCA_CTRLCFG, *LPNET_VCA_CTRLCFG;

//Intelligent device ability set
typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;                //structure length
    BYTE byVCAChanNum;            //intelligent channel number
    BYTE byPlateChanNum;         //LPR channel number
    BYTE byBBaseChanNum;        //Basic VCA number
    BYTE byBAdvanceChanNum;    //Advanced VCA number
    BYTE byBFullChanNum;       //Complete VCA number
    BYTE byATMChanNum;            //Intelligent ATM number
    BYTE byPDCChanNum;         //PDC channel number
    BYTE byITSChanNum;         //Traffic event analysis channel number
    BYTE byBPrisonChanNum;        //VCA (prison surveillance version) channel number
    BYTE byFSnapChanNum;       //Face snap channel number
    BYTE byFSnapRecogChanNum;  //Face snap and recognize channel number
    BYTE byFRetrievalChanNum;  //Face retrieval channel number
    BYTE bySupport;            //ability, bit, 0-not support,1-support
    //bySupport & 0x1,support track 2012-3-22
    //bySupport & 0x2,support 128 channel 2012-12-27
    BYTE byFRecogChanNum;      //Face recognize channel number
    BYTE byBPPerimeterChanNum; //prison perimeter channel number
    BYTE byTPSChanNum;         //Traffic TPS channel number
    BYTE byTFSChanNum;         //Traffic TFS channel number
    BYTE byFSnapBFullChanNum;  //Face capture & behavioural analysis channel number
    BYTE byHeatMapChanNum;     //Heat Map Chan Num
    BYTE bySmartVehicleNum;  //SMART+Vehicle detection Chan Num
    BYTE bySmartHVTNum;     //SMART+HVT Chan Num
    BYTE bySmartNum;          //SMART  Num
    BYTE byVehicleNum;        //Vehicle detection Chan Num
    BYTE bySmartRoadDetectionNum; // SMART+Road Detection Chan Num
    BYTE bySmartFaceDetectionNum; // SMART+Face Detection Chan Num
    BYTE bySmartHeatMapNum; // SMART+Heat Map Chan Num
    BYTE byHumanRecognitionNum; //HumanRecognitionNum
    BYTE byEdcationStudentNum; //EdcationStudentNum
    BYTE byRoadDetectionNum;//Road Detection Num
    BYTE byPersonDensityDetection; //Personnel density detection num
    BYTE bySafetyHelmetDetection; //Safety helmet detection num
    BYTE byPerimeterCapture;//Perimeter Capture num
    BYTE byHeelPDC;//Heel PDC num
    BYTE by12MPLiveView;//1200 preview @20fps(4000*3000)
    BYTE byTeacherBehaviorDetectNum; //Teacher behavior detect num
    BYTE byMixedTargetDetection;     //Mixed target detection
    BYTE byFaceContrast;//face contrast
    BYTE byCityManagement;//city management
    BYTE byMixedTargetDetectionSmart;//Mixed target detection and Smart
    BYTE byRes;
}NET_VCA_DEV_ABILITY, *LPNET_VCA_DEV_ABILITY;


//VCA Abilities Set
typedef enum _VCA_ABILITY_TYPE_
{
    TRAVERSE_PLANE_ABILITY = 0x01,        //traverse plane
    ENTER_AREA_ABILITY = 0x02,        //Enter area
    EXIT_AREA_ABILITY = 0x04,        //Leave area
    INTRUSION_ABILITY = 0x08,        //Intrusion
    LOITER_ABILITY = 0x10,        //Loitering
    LEFT_TAKE_ABILITY = 0x20,        //Object left/take
    PARKING_ABILITY = 0x40,        //Illegal parking
    RUN_ABILITY = 0x80,        //Running
    HIGH_DENSITY_ABILITY = 0x100,       //People density
    LF_TRACK_ABILITY = 0x200,       //Auto-tracking of the speed dome
    VIOLENT_MOTION_ABILITY = 0x400,         //Violent motion
    REACH_HIGHT_ABILITY = 0x800,         //Reach High
    GET_UP_ABILITY = 0x1000,         //Get up
    LEFT_ABILITY = 0x2000,      //Item left
    TAKE_ABILITY = 0x4000,      //Item take
    LEAVE_POSITION = 0x8000,      //Leave position
    TRAIL_ABILITY = 0x10000,     //Trial
    KEY_PERSON_GET_UP_ABILITY = 0x20000,     //Key person get up
    STANDUP_ABILITY = 0x40000,     //Stand Up
    FALL_DOWN_ABILITY = 0x80000,     //Fall down
    AUDIO_ABNORMAL_ABILITY = 0x100000,    //Audio abnormal
    ADV_REACH_HEIGHT_ABILITY = 0x200000,    //Advance reach height
    TOILET_TARRY_ABILITY = 0x400000,    //Toilet tarry
    YARD_TARRY_ABILITY = 0x800000,    //Yard tarry
    ADV_TRAVERSE_PLANE_ABILITY = 0x1000000,   //Advance traverse plane
    LECTURE_ABILITY = 0x2000000,   //Teaching
    ANSWER_ABILITY = 0x4000000,   //Answer
    HUMAN_ENTER_ABILITY = 0x10000000,  //Human enter ATM, supported only in ATM_PANEL mode
    OVER_TIME_ABILITY = 0x20000000,  //Overtime, supported only in ATM_PANEL mode
    STICK_UP_ABILITY = 0x40000000,  //ATM stick-up
    INSTALL_SCANNER_ABILITY = 0x80000000   //Install scanner on ATM
}VCA_ABILITY_TYPE;

typedef enum _VCA_ABILITY_TYPE_EX_
{
    PEOPLENUM_CHANGE_ABILITY = 0x00000002, //PeopleNum Change
    SPACING_CHANGE_ABILITY = 0x00000004,   //Spacing Change
    EVENT_COMBINED_ABILITY = 0x00000008,   //Combined Event
    EVENT_SIT_QUIETLY = 0x00000010,     //Sit Quietly
    EVENT_HIGH_DENSITY_STATUS_ABILITY = 0x00000020,    //high density status
    EVENT_RUNNING = 0x00000040,        //running
    EVENT_RETENTION = 0x00000080, //retention
    EVENT_TEACHER_WRITING = 0x00000100,   //Writing
    EVENT_FAKECARD = 0x00000200 //fake card
}VCA_ABILITY_TYPE_EX;

//Intelligent channel type
typedef enum _VCA_CHAN_ABILITY_TYPE_
{
    VCA_BEHAVIOR_BASE = 1,     //Basic VCA
    VCA_BEHAVIOR_ADVANCE = 2,     //Advanced VCA
    VCA_BEHAVIOR_FULL = 3,     //FULL VCA
    VCA_PLATE = 4,     //LPR
    VCA_ATM = 5,     //ATM
    VCA_PDC = 6,     //PDC
    VCA_ITS = 7,     //Intelligent traffic surveillance
    VCA_BEHAVIOR_PRISON = 8,     //VCA (prison surveillance version)  
    VCA_FACE_SNAP = 9,     //Face snap
    VCA_FACE_SNAPRECOG = 10,    //Face snap and recognize
    VCA_FACE_RETRIEVAL = 11,    //Face retrieval
    VCA_FACE_RECOG = 12,    //Face recognize
    VCA_BEHAVIOR_PRISON_PERIMETER = 13,    //VCA (prison perimeter version)
    VCA_TPS = 14,    //TPS
    VCA_TFS = 15,    //TFS
    VCA_BEHAVIOR_FACESNAP = 16,    //FACESNAP and BEHAVIOR
    VCA_HEATMAP = 17,    //Heat Map
    VCA_SMART_VEHICLE_DETECTION = 18,    // SMART+ Vehicle detection
    VCA_SMART_HVT_DETECTION = 19,    // SMART+ HVT detection
    VCA_SMART_EVENT = 20,    // SMART Event
    VCA_VEHICLE_DETECTION = 21,    // Vehicle detection
    VCA_SMART_ROAD_DETECTION = 22,    // SMART + Road Detection
    VCA_SMART_FACE_DETECTION = 23,    // SMART + Face Detection
    VCA_SMART_HEATMAP = 24,     // SMART + Heat Map
    VCA_HUMAN_RECOGNITION = 25,       // human recognition
    VCA_EDUCATION_STUDENT_DETECTION = 26,  //education Student Detection
    VCA_ROAD_DETECTION = 27,      //Road Detection
    VCA_PERSON_DENSITY_DETECTION = 28,     //Personnel density detection
    VCA_PERIMETER_CAPTURE = 29,           //Perimeter Capture
    VCA_SAFETY_HELMET_DETECTION = 30,     //Safety helmet detection
    VCA_HEEL_PDC = 31,                     //Heel PDC
    VCA_12MPLIVE_VIEW = 32,                //1200W@20fps Preview
    VCA_TEACHER_BEHAVIOR_DETECTION = 33,    //Teacher behavior detection
    VCA_MIXED_TARGET_DETECTION = 34,        //mixed target detection
    VCA_FACE_CONTRAST = 35,                 //face contrast
    VCA_CITY_MANAGEMENT = 36,                //city manager
    VCA_MIXED_TARGET_DETECTION_SMART = 37    //mixed target detection and Smart
}VCA_CHAN_ABILITY_TYPE;

//Intelligent ATM Mode 
typedef enum _VCA_CHAN_MODE_TYPE_
{
    VCA_ATM_PANEL = 0,  //ATM front panel
    VCA_ATM_SURROUND = 1,  //ATM scenario
    VCA_ATM_FACE = 2,     //ATM face recognition & private ATM face detect
    VCA_ATM_SAFETYCABIN = 3  //ATM safetycabin
}VCA_CHAN_MODE_TYPE;


//Intelligent TFS Mode 
typedef enum _TFS_CHAN_MODE_TYPE_
{
    TFS_CITYROAD = 0,  //TFS city road
    TFS_FREEWAY = 1   //TFS free way
}TFS_CHAN_MODE_TYPE;

//Behavior scene mode
typedef enum _BEHAVIOR_SCENE_MODE_TYPE_
{
    BEHAVIOR_SCENE_DEFAULT = 0, //System default
    BEHAVIOR_SCENE_WALL = 1,    //Wall
    BEHAVIOR_SCENE_INDOOR = 2   //Indoor
}BEHAVIOR_SCENE_MODE_TYPE;

//Prison Mode 
typedef enum _BEHAVIOR_PRISON_MODE_TYPE_
{
    BEHAVIOR_PRISON = 0, //Prison
    BEHAVIOR_HEARING = 1, //Hearing
    BEHAVIOR_RECFIELD = 2  //Recfield
}BEHAVIOR_PRISON_MODE_TYPE, LPBEHAVIOR_PRISON_MODE_TYPE;

//Channel ability input
typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;     //VCA_CHAN_ABILITY_TYPE enum
    BYTE byMode;         //VCA_CHAN_MODE_TYPE for ATM analysis; TFS_CHAN_MODE_TYPE for TFS analysis; when VCA_TYPE is traffic event, please refer to TRAFFIC_SCENE_MODE
    BYTE byRes[2];      //Reserved
}NET_VCA_CHAN_IN_PARAM, *LPNET_VCA_CHAN_IN_PARAM;


//Behavior ability set
typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;          //Structure length
    DWORD dwAbilityType;  //Support ability type by digit, please refer to VCA_ABILITY_TYPE
    BYTE byMaxRuleNum;      //Max. rule number
    BYTE byMaxTargetNum;  //Max. target number
    BYTE    bySupport;         //Function type supported (represented by digit)  
    // bySupport & 0x01 -Calibration
    BYTE byRes[5];         //Reserved as 0
    DWORD dwAbilityTypeEx;  //Support ability type by digit, please refer to VCA_ABILITY_TYPE_EX
}NET_VCA_BEHAVIOR_ABILITY, *LPNET_VCA_BEHAVIOR_ABILITY;

typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD    dwSize;
    BYTE    byIDCount;
    BYTE    byRes1[3];
    BYTE    byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// Traffic ability structure
typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD     dwSize;             //Structure size
    DWORD     dwAbilityType;      //Supported ability list, see to ITS_ABILITY_TYPE
    BYTE     byMaxRuleNum;         //Max number of rules
    BYTE     byMaxTargetNum;     //Max number of targets
    BYTE    byRes[10];            //Reserved
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;

/***********************************end*******************************************/

/************************************Intelligent Parameter Structure*********************************/
//Public structure for intelligent functions
//Coordinates normalized, and the  floating-point value is the percentage of the current screen size
//Take accuracy of three decimal places

//Behavior event type
typedef enum _VCA_EVENT_TYPE_
{
    VCA_TRAVERSE_PLANE = 0x1,        //Traverse plane
    VCA_ENTER_AREA = 0x2,         //Enter area (region rule)
    VCA_EXIT_AREA = 0x4,         //Leave area (region rule)
    VCA_INTRUSION = 0x8,         //Intrusion (region rule)
    VCA_LOITER = 0x10,         //Loitering (region rule)
    VCA_LEFT_TAKE = 0x20,         //Object left or take (region rule)
    VCA_PARKING = 0x40,         //Illegal parking (region rule)
    VCA_RUN = 0x80,         //Running (region rule)
    VCA_HIGH_DENSITY = 0x100,         //People density (region rule)
    VCA_VIOLENT_MOTION = 0x200,      //Violent motion
    VCA_REACH_HIGHT = 0x400,      //Reach high
    VCA_GET_UP = 0x800,      //Get up
    VCA_LEFT = 0x1000,     //Item left
    VCA_TAKE = 0x2000,     //Item take
    VCA_LEAVE_POSITION = 0x4000,     //Leave position
    VCA_TRAIL = 0x8000,     //Trail
    VCA_KEY_PERSON_GET_UP = 0x10000,    //Key person get up
    VCA_STANDUP = 0x20000,    //Stand Up
    VCA_FALL_DOWN = 0x80000,    //Fall down
    VCA_AUDIO_ABNORMAL = 0x100000,   //Audio abnormal
    VCA_ADV_REACH_HEIGHT = 0x200000,   //Advance reach height
    VCA_TOILET_TARRY = 0x400000,   //Toilet tarry
    VCA_YARD_TARRY = 0x800000,   //Yard tarry
    VCA_ADV_TRAVERSE_PLANE = 0x1000000,  //Advance traverse plane
    VCA_LECTURE = 0x2000000,  //Lecture
    VCA_ANSWER = 0x4000000,  //Answer
    VCA_HUMAN_ENTER = 0x10000000, //Human enter ATM, supported only in ATM_PANEL mode
    VCA_OVER_TIME = 0x20000000, //Operation overtime, supported only in ATM_PANEL mode
    VCA_STICK_UP = 0x40000000, //ATM stick up (region rule)
    VCA_INSTALL_SCANNER = 0x80000000  //Install scanner on ATM (region rule)
}VCA_EVENT_TYPE;

//Behavior event type(extended)
typedef enum _VCA_RULE_EVENT_TYPE_EX_
{
    ENUM_VCA_EVENT_TRAVERSE_PLANE = 1,   //Traverse plane
    ENUM_VCA_EVENT_ENTER_AREA = 2,   //Enter area
    ENUM_VCA_EVENT_EXIT_AREA = 3,   //Leave area
    ENUM_VCA_EVENT_INTRUSION = 4,   //Intrusion
    ENUM_VCA_EVENT_LOITER = 5,   //Loitering
    ENUM_VCA_EVENT_LEFT_TAKE = 6,   //Object left or take
    ENUM_VCA_EVENT_PARKING = 7,   //Illegal parking
    ENUM_VCA_EVENT_RUN = 8,   //Running
    ENUM_VCA_EVENT_HIGH_DENSITY = 9,   //People density
    ENUM_VCA_EVENT_VIOLENT_MOTION = 10,  //Violent motion
    ENUM_VCA_EVENT_REACH_HIGHT = 11,  //Reach high
    ENUM_VCA_EVENT_GET_UP = 12,  //Get up
    ENUM_VCA_EVENT_LEFT = 13,  //Item left
    ENUM_VCA_EVENT_TAKE = 14,  //Item take
    ENUM_VCA_EVENT_LEAVE_POSITION = 15,  //Leave position
    ENUM_VCA_EVENT_TRAIL = 16,  //Trail
    ENUM_VCA_EVENT_KEY_PERSON_GET_UP = 17,  //Key person get up
    ENUM_VCA_EVENT_STANDUP = 18,  //Stand Up
    ENUM_VCA_EVENT_FALL_DOWN = 20,  //Fall down
    ENUM_VCA_EVENT_AUDIO_ABNORMAL = 21,  //Audio abnormal
    ENUM_VCA_EVENT_ADV_REACH_HEIGHT = 22,  //Advance reach height
    ENUM_VCA_EVENT_TOILET_TARRY = 23,  //Toilet tarry
    ENUM_VCA_EVENT_YARD_TARRY = 24,  //Yard tarry
    ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //Advance traverse plane
    ENUM_VCA_EVENT_LECTURE = 26,  //Lecture
    ENUM_VCA_EVENT_ANSWER = 27,  //Answer
    ENUM_VCA_EVENT_HUMAN_ENTER = 29,  //Human enter ATM, supported only in ATM_PANEL mode  
    ENUM_VCA_EVENT_OVER_TIME = 30,  //Operation overtime, supported only in ATM_PANEL mode
    ENUM_VCA_EVENT_STICK_UP = 31,  //ATM stick up (region rule)
    ENUM_VCA_EVENT_INSTALL_SCANNER = 32,  //Install scanner on ATM (region rule)
    ENUM_VCA_EVENT_PEOPLENUM_CHANGE = 35,  //People Num Change
    ENUM_VCA_EVENT_SPACING_CHANGE = 36,  //Spacing Change
    ENUM_VCA_EVENT_COMBINED_RULE = 37,  //Combination Events
    ENUM_VCA_EVENT_SIT_QUIETLY = 38,   //Sit Quietly    
    ENUM_VCA_EVENT_HIGH_DENSITY_STATUS = 39,   //People density status
    ENUM_VCA_EVENT_RUNNING = 40, //Run detection
    ENUM_VCA_EVENT_RETENTION = 41, //Detention detection
    ENUM_VCA_EVENT_BLACKBOARD_WRITE = 42,   //Black Board Writing
    ENUM_VCA_EVENT_SITUATION_ANALYSIS = 43,   //Situational analysis
    ENUM_VCA_EVENT_PLAY_CELLPHONE = 44,    //play cellphone
    ENUM_VCA_EVENT_DURATION = 45,     //duration
    ENUM_VCA_EVENT_FAKECARD = 46     //fake card
} VCA_RULE_EVENT_TYPE_EX;

//Traverse plane direction
typedef enum _VCA_CROSS_DIRECTION_
{
    VCA_BOTH_DIRECTION,   // Bi-direction
    VCA_LEFT_GO_RIGHT,    // Left to right
    VCA_RIGHT_GO_LEFT     // Right to left
}VCA_CROSS_DIRECTION;

//Line
typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;     // start point
    NET_VCA_POINT struEnd;       // end point
}NET_VCA_LINE, *LPNET_VCA_LINE;

//Polygon
typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                   //Valid point number , should be no less than 3 
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM];  //Boundary point, up to 10 points for each polygon
}NET_VCA_POLYGON, *LPNET_VCA_POLYGON;

//Traverse plane 
typedef struct tagNET_VCA_TRAVERSE_PLANE
{
    NET_VCA_LINE struPlaneBottom;          //Bottom line of the alarm plane
    VCA_CROSS_DIRECTION dwCrossDirection;  //Traverse direction:  0- bi-directional, 1- left to right, 2- right to left
    BYTE bySensitivity;                    //[1,5]
    BYTE byPlaneHeight;                    //Height of the alarm plane
    BYTE byDetectionTarget;                //DetectionTarget: 0-all, 0x01-Human,0x02-Vehicle,0x04-Others, support mutil select eg. 0x03=0x01+0x02
    BYTE byPriority;                       //byPriority,0-low,1-mid,2-high
    BYTE byAlarmConfidence;                //alarmConfidence, 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRecordConfidence;               //recordConfidence , 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRes2[34];
}NET_VCA_TRAVERSE_PLANE, *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//Region
    DWORD   dwDuration;         // trigger after:  1- 3600 second   
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

//Enter or Leave area
typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion; //Region
    BYTE bySensitivity;        //Sensitiviity,[1,5]
    BYTE byDetectionTarget;    //DetectionTarget:0-all,0x01-Human,0x02-Vehicle,0x04-Others, support mutil select eg. 0x03=0x01+0x02
    BYTE byPriority;//byPriority,0-low,1-mid,2-high
    BYTE byRes[5];
}NET_VCA_AREA, *LPNET_VCA_AREA;

//Mark the alarm snapshot according to the alarm delay time (alarm interval is consistent with IO alarm), send 1 snapshot every second
//Intrusion
typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion; //region
    WORD wDuration;     // trigger after:  1- 120 second, suggested 5 
    BYTE bySensitivity;  //[1-100]
    BYTE byRate;
    BYTE byDetectionTarget;    //DetectionTarget: 0-all, 0x01-Human, 0x02-Vehicle,0x04-Others, support mutil select eg. 0x03=0x01+0x02
    BYTE byPriority;//Priority,0-low,1-mid,2-high
    BYTE byAlarmConfidence;    //alarmConfidence, 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRecordConfidence;   //recordConfidence , 0-low,1-mediumLow,2-mediumHigh,3-high
}NET_VCA_INTRUSION, *LPNET_VCA_INTRUSION;

//Loitering
typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 1- 120 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, [1,5]
    BYTE byres[1];
    DWORD dwLoiterDistance; //Total travel distance threshold 100-5000,default 1000cm
}NET_VCA_LOITER, *LPNET_VCA_LOITER;

//Object left or taken
typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 1- 120 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, value range: [1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT, *LPNET_VCA_TAKE_LEFT;

//Illegal 
typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;     //Region
    WORD wDuration;                 //Trigger after: 1- 100 second, suggested 10
    BYTE bySensitivity;            //Sensitivity, value range: [1,5]
    BYTE byRes[5];
}NET_VCA_PARKING, *LPNET_VCA_PARKING;

//Running
typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion; //Region
    float   fRunDistance;         //Target running distance: [0.1,  1.00]
    BYTE    bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE    byMode;             // 0- pixel mode, 1- actual mode
    BYTE    byDetectionTarget;    //DetectionTarget: 0-All, 0x01-human, 0x02-Vehicle,0x04-Others, support mutil select eg. 0x03=0x01+0x02
    BYTE    byRes;
}NET_VCA_RUN, *LPNET_VCA_RUN;

//People gathering
typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;     //Region
    float fDensity;                 //Density range:  [0.1,  1.0]
    BYTE            bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE            byRes;          //Reserved
    WORD            wDuration;      //Threshold of triggering people aggregation alarm,value: 20-360s
}NET_VCA_HIGH_DENSITY, *LPNET_VCA_HIGH_DENSITY;

//Violent motion
typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion; //Region
    WORD  wDuration;            //Trigger after: 1- 120 second
    BYTE  bySensitivity;        //Sensitivity range: [1, 5]
    BYTE  byMode;               //0-Video only,1-Video and audio,2-Audio only
    BYTE  byRes[4];             //Reserved
}NET_VCA_VIOLENT_MOTION, *LPNET_VCA_VIOLENT_MOTION;

// Reach high
typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;    //Alarm plane
    WORD wDuration;  //Trigger after: 1- 120 second
    BYTE    byRes[6];            // Reserved
}NET_VCA_REACH_HIGHT, *LPNET_VCA_REACH_HIGHT;

// Get up
typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion;  //Region
    WORD    wDuration;           //Trigger after: 1- 100 second
    BYTE    byMode;              //mode,0-big bed,1-wide bed,2-sitting
    BYTE    bySensitivity;       //Sensitivity range:[1,10]
    BYTE    byRes[4];            //Reserved
}NET_VCA_GET_UP, *LPNET_VCA_GET_UP;

// Items left
typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion;        // Region 
    WORD            wDuration;         // Threshold of triggering itmes left alarm, value: 4-60s
    BYTE            bySensitivity;     //[1,5]
    BYTE            byRes[5];          // Reserved
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

//Items take
typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // Region
    WORD            wDuration;      // Threshold of triggering itmes take alarm, value: 4-60s
    BYTE            bySensitivity;  //[1,5]
    BYTE            byRes[5];       // Reserved
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion; // Region
    WORD               wDuration;   // Time threshold of operation alarm, value: 4s-60000s
    BYTE   byRes[6];                // Reserved
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];            //Reserved
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

//ATM stick up
typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  //Trigger after: 4- 60 second, suggested 10 second
    BYTE  bySensitivity;        // Sensitivity range: [1, 5]
    BYTE byRes[5];
}NET_VCA_STICK_UP, *LPNET_VCA_STICK_UP;

//Install scanner on ATM
typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion; //Region
    WORD wDuration;  // Scanner reading time: 4- 60 seconds
    BYTE  bySensitivity;        // Sensitivity range: [1, 5]
    BYTE byRes[5];
}NET_VCA_SCANNER, *LPNET_VCA_SCANNER;

//Leave position
typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //Region
    WORD wLeaveDelay;  //Alarm time of no people, unit: s
    WORD wStaticDelay; //Alarm time of sleeping, unit: s
    BYTE byMode;       //mode,0-leave,1-sleep,2-leave and sleep3-onPosition
    BYTE byPersonType; //Person on guard,0-single,1-couple
    BYTE   byOnPosition; //Number of posts, 1-10, default 1
    BYTE      bySensitivity;     //sensitivity, 1-5
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

//Trail
typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//Region
    WORD  wRes;
    BYTE  bySensitivity;       /* Sensitivity range: [1, 5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

//Fall down
typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//Region
    WORD  wDuration;         /* Threshold of triggering itmes take alarm, value: 1-60s*/
    BYTE  bySensitivity;     /* Sensitivity range: [1, 5] */
    BYTE  byHeightThreshold; //Height Threshold,Range[0,250]
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

//Stand Up
typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //Region
    BYTE  bySensitivity;     //Sensitivity range: [1, 100] 
    BYTE  byHeightThreshold; //Height Threshold,Range[0,250]
    WORD  wDuration;         //Threshold of triggering itmes take alarm, value: 1-60s
    BYTE  byRes[4];
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;


//People Num Change
typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //Region
    BYTE  bySensitivity;        //Sensitivity range: [1, 100] 
    BYTE  byPeopleNumThreshold; //People Num Threshold,range: [0,5]
    BYTE  byDetectMode;         //Detect Mode,Comparison People Num Threshold.1-Greater than,2- less than ,3-equal to ,4-Not equal to 
    BYTE  byNoneStateEffective; //None State Effective,0-Invalid,1-Effective
    WORD  wDuration;  //Threshold of triggering itmes take alarm, value:[1,3600]
    BYTE  byPeopleNum; //Number of alarm triggered, read only
    BYTE  byRes;
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

//Spacing Change
typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //Region
    float fSpacingThreshold; //Spacing Threshold,range: [0,10.0],Unit: M
    BYTE  bySensitivity;     //Sensitivity range: [1, 100] 
    BYTE  byDetectMode;      //Detect Mode,Comparison Spacing Threshold.1-Greater than,2- less than
    WORD  wDuration;  //Threshold of triggering itmes take alarm, value:[1,3600]  
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;

//Audio abnormal
typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //Audio decibel
    BYTE bySensitivity;  //Sensitivity range: [1, 100] 
    BYTE byAudioMode;    //Audio mode,0-enable sensitivity detect,1-enable decibel threshold,2-enable sensitivity and decibel threshold detect
    BYTE byEnable;       //0-disabled,1-enabled
    BYTE byThreshold;    //Sound threshold:[1,100]
    BYTE byRes[54];      //Reserved           
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

//Sound intensity dropped 2014-03-21
typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* Sensitivity [1,100] */
    BYTE  byEnable;        //Enable
    BYTE  byRes[6];
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;

typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;
    NET_DVR_SCHEDTIME           struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD                       dwMaxRelRecordChanNum;
    DWORD                       dwRelRecordChanNum;
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //Sound intensity dropped
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//region
    WORD wDelay;        //delay[1,3600],uint:s
    BYTE byRes[6];
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//region
    WORD wDelay;        //delay[1,120],uint:s
    BYTE byRes[6];
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

//play cellphone
typedef struct tagNET_VCA_PLAY_CELLPHONE
{
    NET_VCA_POLYGON struRegion;//region
    WORD wDuration;    //duration[1,600]s, def 20s
    BYTE byRes[6];     //
}NET_VCA_PLAY_CELLPHONE, *LPNET_VCA_PLAY_CELLPHONE;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //region
    DWORD dwCrossDirection;  //Cross direction(VCA_CROSS_DIRECTION)
    BYTE    byRes[4];        // 
}NET_VCA_ADV_REACH_HEIGHT, *LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //Region
    DWORD   dwCrossDirection;   //Cross direction(VCA_CROSS_DIRECTION)
    BYTE    bySensitivity;      //[1,5] 
    BYTE    byRes[3];            //Reserved
} NET_VCA_ADV_TRAVERSE_PLANE, *LPNET_VCA_ADV_TRAVERSE_PLANE;


typedef struct tagNET_VCA_SITDOWN
{
    NET_VCA_POLYGON struRegion;//Region
    BYTE bySensitivity;//Sensitivity Param[1-100]
    BYTE byRes[7];
}NET_VCA_SITDOWN, *LPNET_VCA_SITDOWN;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//Region
    WORD wDuration; //Duration: [1-10]
    BYTE bySensitivity; //Sensitivity,[1-100]
    BYTE byAlarmState;//Alarm State;0-Retain,1-Alarm Begin,2-Alarm end
    BYTE byTrackingMode;//Tracking Mode,0-Auto(Def),1-Horizontal,2-Vertical
    BYTE byZoomMode;//Zoom Mode, 0-Fixed(Def), 1-Auto
    BYTE byZoomOver;//0-Retain,1-Zoom Over
    BYTE byTrackStatus;
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//Region
    BYTE bySensitivity;//Sensitivity,[1-100]
    BYTE byAlarmState;//Alarm State:0-Retain,1-Alarm Begin,2-Alarm end
    BYTE byZoomOver;//0-Retain,1-Zoom Over
    BYTE byAnswerStudent;//0-Reserve,1-No Students Answer,2-A Student Answer,3-Many Students Answer,4-Auspected A Student Answer, 5-A Student Walk
    BYTE byRes[4];
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

//Rule Struct
typedef struct tagNET_VCA_RELATE_RULE_PARAM
{
    BYTE  byRuleID;  //Rule ID
    BYTE  byRes;
    WORD  wEventType;        //Event Type  See VCA_RULE_EVENT_TYPE_EX
}NET_VCA_RELATE_RULE_PARAM, *LPNET_VCA_RELATE_RULE_PARAM;

//Combined Rule
typedef struct tagNET_VCA_COMBINED_RULE_
{
    //Rule Sequence
    BYTE    byRuleSequence;
    BYTE    byRes[7];
    DWORD  dwMinInterval;    //Min Interval
    DWORD  dwMaxInterval;   //Max Interval
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//Rule1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//Rule2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;

//Writing 
typedef struct  tagNET_VCA_BLACKBOARD_WRITE
{
    NET_VCA_POLYGON struRegion;//Region
    BYTE    byTeacherState;//Teacher State
    BYTE    byWritingState;//Writing State
    BYTE    byWritingArea;//Writing Area
    BYTE    byRes[5];
}NET_VCA_BLACKBOARD_WRITE, *LPNET_VCA_BLACKBOARD_WRITE;

//People gathering status
typedef struct tagNET_VCA_HIGH_DENSITY_STATUS
{
    NET_VCA_POLYGON struRegion;        //Region
    float           fDensity;       //Density range:  [0.1,  1.0]
    BYTE            bySensitivity;    //Sensitivity, value range: [1,5]
    BYTE            byRes[3];
}NET_VCA_HIGH_DENSITY_STATUS, *LPNET_VCA_HIGH_DENSITY_STATUS;

//Run detection
typedef struct _NET_VCA_RUNNING_
{
    NET_VCA_POLYGON  struRegion;  //Regional scope
    DWORD  dwSpeed;      //Running speed, range [1,10]
    BYTE byRes[4];
}NET_VCA_RUNNING, *LPNET_VCA_RUNNING;

//Detention detection
typedef struct tagNET_VCA_RETENTION
{
    NET_VCA_POLYGON struRegion; // Regional scope
    WORD       wDuration;       //Trigger alarm time(60 - 3600 seconds) default 1800 seconds
    BYTE       byRes[6];
}NET_VCA_RETENTION, *LPNET_VCA_RETENTION;

//Situational analysis
typedef struct tagNET_VCA_SITUATION_ANALYSIS
{
    NET_VCA_POLYGON struRegion; // Area range
    WORD       wPeopleNum;       //Number of people in Area
    BYTE       byRes[6];
}NET_VCA_SITUATION_ANALYSIS, *LPNET_VCA_SITUATION_ANALYSIS;

//duration
typedef struct _NET_VCA_DURATION_
{
    WORD   wRelationEventType;  //reference VCA_RULE_EVENT_TYPE_EX
    BYTE   byRes[90];
}NET_VCA_DURATION, *LPNET_VCA_DURATION;

//fake card
typedef struct tagNET_VCA_FAKECARD
{
    NET_VCA_POLYGON struRegion;  // Area range
    BYTE         bySensitivity;  // Sensitivity, value range: [1,5]
    BYTE         byRes[7];
}NET_VCA_FAKECARD, *LPNET_VCA_FAKECARD;

//Alarm event parameters
typedef union tagNET_VCA_EVENT_UNION
{
    DWORD                      uLen[23];             //Parameters
    NET_VCA_TRAVERSE_PLANE     struTraversePlane;     //Traverse plane parameters 
    NET_VCA_AREA               struArea;             //Enter or Leave area
    NET_VCA_INTRUSION          struIntrusion;         //Intrusion
    NET_VCA_LOITER             struLoiter;             //Loitering
    NET_VCA_TAKE_LEFT          struTakeTeft;         //Object left or taken
    NET_VCA_PARKING            struParking;         //Illegal parking
    NET_VCA_RUN                struRun;             //Running
    NET_VCA_HIGH_DENSITY       struHighDensity;     //People gathering  
    NET_VCA_VIOLENT_MOTION     struViolentMotion;   //Violent motion
    NET_VCA_REACH_HIGHT        struReachHight;         //Reach High
    NET_VCA_GET_UP               struGetUp;             //Get up
    NET_VCA_LEFT               struLeft;            //Items left
    NET_VCA_TAKE               struTake;            //Items take
    NET_VCA_HUMAN_ENTER        struHumanEnter;      //Human entrance
    NET_VCA_OVER_TIME          struOvertime;        //Operation overtime
    NET_VCA_STICK_UP            struStickUp;         //ATM stick up
    NET_VCA_SCANNER            struScanner;         //Install scanner on ATM     
    NET_VCA_LEAVE_POSITION     struLeavePos;        //Parameter that leave the position
    NET_VCA_TRAIL              struTrail;           //Trail
    NET_VCA_FALL_DOWN          struFallDown;        //Fall down
    NET_VCA_AUDIO_ABNORMAL     struAudioAbnormal;   //Audio abnormal
    NET_VCA_ADV_REACH_HEIGHT   struReachHeight;     //Advance reach height
    NET_VCA_TOILET_TARRY       struToiletTarry;     //Toilet tarry
    NET_VCA_YARD_TARRY         struYardTarry;       //Yard tarry
    NET_VCA_ADV_TRAVERSE_PLANE struAdvTraversePlane;//Advance traverse plane
    NET_VCA_LECTURE            struLecture;            //Lecture
    NET_VCA_ANSWER             struAnswer;            //Answer
    NET_VCA_STANDUP               struStandUp;         //Stand Up
    NET_VCA_PEOPLENUM_CHANGE   struPeopleNumChange; //People Num Change
    NET_VCA_SPACING_CHANGE     struSpacingChange;   //Spacing Change
    NET_VCA_COMBINED_RULE      struCombinedRule;    //Combined Rule
    NET_VCA_SIT_QUIETLY        struSitQuietly;      //Sit Quietly
    NET_VCA_HIGH_DENSITY_STATUS struHighDensityStatus;        //People gathering status 
    NET_VCA_RUNNING     struRunning; //Running parameters
    NET_VCA_RETENTION   struRetention;//Detention detection
    NET_VCA_BLACKBOARD_WRITE   struBlackboardWrite; //Blackboard Write
    NET_VCA_SITUATION_ANALYSIS   struSituationAnalysis; //Situational analysis
    NET_VCA_PLAY_CELLPHONE    struPlayCellphone; //Play cellphone
    NET_VCA_DURATION            struDruation;//duration
    NET_VCA_FAKECARD           struFakeCard; //fake card
}NET_VCA_EVENT_UNION, *LPNET_VCA_EVENT_UNION;

// Target size filter
typedef enum _VCA_SIZE_FILTER_MODE_
{
    IMAGE_PIX_MODE,   // Set by pixels
    REAL_WORLD_MODE,  // Set by actual size
    DEFAULT_MODE       // Default
}SIZE_FILTER_MODE;
//Size filter
typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;             // Enable filter: 0- disable;  1- enable
    BYTE    byMode;             //SIZE_FILTER_MODE
    BYTE    byRes[2];           //Reserved as 0
    NET_VCA_RECT struMiniRect;  //Min. target region, 0 stands for no region settings
    NET_VCA_RECT struMaxRect;     //Max. target region, 0 stands for no region settings
}NET_VCA_SIZE_FILTER, *LPNET_VCA_SIZE_FILTER;

//Alarm rule configuration
typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;                       //Activate rule settings: 0- disable;  1- enable
    BYTE   byRes[7];                       //Reserved as 0
    BYTE   byRuleName[NAME_LEN];           //Rule name
    VCA_EVENT_TYPE dwEventType;          //VCA event type
    NET_VCA_EVENT_UNION uEventParam;      //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter; //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; // Arm time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle method
    BYTE byRelRecordChan[MAX_CHANNUM_V30];             //Alarm trigger recording channel, 1- trigger recording on this channel
}NET_VCA_ONE_RULE, *LPNET_VCA_ONE_RULE;

typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP;  //PU address  
    WORD wPort;              //PU port number  
    BYTE byChannel;           //PU channel number
    BYTE byIvmsChannel;     // Ivms channel
} NET_VCA_DEV_INFO, *LPNET_VCA_DEV_INFO;

//VCA configuration structure
typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;             //Structure length
    BYTE    byPicProType;     //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE    byUpLastAlarm;  //2011-04-06 Whether upload last alarm firstly 
    BYTE   byPicRecordEnable;  /*2012-3-1 Whether record picture, 0-no,1-yes*/
    BYTE    byRes;
    NET_DVR_JPEGPARA struPictureParam;          //snapshot structure
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];   //Rule array
}NET_VCA_RULECFG, *LPNET_VCA_RULECFG;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize;
    DWORD     dwRelativeTime;
    DWORD        dwAbsTime;
    NET_VCA_DEV_INFO  struDevInfo;
    BYTE     byTargetType;
    BYTE     byLeftDirection;
    BYTE     byTargetStatus;
    BYTE     byRes[125];
}NET_DVR_TARGET_LEFT_REGION_ALARM, *LPNET_DVR_TARGET_LEFT_REGION_ALARM;

/* dbd alarm pic info */
typedef struct
{
    /*20-smoke, 21-using cellphone , 22-Fatigue driving , 23-The driver has no visual front, 24-no head, 25-has belt,
    26-Drivers pick up items, 27-Driver yawning, 28-drinking or eating, 29-chatting, 31-Drivers are not wearing work clothes*/
    DWORD dwPicType;                /* picture type */
    char *pPicBuf;                  /* xxx.jpg*/
    DWORD dwPicLen;                 /* picture length */
    DWORD dwTime;                   /* capture time */
    char *pVideoBuf;                 /* xxx.mp4*/
    DWORD dwVideoLen;               /* video length 20180518 */
    BYTE byRes[12];                /* res */
}NET_DVR_DBD_PICTURE_INFO, *LPNET_DVR_DBD_PICTURE_INFO;

/* dbd position info */
typedef struct
{/* 24 bytes */
    DWORD bValid;                   /* 1-valid */
    DWORD dwLongitude;              /* Longitude */
    DWORD dwLatitude;               /* Latitude */
    DWORD dwVehicleSpeed;           /* speed */
    DWORD dwVehicleDirection;       /* direction */
    DWORD dwAltitude;                  /* Altitude cm */
}NET_DVR_DBD_POSITION_INFO, *LPNET_DVR_DBD_POSITION_INFO;

/* dbd alarm state */
typedef struct
{/* 24 bytes */
    BYTE bySmoke;              /* smoke */
    BYTE byPhone;              /* uphone */
    BYTE byTiredDriving;       /* tired driving */
    BYTE byNoVisualFront;      /* no visual front */
    BYTE byNoHead;             /* no head */
    BYTE byWithoutBelt;        /* without belt */
    BYTE byPickingUpThing;     /* picking up thing */
    BYTE byYawn;               /* yawm */
    BYTE byEatOrDrink;         /* eat or drink something */
    BYTE byChatting;           /* chatting */
    BYTE byTampering;          /* tampering camera */
    BYTE byWithoutUniform;     /* without uniform */
    BYTE byDriverCmpFail;     /* Driver Cmp Fail*/
    BYTE byDriverChange;         /* Driver Change*/
    BYTE byDriveLongTime;     /*Drive Long Time*/
    BYTE byInfraredBlockingSunglasses;   /* Infrared Blocking Sunglasses */
    BYTE byOutOfWheel;    /* 0- reserve, 1- take one hand off the wheel, 2- take both hands off the wheel */
    BYTE byRes[7];
}NET_DVR_DBD_ALARM_STATE, *LPNET_DVR_DBD_ALARM_STATE;

/* dbd amarm info */
typedef struct
{
    DWORD dwSize;               /* size */
    BYTE byChannel;            /* channel*/
    BYTE byLevel;              /*alarm level, 1*/
    BYTE byRes1[2];            /* res*/
    NET_VCA_DEV_INFO struIpcInfo;       		/* ipc info 24*/
    NET_DVR_DBD_POSITION_INFO struPosInfo;  /* position info  24*/
    NET_DVR_DBD_PICTURE_INFO struPicInfo;   /* picture info*/
    NET_DVR_DBD_ALARM_STATE struAlarmState; /* alarm state 24*/
    BYTE byRes2[20];           /* res   20*/
}NET_DVR_DBD_ALRAM_INFO, *LPNET_DVR_DBD_ALRAM_INFO;

/* ADAS alarm picture info */
typedef struct
{
    DWORD dwPicType;                /* picture type */
    char *pPicBuf;                  /* xxx.jpg */
    DWORD dwPicLen;                 /* picture length */
    DWORD dwTime;                   /* capture time */
    char *pVideoBuf;                /* xxx.mp4 */
    DWORD dwVideoLen;               /* video length 20180518 */
    BYTE byRes[12];                /* res */
} NET_DVR_ADAS_PICTURE_INFO, *LPNET_DVR_ADAS_PICTURE_INFO;

/* ADAS alarm position info */
typedef struct
{/* 24 bytes */
    DWORD dwValid;                   /* 1-valid */
    DWORD dwLongitude;              /* Longitude */
    DWORD dwLatitude;               /* Latitude */
    DWORD dwVehicleSpeed;           /* speed */
    DWORD dwVehicleDirection;       /* vehicle direction */
    DWORD dwAltitude;                  /* Altitude */
}NET_DVR_ADAS_POSITION_INFO, *LPNET_DVR_ADAS_POSITION_INFO;

/* ADAS alarm state */
typedef struct
{/* 24 bytes */
    BYTE dwFcw;              /* 0-none, 1-event occurrence*/
    BYTE dwLdw;              /* 0-none, 1-left, 2-right */
    BYTE dwHmw;       		 /* 0-none, 1-event occurrence*/
    BYTE dwPcw;      		 /* 0-none, 1-event occurrence*/
    BYTE dwBsd;             /* 0-none, 1-event occurrence, 2 - right blind area alarm, 3 - left blind area alarm, 4 - back blind area alarm*/
    BYTE byAcc;      	    /* accelerate,0-none, 1-event occurrence*/
    BYTE byBrake;      	    /*sharp,0-none, 1-event occurrence */
    BYTE byTurn;      	    /* turn,0-none, 1-left, 2-right*/
    BYTE byRollover;        /* rollover,0-none, 1-event occurrence*/
    BYTE byNoCourtesy;      /* no courtesy,0-none, 1-event occurrence */
    BYTE byTsr;             /*tsr,0- none, 1- speed limit, 2- height limit, 3- width limit*/
    BYTE byRes[13];
}NET_DVR_ADAS_ALARM_STATE, *LPNET_DVR_ADAS_ALARM_STATE;

/* ADAS alarm info */
typedef struct
{
    DWORD dwSize;               /* size */
    BYTE byChannel;            /* channel*/
    BYTE byRes1[3];            /* res*/
    NET_VCA_DEV_INFO struIpcInfo;       		/* ipc info 28*/
    NET_DVR_ADAS_POSITION_INFO struPosInfo;  /* position info 24*/
    NET_DVR_ADAS_PICTURE_INFO struPicInfo;   /* pciture info*/
    NET_DVR_ADAS_ALARM_STATE struAlarmState; /* alarm state 24*/
    BYTE byRes2[20];           /* res   20*/
}NET_DVR_ADAS_ALRAM_INFO, *LPNET_DVR_ADAS_ALRAM_INFO;

/* realtime vehicel info */
typedef struct
{
    DWORD dwSize;
    DWORD dwSpeedValue;         /* speed */
    DWORD dwSpeedPulse;         /* speed pulse */
    BYTE byUpgPercent;         /* upgrade progress,0-100,return 255 when failed, return 0 when started*/
    BYTE byRes1[3];
    DWORD dwVideoLostChans;    /*each bit stands for one channel, 0-normal, 1-videoloss*/
    BYTE byRes2[44];
}NET_DVR_VEH_REALTIME_DATA_INFO, *LPNET_DVR_VEH_REALTIME_DATA_INFO;

#define VCA_ATTEND_MAX_PIC_NUM            3             //Maximum number of pictures of attendance event
#define VCA_ATTEND_DRIVER_NAME_LEN        64            //Group information driver name length
#define VCA_ATTEND_CARD_ID_LEN            32            //Group information driver id number length
#define VCA_ATTEND_MAX_ALARM_ID_LEN       32            //The maximum length of the unique number of the alarm event

typedef struct
{
    DWORD  dwPicLen;    //When the length of alarm picture is 0, it means there is no picture
    char   *pPicBuf;    //Picture pointer
    BYTE   byRes[12];   //reserve 
}NET_DVR_VCA_ATTEND_PICDATA, *LPNET_DVR_VCA_ATTEND_PICDATA;

/* Attendance event picture information */
typedef struct
{
    BYTE   byPicNum;    //Number of attendance pictures
    BYTE   byRes1[3];   //reserve
    NET_DVR_VCA_ATTEND_PICDATA struPicData[VCA_ATTEND_MAX_PIC_NUM]; //Alarm picture data
    DWORD  dwVideoLen;  //Grasp the length of figure video, 0 means there is no alarm video
    char   *pVideoBuf;  //Video pointer
    BYTE   byRes[64];   //reserve 
}NET_DVR_VCA_ATTEND_PICTURE_INFO, *LPNET_DVR_VCA_ATTEND_PICTURE_INFO;

/* Upload information about attendance events*/
typedef struct
{
    DWORD  dwSize;         // Alarm upload structure size
    BYTE   byMethod;       //Attendance mode 0-ic card attendance,1- face attendance
    BYTE   byStatus;       //Attendance status 0- reserved, 1- on duty,2- off duty (no face or shift)
    BYTE   byCertIDType;   //Driver certificate type: 0-operation qualification certificate, 1-id card
    BYTE   byCertIDLen;    //Code length of driver's license
    char   sCertId[VCA_ATTEND_CARD_ID_LEN];           //Driver's license code
    DWORD  dwTime;         //Attendance time
    char   sName[VCA_ATTEND_DRIVER_NAME_LEN];         //Driver's name
    char   sAlarmIdNo[VCA_ATTEND_MAX_ALARM_ID_LEN];   //Alarm identification number
    NET_DVR_VCA_ATTEND_PICTURE_INFO struPicInfo;     //Alarm picture information
    BYTE   byRes[128];     //reserve
}NET_DVR_VCA_ATTEND_ALARM_INFO, *LPNET_DVR_VCA_ATTEND_ALARM_INFO;


//Size filter strategy
typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //0 - Disabled, 1-Width and height filter,2-Area filter
    BYTE    byRes[11];       //Reserved
}NET_VCA_FILTER_STRATEGY, *LPNET_VCA_FILTER_STRATEGY;

//Rule trigger param
typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //Trigger mode,0- Disabled,1- Track point, 2- Target area 
    BYTE   byTriggerPoint;  //Trigger point,effective when track point is enabled, 0- Center,1-Up,2-Down
    BYTE   byRes1[2];       //Reserved
    float  fTriggerArea;    //Trigger area percent [0,100],effective when target area is enabled
    BYTE   byRes2[4];       //Reserved
}NET_VCA_RULE_TRIGGER_PARAM, *LPNET_VCA_RULE_TRIGGER_PARAM;


//Alarm rule configuration
typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //Activate rule settings: 0- disable;  1- enable
    BYTE   byRes1[4];
    BYTE   byEventTypeFlag;  //Event Type Flag,0-dwEventType Effective,1-wEventTypeEx Effective                      
    WORD   wEventTypeEx; //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //Rule name
    VCA_EVENT_TYPE dwEventType;    //Event type,It is kept only for compatibility,in your new code,use wEventTypeEx instead
    NET_VCA_EVENT_UNION uEventParam; //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter; //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// Arm time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle method
    BYTE   byRelRecordChan[MAX_CHANNUM_V30];       //Alarm trigger recording channel, 1- trigger recording on this channel
    WORD   wAlarmDelay; //Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2];                              //Reserved
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //Size filter strategy
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //Rule trigger param
    BYTE    byRes[32];                              //Reserved
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

//VCA configuration structure
typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;
    BYTE   byPicProType;    //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE   byUpLastAlarm; //2011-04-06 Whether upload last alarm firstly
    BYTE   byPicRecordEnable;  /*2012-3-1 Whether to enable the image storage, 0-Not enabled, 1-enabled*/
    BYTE   byRes1;
    NET_DVR_JPEGPARA struPictureParam;         //snapshot structure
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //Rule array
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE   byRes[26]; //Reserved
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

typedef struct NET_VCA_ONE_RULE_V42_
{
    BYTE           byActive;       //Activate rule settings: 0- disable;  1- enable
    BYTE        byEventPriority;//Event Priority 0-low,1-mid,2-high
    BYTE        byBackgroundSuppression;//0-close 1-open 2-auto
    BYTE           byRes1[3];
    WORD          wEventType;        //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE        byRuleName[NAME_LEN/*32*/];        //Rule Name
    NET_VCA_EVENT_UNION  uEventParam;            //VCA event parameters
    NET_VCA_SIZE_FILTER  struSizeFilter;          //Size filter
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; //Alarm Handle Type
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];    //Alarm trigger recording channel, 1- trigger recording on this channel
    WORD          wAlarmDelay; //Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE           byRes2[2];
    NET_VCA_FILTER_STRATEGY     struFilterStrategy;  //Size filter strategy
    NET_VCA_RULE_TRIGGER_PARAM     struTriggerParam;    //Rule trigger param
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;

typedef struct    tagNET_DVR_PTZ_POSITION
{
    // Enable/disable the video scene functions (for speed dome local video scene position configuration) , invalid for video scene rule configuration mode,
    BYTE byEnable;
    BYTE byRes1[3];   //Reserved
    BYTE byPtzPositionName[NAME_LEN];  //Video scene position name
    NET_DVR_PTZPOS struPtzPos;  //PTZ  coordinates
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION, *LPNET_DVR_PTZ_POSITION;

//VCA configuration structure V42
typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD        dwSize;
    BYTE           byPicProType;        //0- do not upload snapshot;  1 - Upload  snapshot on VCA alarm
    BYTE        byUpLastAlarm;         //Whether upload last alarm firstly
    BYTE        byPicRecordEnable;  //Whether to enable the image storage, 0-Not enabled, 1-enabled
    BYTE        byRes1;
    NET_DVR_JPEGPARA       struPicParam;         //snapshot structure
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42/*16*/];       //Rule array
    WORD        wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE        byTrackEnable; //Track Enable
    BYTE        byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //PTZ Position
    WORD        wTrackDuration; //Track Duration
    WORD            wIntervalTime; //Single alarm interval (seconds) [1-7200] (default is 600)
    WORD            wHeightLimit;//Target detection height limit (CM) [0-250] (default 80cm), less than the height of the target will not be detected as a target
    BYTE            byRes[58];
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;

//Simplified target info structure
typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;                 //Target ID, the target ID will be 0 on high density alarm
    NET_VCA_RECT struRect;       //target brim rectangle
    BYTE      byRes[4];             //Reserved
}NET_VCA_TARGET_INFO, *LPNET_VCA_TARGET_INFO;

//Simplified rule info
typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;              //Rule ID, 0- 7
    BYTE   bySceneID;             //Scenario ID, return 0 invalid
    WORD   wEventTypeEx;         //Event type,substitute for dwEventType,refer to VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //Rule name
    VCA_EVENT_TYPE  dwEventType; //Event type,It is kept only for compatibility,in your new code,use wEventTypeEx instead
    NET_VCA_EVENT_UNION uEventParam; //Event parameters
}NET_VCA_RULE_INFO, *LPNET_VCA_RULE_INFO;

//PU address info, (address of connected IP device for iVMS, or local address for the other intelligent devices)
// typedef struct tagNET_VCA_DEV_INFO
// {
//     NET_DVR_IPADDR  struDevIP;  //PU address  
//     WORD wPort;              //PU port number  
//     BYTE byChannel;           //PU channel number
//     BYTE byIvmsChannel;     // Ivms channel
// } NET_VCA_DEV_INFO,  *LPNET_VCA_DEV_INFO; 

//VCA upload info
typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;                         //Structure length
    DWORD    dwRelativeTime;                 //if byRelativeTimeFlag is true,  dwRelativeTime represent UTC time stamp
    DWORD    dwAbsTime;                     //Absolute time stamp
    NET_VCA_RULE_INFO     struRuleInfo;     //Event rule info
    NET_VCA_TARGET_INFO  struTargetInfo;     //Alarm target info
    NET_VCA_DEV_INFO       struDevInfo;         //PU device info
    DWORD    dwPicDataLen;     //Return snapshot length, 0- no snapshot;  others- snapshot data size followed*/
    BYTE     byPicType;    //0- normal picture, 1- contrast picture 
    BYTE     byRelAlarmPicNum; //Related alarm picture number
    BYTE     bySmart;   //IDS DEV Return 0(default),Smart Functiom Return 1
    BYTE     byPicTransType;        //Image data transmission: 0-binary; 1-url
    DWORD    dwAlarmID; //Alarm ID,marking the same group of alarmls,0-unused
    WORD     wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE     byRelativeTimeFlag;      /* dwRelativeTime is valid or not 0-invalid 1-valid */
    BYTE     byAppendInfoUploadEnabled; //Append Info Upload Enabled 0-n 1-y
    BYTE     *pAppendInfo;     //to NET_VCA_APPEND_INFO point,byAppendInfoUploadEnabled=1 avilibled
    BYTE     *pImage;    //Pointer to the snapshot picture
}NET_VCA_RULE_ALARM, *LPNET_VCA_RULE_ALARM;

typedef struct tagNET_VCA_APPEND_INFO
{
    DWORD   dwSize;
    DWORD   dwAppendPicLen;
    BYTE*   pAppendPicBuff;
    BYTE    byAppendPicType;
    BYTE    byUID[64];
    BYTE    byRes1[3];
    DWORD   dwTargetSpeed;  //speed,km/h
    DWORD   dwTargetDistance;  //distance,m
    BYTE    byAlarmType;// 0-vedio 1-radar
    BYTE    byRadarChannel; //radar channel,1,2,3,...
    BYTE    byRes2; 
    BYTE    byAppendChannelType;//0-res;1-visible channel;2-themetry channel;
    DWORD   dwAppendChannel; 
    BYTE    byRes[44];
}NET_VCA_APPEND_INFO, *LPNET_VCA_APPEND_INFO;


//VCA info overlay via DSP
typedef struct tagNET_VCA_DRAW_MODE
{
    DWORD  dwSize;
    BYTE    byDspAddTarget;         //Overlay target info during encoding
    BYTE    byDspAddRule;             //Overlay rule info during encoding
    BYTE    byDspPicAddTarget;         //Overlay target info for snapshot
    BYTE    byDspPicAddRule;         //Overlay rule info for snapshot
    BYTE    byRes[4];
}NET_VCA_DRAW_MODE, *LPNET_VCA_DRAW_MODE;

//Object type
typedef enum tagOBJECT_TYPE_ENUM
{
    ENUM_OBJECT_TYPE_COAT = 1  //coat
}OBJECT_TYPE_ENUM;

//Object color condition
typedef struct tagNET_DVR_OBJECT_COLOR_COND
{
    DWORD  dwChannel;   //Channel number
    DWORD  dwObjType;   //Object type,refer to OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //Reserved
}NET_DVR_OBJECT_COLOR_COND, *LPNET_DVR_OBJECT_COLOR_COND;

//Picture parameters
typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //Picture type,1-jpg
    BYTE   byRes1[3];        //Reserved
    DWORD  dwPicWidth;       //Picture width
    DWORD  dwPicHeight;      //Picture height
    DWORD  dwPicDataLen;     //Picture data length
    DWORD  dwPicDataBuffLen; //Picture buffer size
    BYTE*  byPicDataBuff;    //Picture buffer pointer
    BYTE   byRes2[40];       //Reserved
}NET_DVR_PIC, *LPNET_DVR_PIC;

//Object color union
typedef union tagNET_DVR_OBJECT_COLOR_UNION
{
    NET_DVR_COLOR  struColor;   //Color value
    NET_DVR_PIC    struPicture; //Picture
    BYTE           byRes[64];   //Reserved
}NET_DVR_OBJECT_COLOR_UNION, *LPNET_DVR_OBJECT_COLOR_UNION;

//Object color paraemters
typedef struct tagNET_DVR_OBJECT_COLOR
{
    DWORD  dwSize;       //Structure size
    BYTE   byEnable;     //0-disabled,1-enabled
    BYTE   byColorMode;  //Color mode,1-from color value,2-from picture
    BYTE   byRes1[2];    //Reserved
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //Object color union,depends on the value of byColorMode
    BYTE   byRes2[64];   //Reserved
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;

//Area type
typedef enum tagAREA_TYPE_ENUM
{
    ENUM_OVERLAP_REGION = 1,//Overlap region
    ENUM_BED_LOCATION = 2   //Bed location
}AREA_TYPE_ENUM;

//Auxiliary area
typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //Area type,refer to AREA_TYPE_ENUM
    BYTE   byEnable;     //0-disabled,1-enabled
    BYTE   byRes1[3];    //Reserved
    NET_VCA_POLYGON struPolygon; //Area polygon
    BYTE   byRes2[16];   //Reserved
}NET_DVR_AUXAREA, *LPNET_DVR_AUXAREA;

//Auxiliary area list
typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD     dwSize;    //Structure size
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //Auxiliary area list
    BYTE    byRes2[64];    //Reserved
}NET_DVR_AUXAREA_LIST, *LPNET_DVR_AUXAREA_LIST;

//Channel workmode
typedef enum tagCHAN_WORKMODE_ENUM
{
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //Independent
    ENUM_CHAN_WORKMODE_MASTER = 2,      //Master
    ENUM_CHAN_WORKMODE_SLAVE = 3        //Slave
}CHAN_WORKMODE_ENUM;

//Channel workmode parameters
typedef struct tagNET_DVR_CHANNEL_WORKMODE
{
    DWORD dwSize;        //Structure size
    BYTE  byWorkMode;    //Workmode,refer to CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //Reserved
}NET_DVR_CHANNEL_WORKMODE, *LPNET_DVR_CHANNEL_WORKMODE;

//Device channel
typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];    //Device ip or domain name
    WORD   wDVRPort;                     //Port
    BYTE   byRes1[2];                   //Reserved
    BYTE   sUserName[NAME_LEN];            //Username
    BYTE   sPassword[PASSWD_LEN];       //Password
    DWORD  dwChannel;                   //Channel number
    BYTE   byRes2[32];                  //Reserved
}NET_DVR_CHANNEL, *LPNET_DVR_CHANNEL;

//Slave channel union
typedef union tagNET_DVR_SLAVE_CHANNEL_UNION
{
    BYTE            byRes[152];        //Reserved
    DWORD           dwLocalChannel;    //Local channel
    NET_DVR_CHANNEL struRemoteChannel; //Remote channel
}NET_DVR_SLAVE_CHANNEL_UNION, *LPNET_DVR_SLAVE_CHANNEL_UNION;

//Slave channel parameters
typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //Slave channel type,1-local,2-remote
    BYTE   byRes1[3];    //Reserved
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //Slave channel union,depends on the value of byChanType
    BYTE   byRes2[64];   //Reserved
}NET_DVR_SLAVE_CHANNEL_PARAM, *LPNET_DVR_SLAVE_CHANNEL_PARAM;


//Slave channel config parameters
typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{
    DWORD dwSize;   //Structure size
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//Slave channel list
    BYTE  byRes[64];  //Reserved
}NET_DVR_SLAVE_CHANNEL_CFG, *LPNET_DVR_SLAVE_CHANNEL_CFG;

//Video quality diagnostic detect event
typedef enum tagVQD_EVENT_ENUM
{
    ENUM_VQD_EVENT_BLUR = 1,  //Image blurring
    ENUM_VQD_EVENT_LUMA = 2,  //Brightness abnormal 
    ENUM_VQD_EVENT_CHROMA = 3,  //Color cast
    ENUM_VQD_EVENT_SNOW = 4,  //Snow
    ENUM_VQD_EVENT_STREAK = 5,  //Streak
    ENUM_VQD_EVENT_FREEZE = 6,  //Freeze
    ENUM_VQD_EVENT_SIGNAL_LOSS = 7,  //Signal loss
    ENUM_VQD_EVENT_PTZ = 8,  //Ptz out of control
    ENUM_VQD_EVENT_SCNENE_CHANGE = 9,  //Scene change
    ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10, //Video abnormal
    ENUM_VQD_EVENT_VIDEO_BLOCK = 11, //Video block
    ENUM_VQD_EVENT_CLARTY       = 12, //
    ENUM_VQD_EVENT_JITTER       = 13, //
    ENUM_VQD_EVENT_FLOWERS      = 14,
    ENUM_VQD_EVENT_NOISE        = 15,
    ENUM_VQD_EVENT_GHOST        = 16,
    ENUM_VQD_EVENT_PURPLE       = 17,
    ENUM_VQD_EVENT_ICR          = 18,
    ENUM_VQD_EVENT_PROTECTFILM  = 19
}VQD_EVENT_ENUM;

//Video quality diagnostic event condition
typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //Channel number
    DWORD dwEventType; //Event type,refer to VQD_EVENT_ENUM
    BYTE  byRes[64];   //Reserved
}NET_DVR_VQD_EVENT_COND, *LPNET_DVR_VQD_EVENT_COND;

//Video quality diagnostic event parameters
typedef struct tagNET_DVR_VQD_EVENT_PARAM
{
    BYTE   byThreshold;    //Alarm threshold [0,100]
    BYTE   byTriggerMode;  //Trigger mode,1-continuous,2-single
    BYTE   byUploadPic;    //0-Upload alarm picture,1-Not upload alarm pic,Whether or not,you can always get the lastest alarm picture of certain VQD event, refer to NET_DVR_StartDownload
    BYTE   byRes1;         //Reserved
    DWORD  dwTimeInterval; //Continuous alarm time interval(seconds)
    BYTE   byRes2[64];     //Reserved
}NET_DVR_VQD_EVENT_PARAM, *LPNET_DVR_VQD_EVENT_PARAM;

//Video quality diagnostic event rule
typedef struct tagNET_DVR_VQD_EVENT_RULE
{
    DWORD  dwSize;       //Structure size 
    BYTE   byEnable;     //0-disabled,1-enabled
    BYTE   byRes1[3];    //Reserved
    NET_DVR_VQD_EVENT_PARAM struEventParam; //VQD event parameters
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Detect time
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //Handle method
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE   byRes2[128];   //Reserved
}NET_DVR_VQD_EVENT_RULE, *LPNET_DVR_VQD_EVENT_RULE;

//Baseline scene parameters
typedef struct tagNET_DVR_BASELINE_SCENE
{
    DWORD dwSize;     //Structure size
    BYTE  byEnable;   //0-disabled,1-enabled
    BYTE  byRes[63];  //Reserved
}NET_DVR_BASELINE_SCENE, *LPNET_DVR_BASELINE_SCENE;

//Operation of baseline scene
typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{
    DWORD dwSize;     //Structure size
    DWORD dwChannel;  //Channel number
    BYTE  byCommand;  //Operation type,1-Just reserved for future use,2-Update baselien scene
    BYTE  byRes[127];  //Reserved
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM, *LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//Video quality diagnostic alarm
typedef struct tagNET_DVR_VQD_ALARM
{
    DWORD  dwSize;                //Structure size
    DWORD  dwRelativeTime;        //Relative time
    DWORD  dwAbsTime;              //Absolute time
    NET_VCA_DEV_INFO struDevInfo; //device info
    DWORD  dwEventType;           //VQD event type,refer to VQD_EVENT_ENUM
    float  fThreshold;            //Alarm threshold [0.000,1.000]
    DWORD  dwPicDataLen;          //Alarm picture data,if 0, there is no picture uploaded
    BYTE   *pImage;               //Pointer to picture data           
    BYTE   byRes[128];            //Reserved
}NET_DVR_VQD_ALARM, *LPNET_DVR_VQD_ALARM;

//Sub structure for calibration point
typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;      //calibration point, main camera (fixed camera) 
    NET_DVR_PTZPOS struPtzPos;    //Input PTZ position of the speed dome
    BYTE    byRes[8];
}NET_DVR_CB_POINT, LPNET_DVR_CB_POINT;

//Calibration parameters
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{
    BYTE byPointNum;             //Valid calibration
    BYTE byRes[3];
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT];  //Valid calibration group
}NET_DVR_TRACK_CALIBRATION_PARAM, *LPNET_DVR_TRACK_CALIBRATION_PARAM;

//Speed Dome configuration
typedef struct tagNET_DVR_TRACK_CFG
{
    DWORD dwSize;                       //Structure size    
    BYTE byEnable;                     //Enable/disable calibration
    BYTE byFollowChan;              //Corresponding channel calibrated
    BYTE byDomeCalibrate;             //Set calibration for auto-tracking speed dome, 1-enable, 0-disable 
    BYTE byRes;                     //Reserved
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam;  //Calibration group
}NET_DVR_TRACK_CFG, *LPNET_DVR_TRACK_CFG;

//Tracking mode
typedef enum _TRACK_MODE_
{
    MANUAL_CTRL = 0,   //Manual tracking
    ALARM_TRACK,       //Alarm triggering tracking
    TARGET_TRACK       //Target tracking
}TRACK_MODE;

//Manual control mode
typedef struct tagNET_DVR_MANUAL_CTRL_INFO
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO, *LPNET_DVR_MANUAL_CTRL_INFO;

//Tracking mode
typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;            //Structure size
    BYTE byTrackMode;      //Tracking mode
    BYTE byRuleConfMode;   //Configuration of tracking mode: 0- local tracking mode config, 1- remote tracking mode config
    BYTE byRes[2];         //Reserved
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl; //Manual tracking structure
    }uModeParam;
}NET_DVR_TRACK_MODE, *LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;             //Upload snapshot on alarm 0- disable;  1- upload
    BYTE    byRes[3];               //Reserved
    NET_DVR_JPEGPARA struPicParam;  //Snapshot structure
}NET_DVR_ALARM_JPEG, *LPNET_DVR_ALARM_JPEG;

/**********************ipc/d5.3.0********************************/
typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//SlaveCamera ID number [1,4]
    BYTE             byRes1[3];
    DWORD           dwSceneID;// scene Id 
    BYTE             byRes[56];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE                 byAddressType;   //0-ipv4 ipv6 1-domain
    WORD                wPort;
    BYTE               byLoginStatus; /*Slave Camera Login Status 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;
        } struAddrIP;
    }unionServer;
    BYTE                szUserName[NAME_LEN/*32*/];
    BYTE                szPassWord[PASSWD_LEN/*16*/];
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus;// 0- offline,1-online
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{
    float fPan;
    float fTilt;
    float fZoom;
    DWORD dwFocus;//0-100000
    BYTE  byRes[4];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_BV_CALIB_POSITION
{
    DWORD  dwSize;
    NET_PTZ_INFO struInitialPos;  //Initial Position
    NET_PTZ_INFO struAdjustPos;  //Adjust Position
    BYTE  byRes[300];
}NET_DVR_BV_CALIB_POSITION, *LPNET_DVR_BV_CALIB_POSITION;

typedef struct tagNET_DVR_HUMAN_CALIB_CFG
{
    DWORD  dwSize;
    NET_VCA_POINT struLeftPos;   //Human left position
    NET_VCA_POINT struRightPos;  //Human right position
    BYTE  byRes[300];
}NET_DVR_HUMAN_CALIB_CFG, *LPNET_DVR_HUMAN_CALIB_CFG;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;
    int                iHorValue;
    int                iVerValue;
    BYTE      byRes[8];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE              byCalibMode;//0-res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;
    BYTE byEnable;      // 0-false,1-true
    BYTE byMode;        // 0-close,1-manual,2-auto
    WORD  wTrackingTime;// tracking Time:[0,60]s
    NET_VCA_POLYGON struRegion;
    BYTE byRes[64];
}NET_DVR_TRACKING, *LPNET_DVR_TRACKING;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V50
{
    DWORD            dwSize;
    BYTE               byCalibMode;//0-Res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_V50, *LPNET_DVR_SLAVECAMERA_CALIB_V50;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V51
{
    DWORD            dwSize;
    BYTE                byCalibMode;//0-Res,1-auto, 2-manual
    BYTE             byRes[3];
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE            byRes1[512];
}NET_DVR_SLAVECAMERA_CALIB_V51, *LPNET_DVR_SLAVECAMERA_CALIB_V51;

//The special features at the structure (eagle eye) 
typedef    struct tagNET_DVR_CAPTURE_PICTURE_RESULT
{
    DWORD        dwSize;//The structure size 
    DWORD    dwReturnPicSize;//Returns the size of the image 
    BYTE        byRes[256];
}NET_DVR_CAPTURE_PICTURE_RESULT, *LPNET_DVR_CAPTURE_PICTURE_RESULT;

typedef struct tagNET_DVR_GOTOSCENE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    DWORD            dwSceneID;//scene id
    BYTE              byRes[512];
}NET_DVR_GOTOSCENE_COND, *LPNET_DVR_GOTOSCENE_COND;

typedef struct tagNET_DVR_TRACK_INITPOSTION
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;
    BYTE             byRes[127];
}NET_DVR_TRACK_INITPOSTION, *LPNET_DVR_TRACK_INITPOSTION;

typedef struct tagNET_DVR_MANUAL_TRACKRATIO
{
    DWORD            dwSize;
    BYTE             byCoefficient;//Track Ratio Coefficient [1,60]
    BYTE             byRes[127];
}NET_DVR_MANUAL_TRACKRATIO, *LPNET_DVR_MANUAL_TRACKRATIO;

/**********************ipc/d5.3.0********************************/

//iVMS rule structure
//Alarm rule structure
typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;            /* active the rule, 0- disable,  else- yes */
    BYTE    byRes1[7];     //Reserved as 0
    BYTE   byRuleName[NAME_LEN];  //Rule name
    VCA_EVENT_TYPE dwEventType;    //VCA event type
    NET_VCA_EVENT_UNION uEventParam; //VCA parameters
    NET_VCA_SIZE_FILTER  struSizeFilter;   //Size filter
    BYTE byRes2[68];  /*Reserved as 0*/
}NET_IVMS_ONE_RULE, *LPNET_IVMS_ONE_RULE;

// iVMS rule structure
typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];    //rule array
}NET_IVMS_RULECFG, *LPNET_IVMS_RULECFG;

// IVMS VCA configuration structure
typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;         //Upload snapshot on alarm: 0-disable;  else- upload
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam;                  //snapshot structure
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT]; //corresponding rule on each time period
} NET_IVMS_BEHAVIORCFG, *LPNET_IVMS_BEHAVIORCFG;

//Sub structure of the iVMS sub stream query
typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME     struTime;        //time structure
    NET_DVR_PU_STREAM_CFG struPUStream;  //PU streaming parameters
}NET_IVMS_DEVSCHED, *LPNET_IVMS_DEVSCHED;

//iVMS configuration structure
typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED    struDevSched[MAX_DAYS][MAX_TIMESEGMENT]; // Set PU streaming and rule by time period
} NET_IVMS_STREAMCFG, *LPNET_IVMS_STREAMCFG;

//Mask Area
typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;             //Activate privacy mask,  0- disable, else- enable
    BYTE byRes[3];          //Reserved as 0
    NET_VCA_POLYGON  struPolygon;  //Mask Polygon
}NET_VCA_MASK_REGION, *LPNET_VCA_MASK_REGION;

//Mask region list structure
typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;      //Structure length
    BYTE byRes[4];      //Reserved as 0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM];  //Mask region list structure
}NET_VCA_MASK_REGION_LIST, *LPNET_VCA_MASK_REGION_LIST;


//ATM Enter Region
typedef struct tagNET_VCA_ENTER_REGION//Mask the target entering the region to avoid interference on ATM detection
{
    DWORD dwSize;
    BYTE byEnable;             //Activate the function, 0- disable, else- enable
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon;  //Enter area
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION, *LPNET_VCA_ENTER_REGION;

//IVMS mask region list
typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;     //Structure length
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST, *LPNET_IVMS_MASK_REGION_LIST;

//ATM enter area parameters of iVMS
typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][MAX_TIMESEGMENT];  //Enter area
}NET_IVMS_ENTER_REGION, *LPNET_IVMS_ENTER_REGION;

// iVMS alarm upload structure
typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;
}NET_IVMS_ALARM_JPEG, *LPNET_IVMS_ALARM_JPEG;

// IVMS  Playback Search Config
typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay; // Remote playback
    NET_IVMS_ALARM_JPEG         struAlarmJpeg;  // alarm snapshot upload config
    NET_IVMS_RULECFG           struRuleCfg;    //IVMS VCA rule config
}NET_IVMS_SEARCHCFG, *LPNET_IVMS_SEARCHCFG;

//Calibration parameters
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{
    BYTE byPointNum;    //Calibration point number
    BYTE byRes[3];        //Reserved
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //Calibration point group
    NET_DVR_PTZPOS struHorizonPtzPos;  //Horizontal positon of the track device
    BYTE byRes2[256];    //Reserved
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

//Tracking device configuration parameters
typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{
    DWORD  dwSize;         //Structure size
    BYTE   byEnable;       //Track device enabled, 0-disable, 1 -enable
    BYTE   byTransMode;    //Communication mode,0-NET SDK,1-Serial port 485
    BYTE   byRes1[2];       //Reserved
    NET_DVR_CHANNEL  struTrackDevChan; //Tracking device parameters    
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //Tracking device calibration parameters    
    BYTE    byRes2[256];    //Reserved
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;

/************************************end******************************************/
//NAS identification cfg
typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE    sUserName[NAME_LEN];        /* username len 32*/
    BYTE    sPassword[PASSWD_LEN];        /* passwd len 16*/
    BYTE    byRes1[4];    //res
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;

typedef union tagNET_DVR_MOUNT_PARAM_UNION
{
    BYTE  uLen[52];                    //union len
    NET_DVR_IDENTIFICATION_PARAM struIdentificationParam;//(SMB/CIFS work)
} NET_DVR_MOUNT_PARAM_UNION, *LPNET_DVR_MOUNT_PARAM_UNION;

typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0~res,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;

typedef union tagNET_DVR_MOUNTMETHOD_PARAM_UNION
{
    BYTE  uLen[56]; //union len                   
    NET_DVR_NAS_MOUNT_PARAM struNasMountParam;//NAS mount type (byNetDiskType == NFS(NAS)) 
}NET_DVR_MOUNTMETHOD_PARAM_UNION, *LPNET_DVR_MOUNTMETHOD_PARAM_UNION;


//Network Disk configuration
typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;                         //0- NFS, 1- iSCSI
    BYTE byRes1[3];                             //Reserved
    NET_DVR_IPADDR struNetDiskAddr;             //IP address
    BYTE sDirectory[PATHNAME_LEN];             // PATHNAME_LEN = 128
    WORD wPort;                                 //iSCSI port
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];                //res
}NET_DVR_SINGLE_NET_DISK_INFO, *LPNET_DVR_SINGLE_NET_DISK_INFO;

#define MAX_NET_DISK    16//Max. HDD number

typedef struct tagNET_DVR_NET_DISKCFG
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG, *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;                         //0- NFS, 1- iSCSI
    BYTE byRes1[3];                             //Reserved
    BYTE sDirectory[PATHNAME_LEN];             // PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];    /*domain*/
    WORD wPort;                                 //iSCSI port
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE    byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40, *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;
//Event Type
//Main type
typedef enum _MAIN_EVENT_TYPE_
{
    EVENT_MOT_DET = 0,             //Motion Detect
    EVENT_ALARM_IN = 1,         //Alarm input
    EVENT_VCA_BEHAVIOR = 2,     //VCA
    EVENT_INQUEST = 3,            //Inquest Event
    EVENT_VCA_DETECTION = 4,    //intelligent detect
    EVENT_POS = 5,
    EVENT_TRIAL_CASE = 6,//case info
    EVENT_ACS_CASE = 7,  //case acs
    EVENT_IOT_CASE = 8,  //IOT linkage events
    EVENT_STREAM_INFO = 100     //Stream ID information
}MAIN_EVENT_TYPE;

typedef enum _VCA_DETECTION_MINOR_TYPE_
{
    EVENT_VCA_TRAVERSE_PLANE = 1,        //traverse plane
    EVENT_FIELD_DETECTION,             //field detection
    EVENT_AUDIO_INPUT_ALARM,      //audio input alarm
    EVENT_SOUND_INTENSITY_ALARM,   //sound intensity
    EVENT_FACE_DETECTION,             //face detection
    EVENT_VIRTUAL_FOCUS_ALARM, /*virtul focus*/
    EVENT_SCENE_CHANGE_ALARM, /*scene change*/
    EVENT_PIR_ALARM,
    EVENT_ENTER_REGION,                           //enter region
    EVENT_EXIT_REGION,                            //exit region
    EVENT_LOITERING,                               //loitering 
    EVENT_GROUPDETECTION,                       //group detection
    EVENT_RAPIDMOVE,                            //rapidmove
    EVENT_PARK,                              //park
    EVENT_UNATTENDED_BAGGAGE,                   //unattended baggage
    EVENT_ATTENDEDBAGGAGE,                      //attended baggage
    EVENT_VEHICLE_DETECTION,                     //vehicle detection
    EVENT_ALL = 0xffffffff                //all 
}VCA_DETECTION_MINOR_TYPE;

#define INQUEST_START_INFO        0x1001
#define INQUEST_STOP_INFO         0x1002
#define INQUEST_TAG_INFO          0x1003
#define INQUEST_SEGMENT_INFO      0x1004
#define INQUEST_CASE_INFO          0x1005

//VCA event type corresponding to the main event type, 0xffff stands for all
typedef enum _BEHAVIOR_MINOR_TYPE_
{
    EVENT_TRAVERSE_PLANE = 0,   //Traverse plane
    EVENT_ENTER_AREA,                 //target enter area (region rule)
    EVENT_EXIT_AREA,                 //target leave area  (region rule)
    EVENT_INTRUSION,                 //Intrusion  (region rule)
    EVENT_LOITER,                     //Loitering  (region rule)
    EVENT_LEFT_TAKE,                 //Object left or taken  (region rule)
    EVENT_PARKING,                     //Illegal parking  (region rule)
    EVENT_RUN,                         //Running (region rule)
    EVENT_HIGH_DENSITY,
    EVENT_STICK_UP,                    //Stick up, support area rule
    EVENT_INSTALL_SCANNER,            //Install scanner, support area rule
    EVENT_OPERATE_OVER_TIME,        //Operation overtime
    EVENT_FACE_DETECT,              //Exception face 
    EVENT_LEFT,                     //Items left
    EVENT_TAKE,                      //Items take
    EVENT_LEAVE_POSITION,         //Leave position
    EVENT_TRAIL_INFO = 16,            //Trial
    EVENT_HUMAN_ENTER = 18,                 //Human enter
    EVENT_FALL_DOWN_INFO = 19,                 //Fall down
    EVENT_OBJECT_PASTE = 20,        //object paste
    EVENT_FACE_CAPTURE_INFO = 21,                //Face capture
    EVENT_MULTI_FACES_INFO = 22,                  //Multi faces
    EVENT_AUDIO_ABNORMAL_INFO = 23,             //Audio abnormal
    EVENT_DETECT = 24,                    //smart detection
    EVENT_SUNGLASSES_FACE_INFO = 25,             //sunglasses face
    EVENT_CALLING_FACE_INFO = 26,                   //calling face
    EVENT_VIOLENT_MOTION = 27,                   //violent motion
    EVENT_SAFETY_HELMET = 28,                     //safety helmet detection
    EVENT_PEOPLE_NUM_CHANGE = 29,                 //people number change
    EVENT_GET_UP = 30,                            //get up
    EVENT_ADV_REACH_HEIGHT = 31,
    EVENT_STOOD_UP = 32,                           //stand up
    EVENT_PERSON_DENSITY = 33,                     //pre-warning about density of people
    EVENT_MANUAL_ALARM = 34,                     //Manual alarm
    EVENT_VIOLATION_HIGH_SPEED = 35,             //overspeed
    EVENT_GSENSOR = 36, // G-Sensor Events (sharp acceleration, sharp deceleration, sharp left turn, sharp right turn, vehicle rollover, vehicle collision)
    EVENT_SENSOR_IN = 37, // Sensor-In Behavior (brake, left turn, right turn, reverse)
    EVENT_VCA_DBD = 38, //Driver driving behavior
    EVENT_VCA_ABS = 39, //Advanced assisted driving
    EVENT_TOILET_TARRY = 40                      //toilet tarry
}BEHAVIOR_MINOR_TYPE;

//Major type 6, minor type
typedef enum _TRIAL_CASE_MINOR_TYPE_
{
    TRIAL_START_INFO = 0x1001,    // trial start info
    TRIAL_STOP_INFO = 0x1002,        //trial stio info
    TRIAL_TAG_INFO = 0x1003,        //trial tag info
    TRIAL_SEGMENT_INFO = 0x1004,    // trial segment info
    TRIAL_JUDGE_CASE_INFO = 0x1005 //judge case info
}TRIAL_CASE_MINOR_TYPE;

// Major type 100, minor type
typedef enum _STREAM_INFO_MINOR_TYPE_
{
    EVENT_STREAM_ID = 0,                // all stream id record
    EVENT_TIMING = 1,                    // time record
    EVENT_MOTION_DETECT = 2,            // motion detect record
    EVENT_ALARM = 3,                    // alarm record
    EVENT_ALARM_OR_MOTION_DETECT = 4,    // alarm or motion detect record
    EVENT_ALARM_AND_MOTION_DETECT = 5,    // alarm and motion detect record
    EVENT_COMMAND_TRIGGER = 6,            // command trigger
    EVENT_MANNUAL = 7,                    // mannual record
    EVENT_BACKUP_VOLUME = 8,            // Backup volume
    STREAM_EVENT_SEMAPHORE,
    STREAM_EVENT_HIDE,
    STREAM_EVENT_INVERSE,
    STREAM_EVENT_VIDEO_LOST,
    STREAM_EVENT_WIRELESS_ALARM,
    STREAM_EVENT_PIR_ALARM,
    STREAM_EVENT_CALLHELP_ALARM,

    STREAM_EVENT_FACESNAP,
    STREAM_EVENT_FACE_DETECTION,
    STREAM_EVENT_ITS_PLATE,
    STREAM_EVENT_PDC,
    STREAM_EVENT_SCENECHANGE_DETECTION,
    STREAM_EVENT_DEFOCUS_DETECTION,
    STREAM_EVENT_AUDIOEXCEPTION,

    VCA_EVENT_TRAVERSE_PLANE,
    VCA_EVENT_INTRUSION,
    VCA_EVENT_ENTER_AREA,
    VCA_EVENT_EXIT_AREA,
    VCA_EVENT_LOITER,
    VCA_EVENT_HIGH_DENSITY,
    VCA_EVENT_RUN,
    VCA_EVENT_PARKING,
    VCA_EVENT_LEFT,
    VCA_EVENT_TAKE
}STREAM_INFO_MINOR_TYPE;



#define SEARCH_EVENT_INFO_LEN 300    //Event info length
#define CASE_NO_LEN                64
#define CASE_NAME_LEN            128
#define LITIGANT_LEN            32
#define CHIEF_JUDGE_LEN         32
#define     SEARCH_CASE_NO_LEN        56
#define  SEARCH_CASE_NAME_LEN    100
#define  SEARCH_LITIGANT_LEN    32
#define  SEARCH_CHIEF_JUDGE_LEN 32
#define     CASE_NO_RET_LEN        52
#define  CASE_NAME_RET_LEN        64
#define     LITIGANT_RET_LEN        24
#define     CHIEF_JUDGE_RET_LEN    24
#define  NET_SDK_CASETYPE_LEN      32
//Event search condition
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;             //0- Motion detect, 1- Alarm input,  2-  intelligent event
    WORD wMinorType;             //Sub type- diverse according to the main type, 0xffff- all
    NET_DVR_TIME struStartTime; //Search start and end time, (0,  0) stands for searching from the earliest time and get maximum 4000 events 
    NET_DVR_TIME struEndTime;
    BYTE            byLockType;        // 0xff-all,0-unlock,1-lock
    BYTE             byValue;            //0-by bit,1-by value
    BYTE             byRes[130];
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];
        struct//Alarm input
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];     //Alarm input, if the byAlarmInNo[0] is set as 1, then it stands for event triggered by alarm input 1 
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30];
        }struAlarmParam;

        struct//Alarm input -- By Value
        {
            WORD wAlarmInNo[128];     /*Alarm input No. ,according to the values*/
            BYTE byRes[44];
        }struAlarmParamByValue;

        struct//motion detect
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30]; //Motion detect channel, if byMotDetChanNo[0] is set as 1, then it stands for event triggered by channel 1 motion detect
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30];
        }struMotionParam;

        struct//motion detect -- By Value 
        {
            WORD wMotDetChanNo[64];        /* Motion detect channel No.,according to the values */
            BYTE byRes[172];
        }struMotionParamByValue;

        struct//VCA
        {
            BYTE byChanNo[MAX_CHANNUM_V30]; //Channel than triggered the event
            BYTE byRuleID;                     //Rule ID, 0xff- all
            BYTE byRes1[43];                 //Reserved
        }struVcaParam;

        struct //VCA-- By Value
        {
            WORD wChanNo[64];     //Channel than triggered the event
            BYTE byRuleID;      //Rule ID, 0xff- all
            BYTE byRes[171];
        }struVcaParamByValue;

        struct//Inquest
        {
            BYTE byRoomIndex;    //Inquest room number
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //Reserved
        } struInquestParam;
        struct// VCA Detect Condition
        {
            BYTE byChan[256];//VCA Detect Trigger channel number, If byChan[0] is 1, is to say Find VCA Detect chan 1
        }struVCADetectByBit;

        struct   // VCA Detect Condition, Chan  indicated by value 
        {
            DWORD dwChanNo[MAX_CHANNUM_V30 - 1];// VCA Detect Trigger channel number, by value,  0xffffffff invalid and subsequent data also indicates an invalid value
            BYTE byAll;//0-not all,1-all
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // Stream id
            DWORD                dwCmdType;  // Command type
            BYTE                byBackupVolumeNum;
            BYTE                byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM, *LPNET_DVR_SEARCH_EVENT_PARAM;

#define  MAX_POS_KEYWORDS_NUM               3           
#define  MAX_POS_KEYWORD_LEN                128          
#define  MAX_POS_FILTER_DATA_LEN_MAX         128
#define  SEARCH_EVENT_INFO_LEN_V40             800


typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;             //0- Motion detect, 1- Alarm input,  2-  intelligent event, 7- ACS event
    WORD wMinorType;             //Sub type- diverse according to the main type, 0xffff- all
    NET_DVR_TIME struStartTime; //Search start and end time, (0,  0) stands for searching from the earliest time and get maximum 4000 events 
    NET_DVR_TIME struEndTime;
    BYTE            byLockType;        // 0xff-all,0-unlock,1-lock
    BYTE            byQuickSearch;        // Whether to enable quick query, 0- not enabled, 1- enabled (quick query does not return file size, only query the device database, avoid frequent waking of hard disk)
    BYTE             byRes[130];
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct//Alarm input -- By Value
        {
            WORD wAlarmInNo[128];     /*Alarm input No. ,according to the values*/
            BYTE byRes[544];
        }struAlarmParam;

        struct
        {

            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];
        }struMotionParam;

        struct
        {
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;
            BYTE     byDriverBehaviortType;
            BYTE     byADASType;
            BYTE     byGSensorType;
            BYTE     bySensorInType;
            BYTE byRes[667];
        }struVcaParam;

        struct
        {
            BYTE byRoomIndex;
            BYTE byRes[799];
        } struInquestParam;

        struct
        {
            BYTE byAll;
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // Stream id
            DWORD                dwCmdType;  // Command type
            BYTE                byBackupVolumeNum;
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //Archive label
            BYTE                byRes[656];
        }struStreamIDParam;

        struct
        {
            WORD    wChannel[MAX_CHANNUM_V30];
            BYTE    byAllChan;
            BYTE    byCaseSensitive;
            BYTE    byCombinateMode;
            BYTE    byRes1;
            char    sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
            BYTE    byRes[284];
        }struPosAlarm;

        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;

        struct
        {
            DWORD dwMajor;
            DWORD dwMinor;
            BYTE byCardNo[ACS_CARD_NO_LEN];
            BYTE byName[NAME_LEN];
            BYTE byMACAddr[MACADDR_LEN];
            BYTE byRes[722];
        }struACSAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;

//event search conditions
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V50
{
    WORD wMajorType;            //0- Motion detect, 1- Alarm input,  2-  intelligent event, 7- ACS event , 8-IOT event
    WORD wMinorType;            //Sub type- diverse according to the main type, 0xffff- all
    NET_DVR_TIME_SEARCH_COND struStartTime;    //Search start and end time, (0,  0) stands for searching from the earliest time and get maximum 4000 events 
    NET_DVR_TIME_SEARCH_COND struEndTime;    //
    BYTE            byLockType;        // 0xff-all,0-unlock,1-lock
    BYTE            byQuickSearch;        //
    BYTE             byRes[254];
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct
        {

            WORD wAlarmInNo[128];
            BYTE byRes[544];
        }struAlarmParam;

        struct
        {

            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];
        }struMotionParam;

        struct
        {
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;
            BYTE     byDriverBehaviortType;
            BYTE     byADASType;
            BYTE     byGSensorType;
            BYTE     bySensorInType;
            BYTE byRes[667];
        }struVcaParam;

        struct//Trial event
        {
            BYTE byRoomIndex;
            BYTE byRes[799];
        }struInquestParam;

        struct//Intelligent detection and search conditions, the channel number by value 
        {
            BYTE byAll;
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];//The channel, according to the value, the compact arrangement, encountered 0xFFFF, said the follow-up value of the array is invalid 
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // id,72 byte length
            DWORD                dwCmdType;  //External trigger type, NVR access cloud storage use 
            BYTE                byBackupVolumeNum;
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //
            BYTE                byRes[656];
        }struStreamIDParam;

        struct //pos 
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //The channel, according to the value, the compact arrangement, encountered 0xFFFF, said the follow-up value of the array is invalid 
            BYTE     byAllChan;            //,0-no,1-yes
            BYTE      byCaseSensitive;      //0-Case insensitive 1-Case sensitive 
            BYTE      byCombinateMode;  //combination mode,0-or,1-and
            BYTE      byRes1;
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
            BYTE    byRes[284];
        }struPosAlarm;

        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[547];
        }struTrialParam;

        struct //acs
        {
            DWORD dwMajor;
            DWORD dwMinor;
            BYTE byCardNo[ACS_CARD_NO_LEN];
            BYTE byName[NAME_LEN/*32*/];
            BYTE byMACAddr[MACADDR_LEN];
            BYTE byRes[722];
        }struACSAlarm;
        struct //IOT
        {
            WORD      wDeviceType;            //Device type
            WORD      wEventType;            //Search subtype - 0xffff represents the whole, according to the main type change.
            WORD      wChannel[MAX_CHANNUM_V30/*64*/];        //The channel number, by value, is compact, and when it encounters 0xffff, it means that the array's subsequent value is invalid.
            BYTE      byAllChan;        //Whether to find all channels, 0- no, at this time wChannel is valid, 1- all channels, when wChannel is invalid.
            BYTE      byCaseSensitive;      //0- case insensitive, 1- case sensitive.
            BYTE      byCombinateMode;  //Keyword combination, 0- or 1- with.
            BYTE      bySearchType;      //Search mode: 0- search by video source
            char      sKeyWord[MAX_POS_KEYWORDS_NUM/*3*/][MAX_POS_KEYWORD_LEN/*128*/];//Conditions for keyword search.
            WORD      wZoneNo;           //zone No.
            BYTE      byRes[278];          //reserv
        }struIOTAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V50, *LPNET_DVR_SEARCH_EVENT_PARAM_V50;

//Search result returned
typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;             //Main type
    WORD wMinorType;             //Sub type
    NET_DVR_TIME struStartTime; //Event starts time
    NET_DVR_TIME struEndTime;   //Event ends time, it will be equal to the start time for pulse event
    BYTE byChan[MAX_CHANNUM_V30];
    BYTE byChanEx[32];         //Expand bychan ,you can use this byChanEx replace byChan
    BYTE byRes[4];
    union
    {
        struct//alarm input result
        {
            DWORD dwAlarmInNo;      //alarm input number
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//Motion detect result
        {
            DWORD dwMotDetNo;     //Motion detect channel
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//VCA
        {
            DWORD dwChanNo;                     //Channel than VCA event is triggered
            BYTE byRuleID;                     //Rule ID
            BYTE byRes1[3];                     //Reserved
            BYTE byRuleName[NAME_LEN];         //Rule ID
            NET_VCA_EVENT_UNION uEvent;      //VCA event parameters, wMinorType = VCA_EVENT_TYPE
        }struVcaRet;
        struct//Inquest
        {
            BYTE  byRoomIndex;     //Inquest room number
            BYTE  byDriveIndex;    //Driver number
            BYTE  byRes1[6];       //Reserved
            DWORD dwSegmentNo;     //Segment number
            WORD  wSegmetSize;     //Segment size,M
            WORD  wSegmentState;   //Segment state: 0- Normal, 1- Exception, 2- CD not write when inquest
            BYTE  byRes2[288];     //Reserved
        }struInquestRet;
        struct // Stream id
        {
            DWORD dwRecordType;        //record type 
            DWORD dwRecordLength;    //record length
            BYTE  byLockFlag;    // lock flag 0:locked 1:not locked
            BYTE  byDrawFrameType;    // 0:common record 1:draw frame record
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //File name
            DWORD dwFileIndex;
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE    byRoomIndex;
            BYTE    byDriveIndex;
            WORD    wSegmetSize;
            DWORD    dwSegmentNo;
            BYTE    bySegmentState;
            BYTE    byCaseType;
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];
            BYTE    byCaseName[CASE_NAME_RET_LEN];
            BYTE    byLitigant1[LITIGANT_RET_LEN];
            BYTE    byLitigant2[LITIGANT_RET_LEN];
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];
            BYTE    byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET, *LPNET_DVR_SEARCH_EVENT_RET;

#define NET_SDK_MAX_TAPE_INDEX_LEN  32  //Maximum length of tape number
#define NET_SDK_MAX_FILE_LEN        256  //Maximum length of filename

typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;             //Main type
    WORD wMinorType;             //Sub type
    NET_DVR_TIME struStartTime; //Event starts time
    NET_DVR_TIME struEndTime;   //Event ends time, it will be equal to the start time for pulse event

    WORD  wChan[MAX_CHANNUM_V40/*512*/];
    BYTE byRes[36];
    union
    {
        BYTE  byLen[800];
        struct//alarm input result
        {
            DWORD dwAlarmInNo;      //alarm input number
            BYTE byRes[796];
        }struAlarmRet;
        struct//Motion detect result
        {
            DWORD dwMotDetNo;     //Motion detect channel
            BYTE byRes[796];
        }struMotionRet;
        struct//VCA
        {
            DWORD dwChanNo;                     //Channel than VCA event is triggered
            BYTE byRuleID;                     //Rule ID
            BYTE byRes1[3];                     //Reserved
            BYTE byRuleName[NAME_LEN];         //Rule ID
            NET_VCA_EVENT_UNION uEvent;      //VCA event parameters, wMinorType = VCA_EVENT_TYPE
            BYTE byRes[668];                    //Reserved
        }struVcaRet;

        struct//Inquest
        {
            BYTE  byRoomIndex;     //Inquest room number
            BYTE  byDriveIndex;    //Driver number
            BYTE  byRes1[6];       //Reserved
            DWORD dwSegmentNo;     //Segment number
            WORD  wSegmetSize;     //Segment size,M
            WORD  wSegmentState;   //Segment state: 0- Normal, 1- Exception, 2- CD not write when inquest
            BYTE  byRes2[784];     //Reserved
        }struInquestRet;

        struct
        {
            DWORD dwRecordType;        //record type 
            DWORD dwRecordLength;    //record length
            BYTE  byLockFlag;    // lock flag 0:locked 1:not locked
            BYTE  byDrawFrameType;    // 0:common record 1:draw frame record
            BYTE  byPosition;/* File storage location: 0 - array, 1 - to bring library reservation, you can directly download,
                             2 - tape rolls, need to put the disk on the switch to the ticket reservation,
                             3 - not in the tape library, need to insert a disk into the tape library */
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];     //File name
            DWORD dwFileIndex;
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //File tape number
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //Filename extension
            BYTE  byRes[464];
        }struStreamIDRet;
        struct
        {
            DWORD dwChanNo;
            BYTE byRes[796];
        }struPosRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;


typedef struct tagNET_DVR_SEARCH_EVENT_RET_V50
{
    WORD wMajorType;            //Main type
    WORD wMinorType;            //Sub type
    NET_DVR_TIME_SEARCH struStartTime;  //Event starts time
    NET_DVR_TIME_SEARCH struEndTime;   //Event ends time, it will be equal to the start time for pulse event
    NET_DVR_ADDRESS struAddr;  //Fragments of address information, cluster playback when used
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //the channel number which is triggered ,0xffff-invalid
    BYTE byRes[256];
    union
    {
        BYTE  byLen[800];
        struct//alarm input result
        {
            DWORD dwAlarmInNo;    //alarm input number
            BYTE byRes[796];
        }struAlarmRet;
        struct//Motion detect result
        {
            DWORD dwMotDetNo;    //channel
            BYTE byRes[796];
        }struMotionRet;
        struct//VCA
        {
            DWORD dwChanNo;                    //Channel than VCA event is triggered
            BYTE byRuleID;                    ///Rule ID
            BYTE byRes1[3];                    //Reserved
            BYTE byRuleName[NAME_LEN];        //Rule ID
            NET_VCA_EVENT_UNION uEvent;     //VCA event parameters, wMinorType = VCA_EVENT_TYPE
            BYTE byRes[668];                    //Reserved
        }struVcaRet;

        struct//Inquest
        {
            BYTE  byRoomIndex;     //Inquest room number
            BYTE  byDriveIndex;    //Driver number
            BYTE  byRes1[6];       //Reserved
            DWORD dwSegmentNo;     ///Segment number
            WORD  wSegmetSize;     //Segment size,M
            WORD  wSegmentState;   //Segment state: 0- Normal, 1- Exception, 2- CD not write when inquest
            BYTE  byRes2[784];     //Reserved
        }struInquestRet;

        struct //StreamID
        {
            DWORD dwRecordType;      //record type
            DWORD dwRecordLength;    ////record length
            BYTE  byLockFlag;    // lock flag 0:locked 1:not locked
            BYTE  byDrawFrameType;    // 0:common record 1:draw frame record
            BYTE  byPosition;/* File storage location: 0 - array, 1 - to bring library reservation, you can directly download,
                             2 - tape rolls, need to put the disk on the switch to the ticket reservation,
                             3 - not in the tape library, need to insert a disk into the tape library */
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];      //File name
            DWORD dwFileIndex;
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //File tape number
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //Filename extension
            BYTE  byRes[464];
        }struStreamIDRet;

        struct//POS
        {
            DWORD dwChanNo;        //channel
            BYTE byRes[796];
        }struPosRet;

        struct
        {
            BYTE    byRoomIndex;
            BYTE    byDriveIndex;
            WORD    wSegmetSize;
            DWORD   dwSegmentNo;
            BYTE    bySegmentState;
            BYTE    byCaseType;
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];
            BYTE    byCaseName[CASE_NAME_RET_LEN];
            BYTE    byLitigant1[LITIGANT_RET_LEN];
            BYTE    byLitigant2[LITIGANT_RET_LEN];
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];
            BYTE    byRes1[600];
        }struTrialRet;
        struct//IOT
        {
            DWORD dwChanNo;        //The channel number that triggers the event (event source channel)
            BYTE byRes[796];
        }struIOTRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V50, *LPNET_DVR_SEARCH_EVENT_RET_V50;

//SDK_V35  2009- 10- 26


// Set face recognition parameter key word
typedef enum _FACE_PARAM_KEY_
{
    MAX_FACE_SIZE = 20,    //Max. face size
    MINI_FACE_SIZE = 21        //Min. Face size
}FACE_PARAM_KEY;            //Face recognition parameter 


// Calibration type 
typedef enum tagCALIBRATE_TYPE
{
    PDC_CALIBRATE = 0x01,  //PDC calibration
    BEHAVIOR_OUT_CALIBRATE = 0x02,  //VCA outdoor calibration  
    BEHAVIOR_IN_CALIBRATE = 0x03,  //VCA indoor calibration
    ITS_CALBIRETE = 0x04,  //Traffic event calibration
    BV_DIRECT_CALIBRATE = 0x05,  //Binocular camera calibration  
    PDC_LINE_CALIBRATE = 0x06   //PDC Line
}CALIBRATE_TYPE;

#define MAX_RECT_NUM  6
typedef struct tagNET_DVR_RECT_LIST
{
    BYTE    byRectNum;     // Rectangle number
    BYTE    byRes1[11];   //Reserved
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM];  // Maximum 6 rectangles 
}NET_DVR_RECT_LIST, *LPNET_DVR_RECT_LIST;

// PDC  Calibration
typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;   //Calibrated rectangle list
    BYTE           byRes[120];        //Reserved 
}NET_DVR_PDC_CALIBRATION, *LPNET_DVR_PDC_CALIBRATION;


//Calibration line mode
typedef enum tagLINE_MODE
{
    HEIGHT_LINE,           //Height calibration
    LENGTH_LINE        //Length calibration
}LINE_MODE;
/*
For calibration setting, if the user also set 'enable' status, then they can set corresponding parameters,
otherwise the users can get relative parameters after calibration setting
*/
typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;    //Enable camera height line setting
    BYTE    byEnableAngle;     //Enable camera view angle setting
    BYTE    byEnableHorizon;   //Enable camera horizon setting
    BYTE    byRes[5];          //Reserved 
    float   fCameraHeight;     //Enable Camera height setting
    float   fCameraAngle;      //Enable Camera install angle setting
    float   fHorizon;          //enable setting of  video scene's horizon
}NET_DVR_CAMERA_PARAM, *LPNET_DVR_CAMERA_PARAM;
/*
 If the fValue stands for the target height, then struStartPoint and struEndPoint stands for the target upped point and bottom point
 If the fValue stands for the length of the line, then struStartPoint and struEndPoint stands for the start point and end point of the line
 mode stands for the line type (height or length)
 */
typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;      //plz refer to LINE_MODE
    BYTE            byRes[3];        //Reserved 
    NET_VCA_POINT   struStartPoint;
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT, *LPNET_DVR_LINE_SEGMENT;

#define  MAX_LINE_SEG_NUM 8

/*
Needs 4-8 calibration lines to get camera parameters
*/
typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;                          // Calibration line number
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];     // Max. calibration line number
    NET_DVR_CAMERA_PARAM    struCameraParam;                       // Camera parameters
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION, *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

/*
Calibration sample
--including 1 target brim rectangle (standing target) and 1 corresponding height calibration line (from head to bottom)
*/
typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;    // target brim rectangle
    NET_DVR_LINE_SEGMENT struLineSegment;     // Height calibration line
}NET_DVR_IN_CAL_SAMPLE, *LPNET_DVR_IN_CAL_SAMPLE;

#define  MAX_SAMPLE_NUM 5
#define  MAX_SAMPLE_NUM_EX 7

typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION
{
    DWORD    dwCalSampleNum;       //  Calibration sample number
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM];  // Max. calibration sample number
    NET_DVR_CAMERA_PARAM    struCameraParam;     // Camera parameters
    BYTE byRes[16];
}NET_DVR_BEHAVIOR_IN_CALIBRATION, *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

#define  CALIB_PT_NUM 4
typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum;  //Calibration number
    NET_VCA_POINT struPoint[CALIB_PT_NUM];  //Image coordinates
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];         // Reserved
}NET_DVR_ITS_CALIBRATION, *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{
    DWORD  dwCameraHeight;   //Camera Height,unit:cm
    float  fPitchAngle;      //Camera Pitch Angle[0, 60],
    float  fInclineAngle;    //Camera Incline Angle[-20,20]
    BYTE   byRes1[228];
}NET_DVR_BV_DIRECT_CALIBRATION, *LPNET_DVR_BV_DIRECT_CALIBRATION;

// PDC Line
typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[224];
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;


// Calibration union
typedef union tagNET_DVR_CALIBRATION_PRARM_UNION
{
    BYTE byRes[240];                     //Union size
    NET_DVR_PDC_CALIBRATION struPDCCalibration;   //PDC calibration parameters
    NET_DVR_BEHAVIOR_OUT_CALIBRATION  struBehaviorOutCalibration;   //  Outdoor calibration for VCA (mainly for IVS)
    NET_DVR_BEHAVIOR_IN_CALIBRATION  struBehaviorInCalibration;      // Indoor calibration for VCA (mainly for IAS)
    NET_DVR_ITS_CALIBRATION struITSCalibration;
    NET_DVR_BV_DIRECT_CALIBRATION struBvDirectCalibration; // calibration
    NET_DVR_PDC_LINE_CALIBRATION struPDCLineCalibration; //PDC Line
}NET_DVR_CALIBRATION_PRARM_UNION, *LPNET_DVR_CALIBRATION_PRARM_UNION;


// Calibration configuration
typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;                // Calibration structure size
    BYTE    byEnable;              // Enable/disable calibration
    BYTE    byCalibrationType;     // Calibration type, please refer to CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;   // Calibration type union
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG, *LPNET_DVR_CALIBRATION_CFG;

//PDC direction structure
typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // Start point of the direction
    NET_VCA_POINT struEndPoint;     // End point of the direction 
}NET_DVR_PDC_ENTER_DIRECTION, *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;               //Structure size
    BYTE            byEnable;             //Enable/disable the function; 
    BYTE            byRes1[23];           //Reserved 
    NET_VCA_POLYGON          struPolygon;              //Polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;   //Enter direction
} NET_DVR_PDC_RULE_CFG, *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;
    BYTE            byEnable;             // enable;
    BYTE            byRes1[23];       //
    NET_VCA_POLYGON struPolygon;            //polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // enter direction
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//alarm time
    NET_DVR_TIME_EX struDayStartTime; //day start time
    NET_DVR_TIME_EX struNightStartTime; //night start time
    BYTE            byRes[100];       // 
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

/********* IPC5.1.7 Traffic statistical rules Begin 2014-03-21***********/
typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    DWORD dwID; //Scene ID, compatible with the ball machine scene concept, more compatible with the old version of the SDK configuration of new equipment, keep byte 0, so the byte 0, also for scenario 1 by default 
    BYTE  byRes[60];
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

//Polygonal line structure 
typedef struct tagNET_VCA_POLYLINE
{
    NET_VCA_POINT struPoint[4];    //polygonal line
}NET_VCA_POLYLINE, *LPNET_VCA_POLYLINE;

typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize;
    BYTE   byEnable; //byEnable;
    BYTE   byOSDEnable;//Traffic statistics OSD display is enabled, 0 - no (0 - no), 1 - (0 to enter and leave), 2 -, 3 - to leave for the old equipment is not enabled OSD superposition corresponding (no), enable the corresponding (enter/leave) 4-pass people number, 5- enter and pass people. 
    BYTE   byCurDetectType;// current detection area type,0-Polygon,1-Detection line,2-Polygonal line detection
    BYTE   byInterferenceSuppression; //Interference suppression, bitwise said, 0 - this option is 1 - check, bit0 - shadow, bit1 - hovering, bit2 - cart 
    NET_VCA_POINT   struOSDPoint;//OSD Upper left corner
    BYTE   byDataUploadCycle;
    BYTE   bySECUploadEnable;
    BYTE   byEmailDayReport;
    BYTE   byEmailWeekReport;
    BYTE   byEmailMonthReport;
    BYTE   byEmailYearReport;
    BYTE   byRes2[6];
    NET_VCA_POLYGON          struPolygon; // Polygon
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // Flow Enter Direction
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    NET_DVR_TIME_EX struDayStartTime; //Day Start Time
    NET_DVR_TIME_EX struNightStartTime; //Night Start Time
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*Alarm Handle Type*/
    BYTE   byDetecteSensitivity;//Sensitivity:Range:1-100,Default:50
    BYTE   byGenerateSpeedSpace;//Generate Speed Space:Range:1-100,Default:50
    BYTE   byGenerateSpeedTime;// Generate Speed Time:Range:1-100,Default:50
    BYTE   byCountSpeed;// Count Speed:Range:1-100,Default:50
    BYTE   byDetecteType;// Detecte Type:0-Automatic ,1-head,2-head and shoulders,Default0-Automatic 
    BYTE   byTargetSizeCorrect;//Target Size Correction:Range:1-100,Default:50
    BYTE   byStreamOverlayRuleInfos;//Stream intelligence information overlay 0- no, 1- yes 
    BYTE   byRes3;
    NET_VCA_LINE  struLine;//Detection line
    BYTE byHeightFilterEnable;//High filtration is open, 1 to shut down, 2 to open it
    BYTE byDetectThreshold;//Detect Threshold
    BYTE byAidedTrackEnabled;//Aided Track Enabled
    BYTE byRes4;
    float fHeightFilter;//Filter height, unit: cm. Default value: 120 cm, range: 40-200 cm. ByHeightFilterEnable 1 is effective 
    BYTE byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration 
    BYTE byCountingType;//Count trigger mode 0- no, 1- alarm input trigger, 2- video analysis trigger 
    BYTE bySignalType;//Signal type 0- level, 1- pulse 
    BYTE byRS485TransmissionEnabled;//Enable 485 transfer 0- off, 1- open 
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, setting up effective when byCalibrateType is 2 
    NET_VCA_POLYGON struCountPolygon;//Count area 
    NET_VCA_POLYGON struAutoCalibPolygon;//Calibration area, effective when byCalibrateType is 1 
    NET_DVR_TIME_EX struDailyResetTime; //Timing clear
    NET_VCA_POLYLINE struPolyLine;//Polygonal line detection area (configuration line, struLine do not display) 
    BYTE   byRes[4];
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;
/********* IPC5.1.7 Traffic statistical rules End 2014-03-21***********/

typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //Reserve time,0xffff--invalid, uint:day
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byRes[64];
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //Enable,0-no,1-yes
    BYTE  byMode; //Mode,0-Timing, 1- manual
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//Reset counter time
    BYTE  byRes[64];
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

#define NET_SDK_MAX_RELATED_CHAN_NUM  4 //Maximum related channel number 

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;        //vca enable
    BYTE   byVCAType;        //vca type,VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //stream with vca
    BYTE   byMode;            //mode,VCA_CHAN_MODE_TYPE for ATM analysis,TFS_CHAN_MODE_TYPE for TFS analysis,BEHAVIOR_SCENE_MODE_TYPE for behavior full analysis
    BYTE   byControlType;   //contril type,bit,0-no,1-yes
    // byControlType &1 enable snap 
    // byControlType &2 enable related ipc
    BYTE   byRes1[3];
    WORD   wRelatedChannel[NET_SDK_MAX_RELATED_CHAN_NUM/*4*/];     /*related channel, 0-Not related*/
    BYTE   byRes[72];         //
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;

//Set PDC statistic parameters 
// HUMAN_GENERATE_RATE
// Speed for target generating. This parameter controls the time interval from target appear in the image to analysis starts. For video scene with various interference signals, please set a lower speed to avoid false alarm;  and for video scene with high speed objects, please set a higher speed to avoid event missing. Totally 5 levels, ranges from 1 (lowest speed)~ 5 (highest speed), and the default value is 3
// 
// DETECT_SENSITIVE
//Object detection sensitivity level , ranges from 1(lowest) to 5 (highest) , default level: 3

typedef enum tagPDC_PARAM_KEY
{
    HUMAN_GENERATE_RATE = 50,                //Target  generating speed, start from 50
    DETECT_SENSITIVE = 51,                //Detecting sensitivity
}PDC_PARAM_KEY;


typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                  //Target ID
    NET_VCA_RECT struTargetRect;             //Target brim
    BYTE      byRes1[8];                     //Reserved
}NET_DVR_PDC_TARGET_INFO, *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                    //Target number
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];    //Target info array
    BYTE    byRes2[8];                   // Reserved
}NET_DVR_PDC_TARGET_IN_FRAME, *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;             // PDC alarm upload structure size
    BYTE                        byMode;             // 0 - single frame statistic result;  1- statistic result in min. time period  2 The signal trigger (results exist in "Statistics starting time" & & "statistical end time") 
    BYTE                        byChannel;          // Alarm upload channel
    /********* IPC5.1.7 New Begin 2014-03-21***********/
    BYTE                        bySmart;         //0-Intelligence,1-Smart 
    BYTE                        byRes1;
    /********* IPC5.1.7 New End 2014-03-21***********/
    NET_VCA_DEV_INFO       struDevInfo;                 // PU device info
    union
    {
        struct   // For single frame statistic result
        {
            DWORD   dwRelativeTime;      // Relative time stamp
            DWORD   dwAbsTime;           // Absolute time stamp
            BYTE    byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
            char    cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
            char    cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
            BYTE    byRes[89];             
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // Statistic start time 
            NET_DVR_TIME                      tmEnd;   //  Statistic end time
            BYTE	        byTimeDifferenceFlag;   /*Time difference is valid or not 0-invalid 1-valid*/
            char            cStartTimeDifferenceH;      /*Start time difference(HOUR) from UTC*/
            char            cStartTimeDifferenceM;      /*Start time difference(MINUTE) from UTC*/
            char            cStopTimeDifferenceH;        /*Stop time difference(HOUR) from UTC*/
            char            cStopTimeDifferenceM;       /*Stop time difference(MINUTE) from UTC*/
            BYTE            byRes[87]; 
        }struStatTime;
    }uStatModeParam;
    DWORD                       dwLeaveNum;         // Number of left
    DWORD                       dwEnterNum;         // Number of entered
    BYTE                        byBrokenNetHttp;     //Offline continuingly flags, 0 - not the retransmission data, 1 - retransmission data 
    BYTE                        byRes3;
    WORD                        wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    DWORD                       dwPassingNum;        // After the number (after wandering into the area did not trigger the number of people entering and leaving) 
    DWORD                       dwChildLeaveNum;        // Number of children leaving
    DWORD                       dwChildEnterNum;        //Number of number of children entering
    DWORD                       dwDuplicatePeople;        // Duplicate People
    DWORD                       dwXmlLen;//EventNotificationAlert XML Block
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*  pXmlBuf; // EventNotificationAlert XML Block
#else
    char*   pXmlBuf; //EventNotificationAlert XML Block
    BYTE  byRes4[4];
#endif 
    BYTE                        byRes2[8];
}NET_DVR_PDC_ALRAM_INFO, *LPNET_DVR_PDC_ALRAM_INFO;


//  PDC Info Query
typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD        dwLeaveNum;
    DWORD        dwEnterNum;
    BYTE         byRes1[256];
}NET_DVR_PDC_QUERY, *LPNET_DVR_PDC_QUERY;


typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;              // Structure size
    NET_DVR_PTZ_POSITION    struPtzPosition;     // Video scene position info
    NET_VCA_RULECFG         struVcaRuleCfg;      //Video 
    BYTE                    byRes2[80];          // Reserved
}NET_DVR_POSITION_RULE_CFG, *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // Structure size 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // Video scene position info
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //Video
    BYTE  byTrackEnable; //Enable track
    BYTE  byRes1;
    WORD wTrackDuration; //Track duration(s)
    BYTE                    byRes2[76];         // 
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;

typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;      // Enable video scene position limitation
    BYTE                byRes1[3];
    NET_DVR_PTZPOS      struUp;      // upper limit position
    NET_DVR_PTZPOS      struDown;    // bottom limit position 
    NET_DVR_PTZPOS      struLeft;    // left limit position
    NET_DVR_PTZPOS      struRight;   // right limit position
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE, *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    //video scene index
    BYTE    byRes1;
    WORD    wDwell;     // dwell time
    BYTE    byRes2[4];  // Reserved
}NET_DVR_POSITION_INDEX, *LPNET_DVR_POSITION_INDEX;

#define  MAX_POSITION_NUM 10
typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD   dwSize;
    BYTE    byNum;  // video scene number
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG, *LPNET_DVR_POSITION_TRACK_CFG;

//Patrol path scene info
typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;          // Dwell time [30- 300]
    BYTE   byPositionID;    // Scene number 1- 10, Default: 0 (do not add to patrol scene)
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO, *LPNET_DVR_PATROL_SCENE_INFO;

// Patrol scene tracking info
typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                  // Structure size
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];     // patrol path
    BYTE   byRes[16];                               // Reserved
}NET_DVR_PATROL_TRACKCFG, *LPNET_DVR_PATROL_TRACKCFG;

//Speed dome local rule configuration via menu
typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // Structure size
    WORD    wAlarmDelayTime;    // Alarm delay time (speed dome only supports global intrusion detection mode) range:1-120s
    WORD    wTrackHoldTime;     // Alarm tracking holding time range 0-300s
    BYTE    byTrackMode;        //  Plz refer to IPDOME_TRACK_MODE
    BYTE    byPreDirection;     // Pre judge of tracking direction 0-disable 1-enable
    BYTE     byTrackSmooth;         //Smooth tracking 0-disable 1-enable    
    BYTE    byZoomAdjust;         // Zoom adjustment
    BYTE    byMaxTrackZoom;     // Max. zoom ratio 0-default zoom ratio,1-15
    BYTE    byStopTrackWhenFindFace;  //stop track when find face 0-no 1-yes
    BYTE    byStopTrackThreshold;   //the value for stop track
    BYTE    byRes[9];               //  Reserved                
}NET_DVR_TRACK_PARAMCFG, *LPNET_DVR_TRACK_PARAMCFG;

typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;    // Max. zoom ratio
    BYTE    byRes[42];   // Reserved
}NET_DVR_DOME_MOVEMENT_PARAM, *LPNET_DVR_DOME_MOVEMENT_PARAM;


/********************************Intelligent traffic event  begin****************************************/
#define  MAX_REGION_NUM            8       // Max. region list number
#define  MAX_TPS_RULE            8       // Max. rule number
#define  MAX_AID_RULE            8       // Max. event rule number
#define  MAX_LANE_NUM            8        // Max. traffic lane number

//Traffic event type
typedef enum tagTRAFFIC_AID_TYPE
{
    CONGESTION = 0x01,     //Traffic jam
    PARKING = 0x02,     //Parking
    INVERSE = 0x04,     //Inverse travel
    PEDESTRIAN = 0x08,     //Pedestrian                      
    DEBRIS = 0x10,     //Debris 
    SMOKE = 0x20,     //Smoke
    OVERLINE = 0x40,      //Over line
    VEHICLE_CONTROL_LIST = 0x80,    //block list
    SPEED = 0x100,    //over speed
    LANECHANGE = 0x200,      //lane change
    TURNAROUND = 0x400,     //turn around
    VEHICLE_OCCUPANCY_NONVEHICLE = 0x800, //Occupy the non motorized vehicle parking spaces
    GASSER = 0x1000,    //gasser
    ROADBLOCK = 0x2000,   //roadblock
    CONSTRUCTION = 0x4000,    //construction
    TRAFFIC_ACCIDENT = 0x8000,    //traffic accident
    PARALLEL_PARKING = 0x10000,    //parallel parking
    FOG_DETECTION = 0x20000,       // fog detection
    OCCUPY_EMERGENCY_LANE = 0x40000, //occupy emergency lane
    CONFLAGRATION = 0X80000,     //conflagration
    TFS_MANUAL_TRIGGER = 0x100000,   //TFS manual track
    LOADING_DOCK_TRIGGER_UPLOAD =  0x200000,  //LOADING_DOCK_TRIGGER_UPLOAD
    OCCUPY_OVERTAKING_LANE = 0x400000, //occupy overtaking lane
    PROHIBITION_MARK_VIOLATION = 0x800000, //prohibition mark violation
    CHECK_POINT = 0x1000000, //check point
    SUDDEN_SPEED_DROP = 0x2000000, //sudden speed drop
    SLOW_MOVING = 0x4000000 //slow moving
}TRAFFIC_AID_TYPE;

typedef enum tagTRAFFIC_SCENE_MODE
{
    FREEWAY = 0,    //  High-speed outdoor scene
    TUNNEL,         //  High-speed tunnel scene 
    BRIDGE          //  High-speed bridge scene
}TRAFFIC_SCENE_MODE;

typedef enum tagITS_ABILITY_TYPE
{
    ITS_CONGESTION_ABILITY = 0x01,       //Traffic jam
    ITS_PARKING_ABILITY = 0x02,       //Parking 
    ITS_INVERSE_ABILITY = 0x04,       //Inverse travel
    ITS_PEDESTRIAN_ABILITY = 0x08,       //Pedestrian                      
    ITS_DEBRIS_ABILITY = 0x10,       //Debris
    ITS_SMOKE_ABILITY = 0x20,       //Smoke - tunnel
    ITS_OVERLINE_ABILITY = 0x40,       //Over line
    ITS_VEHICLE_CONTROL_LIST_ABILITY = 0x80,        //block list
    ITS_SPEED_ABILITY = 0x100,        //over speed    
    ITS_LANECHANGE_ABILITY = 0x200,     //lane change
    ITS_TURNAROUND_ABILITY = 0x400,      //turn around
    ITS_LANE_VOLUME_ABILITY = 0x010000,   //Flow  counting of traffic lane
    ITS_LANE_VELOCITY_ABILITY = 0x020000,   //Vehicle velocity of traffic lane
    ITS_TIME_HEADWAY_ABILITY = 0x040000,   //Vehicle headway counting (unit: time)
    ITS_SPACE_HEADWAY_ABILITY = 0x080000,   //Vehicle headway counting (unit: distance) 
    ITS_TIME_OCCUPANCY_RATIO_ABILITY = 0x100000,   //Traffic lane occupancy (unit: time)
    ITS_SPACE_OCCUPANCY_RATIO_ABILITY = 0x200000,   //Traffic lane occupancy (unit: distance) 
    ITS_LANE_QUEUE_ABILITY = 0x400000,   //Queue length
    ITS_VEHICLE_TYPE_ABILITY = 0x800000,   //Vehicle type
    ITS_TRAFFIC_STATE_ABILITY = 0x1000000   //Traffic state
}ITS_ABILITY_TYPE;

// Traffic statistics
typedef enum tagITS_TPS_TYPE
{
    LANE_VOLUME = 0x01,     //Traffic lane flow
    LANE_VELOCITY = 0x02,     //Vehicle velocity
    TIME_HEADWAY = 0x04,     //Vehicle headway counting (unit: time)
    SPACE_HEADWAY = 0x08,     //Vehicle headway counting (unit: distance) 
    TIME_OCCUPANCY_RATIO = 0x10,     //Traffic lane occupancy (unit: time)
    SPACE_OCCUPANCY_RATIO = 0x20,     //Traffic lane occupancy (unit: distance)  
    QUEUE = 0x40,     //Queue length
    VEHICLE_TYPE = 0x80,     //vehicle type
    TRAFFIC_STATE = 0x100     //traffic state
}ITS_TPS_TYPE;

typedef struct tagNET_DVR_REGION_LIST
{
    DWORD    dwSize;     // Structure size
    BYTE    byNum;       // Region number
    BYTE    byRes1[3];     // Reserved
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM];  // Region
    BYTE    byRes2[20];     // Reserved
}NET_DVR_REGION_LIST, *LPNET_DVR_REGION_LIST;


// Direction structure
typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;    // Direction start point
    NET_VCA_POINT struEndPoint;      // Direction end point
}NET_DVR_DIRECTION, *LPNET_DVR_DIRECTION;

// Single traffic lane
typedef struct tagNET_DVR_ONE_LANE
{
    BYTE    byEnable;  // Enable traffic lane
    BYTE    byRes1[11];     // Reserved
    BYTE    byLaneName[NAME_LEN];        // Traffic lane name
    NET_DVR_DIRECTION struFlowDirection;     // Flow direction of the traffic lane
    NET_VCA_POLYGON struPolygon;         // Traffic lane region
}NET_DVR_ONE_LANE, *LPNET_DVR_ONE_LANE;

// Traffic lane configuration
typedef struct tagNET_DVR_LANE_CFG
{
    DWORD    dwSize;     // Structure size
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];     // Traffic lane parameter, and the  subscript is corresponding to the traffic lane ID 
    BYTE    byRes1[40];      // Reserved
}NET_DVR_LANE_CFG, *LPNET_DVR_LANE_CFG;

// Traffic event parameters
typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;        // Parking time [10s- 120s]
    WORD    wPedestrianDuration;     // Pedestrian time [1s- 120s]
    WORD    wDebrisDuration;         // Debris time [10s- 120s]
    WORD    wCongestionLength;       // Traffic jam distance threshold [5m- 200m] 
    WORD    wCongestionDuration;     // Traffic jam time length [10s- 120s]
    WORD    wInverseDuration;        // Inverse travel time [1s- 10s]
    WORD    wInverseDistance;        // Inverse travel distance [2m- 100m] (default: 10m)
    WORD    wInverseAngleTolerance;  // Inverse angle tolerance [90- 180] degree
    WORD    wIllegalParkingTime;     // Illegal parking time[4min,60min],take effect in mode TFS_CITYROAD
    WORD    wIllegalParkingPicNum;   // Illegal parking snap pic num[1,6], take effect in mode TFS_CITYROAD
    BYTE    byMergePic;              // Merge snap pics ,0- disable 1- enable ,take effect in mode TFS_CITYROAD
    BYTE    byRes1[23];              // reserved
}NET_DVR_AID_PARAM, *LPNET_DVR_AID_PARAM;

// Traffic rule structure
typedef struct tagNET_DVR_ONE_AID_RULE
{
    BYTE    byEnable;                    //enable/disable event rules
    BYTE    byRes1[3];                   //Reserved
    BYTE    byRuleName[NAME_LEN];        //Rule name 
    DWORD   dwEventType;                 //Traffic event detection type TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter;  //Size filter
    NET_VCA_POLYGON     struPolygon;     //Rule region
    NET_DVR_AID_PARAM struAIDParam;      //Event parameters
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; //Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     // Handle method
    BYTE byRelRecordChan[MAX_CHANNUM_V30];             //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE    byRes2[20];
}NET_DVR_ONE_AID_RULE, *LPNET_DVR_ONE_AID_RULE;

// Traffic events
typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;         // Structure size 
    BYTE    byPicProType;     //0- do not upload snapshot on alarm;  1- upload snapshot on alarm
    BYTE    byRes1[3];      // Reserved
    NET_DVR_JPEGPARA struPictureParam;          //Snapshot parameter structure
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];  //Rule array
    BYTE    byRes2[32];     //Reserved
}NET_DVR_AID_RULECFG, *LPNET_DVR_AID_RULECFG;

typedef struct tagNET_DVR_ONE_AID_RULE_V41
{
    BYTE                        byEnable;                 // 0 - disable, 1 - enable
    BYTE                        byLaneNo;                 // Relate Lane No
    BYTE                        byRes1[2];                // Reserved
    BYTE                        byRuleName[NAME_LEN];     // Rule name
    DWORD                       dwEventType;              // Traffic event detection type TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // Size filter
    NET_VCA_POLYGON             struPolygon;              // Rule region
    NET_DVR_AID_PARAM           struAIDParam;             // Event parameters
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;              //Handle method
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //Recording channel triggered by alarm, 1-trigger recording on this channel
    BYTE                        byRes2[60];               //Reserved
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // Structure size 
    BYTE    byPicProType;               // 0- do not upload snapshot on alarm;  1- upload snapshot on alarm
    BYTE    byRes1[3];                  // Reserved
    NET_DVR_JPEGPARA struPictureParam;     // Snapshot parameter structure
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //Rule array
    BYTE    byRes2[128];                //Reserved
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

// Traffic statistics structure
typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;        // Enable traffic rule parameters
    BYTE    byLaneID;           // Traffic lane ID
    BYTE    byRes1[2];       //Reserved
    DWORD   dwCalcType;      // Statistics type ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter;  // Size filter
    NET_VCA_POLYGON struVitrualLoop;     // Virtual coil
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2]; //Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;     //Handle mode (upload to center)
    BYTE    byRes2[20];   // Reserved
}NET_DVR_ONE_TPS_RULE, *LPNET_DVR_ONE_TPS_RULE;

// Traffic statistics rule configuration structure
typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;               // Structure size
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE];  // The subscript is corresponding to the traffic parameter's ID
    BYTE    byRes2[40];      // Reserved
}NET_DVR_TPS_RULECFG, *LPNET_DVR_TPS_RULECFG;

typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //0 - disable,1 - enable
    BYTE    byLaneID;                      //Lane id
    BYTE    byRes1[2];                    //Reserved
    DWORD   dwCalcType;                   //Statistics type ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //Size filter
    NET_VCA_POLYGON      struVitrualLoop; //Virtual coil
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Arm schedule
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;       //Handle mode
    BYTE    byRes2[60];                   // Reserved
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;

typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         //Structure size
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; //The subscript is corresponding to the traffic parameter's ID
    BYTE    byRes[128];     //Reserved
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;

//Traffic event types expand
typedef enum tagTRAFFIC_AID_TYPE_EX
{
    ENUM_AID_TYPE_CONGESTION = 1,
    ENUM_AID_TYPE_PARKING = 2,
    ENUM_AID_TYPE_INVERSE = 3,
    ENUM_AID_TYPE_PEDESTRIAN = 4,
    ENUM_AID_TYPE_DEBRIS = 5,
    ENUM_AID_TYPE_SMOKE = 6,
    ENUM_AID_TYPE_OVERLINE = 7,
    ENUM_AID_TYPE_VEHICLE_CONTROL_LIST = 8,
    ENUM_AID_TYPE_SPEED = 9,
    ENUM_AID_TYPE_LANECHANGE = 10,
    ENUM_AID_TYPE_TURNAROUND = 11,
    ENUM_AID_TYPE_VEHICLE_OCCUPANCY_NONVEHICLE = 12,
    ENUM_AID_TYPE_GASSER = 13,
    ENUM_AID_TYPE_ROADBLOCK = 14,
    ENUM_AID_TYPE_CONSTRUCTION = 15,
    ENUM_AID_TYPE_TRAFFIC_ACCIDENT = 16,
    ENUM_AID_TYPE_PARALLEL_PARKING = 17,
    ENUM_AID_TYPE_FOG_DETECTION = 18,
    ENUM_AID_TYPE_OCCUPY_EMERGENCY_LANE = 19,
    ENUM_AID_TYPE_CONFLAGRATION = 20,
    ENUM_AID_TYPE_TFS_MANUAL_TRIGGER = 21,
    ENUM_AID_TYPE_LOADING_DOCK_TRIGGER_UPLOAD = 22,
    ENUM_AID_TYPE_OCCUPY_OVERTAKING_LANE = 23,
    ENUM_AID_TYPE_PROHIBITION_MARK_VIOLATION = 24,
    ENUM_AID_TYPE_CHECK_POINT = 25,
    ENUM_AID_TYPE_SUDDEN_SPEED_DROP = 26,
    ENUM_AID_TYPE_SLOW_MOVING = 27,
    ENUM_AID_TYPE_NOT_KEEP_DISTANCE = 28,
    ENUM_AID_TYPE_NOT_SLOW_ZEBRA_CROSSING = 29,
    ENUM_AID_TYPE_OVER_TAKE_RIGHT_SIDE = 30,
    ENUM_AID_TYPE_LOW_SPEED = 31,
    ENUM_AID_TYPE_DRAG_RACING = 32,
    ENUM_AID_TYPE_CHANGE_LANE_CONTINUOUSLY = 33,
    ENUM_AID_TYPE_S_SHARP_DRIVING = 34,
    ENUM_AID_TYPE_LARGE_VEHICLE_OCCUPY_LINE = 35,
    ENUM_AID_TYPE_ROAD_GROUP = 36,
    ENUM_AID_TYPE_SINGLE_VEHICLE_BREAKDOWN = 37,
    ENUM_AID_TYPE_BLACK_SMOKE_VEHICLE = 38,
    ENUM_AID_TYPE_VEHNOYIELDPEDEST = 39,//Motor Vehicles Failing to Yield for Pedestrians
    ENUM_AID_TYPE_ILLEGALMANNEDVEH = 40,//Illegal Manned Motor Vehicle
    ENUM_AID_TYPE_ILLEGALMANNEDNONMOTORVEH = 41,//Illegal Manned Non-Motor Vehicle
    ENUM_AID_TYPE_UMBRELLATENTINSTALL = 42,//Umbrella Tent Installation Violation on Non-Motor Vehicle
    ENUM_AID_TYPE_NONMOTORVEHONVEHLANE = 43,//Non-Motor Vehicle on Motor Vehicle Lane
    ENUM_AID_TYPE_WEARINGNOHELMET = 44,//Wearing No Helmet
    ENUM_AID_TYPE_PEDESTREDLIGHTRUNNING = 45,//Pedestrian Red Light Running
    ENUM_AID_TYPE_PEDESTONNONMOTORVEHLANE = 46,//Pedestrian Walking on Non-Motor Vehicle Lane
    ENUM_AID_TYPE_PEDESTONVEHLANE = 47,//Pedestrian Walking on Motor Vehicle Lane
    ENUM_AID_TYPE_OCCUPYDEDICATEDLANE = 48,//Occupy Dedicated Lan
    ENUM_AID_TYPE_NOTDRIVEINDEDICATEDLANE = 49,//Not Drive In Dedicated Lane
}TRAFFIC_AID_TYPE_EX;


// Traffic event info
typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;    // Rule ID, which is equal to the subscript of the rule configuration structure ([0- 16])
    BYTE            byVisibilityLevel; //
    BYTE            byRes1[2];
    BYTE            byRuleName[NAME_LEN];  //  Rule ID
    DWORD           dwAIDType;   // Alarm event type
    NET_DVR_DIRECTION   struDirect;  // ALarm region  
    BYTE    bySpeedLimit; //Limit speed,km/h[0,255]
    BYTE    byCurrentSpeed; //current speed,km/h[0,255]
    BYTE    byVehicleEnterState;//vehicle state  0-invalid  1-in 2-out 
    BYTE            byState; //0-change,1-loop, 2- upload the data captured by the current device at regular intervals
    BYTE            byParkingID[16]; //parking id
    DWORD           dwAIDTypeEx;  // For the alarm event type extension, refer to TRAFFIC_AID_TYPE_EX
    BYTE            byRes2[16];
}NET_DVR_AID_INFO, *LPNET_DVR_AID_INFO;

// Traffic event alarm
typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;          // Structure length
    DWORD               dwRelativeTime;     // Relative time stamp
    DWORD               dwAbsTime;         // Absolute time stamp
    NET_VCA_DEV_INFO      struDevInfo;     // PU info
    NET_DVR_AID_INFO    struAIDInfo;     // Traffic event info
    DWORD               dwPicDataLen;    // Return snapshot picture length, 0- no snapshot;  else- snapshot data length
    BYTE                *pImage;         // pointer to the snapshot picture data
    BYTE                byRes[40];       // Reserved  
}NET_DVR_AID_ALARM, *LPNET_DVR_AID_ALARM;

// Queue structure of the Traffic Line
typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;        //Head of the queue
    NET_VCA_POINT   struTail;        //End of the queue
    DWORD           dwLength;         //Actual queue length
}NET_DVR_LANE_QUEUE, *LPNET_DVR_LANE_QUEUE;


typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];                  //Traffic lane rule name
    BYTE    byRuleID;                // Rule ID, which is equal to the subscript of the rule configuration structure ([0- 7]) 
    BYTE    byVaryType;       //Vehicle status for virtual coil, 1-vehicle passing, 0-no vehicle passing 
    BYTE    byLaneType;             // Traffic lane type
    BYTE    byRes1;
    DWORD    dwLaneVolume;     // Traffic flow
    DWORD   dwLaneVelocity;       //velocity on this traffic lane (km/h)
    DWORD   dwTimeHeadway;       //Vehicle headway counting (unit: time)
    DWORD   dwSpaceHeadway;        //Vehicle headway counting (unit: m)
    float   fSpaceOccupyRation;  //Occupation 
    NET_DVR_LANE_QUEUE  struLaneQueue;          //Queue length of the traffic lane
    NET_VCA_POINT       struRuleLocation;      //Center position of the coil rule
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM, *LPNET_DVR_LANE_PARAM;


typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;    // Traffic lane number for the rule
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO, *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD       dwSize;               // Structure size
    DWORD       dwRelativeTime;       // relative time stamp
    DWORD       dwAbsTime;            // Absolute time stamp
    NET_VCA_DEV_INFO      struDevInfo;  // PU device info
    NET_DVR_TPS_INFO  struTPSInfo;    // Traffic event info
    BYTE        byRes1[32];           // Reserved
}NET_DVR_TPS_ALARM, *LPNET_DVR_TPS_ALARM;

typedef enum tagTRAFFIC_DATA_VARY_TYPE_EX_ENUM
{
    ENUM_TRAFFIC_VARY_NO = 0x00,   //No vary
    ENUM_TRAFFIC_VARY_VEHICLE_ENTER = 0x01,   //Vehicle enter the virtual loop
    ENUM_TRAFFIC_VARY_VEHICLE_LEAVE = 0x02,   //Vehicle leave the vitual loop
    ENUM_TRAFFIC_VARY_QUEUE = 0x04,   //Queue vary
    ENUM_TRAFFIC_VARY_STATISTIC = 0x08,   //Statistics vary
}TRAFFIC_DATA_VARY_TYPE_EX_ENUM;

typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; //Traffic lane rule name
    BYTE               byRuleID;             //Rule ID, which is equal to the subscript of the rule configuration structure ([0- 7])  
    BYTE               byLaneType;             //Lane type,up or down
    BYTE               byTrafficState;       //Traffic state,0-Invalid,1-Smooth,2-Crowd,3-Blocked
    BYTE               byLaneNo;            //Relate Lane No
    DWORD              dwVaryType;           //Data vary type,refer to TRAFFIC_DATA_VARY_TYPE_EX_ENUM
    DWORD              dwTpsType;            //Tell which member of this structure is used,refer to ITS_TPS_TYPE
    DWORD              dwLaneVolume;         //Traffic flow
    DWORD              dwLaneVelocity;       //Velocity on this traffic lane (km/h)
    DWORD              dwTimeHeadway;       //Vehicle headway counting (unit: time)
    DWORD              dwSpaceHeadway;       //Vehicle headway counting (unit: m)
    float              fSpaceOccupyRation;   //Space Occupation
    float              fTimeOccupyRation;    //Time Occupation 
    DWORD              dwLightVehicle;       //Number of light vehicle
    DWORD              dwMidVehicle;         //Number of mid vehicle
    DWORD              dwHeavyVehicle;       //Number of heavy vehicle
    NET_DVR_LANE_QUEUE struLaneQueue;        //Queue length of the traffic lane
    NET_VCA_POINT      struRuleLocation;     //Center position of the coil rule
    DWORD               dwOversizeVehicle;    //Number of Oversize vehicle
    BYTE               byRes2[60];           //Reserved
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;


typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          //Traffic lane number for the rule
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE]; //Lane param array
    DWORD                   dwSceneID;//scene ID
    BYTE                    byRes[28];         //Reserved
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

// Face rule configuration 
typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              //Structure size
    BYTE           byEnable;            //Enable or not
    BYTE           byEventType;            //Event type: 0- abnormal face, 1- normal face, 2- abnormal face and normal face, 4- More than one face & abnormal face; 5- More than one face & normal face; 6- More than one face & abnormal face & normal face;7- More than one face
    BYTE           byUpLastAlarm;       //2011-04-06 Whether upload last alarm firstly
    BYTE           byUpFacePic; //Enable upload face picture,0-no, 1-yes
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon; //Face detection rule region
    BYTE           byPicProType;        //Picture handling mode when alarming: 0- not handle, none 0- upload
    BYTE           bySensitivity;       //Rule sensitivity
    WORD            wDuration;          //Time threshold to trigger face alarm
    NET_DVR_JPEGPARA    struPictureParam;         //Picture parameter
    NET_VCA_SIZE_FILTER struSizeFilter;         //Size filter
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//Time parameter of fortification 
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //Handling mode 
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];//Whether alarm triggers recording channel:1-trigger;0-not trigger 
    BYTE          byPicRecordEnable;  /*2012-3-1 Whether record picture, 0-no, 1-yes*/
    BYTE           byRes1[3];         //Reserved
    /*
    Alert event types:
    0x00: invalid
    0x01: abnormal human face
    0x02: normal human face
    0x04: more than one face
    0x08: sunglasses face
    0x10: calling face
    */
    DWORD          dwEventTypeEx; //dwEventTypeEx fields for 0, byEventType field effect.If dwEventTypeEx, byEventType fields have values, will be subject to dwEventTypeEx field.After the upper configuration dwEventTypeEx field, will value synchronization to byEventType.
    BYTE            byRes2[32];         //Reserved
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{
    BYTE byEnable; //enable PIP
    BYTE byBackChannel; //Back channel(panel channel)
    BYTE byPosition; //position,0-left top,1-left bottom,2-right top,3-right bottom
    BYTE byPIPDiv; //Division (face:panel),0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              //Structure size
    BYTE  byEnable;            //Enable or not
    BYTE  byEventType;            //Event type: 0- abnormal face, 1- normal face, 2- abnormal face and normal face, 4- More than one face & abnormal face; 5- More than one face & normal face; 6- More than one face & abnormal face & normal face;7- More than one face
    BYTE  byUpLastAlarm;       //2011-04-06 Whether upload last alarm firstly
    BYTE  byUpFacePic; //Enable upload face picture,0-no, 1-yes    
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    //Face detection rule region
    BYTE  byPicProType;    //Picture handling mode when alarming: 0- not handle, none 0- upload
    BYTE  bySensitivity;   //Rule sensitivity
    WORD  wDuration;      //Time threshold to trigger face alarm
    NET_DVR_JPEGPARA    struPictureParam;         //Picture parameter
    NET_VCA_SIZE_FILTER struSizeFilter;         //Size filter
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Time parameter of fortification
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //Handling mode 
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];            //Whether alarm triggers recording channel:1-trigger;0-not trigger
    BYTE  byPicRecordEnable;  /*2012-10-22Whether record picture, 0-no, 1-yes*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22 Alarm delay,0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7 Face PIP
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; /*Relate snap channel,when the main channel alarms,together upload the relate channel picture
                                               0-unused,other- channel number*/
    BYTE  byRes2[2];         //Reserved
    /*
    Alert event types:
    0x00: invalid
    0x01: abnormal human face
    0x02: normal human face
    0x04: more than one face
    0x08: sunglasses face
    0x10: calling face
    */
    DWORD dwEventTypeEx; //dwEventTypeEx fields for 0, byEventType field effect.If dwEventTypeEx, byEventType fields have values, will be subject to dwEventTypeEx field.After the upper configuration dwEventTypeEx field, will value synchronization to byEventType.
    BYTE  byRes[16];         //Reserved
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD  dwSize;                 // Structure size
    DWORD     dwRelativeTime;     // Relative time
    DWORD    dwAbsTime;            // Absolute time
    BYTE        byRuleName[NAME_LEN];       //Rule name
    NET_VCA_TARGET_INFO  struTargetInfo;    //Alarm target information
    NET_VCA_DEV_INFO       struDevInfo;        //Device information
    DWORD dwPicDataLen;                        //Returned picture length, 0 means no picture, larger than 0 means picture data follows the structure
    BYTE        byAlarmPicType;                //0- abnormal face alarm picture, 1- face picture,2-multi faces,3-sunglasses face, 4-calling face  
    BYTE     byPanelChan;        /*2012-3-1 Related panel channel*/
    BYTE    byRelAlarmPicNum; //Related alarm picture num
    BYTE    byRes1; //Reserved
    DWORD   dwFacePicDataLen;//Face picture length
    DWORD   dwAlarmID;    //Alarm ID,marking the same group of alarmls,0-unused
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes2[42];   //Reserved
    BYTE    *pFaceImage; //Pointer to face picture
    BYTE    *pImage;       //Pointer to picture
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD  uLen[3];        //Union size, 12 bytes
    DWORD  dwHumanIn;         //There are nobody or someone access, 0 -nobody, 1- someone  
    float  fCrowdDensity;  //Aggregation value of people
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

//Real-time alarm upload of someone and onbody event or people aggregation event
typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;                // Rule ID
    BYTE   byRes[3];                // Reserved
    BYTE   byRuleName[NAME_LEN];    // Rule name
    DWORD       dwEventType;        // See to VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE            byNum;      // Total number of event real-time information
    BYTE            byRes1[3];  // Reserved
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];    // Event real-time information
}NET_DVR_EVENT_INFO_LIST, *LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD         dwSize;                       // Structure size
    DWORD         dwRelativeTime;         // Relative time
    DWORD        dwAbsTime;                // Absolute time
    NET_VCA_DEV_INFO      struDevInfo;    // Front-end device information
    NET_DVR_EVENT_INFO_LIST struEventInfoList;    //Event information list
    BYTE            byRes2[40];            // Reserved
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 - Disabled,1-Enabled
    BYTE     byRes1[3];                    //Reserved
    DWORD    dwSceneID;                    //Scene ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //Scene onset time 
    BYTE     byRes2[16];                   //Reserved
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME;

typedef struct tagNET_DVR_SCENE_TIME_CFG
{
    DWORD  dwSize;                                               //Structure size
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //Scene time array
    BYTE   byRes[64];                                            //Reserved
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;

typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{
    BYTE   byEnable;                 //Enable scene,0-disabled 1- enabled
    BYTE   byDirection;              //Monitoring direction: 1- up-road,2- down-road, 3- two-way, 4- from east to west, 5- from south to north, 6- from west to east, 7- from north to south, 8- others 
    BYTE   byRes1[2];                //Reserved
    DWORD  dwSceneID;                //Scene ID(Read only), 0 - Invalid
    BYTE   bySceneName[NAME_LEN];    //Scene name
    NET_DVR_PTZPOS struPtzPos;       //Ptz pos
    DWORD  dwTrackTime;              //Track time[5s,300s],take effect in TFS intelligent analysis
    BYTE   byRes2[24];               //Reserved
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;


typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //Structure size
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //Scene configuration param
    BYTE   byRes[40];                                      //Reserved
}NET_DVR_SCENE_CFG, *LPNET_DVR_SCENE_CFG;


typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //Structure size
    LONG    lChannel;     //Channel number
    DWORD   dwSceneID;    //Scene ID, 0-Invalid
    BYTE    byRes[48];    //Reserved
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //Structure size
    BYTE   byMode;      //Forentics mode,0-Manual ,1-Auto,2-semiAutoTrack
    BYTE   byRes[23];   //Reserved
}NET_DVR_FORENSICS_MODE, *LPNET_DVR_FORENSICS_MODE;

typedef struct tagNET_DVR_SCENE_INFO_
{
    DWORD           dwSceneID;              //Scene ID, 0 - Invalid
    BYTE            bySceneName[NAME_LEN];  //Scene name
    BYTE            byDirection;            //Monitoring direction: 1- up-road,2- down-road, 3- two-way, 4- from east to west, 5- from south to north, 6- from west to east, 7- from north to south, 8- others 
    BYTE            byRes1[3];              //Reserved
    NET_DVR_PTZPOS  struPtzPos;             //Ptz Pos
    BYTE            byRes2[64];            //Reserved
}NET_DVR_SCENE_INFO, *LPNET_DVR_SCENE_INFO;

typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //Structure size
    DWORD              dwRelativeTime;        //Relative time
    DWORD              dwAbsTime;            //Absolute time
    NET_VCA_DEV_INFO   struDevInfo;            //Device info
    NET_DVR_AID_INFO   struAIDInfo;         //Traffic event info
    NET_DVR_SCENE_INFO struSceneInfo;       //Scene info
    DWORD              dwPicDataLen;        //Picture length 
    BYTE               *pImage;             //pointer to image data 
    // 0- upload data directly; 1- cloud storage server URL (3.7Ver) image data into URL data the original picture into URL length
    BYTE               byDataType;
    BYTE               byLaneNo;  //Relate Lane No 
    WORD               wMilliSecond;        //milliseconds
    BYTE               byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE               byDeviceID[DEVICE_ID_LEN/*48*/];
    DWORD              dwXmlLen;//XML Alarm Len
    char*              pXmlBuf;// EventNotificationAlert XML Block
    BYTE               byTargetType;// Type of calibration target,0~unknown,1~pedestrians,2~Two wheels,3~tricycle(Return during pedestrian detection)
    BYTE               byRuleID;//ID of rule, 1-4
	WORD               wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE               byBrokenNetHttp;           //Broken net HTTP(0 - not continuingly, 1 - continuingly)
    BYTE               byRes[3];
    DWORD              dwPlateSmallPicDataLen;
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*                   pPlateSmallImage;  
#else
    char*                   pPlateSmallImage; 
    BYTE                   byRes1[4];
#endif  
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          //Structure size
    DWORD                 dwRelativeTime;  //Relative time
    DWORD                 dwAbsTime;       //Absolute time
    NET_VCA_DEV_INFO      struDevInfo;     //Device info
    NET_DVR_TPS_INFO_V41  struTPSInfo;     //Traffic parameter statistics information 
    BYTE           byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE           byDeviceID[DEVICE_ID_LEN/*48*/];
    DWORD                dwStartTime;
    DWORD                dwStopTime;
    BYTE                   byRes[24];
} NET_DVR_TPS_ALARM_V41, *LPNET_DVR_TPS_ALARM_V41;

/*******************************Intelligent Traffic Function end*****************************************/

#define PRIVT_XXX_MAJOR_VERSION      2

#define PRIVT_XXX_SUB_VERSION        3 /* Sub version value, up to 31 */

#define PRIVT_XXX_REVISION_VERSION   4

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;         // Main version
    WORD    wMinorVersion;         // Sub version
    WORD    wRevisionNumber;     // Revision
    WORD    wBuildNumber;         // Build
    WORD    wVersionYear;         //Version date- Year
    BYTE    byVersionMonth;         //Version date- Month
    BYTE    byVersionDay;             //Version date- Day
    BYTE    byType;
    BYTE    byRes[7];
}NET_DVR_VCA_VERSION, *LPNET_DVR_VCA_VERSION;

/******************************Intelligent function end***********************************/

/*******************************Video Management system***********************************/
//09- 11- 21
#define MAX_SUBSYSTEM_NUM    80   //Max. sub system number in the matrix
#define MAX_SERIALLEN        36   //Max. SN Length
#define MAX_LOOPPLANNUM        16   //Max loop group number
#define DECODE_TIMESEGMENT  4    //Time segment number of decoding schedule
typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE        bySubSystemType; //Sub system type, 1- decoding, 2- encoding, 0- NULL (Read-only) 
    BYTE        byChan; //Channel parameters for the sub system (Read-only) 
    BYTE        byLoginType; //Registration type, 1- direct connect, 2- DNS, 3- Peanut Hull
    BYTE        byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;         /*IP Address */
    WORD        wSubSystemPort;         //Sub system port number 
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask; //Subnet mask
    NET_DVR_IPADDR    struGatewayIpAddr;     /*Network Gateway*/
    BYTE        sUserName[NAME_LEN];     /* User name  (Read-only) */
    BYTE        sPassword[PASSWD_LEN];     /*Password (Read-only) */
    char        sDomainName[MAX_DOMAIN_NAME]; // Domain name  
    char         sDnsAddress[MAX_DOMAIN_NAME]; /*DNS domain name or IP*/
    BYTE        sSerialNumber[SERIALNO_LEN]; //SN (Read-only) 
}NET_DVR_SUBSYSTEMINFO, *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO, *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct  tagNET_DVR_LOOPPLAN_SUBCFG
{
    DWORD                             dwSize;
    DWORD                            dwPoolTime;        /*unit: second*/
    NET_DVR_MATRIX_CHAN_INFO_V30 struChanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
}NET_DVR_LOOPPLAN_SUBCFG, *LPNET_DVR_LOOPPLAN_SUBCFG;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD     dwSize;
    BYTE    byAlarmMode; //Alarm trigger mode, 1- loop, 2- Remain        
    WORD    wLoopTime; //Loop cycle interval (unit: second)            
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG, *LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD            dwSize;
    NET_DVR_IPADDR   struIP;         /*IP of Code Distributor*/
    WORD        wPort;                     //Port number of Code Distributor
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];     /* User name */
    BYTE        sPassword[PASSWD_LEN];     /*Password */
    BYTE        byChan; //485 port number of the Code Distributor
    BYTE        by485Port; //485 address of the Code Distributor
    BYTE        byRes2[14];
} NET_DVR_CODESPLITTERINFO, *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE    byAssociateType; //Alarm linkage, 1- alarm out
    WORD    wAlarmDelay; //Alarm out delay, 0- 5 seconds;  1- 10 seconds; 2- 30 seconds; 3- 1 minute; 4- 2 minutes; 5- 5 minutes; 6- 10 minutesw; 
    BYTE    byAlarmNum; //Alarm ID number
    BYTE    byRes[8];
} NET_DVR_ASSOCIATECFG, *LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD                            dwSize;
    NET_DVR_ASSOCIATECFG           struAssociateCfg; //Trigger dynamic decoding associated structure
    NET_DVR_PU_STREAM_CFG        struPuStreamCfg; //Dynamic decoding structure
    BYTE                            byRes[8];
}NET_DVR_DYNAMICDECODE, *LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime; //
    BYTE  byDecodeType; /*0- no, 1- loop decoding, 2- dynamic decoding*/
    BYTE  byLoopGroup; //Loop Group
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec; //Dynamic decoding
} NET_DVR_DECODESCHED, *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT]; //Start from Monday, consistent with 9000
    BYTE byRes[8];
} NET_DVR_PLANDECODE, *LPNET_DVR_PLANDECODE;

typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;     //Main type 1- alarm;  2- abnormal;  3- operation;  0xff- all 
    DWORD    dwMinorType;     //Hypo- Type 0- all; 
    BYTE    sPanelUser[MAX_NAMELEN];  //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN]; //user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr; //remote host IP
    DWORD    dwParaType; //parameter type
    DWORD    dwChannel; //channel number
    DWORD    dwDiskNumber; //HD number
    DWORD    dwAlarmInPort; //alarm input port
    DWORD    dwAlarmOutPort; //alarm output port
    DWORD   dwInfoLen;
    BYTE  byDevSequence; //Slot number
    BYTE  byMacAddr[MACADDR_LEN]; //MAC address, 6
    BYTE  sSerialNumber[SERIALNO_LEN]; //Serial Number, 48
    char  sInfo[LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1];
}NET_DVR_LOG_MATRIX, *LPNET_DVR_LOG_MATRIX;

//2009- 11- 21 Video Management Platform
typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition; //Search condition, 0-  search by slot number, 1- Search by SN,  2- Search by MAC
    //Slot number, 0- 79: (corresponding to the slot number in the sub system); 
    //0xff: Search all the logs
    //0xfe: Search logs on 78k;0xfd:Search logs on sub domain;0xfc:Search logs on domain
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN]; //Serial Number, 48
    BYTE  byMacAddr[MACADDR_LEN]; //MAC, 6
} NET_DVR_VEDIOPLATLOG, *LPNET_DVR_VEDIOPLATLOG;

//2009- 11- 21
#define VIDEOPLATFORM_SBUCODESYSTEM_ABILITY          0x211 //Encoding sub system ability
typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion; //Ability version number, the highest 16 digits stands for the main version and the lowest 16 digits stands for the sub version 
    DWORD dwSupportMaxVideoFrameRate; //Unit (Kbps) 
    /*Recording mode by digit:
    0: continuous recording according to time schedule;
    1: continues| event trigger recording
    2: Motion detect
    3: Network alarm;
    4: Motion| Network Alarm;
    5: Motion & Network alarm;
    6: Perimeter alarm;
    7: Face recognition;
    8: LPR;
    9: Manual recording*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode; //By digit: 0th-main stream; 1st: sub stream
    BYTE  bySupportStringRow;//Supported character string rows
    BYTE  byRes1[2];
    //Resolution:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5-(Reserved),
    //16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA(800*600),
    //19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i, 
    //28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048    
    BYTE  byMainStreamSupportResolution[32]; //Supported resolution of main stream(added in v1.1 ability)
    BYTE  bySubStreamSupportResolution[32];  //Supported resolution of sub stream(added in v1.1 ability)
    BYTE  byEventStreamSupportResolution[32];//Supported resolution of event stream(added in v1.1 ability)
    BYTE  byRes2[28];//Reserved
}NET_DVR_CODESYSTEMABILITY, *LPNET_DVR_CODESYSTEMABILITY;

//2010- 03- 31 Add ability set of the video management system
typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
    BYTE  bySubSystemType; //Sub system type, 1- Decoding, 2- Encoding, 0- NULL
    BYTE  byChanNum; //Channel number in the sub system
    BYTE  byStartChan; //Start channel of the sub system
    BYTE  bySlotNum;
    BYTE  byRes1[4];
    union
    {
        BYTE Res[200];
        struct
        {
            BYTE  byVGANums; // Display channel number of VGA( start from 1) 
            BYTE  byBNCNums; // Display channel number of BNC(start from 9) 
            BYTE  byHDMINums; // Display channel number of HDMI (start from 25) 
            BYTE  byDVINums; // Display channel number of DVI(start from 29) 
            BYTE  byRes[196];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byRes[200];
        }struCoderSystemAbility;
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums; //number of encoding sub system
    BYTE  byDecodeSubSystemNums; //number of decoding sub system
    BYTE  bySupportNat; //0- does not support NAT, 1- support NAT
    BYTE  byRes1[17];
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  byRes2[640];
}NET_DVR_VIDEOPLATFORM_ABILITY, *LPNET_DVR_VIDEOPLATFORM_ABILITY;

/********************************end*******************************************/

/******************************Intelligent Traffic Surveillance Camera*******************************************/
//IO input
typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus; //Input IO status, 0- Falling edge, 1- Rising edge, 2- Falling edge and Rising edge, 3- HIGH, 4- LOW
    BYTE    byRes[3]; //Reserved
}NET_DVR_IO_INCFG, *LPNET_DVR_IO_INCFG;

//IO output
typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus; //Default IO status: 0- LOW, 1- HIGH 
    BYTE    byIoOutStatus; //IO valid status: 0- LOW, 1- HIGH, 2- PULSE
    WORD    wAheadTime; //Advance time of IO Output, Unit: us
    DWORD   dwTimePluse; //Pulse interval (unit: us)
    DWORD   dwTimeDelay; //IO delay time (unit: us)
    BYTE    byFreqMulti;        //frequence,[1,15]
    BYTE    byDutyRate;        //duty rate,[0,40%]
    BYTE    byRes2[2];
}NET_DVR_IO_OUTCFG, *LPNET_DVR_IO_OUTCFG;

//Flashlight
typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;// 0- not flashing, 1- flashing, 2- alarm linkage, 3- loop mode
    BYTE   byRelatedIoIn;//Corresponding IO (for alarm linkage mode) 
    BYTE   byRecognizedLane;  /*Corresponding IO, expressed by bit, bit0 means whether IO1 is related: 0-not related, 1-related*/
    BYTE   byDetectBrightness;/*Detect brightness enable flashlight automatically:0-not detect;1-detect*/
    BYTE   byBrightnessThreld;/*Brightness threshold of enable flashlight:[0,100].Flashlight works when up to the threshold*/
    BYTE   byStartHour;            //Start time--hour, value range: 0-23
    BYTE   byStartMinute;        //Start time--minute, value range: 0-59
    BYTE   byEndHour;            //End time--hour, value range: 0-23
    BYTE   byEndMinute;            //End time--minute, value range: 0-59
    BYTE   byFlashLightEnable;    //Set flashlight time enable: 0 - off, 1 - open
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

//Traffic light 
typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE    byLightIoIn; //Traffic Light IO
    BYTE    byTrigIoIn; //Triggered IO
    BYTE    byRelatedDriveWay; //Corresponding traffic lane
    BYTE    byTrafficLight;  //0- HIGH status for red light and LOW for green light; 1- HIGH status for green light and LOW for red light
    BYTE     bySnapTimes1;  //Red light snapshot time, 0- disable, else- snapshot time (up to 5)
    BYTE     bySnapTimes2;  //Green light snapshot time, 0-disable, else- snapshot time (up to 5) 
    BYTE    byRes1[2];
    WORD    wIntervalTime1[4]; //Red light snapshot interval (unit: ms)
    WORD    wIntervalTime2[4]; //Green light snapshot interval (unit: ms)
    BYTE    byRecord; //Record when driving on red light, 0- disable, 1- enable
    BYTE    bySessionTimeout; //Time out session for red light recording (unit: s) 
    BYTE    byPreRecordTime; //Pre-Recording time for red light recording (unit: s)
    BYTE    byVideoDelay; //Post--Recording time for red light recording (unit: s) 
    BYTE    byRes2[32]; //Reserved
}NET_DVR_LIGHTSNAPCFG, *LPNET_DVR_LIGHTSNAPCFG;

//Speed Measurement
typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE    byTrigIo1;    //Testing coil 1
    BYTE    byTrigIo2;    //Testing coil 2
    BYTE    byRelatedDriveWay; //Corresponding traffic lane
    BYTE    byTestSpeedTimeOut; //Timeout for speed testing (unit: s) 
    DWORD   dwDistance; //Coil distance, cm
    BYTE    byCapSpeed; //Capture speed starts from (unit:km/h)
    BYTE    bySpeedLimit; //Speed limitation (km/h)
    BYTE     bySnapTimes1;  //Snapshot time for coil 1, 0- disable, else- snapshot time (up to 5)
    BYTE     bySnapTimes2;  //Snapshot time for coil 2, 0- disable, else- snapshot time (up to 5)
    WORD    wIntervalTime1[4]; //Snapshot interval for Coil 1 (unit: ms)
    WORD    wIntervalTime2[4]; //Snapshot interval for Coil 2 (unit: ms)
    BYTE    byRes[32]; //Reserved
}NET_DVR_MEASURESPEEDCFG, *LPNET_DVR_MEASURESPEEDCFG;


typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND, *LPNET_DVR_CLOUDSTORAGE_COND;


typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// Pool ID
    BYTE    byRes[4];
}NET_DVR_POOLPARAM, *LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort; //Data Port
    BYTE    byRes1[2];
    char    szUser[CLOUD_NAME_LEN/*48*/]; //User 
    char    szPassword[CLOUD_PASSWD_LEN/*48*/];     // Password
    NET_DVR_POOLPARAM  struPoolInfo[16];//Array 0 bayonet video pool, an array of 1 said illegal video pool
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG, *LPNET_DVR_CLOUDSTORAGE_CFG;

typedef  struct  tagNET_DVR_PARKLAMP_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byParkingIndex;//ParkingIndex(1~4)
    BYTE   byRes[15];
}NET_DVR_PARKLAMP_COND, *LPNET_DVR_PARKLAMP_COND;

typedef  struct  tagNET_DVR_PARKLAMP_INFOCFG
{
    DWORD dwSize;
    char  sLicense[MAX_LICENSE_LEN/*16*/];//Plate License
    char  sParkingNo[MAX_LICENSE_LEN/*16*/];//Parking No(Actual)
    BYTE   byLampFlicker;//0 ~ no flashing 1 ~flashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work)
    BYTE   byStatus; //Parking state 0- no car, 1- car
    BYTE   byColorDepth; //Body color shades,0-Dark,1-Light,0xff-unknown
    BYTE   byColor;//Body color,0-other colors,1-white,2-Silver,3-gray,4-black,5-red,6-Deep Blue,7-Blue,8-yellow,9-Green,10-brown,11-pink,12-purple,0xff-Body color recognition not performed 
    //Identify the type of vehicle brands; Reference enumerated type: VLR_VEHICLE_CLASS
    BYTE   byVehicleLogoRecog;
    BYTE   byRes[250];//Reservations
}NET_DVR_PARKLAMP_INFOCFG, *LPNET_DVR_PARKLAMP_INFOCFG;

//Video parameter configuration
typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel;  /*0- 100*/
    BYTE byContrastLevel;  /*0- 100*/
    BYTE bySharpnessLevel;  /*0- 100*/
    BYTE bySaturationLevel;  /*0- 100*/
    BYTE byHueLevel;  /*0- 100,  (Reserved) */
    BYTE byEnableFunc; //enable,bit0-SMART IR,bit1-illumination,bit2-light inhibit,0-no,1-yes
    BYTE byLightInhibitLevel; //light inhibit level,[1-3]
    BYTE byGrayLevel; //gray level,0-[0-255],1-[16-235]
}NET_DVR_VIDEOEFFECT, *LPNET_DVR_VIDEOEFFECT;

//Gain Configuration
typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel;  /*Gain: 0- 100*/
    BYTE byGainUserSet;  /*Customize Gain level adjustment ([0- 100]) for CCD mode*/
    BYTE byRes[2];
    DWORD dwMaxGainValue; /*Max. Gain level (unit: dB)*/
}NET_DVR_GAIN, *LPNET_DVR_GAIN;

//White Balance
typedef struct tagNET_DVR_WHITEBALANCE
{
    BYTE byWhiteBalanceMode;  /*0-MWB,1-AWB1,2-AWB2,3-Locked WB,
                             4-Outdoor,5-Indoor,6-Fluorescent Lamp,7-Sodium Lamp,
                             8-Auto-Track,9-One Push,10-Auto-Outdoor,
                             11-Auto-Sodiumlight,12-Mercury Lamp,13-Auto,
                             14-IncandescentLamp,15-Warm Light Lamp,16-Natural Light */
    BYTE byWhiteBalanceModeRGain;  /*R Gain for Manual White Balance mode*/
    BYTE byWhiteBalanceModeBGain;  /*B Gain for Manual White Balance mode*/
    BYTE byRes[5];
}NET_DVR_WHITEBALANCE, *LPNET_DVR_WHITEBALANCE;

//Exposure Control
typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode;  /*0 - manual exposure 1- auto exposure*/
    BYTE  byAutoApertureLevel; /* Auto Aperture Level, 0-10 */
    BYTE  byRes[2];
    DWORD dwVideoExposureSet;  /* Exposure time for manual mode or Max. exposure time for auto mode(unit: us) 20-1s(1000000us)*/
    DWORD dwExposureUserSet;  /* Exposure time (Shutter speed for CCD mode)*/
    DWORD dwRes;
} NET_DVR_EXPOSURE, *LPNET_DVR_EXPOSURE;

//WDR configuration
typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled;  /*WDR: 0 disable  1 enable 2 auto*/
    BYTE byWDRLevel1;  /*0- F*/
    BYTE byWDRLevel2;  /*0- F*/
    BYTE byWDRContrastLevel;  /*0- 100*/
    BYTE byRes[16];
} NET_DVR_WDR, *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;
    NET_DVR_WDR  struWDR;
} NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;


//Day/Night Switching
typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType;  /*Day/Night mode: 0 day, 1 night, 2 auto,3-timing,4-alarm in trigger,
                                5 - automatic mode 2 (no light) ,6-black light,7-auto black light,8-time black light*/
    BYTE bySwitchScheduleEnabled;  /*0 disable  1 enable (Reserved) */
    //Mode 1 
    BYTE byBeginTime;  /*begin time hour,0-23*/
    BYTE byEndTime;  /*end time hour,0-23*/
    //Mode 2 (Reserved)
    BYTE byDayToNightFilterLevel;  //0- 7
    BYTE byNightToDayFilterLevel;  //0- 7
    BYTE byDayNightFilterTime; // (60 sec) 
    BYTE byBeginTimeMin; //begin time min,0-59
    BYTE byBeginTimeSec; //begin time sec,0-59
    BYTE byEndTimeMin; //end time min,0-59
    BYTE byEndTimeSec; //end time sec,0-59
    BYTE byAlarmTrigState; //alarm in trigger state,0-day,1-night
} NET_DVR_DAYNIGHT, *LPNET_DVR_DAYNIGHT;

//Gamma correction
typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled;  /*0- disable;  1- enable*/
    BYTE byGammaCorrectionLevel;  /*0- 100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT, *LPNET_DVR_GAMMACORRECT;

//BLC
typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode;  /*BLC: 0-off  1- UP, 2- DOWN, 3- LEFT, 4- RIGHT, 5- MIDDLE, 6-USERSET ,10-start,11-auto,12-Multi regional backlight compensation*/
    BYTE byBacklightLevel;  /*0x0- 0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1;  // (X coordinate 1) 
    DWORD dwPositionY1;  // (Y coordinate 1) 
    DWORD dwPositionX2;  // (X coordinate 2) 
    DWORD dwPositionY2;  // (Y coordinate 2) 
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT, *LPNET_DVR_BACKLIGHT;

//DNR
typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable;  /*DNR: 0- disable  1- normal mode, 2-expert mode*/
    BYTE byDigitalNoiseRemoveLevel;  /*0x0- 0xF*/
    BYTE bySpectralLevel;   /*expert mode Spatial intensity, 0-100*/
    BYTE byTemporalLevel;   /*expert mode Time-domain intensity, 0-100*/
    BYTE byDigitalNoiseRemove2DEnable;
    BYTE byDigitalNoiseRemove2DLevel;
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE, *LPNET_DVR_NOISEREMOVE;

//Lens configuration under CMOS mode
typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;    //Snapshot mode: 0- mode1; 1- mode2
    BYTE byBrightnessGate; //Brightness threshold
    BYTE byCaptureGain1;    //Snapshot Gain1, 0- 100
    BYTE byCaptureGain2;    //Snapshot Gain2, 0- 100
    DWORD dwCaptureShutterSpeed1; //Snapshot Shutter speed 1
    DWORD dwCaptureShutterSpeed2; //Snapshot Shutter speed 2
    BYTE    byRes[4];
}NET_DVR_CMOSMODECFG, *LPNET_DVR_CMOSMODECFG;

//IPC CCD Parameter Configuration
typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect; /*Brightness, Contrast, Saturation, Sharpness, Hue Configuration*/
    NET_DVR_GAIN struGain; /*Auto Gain*/
    NET_DVR_WHITEBALANCE struWhiteBalance; /*White Balance*/
    NET_DVR_EXPOSURE struExposure;  /*Exposure Control*/
    NET_DVR_GAMMACORRECT struGammaCorrect; /*Gamma Correction*/
    NET_DVR_WDR struWdr; /*WDR*/
    NET_DVR_DAYNIGHT struDayNight; /*Day/Night*/
    NET_DVR_BACKLIGHT struBackLight; /*BLC*/
    NET_DVR_NOISEREMOVE struNoiseRemove; /*DNR*/
    BYTE byPowerLineFrequencyMode;  /*0- 50HZ;  1- 60HZ*/
    /*
        0-Auto Iris,
        1-Manual Iris,
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-HIK 3.8-16mm F1.5(HV3816P-8MPIR)
        6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        7-HIK 2.7-12mm F1.2(TV2712P-MPIR)
        8- MZ5721D-12MPIR
        9- MZ1555D-12MPIR
        10- MZ5721D-12MPIR(RS485)
        11- MZ1555D-12MPIR(RS485)
        */
    BYTE byIrisMode;
    BYTE byMirror;   /* Mirror: 0 off, 1- leftright, 2- updown, 3-center */
    BYTE byDigitalZoom;   /*Digital zoom: 0 disable  1 enable*/
    BYTE byDeadPixelDetect;    /*Corrupted Pixel detect, 0-disable  1-enable*/
    BYTE byBlackPwl; /*Black Power Level ,   0- 255*/
    BYTE byEptzGate; // EPTZ: 0-off; 1-Eletronic PTZ
    BYTE byLocalOutputGate; //Local output 0- local output closed; 1- Local BNC output open; 2- HDMI output closed  
    //20- HDMI_720P50 output open
    //21- HDMI_720P60 output open
    //22- HDMI_1080I60 output open
    //23- HDMI_1080I50 output open
    //24- HDMI_1080P24 output open
    //25- HDMI_1080P25 output open
    //26- HDMI_1080P30 output open
    //27- HDMI_1080P50 output open
    //28- HDMI_1080P60 output open

    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60
    BYTE byCoderOutputMode; //Encoder's FPGA output mode
    BYTE byLineCoding; //Enable line coding or not: 0- enable, 1- disable
    BYTE byDimmerMode; //Dimming mode: 0- semi-automatic, 1- automatic
    BYTE byPaletteMode; //Color palette: 0- incandescence, 1- Black heat, 2- palette 2, ..., 8- palette 8
    BYTE byEnhancedMode; //Enhance mode (around detected object): 0- not enhance, 1- 1, 2- 2, 3- 3, 4- 4
    BYTE byDynamicContrastEN;     //Increase Dynamic Contrast 0- 1
    BYTE byDynamicContrast;     //Dynamic Contrast 0- 100
    BYTE byJPEGQuality;     //JPEG Quality: 0- 100
    NET_DVR_CMOSMODECFG struCmosModeCfg; //Configuration under CMOS mode
    BYTE byFilterSwitch; //Filter switch: 0- disable, 1- enable
    BYTE byFocusSpeed;  //Focus speed: 0-10
    BYTE byAutoCompensationInterval; //Scheduled automatic shutter compensation: 1-120, unit: minute
    BYTE bySceneMode;  //Scene mode: 0- outdoor, 1- indoor, 2- default, 3 - lowLight
}NET_DVR_CAMERAPARAMCFG, *LPNET_DVR_CAMERAPARAMCFG;

typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //mode 0-disable,1-auto,2-enble
    BYTE byLevel; //level 1-100 
    BYTE byRes[6];
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;
    BYTE byLevel; //level 1-100 
    BYTE byRes[6];
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; // 0~NO enable, 1~ enable
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0~Automatic,1~manual
    BYTE  byIRDistance;//Infrared distance class (grade, distance is proportional) level:1~100 default: 50 (manual mode increase)
    BYTE  byShortIRDistance;// Short IR Distance(1~100)
    BYTE  byLongIRDistance;// Long IR Distance(1~100)
}NET_DVR_SMARTIR_PARAM, *LPNET_DVR_SMARTIR_PARAM;

typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0~Automatic,1~manual
    BYTE  byPIrisAperture;//Infrared aperture size grade (grade, aperture size is proportional) level:1~100 default: 50 (manual mode increase)
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM, *LPNET_DVR_PIRIS_PARAM;

//laser parameter 2014-02-25
typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE    byControlMode;        //control mode            0-invalid,1-auto,2-manual  the default is auto
    BYTE    bySensitivity;        //laser sensitivity        0-100  the default is 50
    BYTE    byTriggerMode;        //laser trigger mode    0-invalid,1-Camera Module Trigger,2-Photoresistance Trigger  the default is 1
    BYTE    byBrightness;        //Manual mode;laser brightness        0-255  the default is 100
    BYTE    byAngle;            //laser angle            0-invalid,1-36  the default is 12
    BYTE    byLimitBrightness;  //Auto mode;Laser lamp brightness limit 0~100      2014-01-26
    BYTE    byEnabled;         //Enabled
    BYTE    byIllumination;     //Illumination; 0~100
    BYTE    byLightAngle;       //Light Angle 0~100
    BYTE    byRes[7];
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off 
    BYTE   byMode;
    //(time: according to ability display unit minutes, options 10,20,30,40,50,60,120,180,240)
    BYTE   byRes1;
    WORD  wCompensateTime; //Timing mode effect
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM, *LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//Normal Mode Level[1,100],Normal mode effect
    BYTE  byExpertLevel;//Exper Mode Level[1,100],Exper Mode effect
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM, *LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//Light Level[1,100];Manual Mode effect
    BYTE  byGainLevel; //Gain Level[1,100];Manual Mode effect
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM, *LPNET_DVR_AGC_PARAM;

//Snap CCD CFG
typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG
{
    BYTE byWDRMode;   // WDR Mode
    BYTE byWDRType;    // WDR Type
    BYTE byWDRLevel;   // WDR Level
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //Start WDR Time
    NET_DVR_TIME_EX struEndTime; //Stop WDR Time
    BYTE byDayNightBrightness; //Day Night Brightness
    //MCE
    BYTE byMCEEnabled;//MCE Enabled,
    BYTE byMCELevel;//MCE Level
    //Auto Contrast
    BYTE byAutoContrastEnabled;//Auto Contrast Enabled
    BYTE byAutoContrastLevel;//Auto Contrast Level
    //LSE Detail
    BYTE byLSEDetailEnabled;//LSE Detail Enabled
    BYTE byLSEDetailLevel;//LSE Detail Level
    // License Plate Definition Enhancement
    BYTE byLPDEEnabled;//LPDE Enabled
    BYTE byLPDELevel;//LPDE Level
    //Contrast enhancement
    BYTE byLseEnabled; //Contrast enhancement enable, true:turn on, false: turn off
    BYTE byLseLevel; //Contrast enhancement level 0-100, default 0
    BYTE byLSEHaloLevel;//Halo suppression level range 0-100, default 0 
    BYTE byLseType; //Contrast enhancement switch model 0~force enable, 1~enable by time, 2~enable by brightness
    BYTE byRes2[3];
    NET_DVR_TIME_EX struLSEStartTime; //enable Contrast enhancement time(when byLseType is 1)
    NET_DVR_TIME_EX struLSEEndTime; //disable Contrast enhancement time(when byLseType is 1)
    BYTE byLightLevel;//brightness range 0-100, default 0(Take effect when byLseType is 2)
    //plate contrast
    BYTE byPlateContrastLevel;//plate contrast level range 0-100,default 0
    //plate saturation
    BYTE byPlateSaturationLevel;//plate saturation level range 0-100 default 0
    BYTE byRes[9];
} NET_DVR_SNAP_CAMERAPARAMCFG, *LPNET_DVR_SNAP_CAMERAPARAMCFG;

//Optical Dehaze
typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~disable,1~Enable
    BYTE byRes[7];
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

//Thermometry AGC configure
typedef struct tagNET_DVR_THERMOMETRY_AGC
{
    BYTE  byMode;//AGC Mode,0~invalid,1~auto,2~manual
    BYTE  byRes1[3];
    int     iHighTemperature;//High temperature,range:-273~9999 centigrade(1~manual valid)
    int     iLowTemperature;//Low temperature,range:-273~9999 centigrade(1~manual valid)
    BYTE  byRes[8];
}NET_DVR_THERMOMETRY_AGC, *LPNET_DVR_THERMOMETRY_AGC;

//IPC CCD Parameter Configuration
typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect; /*Brightness, Contrast, Saturation, Sharpness, Hue Configuration*/
    NET_DVR_GAIN struGain; /*Auto Gain*/
    NET_DVR_WHITEBALANCE struWhiteBalance; /*White Balance*/
    NET_DVR_EXPOSURE struExposure;  /*Exposure Control*/
    NET_DVR_GAMMACORRECT struGammaCorrect; /*Gamma Correction*/
    NET_DVR_WDR struWdr; /*WDR*/
    NET_DVR_DAYNIGHT struDayNight; /*Day/Night*/
    NET_DVR_BACKLIGHT struBackLight; /*BLC*/
    NET_DVR_NOISEREMOVE struNoiseRemove; /*DNR*/
    BYTE byPowerLineFrequencyMode;  /*0- 50HZ;  1- 60HZ*/
    BYTE byIrisMode;
    /*
    0-Auto Iris
    1-Manual Iris
    2-P-Iris1
    3-Union 3-9mm F1.6-2.7 (T5280-PQ1)
    4-Union 2.8-12mm F1.
    5-private 3.8-16mm F1.5(HV3816P-8MPIR)
    6-private 11-40mm F1.7 (HV1140P-8MPIR)
    7-private 2.7-12mm F1.2(TV2712P-MPIR)
    8- MZ5721D-12MPIR
    9- MZ1555D-12MPIR
    10- MZ5721D-12MPIR(RS485)
    11- MZ1555D-12MPIR(RS485)
    */
    BYTE byMirror;   /* Mirror: 0 off, 1- leftright, 2- updown, 3-center */
    BYTE byDigitalZoom;   /*Digital zoom: 0 disable, 1-*2,2-*4,3-*8,4-*16,5-*32*/
    BYTE byDeadPixelDetect;    /*Corrupted Pixel detect, 0-disable  1-enable*/
    BYTE byBlackPwl; /*Black Power Level ,   0- 255*/
    BYTE byEptzGate; // EPTZ: 0-off; 1-Eletronic PTZ
    BYTE byLocalOutputGate; //Local output 0- local output closed; 1- Local BNC output open; 2- HDMI output closed  
    //20- HDMI_720P50 output open
    //21- HDMI_720P60 output open
    //22- HDMI_1080I60 output open
    //23- HDMI_1080I50 output open
    //24- HDMI_1080P24 output open
    //25- HDMI_1080P25 output open
    //26- HDMI_1080P30 output open
    //27- HDMI_1080P50 output open
    //28- HDMI_1080P60 output open
    BYTE byCoderOutputMode; //Encoder's FPGA output mode
    BYTE byLineCoding; //Enable line coding or not: 0- enable, 1- disable
    BYTE byDimmerMode; //Dimming mode: 0- semi-automatic, 1- automatic
    BYTE byPaletteMode; //Color palette: 0- incandescence, 1- Black heat, 2- palette 2, ..., 8- palette 8,22-color3
    BYTE byEnhancedMode; //Enhance mode (around detected object): 0- not enhance, 1- 1, 2- 2, 3- 3, 4- 4
    BYTE byDynamicContrastEN;     //Increase Dynamic Contrast 0- 1
    BYTE byDynamicContrast;     //Dynamic Contrast 0- 100
    BYTE byJPEGQuality;     //JPEG Quality: 0- 100
    NET_DVR_CMOSMODECFG struCmosModeCfg; //Configuration under CMOS mode
    BYTE byFilterSwitch; //Filter switch: 0- disable, 1- enable
    BYTE byFocusSpeed;  //Focus speed: 0-10
    BYTE byAutoCompensationInterval; //Scheduled automatic shutter compensation: 1-120, unit: minute
    BYTE bySceneMode;  //Scene mode: 0- outdoor, 1- indoor, 2- default, 3 - lowLight
    NET_DVR_DEFOGCFG struDefogCfg;//
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//
    BYTE   byExposureSegmentEnable; //0~ is not enabled, 1~ enables the exposure time and gain ladder adjustment, such as exposure to adjust, improve the exposure time to the intermediate value, and then increase the gain to the intermediate value, and then improve the exposure to a maximum value, finally improve the gain to the maximum
    BYTE   byBrightCompensate;//Brightness enhancement [0~100]
    /*
      0-close,1-640*480@25fps,2-640*480@30ps,3-704*576@25fps,4-704*480@30fps,5-1280*720@25fps,6-1280*720@30fps,
      7-1280*720@50fps,8-1280*720@60fps,9-1280*960@15fps,10-1280*960@25fps,11-1280*960@30fps,
      12-1280*1024@25fps,13--1280*1024@30fps,14-1600*900@15fps,15-1600*1200@15fps,16-1920*1080@15fps,
      17-1920*1080@25fps,18-1920*1080@30fps,19-1920*1080@50fps,20-1920*1080@60fps,21-2048*1536@15fps,22-2048*1536@20fps,
      23-2048*1536@24fps,24-2048*1536@25fps,25-2048*1536@30fps,26-2560*2048@25fps,27-2560*2048@30fps,
      28-2560*1920@7.5fps,29-3072*2048@25fps,30-3072*2048@30fps,31-2048*1536@12.5,32-2560*1920@6.25,
      33-1600*1200@25,34-1600*1200@30,35-1600*1200@12.5,36-1600*900@12.5,37-1280*960@12.5fps,38-800*600@25fps,39-800*600@30fps40,
      4000*3000@12.5fps,41-4000*3000@15fps,42-4096*2160@20fps,43-3840*2160@20fps ,44-960*576@25fps,45-960*480@30fps,46-752*582@25fps,
      47-768*494@30fps,48-2560*1440@25fps,49-2560*1440@30fps ,50-720P@100fps,51-720P@120fps,52-2048*1536@50fps,53-2048*1536@60fps,
      54-3840*2160@25fps,55-3840*2160@30fps,56-4096*2160@25fps,57-4096*2160@30fps ,58-1280*1024@50fps,59-1280*1024@60fps,
      60-3072*2048@50fps,61-3072*2048@60fps,62-3072*1728@25fps,63-3072*1728@30fps,64-3072*1728@50fps,65-3072*1728@60fps,66-336*256@50fps,67-336*256@60fps,
      68-384*288@50fps,69-384*288@60fps ,70- 640 * 512@50fps ,71- 640 * 512@60fps,72-2592*1944@25fps,73-2592*1944@30fps,74-2688*1536@25fps,75-2688*1536@30fps
      76-2592*1944@20fps,77-2592*1944@15fps,78-2688*1520@20fps,79-2688*1520@15fps,80-2688*1520@25fps,81-2688*1520@30fps,82- 2720*2048@25fps, 83- 2720*2048@30fps,
      84- 336*256@25fps,85- 384*288@25fps,86-640*512@25fps,87-1280*960@50fps,88-1280*960@60fps,89-1280*960@100fps,90-1280*960@120fps,91-4000*3000@20fps,
      92-1920*1200@25fps,93-1920*1200@30fps,94-2560*1920@25fps,95-2560*1920@20fps,96-2560*1920@30fps,97-1280*1920@25fps,98-1280*1920@30fps,
      99-4000*3000@24fps,100-4000*3000@25fps,101-4000*3000@10fps,102- 384*288@30fps,103-2560*1920@15fps,104-2400*3840@25fps,105-1200*1920@25fps,
      106-4096*1800@30fps,107-3840*1680@30fps,108-2560*1120@30fps,109-704*320@30fps,110-1280*560@30fps,111-4096*1800@25fps,112-3840*1680@25fps,
      113-2560*1120@25fps,114-704*320@25fps,115-1280*560@25fps,116-2400*3840@24fps,117-3840*2400@24fps,118-3840*2400@25fps,119-2560*1920@12.5fps,
      120-2560*2048@12fps,121-2560*2048@15fps,122-2560*1536@25fps,123-2560*1536@30fps,124-2256*2048@25fps,125-2256*2048@30fps,126-2592*2592@12.5fps,127-2592*2592@15fps,
      128 - 640*512@30fps,129-2048*1520@30fps,130-2048*1520@25fps,131-3840*2160@24fps,132-2592*1520@25fps,133-2592*1520@30fps,134-2592*1536@25fps,135-2592*1536@30fps,
      136-640*960@25fps,137-640*960@24fps,139-3840*1080@25fps,140-3840*1080@30fps,142-2992*2192@25fps,143-2992*2192@30fps,144-3008*2160@25fps,145-3008*2160@30fps,
      146-3072*1728@20fps,147-2560*1440@20fps,148-2160*3840@25fps,149-2160*3840@30fps,150-7008*1080@25fps,151-7008*1080@30fps,152-3072*2048@20fps,153-1536*864@25fps,
      154-2560*1920@24fps,155-2400*3840@30fps,156-3840*2400@30fps,157-3840*2160@15fps,
      158-384*288@8.3fps, 159-640*512@8.3fps, 160-160*120@8.3fps, 161-1024*768@8.3fps, 162-640*480@8.3fps, 163-3840*2160@12.5fps, 164-2304*1296@30fps, 165-2304*1296@25fps,
      166-2560*1440@24fps, 167-2688*1512@25fps, 168-2688*1512@30fps, 169-2688*1512@50fps, 170-2688*1512@60fps, 171-1536*864@30fps, 172-2560*1440@50fps, 173-2560*1440@60fps,
      174-2048*2048@25fps, 175-2048*2048@30fps, 176-4000*3060@20fps, 177-3060*3060@25fps, 178-3060*3060@30fps, 179-3000*3000@25fps, 180-3000*3000@30fps,181-8160*3616@30fps,
      182-8160*3616@25fps, 183-3000*3000@20fps, 184-3000*3000@15fps, 185-3000*3000@12.5fps,186-5472*3648@25fps,187-5472*3648@30fps,188-7680*4320@25fps,189-7680*4320@30fps,
      190-8160*2400@25fps, 191-8160*2400@30fps, 192-5520*2400@25fps, 193-5520*2400@30fps, 194-2560*1440@15fps, 195-1944*1212@24fps, 196-1944*1212@25fps, 197-3456*1920@30fps,
      198-4800*2688@25fps, 199-4800*2688@30fps, 200-6480*1080@25fps, 201-6480*1080@30fps, 202-8640*1440@25fps, 203-8640*1440@30fps, 204-3456*1920@25fps, 205-2688*1520@50fps,
      206-2688*1520@60fps, 207-4976*1452@25fps, 208-4976*1452@30fps, 209-3200*1800@25fps, 210-3200*1800@30fps, 211-5472*3648@24fps, 212-1920*1080@12.5fps, 213-2944*1656@20fps,
      214-1920*1080@24fps, 215-4800*1600@25fps, 216-4800*1600@30fps, 217-2560*1440@12.5fps, 218-6560*3690@1fps, 219-5120*1400@20fps, 220-7680*4320@1fps, 221-1920*1080@20fps,
      222-5120*1440@20fps, 222-5120*1440@20fps, 223-4080*1808@25fps, 224-4080*1808@30fps, 225-4080*1152@25fps, 226-4080*1152@30fps, 227-2688*1944@20fps,228-2592*1944@24fps,
      229-3200*1800@15fps, 230-4416*1696@20fps, 231-3456*1080@25fps, 232-3200*1800@12.5fps, 233-2688*1532@25fps, 234-2688*1532@30fps, 235-4416*1696@12.5fps, 236-3840*2048P12.5fps,
      237-3840*4096P12.5fps, 238-5120*1440@12.5fps, 239-3840*1080@24fps, 240-320*256@30fps, 241-3264*2448@25fps, 242-3264*2448@30fps, 243-5430*3054@1fps, 244-2688*1520@24@24fps,
      245-4000*3000@30fps*/
    BYTE   byCaptureModeN;
    BYTE   byCaptureModeP;
    NET_DVR_SMARTIR_PARAM struSmartIRParam;
    NET_DVR_PIRIS_PARAM struPIrisParam;//The PIris configuration information corresponding to the byIrisMode field come into force from 2-PIris1
    NET_DVR_LASER_PARAM_CFG struLaserParam;    //laser parameter
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//Lens distortion correction 0-Disable,1-Enable
    BYTE   byDistortionCorrectionLevel;//0-res;1-level1;2-level2;3-level3;255-custom
    BYTE   byCalibrationAccurateLevel;//[0-100]
    BYTE   byZoomedInDistantViewLevel;//[0-100]
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD; //Snap CCD CFG
    NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//Optical Dehaze
    NET_DVR_THERMOMETRY_AGC struThermAGC;//AGC configure
    BYTE   byFusionMode; //fusion mode,0-thermal;1-fusion;2-PIP,3~Visible mode, 4~Fusion black and white mode, 5~Fusion color mode-Grassland, 6~Fusion color mode-Waste land, 7~Fusion color mode-Snow, 8~Fusion color mode-Ocean, 9~Fusion color mode-City
    BYTE   byHorizontalFOV;//[0-100]
    BYTE   byVerticalFOV;//[0-100]
    BYTE   byBrightnessSuddenChangeSuppression;//0-close 1-open
    BYTE   byGPSEnabled;//GPS switch enabled, 0-off, 1-on
    BYTE   byRes2[155];
}NET_DVR_CAMERAPARAMCFG_EX, *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD  dwSize;
    BYTE    byState;//Focusing Position State: 0-not in place,1-in place
    BYTE    byRes[31];
} NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;

//plate color
typedef enum _VCA_PLATE_COLOR_
{
    VCA_BLUE_PLATE = 0,       //Blue license plate
    VCA_YELLOW_PLATE,          //Yellow license plate
    VCA_WHITE_PLATE,           //White license plate
    VCA_BLACK_PLATE,           //Black license plate
    VCA_GREEN_PLATE,           //Green license plate
    VCA_BKAIR_PLATE,           //Civil aviation balck license plate
    VCA_RED_PLATE,            //Red license plate
    VCA_ORANGE_PLATE,         //Orange license plate
    VCA_OTHER = 0xff           //Other
}VCA_PLATE_COLOR;

//plate type
typedef enum _VCA_PLATE_TYPE_
{
    VCA_STANDARD92_PLATE = 0,    //Standard civil car and military car
    VCA_STANDARD02_PLATE,        //civil car license plate of form 02
    VCA_WJPOLICE_PLATE,            //Armed police car 
    VCA_JINGCHE_PLATE,            //Police car
    STANDARD92_BACK_PLATE,      //Dual-line rear plate of civil car
    VCA_SHIGUAN_PLATE,          //Embassy license plate
    VCA_NONGYONG_PLATE,         //Agricultural vehicles
    VCA_MOTO_PLATE,              //Motorcycle
    NEW_ENERGY_PLATE,             //new Energy Plate
    VCA_CONSULATE_PLATE = 9,      //consulate Plate
    VCA_EMERGENCY_PLATE = 10,     //emergency plate
    //2017-05-18 add The Middle East Plate Type
    TRANSPORT_PLATE = 0x20,     //Transport
    COMMERCIAL_PLATE,           //Commercial
    PRIVATE_PLATE,              //Private car
    LEARNING_PLATE,             //Learning
    CD_PLATE,                   //Embassy car(CD)
    CC_PLATE,                   //Embassy car(CC)
    ARMY_PLATE,                 //military car
    PROTOCOL_PLATE,             //PROTOCOL
    GOVERNMENT_PLATE,           //Government Car
    EXPORT_PLATE,               //EXPORT
    TAXI_PLATE,                 //Taxi
    TESTING_PLATE,              //TESTING
    TRANSFER_PLATE,             //TRANSFER
    TRUCK_PLATE,                //TRUCK
    BUS_PLATE,                  //BUS
    PUBLIC_PLATE,               //PUBLIC
    PUB_TRANS_PLATE,            //PUBLIC TRANSFER
    PRI_TRANS_PLATE,            //PRIVATE TRANSPORT
    UNKNOWN_PLATE = 0xff,       //Unknown(Unrecognized)
}VCA_PLATE_TYPE;

//Vehicle Color
typedef enum _VCR_CLR_CLASS
{
    VCR_CLR_UNSUPPORT = 0,      //Not supported
    VCR_CLR_WHITE = 1,   //White
    VCR_CLR_SILVER = 2,   //Silver
    VCR_CLR_GRAY = 3,      //Gray
    VCR_CLR_BLACK = 4,      //Black
    VCR_CLR_RED = 5,      //Red
    VCR_CLR_DARKBLUE = 6,      //Darkblue
    VCR_CLR_BLUE = 7,      //Blue
    VCR_CLR_YELLOW = 8,      //Yellow
    VCR_CLR_GREEN = 9,      //Green
    VCR_CLR_BROWN = 10,  //Brown
    VCR_CLR_PINK = 11,  //Pink
    VCR_CLR_PURPLE = 12,  //Purple
    VCR_CLR_DARKGRAY = 13,  //Darkgray
    VCR_CLR_CYAN = 14   //Cyan
}VCR_CLR_CLASS;

//Vehicle Operate Type 2013-11-04
typedef enum _VCA_OPERATE_TYPE_
{
    VCA_LICENSE_TYPE = 0x1,  //License
    VCA_PLATECOLOR_TYPE = 0x2,  //Plate Color
    VCA_CARDNO_TYPE = 0x4,  //Card No
    VCA_PLATETYPE_TYPE = 0x8,  //Plate Type
    VCA_LISTTYPE_TYPE = 0x10, //List Type
    VCA_INDEX_TYPE = 0x20,  //Data Index
    VCA_OPERATE_INDEX_TYPE = 0x40   //Operate Index Type 2014-03-03
}VCA_OPERATE_TYPE;

typedef enum _VCA_ILLEGAL_TYPE_
{
    VCA_POSTPIC_TYPE = 0x1,
    VCA_LOWSPEED_TYPE = 0x2,
    VCA_HIGHSPEED_TYPE = 0x4,
    VCA_RETROGRADE_TYPE = 0x8,
    VCA_RUSH_REDLIGHT_TYPE = 0x10,
    VCA_PRESS_LANE_TYPE = 0x20,
    VCA_VIOLATE_GUIDE_TYPE = 0x40,
    VCA_ROAD_STRAND_TYPE = 0x80,
    VCA_VEHICLE_ILLEGAL_LANE_TYPE = 0x100,
    VCA_ILLEGAL_LANE_CHANGE_TYPE = 0x200,
    VCA_ILLEGAL_LANE_DRIVE_TYPE = 0x400,
    VCA_VIOLATE_BAN_TYPE = 0x800,
    VCA_CROSS_PARKING_TYPE = 0x1000,
    VCA_GREEN_PARKING_TYPE = 0x2000
}VCA_ILLEGAL_TYPE;

typedef enum _VCA_VEHICLE_TYPE_
{
    VCA_OTHER_TYPE = 0x1,
    VCA_SMALLCAR_TYPE = 0x2,
    VCA_BIGCAR_TYPE = 0x4,
    VCA_BUS_TYPE = 0x8,
    VCA_TRUCK_TYPE = 0x10,
    VCA_CAR_TYPE = 0x20,
    VCA_MINIBUS_TYPE = 0x40,
    VCA_SMALL_TRUCK_TYPE = 0x80
}VCA_VEHICLE_TYPE;

typedef enum _VLR_VEHICLE_CLASS
{
    VLR_OTHER = 0,
    VLR_VOLKSWAGEN = 1,
    VLR_BUICK = 2,
    VLR_BMW = 3,
    VLR_HONDA = 4,
    VLR_PEUGEOT = 5,
    VLR_TOYOTA = 6,
    VLR_FORD = 7,
    VLR_NISSAN = 8,
    VLR_AUDI = 9,
    VLR_MAZDA = 10,
    VLR_CHEVROLET = 11,
    VLR_CITROEN = 12,
    VLR_HYUNDAI = 13,
    VLR_CHERY = 14,
    VLR_KIA = 15,
    VLR_ROEWE = 16,
    VLR_MITSUBISHI = 17,
    VLR_SKODA = 18,
    VLR_GEELY = 19,
    VLR_ZHONGHUA = 20,
    VLR_VOLVO = 21,
    VLR_LEXUS = 22,
    VLR_FIAT = 23,
    VLR_EMGRAND = 24,
    VLR_DONGFENG = 25,
    VLR_BYD = 26,
    VLR_SUZUKI = 27,
    VLR_JINBEI = 28,
    VLR_HAIMA = 29,
    VLR_SGMW = 30,
    VLR_JAC = 31,
    VLR_SUBARU = 32,
    VLR_ENGLON = 33,
    VLR_GREATWALL = 34,
    VLR_HAFEI = 35,
    VLR_ISUZU = 36,
    VLR_SOUEAST = 37,
    VLR_CHANA = 38,
    VLR_FOTON = 39,
    VLR_XIALI = 40,
    VLR_BENZ = 41,
    VLR_FAW = 42,
    VLR_NAVECO = 43,
    VLR_LIFAN = 44,
    VLR_BESTURN = 45,
    VLR_CROWN = 46,
    VLR_RENAULT = 47,
    VLR_JMC = 48,
    VLR_MG = 49,
    VLR_KAMA = 50,
    VLR_ZOTYE = 51,
    VLR_CHANGHE = 52,
    VLR_XMKINGLONG = 53,
    VLR_HUIZHONG = 54,
    VLR_SZKINGLONG = 55,
    VLR_HIGER = 56,
    VLR_YUTONG = 57,
    VLR_CNHTC = 58,
    VLR_BEIBEN = 59,
    VLR_XINGMA = 60,
    VLR_YUEJIN = 61,
    VLR_HUANGHAI = 62,
    VLR_OLDWALL = 63,
    VLR_CHANACOMMERCIAL = 64,
    VLR_PORSCHE = 65,
    VLR_CADILLAC = 66,
    VLR_INFINITI = 67,
    VLR_GLEAGLE = 68,
    VLR_JEEP = 69,
    VLR_LANDROVER = 70,
    VLR_CHANGFENG = 71,
    VLR_BENNI = 72,
    VLR_ERA = 73,
    VLR_TAURUS = 74,
    VLR_EADO = 75,
    VLR_SHANQI = 76,
    VLR_HONGYAN = 77,
    VLR_DRAGON = 78,
    VLR_JACTEXT = 79,
    VLR_JACBUS = 80,
    VLR_ANKAI = 81,
    VLR_SHENLONG = 82,
    VLR_DAEWOO = 83,
    VLR_WUZHENG = 84,
    VLR_MAN = 85,
    VLR_ZHONGTONG = 86,
    VLR_BAOJUN = 87,
    VLR_BQWEIWANG = 88,
    VLR_TRUMPCHE = 89,
    VLR_LUFENG = 90,
    VLR_HMZHENGZHOU = 91,
    VLR_BEIJING = 92,
    VLR_ZHONGSHUN = 93,
    VLR_WEILIN = 94,
    VLR_OPEL = 95,
    VLR_KARRY = 96,
    VLR_SMA = 97,
    VLR_SMATEXT = 98,
    VLR_YUWIN = 99,
    VLR_MINI = 100,
    VLR_MARK = 101,
    VLR_HAVAL = 102,
    VLR_OGA = 103,
    VLR_VENUCIA = 104,
    VLR_BYD2 = 105,
    VLR_SMART = 106,
    VLR_BAW = 107,
    VLR_LUXGEN = 108,
    VLR_YEMA = 109,
    VLR_ZTE = 110,
    VLR_EVERUS = 111,
    VLR_CHRYSLER = 112,
    VLR_GONOW = 113,
    VLR_SHJIANG = 114,
    VLR_RUILIN = 115,
    VLR_FORTA = 116,
    VLR_GAGUAR = 117,
    VLR_HEIBAO = 118,
    VLR_TKING = 119,
    VLR_TKINGTEXT = 120,
    VLR_FODAY = 121,
    VLR_LOTUS = 122,
    VLR_NANJUN = 123,
    VLR_SHUANGHUAN = 124,
    VLR_SAIBAO = 125,
    VLR_HAWTAI = 126,
    VLR_LIFO = 127,
    VLR_JONWAY = 128,
    VLR_FULONGMA = 129,
    VLR_WEILI = 130,
    VLR_ANCHI = 131,
    VLR_PAIXI = 132,
    VLR_HIGERTEXT = 133,
    VLR_RIYECAR = 134,
    VLR_RIYETRUCK = 135,
    VLR_JIANGNAN = 136,
    VLR_OLDZOTYE = 137,
    VLR_OLDXIALI = 138,
    VLR_NEWAOCHI = 139,
    VLR_CDW = 140,
    VLR_CDWTEXT = 141,
    VLR_CIIMO = 142,
    VLR_CHANADS = 143,
    VLR_DS = 144,
    VLR_ROHENS = 145,
    VLR_YANTAI = 146,
    VLR_SHUANGLONG = 147,
    VLR_FENGLING = 148,
    VLR_XINKAI = 149,
    VLR_GMC = 150,
    VLR_DATONG = 151,
    VLR_BQYINXIANG = 152,
    VLR_NEWCHERY = 153,
    VLR_MUDAN = 154,
    VLR_DAYUN = 155,
    VLR_DONGWO = 156,
    VLR_UNION = 157,
    VLR_CHUNZHOU = 158,
    VLR_SANY = 159,
    VLR_YAXING = 160,
    VLR_HENGTONG = 161,
    VLR_SHAOLIN = 162,
    VLR_YOUNG = 163,
    VLR_STOM = 164,
    VLR_SANHUAN = 165,
    VLR_XUGONG = 166,
    VLR_BEIFANG = 167,
    VLR_JIANGHUAN = 168,
    VLR_BJFARM = 169,
    VLR_NEWDADI = 170,
    VLR_SUNWIN = 171,
    VLR_YINGTIAN = 172,
    VLR_QINGQI = 173,
    VLR_CHUFENG = 174,
    VLR_SCANIA = 175,
    VLR_JIULONG = 176,
    VLR_YOUYI = 177,
    VLR_SHANGRAO = 178,
    VLR_JIJIANG = 179,
    VLR_YANGZI = 180,
    VLR_XIWO = 181,
    VLR_CHANGJIANG = 182,
    VLR_WUYI = 183,
    VLR_CHENGDU = 184,
    VLR_TIANMA = 185,
    VLR_BAOLONG = 186,
    VLR_NEWYATU = 187,
    VLR_BARUI = 188,
    VLR_GUANZHI = 189,
    VLR_XIYATE = 190,
    VLR_BINLI = 191,
    VLR_DADI = 192,
    VLR_FUQI = 193,
    VLR_HANGTIAN = 194,
    VLR_HENGTIAN = 195,
    VLR_JMCCAR = 196,
    VLR_KAERSEN = 197,
    VLR_KAWEI = 198,
    VLR_LANBOJINI = 199,
    VLR_MASHALADI = 200,
    VLR_SHUCHI = 201,
    VLR_SHILI = 202,
    VLR_HUABEI = 203,
    VLR_YIZHENG = 204,
    VLR_CHUNLAN = 205,
    VLR_DAFA = 206,
    VLR_SHENYE = 207,
    VLR_FALALI = 208,
    VLR_FUXING = 209,
    VLR_ANYUAN = 210,
    VLR_JINGHUA = 211,
    VLR_TAIHU = 212,
    VLR_WUZHOULONG = 213,
    VLR_CHANGLONG = 214,
    VLR_YUEXI = 215,
    VLR_SHENMA = 216,
    VLR_LUSHAN = 217,
    VLR_WANFENG = 218,
    VLR_GZYUNBAO = 219,
    VLR_ZHONGDA = 220,
    VLR_THREEWHEEL = 221,
    VLR_TWOWHEEL = 222,
    VLR_JBC = 223,
    VLR_YZJIANG = 224,
    VLR_CNJ = 225,
    VLR_FORLAND = 226,
    VLR_FARMCAR = 227,
    VLR_DONGFANGHONG = 228,
    VLR_STEYR = 229,
    VLR_HONGQI = 230,
    VLR_USER1 = 231,
    VLR_USER2 = 232,
    VLR_USER3 = 233,
    VLR_USER4 = 234,
    VLR_USER5 = 235,
    VLR_USER6 = 236,
    VLR_USER7 = 237,
    VLR_USER8 = 238
}VLR_VEHICLE_CLASS;

/********************Vehicle Brand Sub Type Begin*************************/
//VOLKSWAGEN
typedef enum _VSB_VOLKSWAGEN_CLASS
{
    VSB_VOLKSWAGEN_OTHER = 0,
    VSB_VOLKSWAGEN_LAVIDA = 1,
    VSB_VOLKSWAGEN_CROSSLAVIDA = 2,
    VSB_VOLKSWAGEN_TIGUAN = 3,
    VSB_VOLKSWAGEN_TOURAN = 4,
    VSB_VOLKSWAGEN_SANTANA = 5,
    VSB_VOLKSWAGEN_SANTANA2000 = 6,
    VSB_VOLKSWAGEN_SANTANA3000 = 7,
    VSB_VOLKSWAGEN_VISTA = 8,
    VSB_VOLKSWAGEN_PASSAT = 9,
    VSB_VOLKSWAGEN_PASSATLINGYU = 10,
    VSB_VOLKSWAGEN_POLO = 11,
    VSB_VOLKSWAGEN_POLOCROSS = 12,
    VSB_VOLKSWAGEN_POLOGTI = 13,
    VSB_VOLKSWAGEN_SAGITAR = 14,
    VSB_VOLKSWAGEN_MAGOTAN = 15,
    VSB_VOLKSWAGEN_JETTA = 16,
    VSB_VOLKSWAGEN_BORA = 17,
    VSB_VOLKSWAGEN_NEWGOLF = 18,
    VSB_VOLKSWAGEN_GOLFGTI = 19,
    VSB_VOLKSWAGEN_GOL = 20,
    VSB_VOLKSWAGEN_CADDY = 21,
    VSB_VOLKSWAGEN_PHAETON = 22,
    VSB_VOLKSWAGEN_TOUREG = 23,
    VSB_VOLKSWAGEN_SCIROCCO = 24,
    VSB_VOLKSWAGEN_BEETLE = 25,
    VSB_VOLKSWAGEN_SHARAN = 26,
    VSB_VOLKSWAGEN_MULTIVAN = 27,
    VSB_VOLKSWAGEN_CARBONCOPY = 28,
    VSB_VOLKSWAGEN_VISTACHANGDA = 29,
    VSB_VOLKSWAGEN_BORASPORTLINE = 30,
    VSR_VOLKSWAGEN_CC_1 = 31,
    VSR_VOLKSWAGEN_Cross_POLO_1 = 32,
    VSR_VOLKSWAGEN_Cross_POLO_2 = 33,
    VSR_VOLKSWAGEN_MULTIVAN_1 = 34,
    VSR_VOLKSWAGEN_POLO_1 = 35,
    VSR_VOLKSWAGEN_POLO_2 = 36,
    VSR_VOLKSWAGEN_POLO_JINQU_1 = 37,
    VSR_VOLKSWAGEN_POLO_JINQU_2 = 38,
    VSR_VOLKSWAGEN_Tiguan_1 = 39,
    VSR_VOLKSWAGEN_Tiguan_2 = 40,
    VSR_VOLKSWAGEN_XIALANG_1 = 41,
    VSR_VOLKSWAGEN_BAOLAI_1 = 42,
    VSR_VOLKSWAGEN_BAOLAI_2 = 43,
    VSR_VOLKSWAGEN_BAOLAI_3 = 44,
    VSR_VOLKSWAGEN_BAOLAI_4 = 45,
    VSR_VOLKSWAGEN_SHANGKU_1 = 46,
    VSR_VOLKSWAGEN_PASATE_1 = 47,
    VSR_VOLKSWAGEN_PASATE_2 = 48,
    VSR_VOLKSWAGEN_PASATE_3 = 49,
    VSR_VOLKSWAGEN_PASATE_4 = 50,
    VSR_VOLKSWAGEN_PASATE_5 = 51,
    VSR_VOLKSWAGEN_JIEDA_1 = 52,
    VSR_VOLKSWAGEN_JIEDA_2 = 53,
    VSR_VOLKSWAGEN_JIEDA_3 = 54,
    VSR_VOLKSWAGEN_JIEDA_4 = 55,
    VSR_VOLKSWAGEN_LANGYI_1 = 56,
    VSR_VOLKSWAGEN_LANGYI_2 = 57,
    VSR_VOLKSWAGEN_SANGTANA_1 = 58,
    VSR_VOLKSWAGEN_SANGTANA_2 = 59,
    VSR_VOLKSWAGEN_SANGTANA_3 = 60,
    VSR_VOLKSWAGEN_SANGTANA_4 = 61,
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,
    VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,
    VSR_VOLKSWAGEN_JIAKECHONG_1 = 64,
    VSR_VOLKSWAGEN_JIAKECHONG_2 = 65,
    VSR_VOLKSWAGEN_HUITENG_2 = 66,
    VSR_VOLKSWAGEN_MAITENG_1 = 67,
    VSR_VOLKSWAGEN_MAITENG_2 = 68,
    VSR_VOLKSWAGEN_TUAN_3 = 69,
    VSR_VOLKSWAGEN_TUAN_1 = 70,
    VSR_VOLKSWAGEN_TUAN_2 = 71,
    VSR_VOLKSWAGEN_TUGUAN_1 = 72,
    VSR_VOLKSWAGEN_TURUI_1 = 73,
    VSR_VOLKSWAGEN_TURUI_2 = 74,
    VSR_VOLKSWAGEN_SUTENG_1 = 75,
    VSR_VOLKSWAGEN_SUTENG_2 = 76,
    VSR_VOLKSWAGEN_SUTENG_3 = 77,
    VSR_VOLKSWAGEN_GAOERFU_1 = 78,
    VSR_VOLKSWAGEN_GAOERFU_2 = 79,
    VSR_VOLKSWAGEN_GAOERFU_3 = 80,
    VSR_VOLKSWAGEN_LANGYI_3 = 81,
    VSR_VOLKSWAGEN_HUITENG_1 = 82
} VSB_VOLKSWAGEN_CLASS;


typedef enum _VBR_BUICK_CLASS
{
    VBR_BUICK_OTHER = 0,
    VBR_BUICK_ENCORE = 1,
    VBR_BUICK_GL8 = 2,
    VBR_BUICK_LEGAL = 3,
    VBR_BUICK_LACROSS = 4,
    VBR_BUICK_EXCELLE = 5,
    VBR_BUICK_EXCELLEGT = 6,
    VBR_BUICK_WXCELLEXT = 7,
    VBR_BUICK_ENCLAVE = 8,
    VBR_BUICK_ROYAUM = 9,
    VBR_BUICK_SAIL = 10,
    VBR_BUICK_EXCELLEHRV = 11,
    VBR_BUICK_PARKAVENUE = 12,
    VBR_BUICK_CENTURY = 13,
    VBR_BUICK_GL8_1 = 14,
    VBR_BUICK_GL8_2 = 15,
    VBR_BUICK_GL8_3 = 16,
    VBR_BUICK_GL8_4 = 17,
    VBR_BUICK_GL8_5 = 18,
    VBR_BUICK_ENCORE_1 = 19,
    VBR_BUICK_ENCLAVE_1 = 20,
    VBR_BUICK_LEGAL_1 = 21,
    VBR_BUICK_LEGAL_2 = 22,
    VBR_BUICK_LEGAL_3 = 23,
    VBR_BUICK_LEGAL_4 = 24,
    VBR_BUICK_LEGAL_5 = 25,
    VBR_BUICK_LEGAL_6 = 26,
    VBR_BUICK_LACROSS_1 = 27,
    VBR_BUICK_LACROSS_2 = 28,
    VBR_BUICK_LACROSS_3 = 29,
    VBR_BUICK_EXCELLE_1 = 30,
    VBR_BUICK_EXCELLE_2 = 31,
    VBR_BUICK_EXCELLE_3 = 32,
    VBR_BUICK_EXCELLE_4 = 33,
    VBR_BUICK_PARKAVENUE_1 = 34,
    VBR_BUICK_SAIL_1 = 35,
    VBR_BUICK_EXCELLEGT_1 = 36,
    VBR_BUICK_WXCELLEXT_1 = 37,
    VBR_BUICK_CENTURY_1 = 38,
    VBR_BUICK_RONGYU_1 = 39
}VBR_BUICK_CLASS;


typedef enum _VSB_BMW_CLASS
{
    VSB_BMW_OTHER = 0,
    VSB_BMW_3SERIES = 1,
    VSB_BMW_5SERIES = 2,
    VSB_BMW_X1 = 3,
    VSB_BMW_1SERIES = 4,
    VSB_BMW_7SERIES = 5,
    VSB_BMW_X3 = 6,
    VSB_BMW_X5 = 7,
    VSB_BMW_X6 = 8,
    VSB_BMW_Z4 = 9,
    VSB_BMW_MINI = 10,
    VSB_BMW_6SERIES = 11,
    VSB_BMW_YIXI_1 = 12,
    VSB_BMW_YIXI_2 = 13,
    VSB_BMW_SANXI_1 = 14,
    VSB_BMW_SANXI_2 = 15,
    VSB_BMW_SANXI_3 = 16,
    VSB_BMW_SANXI_4 = 17,
    VSB_BMW_WUXI_1 = 18,
    VSB_BMW_WUXI_2 = 19,
    VSB_BMW_LIUXI_1 = 20,
    VSB_BMW_QIXI_1 = 21,
    VSB_BMW_QIXI_2 = 22,
    VSB_BMW_X1_1 = 23,
    VSB_BMW_X1_2 = 24,
    VSB_BMW_X3_1 = 25,
    VSB_BMW_X3_2 = 26,
    VSB_BMW_X5_1 = 27,
    VSB_BMW_X5_2 = 28,
    VSB_BMW_X5_3 = 29,
    VSB_BMW_X6_1 = 30,
    VSB_BMW_Z4_1 = 31
}VSB_BMW_CLASS;


typedef enum _VSB_HONDA_CLASS
{
    VSB_HONDA_OTHER = 0,
    VSB_HONDA_CRV = 1,
    VSB_HONDA_JADE = 2,
    VSB_HONDA_CIVIC = 3,
    VSB_HONDA_SPIRIOR = 4,
    VSB_HONDA_CIIMO = 5,
    VSB_HONDA_ELYSION = 6,
    VSB_HONDA_OBYSSEY = 7,
    VSB_HONDA_FIT = 8,
    VSB_HONDA_NEWCITY = 9,
    VSB_HONDA_CROSSTOUR = 10,
    VSB_HONDA_CRIDER = 11,
    VSB_HONDA_ACCORD = 12,
    VSB_HONDA_CITY = 13,
    VSB_HONDA_ANTILOCK = 14,
    VSB_HONDA_CRZ = 15,
    VSB_HONDA_CRV_1 = 16,
    VSB_HONDA_CRV_2 = 17,
    VSB_HONDA_CRV_3 = 18,
    VSB_HONDA_CRV_4 = 19,
    VSB_HONDA_CRV_5 = 20,
    VSB_HONDA_CRIDER_1 = 21,
    VSB_HONDA_OBYSSEY_1 = 22,
    VSB_HONDA_OBYSSEY_2 = 23,
    VSB_HONDA_OBYSSEY_3 = 24,
    VSB_HONDA_OBYSSEY_4 = 25,
    VSB_HONDA_CIVIC_1 = 26,
    VSB_HONDA_CIVIC_5 = 27,
    VSB_HONDA_CIVIC_2 = 28,
    VSB_HONDA_CIVIC_3 = 29,
    VSB_HONDA_CIVIC_4 = 30,
    VSB_HONDA_CITY_1 = 31,
    VSB_HONDA_SPIRIOR_1 = 32,
    VSB_HONDA_SIMING_1 = 33,
    VSB_HONDA_JIEDE_1 = 34,
    VSB_HONDA_CROSSTOUR_1 = 35,
    VSB_HONDA_AILISHEN_1 = 36,
    VSB_HONDA_NEWCITY_1 = 37,
    VSB_HONDA_NEWCITY_2 = 38,
    VSB_HONDA_NEWCITY_3 = 39,
    VSB_HONDA_ACCORD_1 = 40,
    VSB_HONDA_ACCORD_2 = 41,
    VSB_HONDA_ACCORD_3 = 42,
    VSB_HONDA_ACCORD_4 = 43,
    VSB_HONDA_ACCORD_5 = 44,
    VSB_HONDA_ACCORD_6 = 45,
    VSB_HONDA_ACCORD_7 = 46,
    VSB_HONDA_ACCORD_8 = 47,
    VSB_HONDA_ACCORD_9 = 48,
    VSB_HONDA_ACCORD_10 = 49,
    VSB_HONDA_FIT_1 = 50,
    VSB_HONDA_FIT_2 = 51,
    VSB_HONDA_FIT_3 = 52,
    VSB_HONDA_FIT_4 = 53,
    VSB_HONDA_FIT_5 = 54,
    VSB_HONDA_FIT_6 = 55
}VSB_HONDA_CLASS;


typedef enum _VSB_PEUGEOT_CLASS
{
    VSB_PEUGEOT_OTHER = 0,
    VSB_PEUGEOT_2008 = 1,
    VSB_PEUGEOT_207 = 2,
    VSB_PEUGEOT_SENNA = 3,
    VSB_PEUGEOT_3008 = 4,
    VSB_PEUGEOT_301 = 5,
    VSB_PEUGEOT_307 = 6,
    VSB_PEUGEOT_308 = 7,
    VSB_PEUGEOT_408 = 8,
    VSB_PEUGEOT_508 = 9,
    VSB_PEUGEOT_206 = 10,
    VSB_PEUGEOT_407 = 11,
    VSB_PEUGEOT_206_1 = 12,
    VSB_PEUGEOT_207_1 = 13,
    VSB_PEUGEOT_207_2 = 14,
    VSB_PEUGEOT_3008_1 = 15,
    VSB_PEUGEOT_301_1 = 16,
    VSB_PEUGEOT_307_1 = 17,
    VSB_PEUGEOT_307_2 = 18,
    VSB_PEUGEOT_307_3 = 19,
    VSB_PEUGEOT_308_1 = 20,
    VSB_PEUGEOT_407_1 = 21,
    VSB_PEUGEOT_408_1 = 22,
    VSB_PEUGEOT_408_2 = 23,
    VSB_PEUGEOT_508_1 = 24,
    VSB_PEUGEOT_207_3 = 25,
    VSB_PEUGEOT_307_4 = 26

}VSB_PEUGEOT_CLASS;


typedef enum _VSB_TOYOTA_CLASS
{
    VSB_TOYOTA_OTHER = 0,
    VSB_TOYOTA_HIGHLANDER = 1,
    VSB_TOYOTA_CAMRY = 2,
    VSB_TOYOTA_YARIS = 3,
    VSB_TOYOTA_YARISL = 4,
    VSB_TOYOTA_VERSO = 5,
    VSB_TOYOTA_HUAGUAN = 6,
    VSB_TOYOTA_CROWN = 7,
    VSB_TOYOTA_COROLLA = 8,
    VSB_TOYOTA_COSTER = 9,
    VSB_TOYOTA_PRADO = 10,
    VSB_TOYOTA_PRIUS = 11,
    VSB_TOYOTA_RAV4 = 12,
    VSB_TOYOTA_REZI = 13,
    VSB_TOYOTA_VIOS = 14,
    VSB_TOYOTA_PREVIA = 15,
    VSB_TOYOTA_HIACE = 16,
    VSB_TOYOTA_86 = 17,
    VSB_TOYOTA_SPEQUOIA = 18,
    VSB_TOYOTA_LANDCRUISER = 19,
    VSB_TOYOTA_SIENNA = 20,
    VSB_TOYOTA_CAMRYHYBRID = 21,
    VSB_TOYOTA_GRACE = 22,
    VSB_TOYOTA_ALPHARD = 23,
    VSB_TOYOTA_RAV4_1 = 24,
    VSB_TOYOTA_RAV4_2 = 25,
    VSB_TOYOTA_86_1 = 26,
    VSB_TOYOTA_JIAMEI_2 = 27,
    VSB_TOYOTA_JIAMEI_3 = 28,
    VSB_TOYOTA_LANDEKLZ_1 = 29,
    VSB_TOYOTA_KAIMEIRUI_1 = 30,
    VSB_TOYOTA_KAIMEIRUI_2 = 31,
    VSB_TOYOTA_KAIMEIRUI_3 = 32,
    VSB_TOYOTA_KAIMEIRUI_4 = 33,
    VSB_TOYOTA_KAIMEIRUI_5 = 34,
    VSB_TOYOTA_KAIMEIRUI_6 = 35,
    VSB_TOYOTA_KALUOLA_1 = 36,
    VSB_TOYOTA_KALUOLA_2 = 37,
    VSB_TOYOTA_AIERFA_1 = 38,
    VSB_TOYOTA_AIERFA_2 = 39,
    VSB_TOYOTA_WEICHI_1 = 40,
    VSB_TOYOTA_WEICHI_2 = 41,
    VSB_TOYOTA_WEICHI_3 = 42,
    VSB_TOYOTA_WEICHI_4 = 43,
    VSB_TOYOTA_WEICHI_5 = 44,
    VSB_TOYOTA_PULADUO_1 = 45,
    VSB_TOYOTA_PULADUO_2 = 46,
    VSB_TOYOTA_PULADUO_3 = 47,
    VSB_TOYOTA_PURUIWEIYA_1 = 48,
    VSB_TOYOTA_PURUIWEIYA_4 = 49,
    VSB_TOYOTA_PURUIWEIYA_2 = 50,
    VSB_TOYOTA_PURUIWEIYA_3 = 51,
    VSB_TOYOTA_KESIDA_1 = 52,
    VSB_TOYOTA_KESIDA_2 = 53,
    VSB_TOYOTA_HANLANDA_1 = 54,
    VSB_TOYOTA_HANLANDA_2 = 55,
    VSB_TOYOTA_HANLANDA_3 = 56,
    VSB_TOYOTA_HAISHI_1 = 57,
    VSB_TOYOTA_HUANGGUAN_1 = 58,
    VSB_TOYOTA_HUANGGUAN_2 = 59,
    VSB_TOYOTA_HUANGGUAN_3 = 60,
    VSB_TOYOTA_HUANGGUAN_4 = 61,
    VSB_TOYOTA_HONGSHAN_1 = 62,
    VSB_TOYOTA_HUAGUAN_1 = 63,
    VSB_TOYOTA_HUAGUAN_2 = 64,
    VSB_TOYOTA_HUAGUAN_3 = 65,
    VSB_TOYOTA_YIZHI_1 = 66,
    VSB_TOYOTA_RUIZHI_1 = 67,
    VSB_TOYOTA_RUIZHI_2 = 68,
    VSB_TOYOTA_RUIZHI_3 = 69,
    VSB_TOYOTA_RUIZHI_4 = 70,
    VSB_TOYOTA_LUDIXUNYANG_1 = 71,
    VSB_TOYOTA_YALISHI_1 = 72,
    VSB_TOYOTA_YALISHI_2 = 73,
    VSB_TOYOTA_RAV4_3 = 74,
    VSB_TOYOTA_YARiSL_1 = 75,
    VSB_TOYOTA_JIAMEI_1 = 76,
    VSB_TOYOTA_PLATZ_1 = 77,
    VSB_TOYOTA_LANDEKLZ_2 = 78
}VSB_TOYOTA_CLASS;


typedef enum _VSB_FORD_CLASS
{
    VSB_FORD_OTHER = 0,
    VSB_FORD_FOCUS = 1,
    VSB_FORD_FIESTA = 2,
    VSB_FORD_SMAX = 3,
    VSB_FORD_MONDEO = 4,
    VSB_FORD_ECOSPORT = 5,
    VSB_FORD_ESCAPE = 6,
    VSB_FORD_ZHISHENG = 7,
    VSB_FORD_ESCORT = 8,
    VSB_FORD_EXPLORER = 9,
    VSB_FORD_EDGE = 10,
    VSB_FORD_TRANSIT = 11,
    VSB_FORD_QUANSHUN_1 = 12,
    VSB_FORD_JIANIANHUA_1 = 13,
    VSB_FORD_JIANIANHUA_2 = 14,
    VSB_FORD_JIANIANHUA_3 = 15,
    VSB_FORD_JIANIANHUA_4 = 16,
    VSB_FORD_TANXIANZHE_1 = 17,
    VSB_FORD_FOCUS_1 = 18,
    VSB_FORD_FOCUS_2 = 19,
    VSB_FORD_FOCUS_3 = 20,
    VSB_FORD_FOCUS_4 = 21,
    VSB_FORD_FOCUS_5 = 22,
    VSB_FORD_FOCUS_6 = 23,
    VSB_FORD_YIBO_1 = 24,
    VSB_FORD_YIHU_1 = 25,
    VSB_FORD_MENGDIOU_1 = 26,
    VSB_FORD_MENGDIOU_2 = 27,
    VSB_FORD_MENGDIOU_3 = 28,
    VSB_FORD_MENGDIOU_4 = 29,
    VSB_FORD_MENGDIOU_5 = 30,
    VSB_FORD_MENGDIOU_6 = 31,
    VSB_FORD_RUIJIE_1 = 32,
    VSB_FORD_MAIKESI_1 = 33
}VSB_FORD_CLASS;


typedef enum _VSB_NISSAN_CLASS
{
    VSB_NISSAN_OTHER = 0,
    VSB_NISSAN_XTRAIL = 1,
    VSB_NISSAN_MURANO = 2,
    VSB_NISSAN_LIVINA = 3,
    VSB_NISSAN_MARCH = 4,
    VSB_NISSAN_TIIDA = 5,
    VSB_NISSAN_TEANA = 6,
    VSB_NISSAN_QASHQAI = 7,
    VSB_NISSAN_SYLPHY = 8,
    VSB_NISSAN_SUNNY = 9,
    VSB_NISSAN_D22PICKUP = 10,
    VSB_NISSAN_D22VAN = 11,
    VSB_NISSAN_CABSTAR = 12,
    VSB_NISSAN_HV200 = 13,
    VSB_NISSAN_PALADIN = 14,
    VSB_NISSAN_YIDA = 15,
    VSB_NISSAN_DUCK = 16,
    VSB_NISSAN_CEFIRO = 17,
    VSB_NISSAN_FENGSHENBLUEBIRD = 18,
    VSB_NISSAN_FENGSHENSUNNY = 19,
    VSB_NISSAN_SUCCE = 20,
    VSB_NISSAN_FUGA = 21,
    VSB_NISSAN_BLUEBIRD4 = 22,
    VSB_NISSAN_VENUCIA = 23,
    VSB_NISSAN_QUEST = 24,
    VSB_NISSAN_GENISS = 25,
    VSB_NISSAN_NV200_1 = 26,
    VSB_NISSAN_TIANLAI_1 = 27,
    VSB_NISSAN_TIANLAI_2 = 28,
    VSB_NISSAN_TIANLAI_3 = 29,
    VSB_NISSAN_TIANLAI_4 = 30,
    VSB_NISSAN_TIANLAI_5 = 31,
    VSB_NISSAN_TIANLAI_6 = 32,
    VSB_NISSAN_QIJUN_1 = 33,
    VSB_NISSAN_QIJUN_2 = 34,
    VSB_NISSAN_PALADING_1 = 35,
    VSB_NISSAN_LOULAN_1 = 36,
    VSB_NISSAN_LOULAN_2 = 37,
    VSB_NISSAN_LANNIAO_1 = 38,
    VSB_NISSAN_LANNIAO_2 = 39,
    VSB_NISSAN_LANNIAO_3 = 40,
    VSB_NISSAN_GUISHI_1 = 41,
    VSB_NISSAN_XUANYI_1 = 42,
    VSB_NISSAN_XUANYI_2 = 43,
    VSB_NISSAN_XUANYI_3 = 44,
    VSB_NISSAN_XIAOKE_1 = 45,
    VSB_NISSAN_XIAOKE_2 = 46,
    VSB_NISSAN_SUNNY_3 = 47,
    VSB_NISSAN_SUNNY_1 = 48,
    VSB_NISSAN_SUNNY_2 = 49,
    VSB_NISSAN_YIDA_1 = 50,
    VSB_NISSAN_YIDA_2 = 51,
    VSB_NISSAN_FENGDU_1 = 52,
    VSB_NISSAN_FENGYA_1 = 53,
    VSB_NISSAN_LIWEI_1 = 54,
    VSB_NISSAN_LIWEI_2 = 55,
    VSB_NISSAN_LIWEI_3 = 56,
    VSB_NISSAN_LIWEI_4 = 57,
    VSB_NISSAN_JUNYI_1 = 58,
    VSB_NISSAN_QIDA_1 = 59,
    VSB_NISSAN_QIDA_2 = 60,
    VSB_NISSAN_QIDA_3 = 61,
    VSB_NISSAN_RUIQI_1 = 62
}VSB_NISSAN_CLASS;


typedef enum _VSB_AUDI_CLASS
{
    VSB_AUDI_OTHER = 0,
    VSB_AUDI_A3 = 1,
    VSB_AUDI_A4L = 2,
    VSB_AUDI_A6L = 3,
    VSB_AUDI_Q3 = 4,
    VSB_AUDI_Q5 = 5,
    VSB_AUDI_A1 = 6,
    VSB_AUDI_A4 = 7,
    VSB_AUDI_A5 = 8,
    VSB_AUDI_A6 = 9,
    VSB_AUDI_A7 = 10,
    VSB_AUDI_A8L = 11,
    VSB_AUDI_Q7 = 12,
    VSB_AUDI_S5 = 13,
    VSB_AUDI_TT = 14,
    VSB_AUDI_100 = 15,
    VSB_AUDI_200 = 16,
    VSB_AUDI_S7 = 17,
    VSB_AUDI_S8 = 18,
    VSB_AUDI_100_1 = 19,
    VSB_AUDI_200_1 = 20,
    VSB_AUDI_A1_1 = 21,
    VSB_AUDI_A3_1 = 22,
    VSB_AUDI_A3_2 = 23,
    VSB_AUDI_A4_1 = 24,
    VSB_AUDI_A4_2 = 25,
    VSB_AUDI_A4L_1 = 26,
    VSB_AUDI_A5_1 = 27,
    VSB_AUDI_A6_1 = 28,
    VSB_AUDI_A6L_1 = 29,
    VSB_AUDI_A6L_2 = 30,
    VSB_AUDI_A6L_3 = 31,
    VSB_AUDI_A7_1 = 32,
    VSB_AUDI_A8L_1 = 33,
    VSB_AUDI_A8L_2 = 34,
    VSB_AUDI_A8L_3 = 35,
    VSB_AUDI_A8L_4 = 36,
    VSB_AUDI_Q3_1 = 37,
    VSB_AUDI_Q5_1 = 38,
    VSB_AUDI_Q5_2 = 39,
    VSB_AUDI_Q5_3 = 40,
    VSB_AUDI_Q5_4 = 41,
    VSB_AUDI_Q7_1 = 42,
    VSB_AUDI_Q7_2 = 43,
    VSB_AUDI_S7_1 = 44,
    VSB_AUDI_S8_1 = 45,
    VSB_AUDI_TT_2 = 46,
    VSB_AUDI_TT_3 = 47,
    VSB_AUDI_TT_4 = 48,
    VSB_AUDI_TT_1 = 49
}VSB_AUDI_CLASS;


typedef enum _VSB_MAZDA_CLASS
{
    VSB_MAZDA_OTHER = 0,
    VSB_MAZDA_CX5 = 1,
    VSB_MAZDA_2 = 2,
    VSB_MAZDA_3 = 3,
    VSB_MAZDA_6 = 4,
    VSB_MAZDA_8 = 5,
    VSB_MAZDA_COREWING = 6,
    VSB_MAZDA_CX7 = 7,
    VSB_MAZDA_X5 = 8,
    VSB_MAZDA_5 = 9,
    VSB_MAZDA_PREMACY = 10,
    VSB_MAZDA_MPV = 11,
    VSB_MAZDA_CX5_1 = 12,
    VSB_MAZDA_CX7_1 = 13,
    VSB_MAZDA_2_1 = 14,
    VSB_MAZDA_3_1 = 15,
    VSB_MAZDA_3_2 = 16,
    VSB_MAZDA_3_3 = 17,
    VSB_MAZDA_3_4 = 18,
    VSB_MAZDA_5_1 = 19,
    VSB_MAZDA_5_2 = 20,
    VSB_MAZDA_6_2 = 21,
    VSB_MAZDA_6_3 = 22,
    VSB_MAZDA_8_1 = 23,
    VSB_MAZDA_PREMACY_1 = 24,
    VSB_MAZDA_PREMACY_2 = 25,
    VSB_MAZDA_COREWING_1 = 26,
    VSB_MAZDA_COREWING_2 = 27,
    VSB_MAZDA_COREWING_3 = 28,
    VSB_MAZDA_2_2 = 29,
    VSB_MAZDA_6_1 = 30,
    VSB_MAZDA_6_4 = 31
}VSB_MAZDA_CLASS;


typedef enum _VSB_CHEVROLET_CLASS
{
    VSB_CHEVROLET_OTHER = 0,
    VSB_CHEVROLET_NEWAVEO = 1,
    VSB_CHEVROLET_EPICA = 2,
    VSB_CHEVROLET_CRUZE = 3,
    VSB_CHEVROLET_CAPTIVA = 4,
    VSB_CHEVROLET_MALIBU = 5,
    VSB_CHEVROLET_SAIL = 6,
    VSB_CHEVROLET_CAMARO = 7,
    VSB_CHEVROLET_LECHENG = 8,
    VSB_CHEVROLET_LOVA = 9,
    VSB_CHEVROLET_OLDAVEO = 10,
    VSB_CHEVROLET_SPARK = 11,
    VSB_CHEVROLET_SAILSRV = 12,
    VSB_CHEVROLET_LOVA_1 = 13,
    VSB_CHEVROLET_LOVA_2 = 14,
    VSB_CHEVROLET_SPARK_1 = 15,
    VSB_CHEVROLET_SPARK_2 = 16,
    VSB_CHEVROLET_OLDAVEO_1 = 17,
    VSB_CHEVROLET_OLDAVEO_2 = 18,
    VSB_CHEVROLET_EPICA_1 = 19,
    VSB_CHEVROLET_EPICA_3 = 20,
    VSB_CHEVROLET_EPICA_4 = 21,
    VSB_CHEVROLET_EPICA_5 = 22,
    VSB_CHEVROLET_NEWAVEO_1 = 23,
    VSB_CHEVROLET_CAPTIVA_1 = 24,
    VSB_CHEVROLET_CAPTIVA_2 = 25,
    VSB_CHEVROLET_KEMAILUO_1 = 26,
    VSB_CHEVROLET_CRUZE_1 = 27,
    VSB_CHEVROLET_SAIL_1 = 28,
    VSB_CHEVROLET_SAIL_2 = 29,
    VSB_CHEVROLET_MALIBU_1 = 30,
    VSB_CHEVROLET_EPICA_2 = 31
}VSB_CHEVROLET_CLASS;


typedef enum _VSB_CITROEN_CLASS
{
    VSB_CITROEN_OTHER = 0,
    VSB_CITROEN_C2 = 1,
    VSB_CITROEN_C4L = 2,
    VSB_CITROEN_C5 = 3,
    VSB_CITROEN_ELYSEE = 4,
    VSB_CITROEN_CQUATRELIANGXIANG = 5,
    VSB_CITROEN_CQUATRESANXIANG = 6,
    VSB_CITROEN_SAEAPICASSO = 7,
    VSB_CITROEN_PICASSO = 8,
    VSB_CITROEN_CTRIOMPHE = 9,
    VSB_CITROEN_XSARA = 10,
    VSB_CITROEN_SHENLONGFUKANG = 11,
    VSB_CITROEN_CHANGANDS = 12,
    VSB_CITROEN_C2_1 = 13,
    VSB_CITROEN_C4L_1 = 14,
    VSB_CITROEN_C4PICASSO_1 = 15,
    VSB_CITROEN_C5_1 = 16,
    VSB_CITROEN_CQUATRESANXIANG_1 = 17,
    VSB_CITROEN_CQUATRELIANGXIANG_1 = 18,
    VSB_CITROEN_CTRIOMPHE_1 = 19,
    VSB_CITROEN_FUKANG_1 = 20,
    VSB_CITROEN_ELYSEE_1 = 21,
    VSB_CITROEN_ELYSEE_2 = 22,
    VSB_CITROEN_SAEAPICASSO_1 = 23
}VSB_CITROEN_CLASS;


typedef enum _VSB_HYUNDAI_CLASS
{
    VSB_HYUNDAI_OTHER = 0,
    VSB_HYUNDAI_IX35 = 1,
    VSB_HYUNDAI_LANGDONG = 2,
    VSB_HYUNDAI_MOINCA = 3,
    VSB_HYUNDAI_SHENGDA = 4,
    VSB_HYUNDAI_VERNA = 5,
    VSB_HYUNDAI_RUIYI = 6,
    VSB_HYUNDAI_SONATAEIGHT = 7,
    VSB_HYUNDAI_TUCSON = 8,
    VSB_HYUNDAI_YUEDONG = 9,
    VSB_HYUNDAI_ELANTRA = 10,
    VSB_HYUNDAI_GRANDSANTAFE = 11,
    VSB_HYUNDAI_COUPE = 12,
    VSB_HYUNDAI_MATRIX = 13,
    VSB_HYUNDAI_ACCENT = 14,
    VSB_HYUNDAI_IX30 = 15,
    VSB_HYUNDAI_SONATA = 16,
    VSB_HYUNDAI_REFINE = 17,
    VSB_HYUNDAI_MISTRA = 18,
    VSB_HYUNDAI_SONATAYUFENG = 19,
    VSB_HYUNDAI_SANTAFE = 20,
    VSB_HYUNDAI_HUIYI = 21,
    VSB_HYUNDAI_I30_1 = 22,
    VSB_HYUNDAI_IX35_1 = 23,
    VSB_HYUNDAI_YILANTE_1 = 24,
    VSB_HYUNDAI_YILANTE_2 = 25,
    VSB_HYUNDAI_YILANTE_3 = 26,
    VSB_HYUNDAI_SHENGDA_1 = 27,
    VSB_HYUNDAI_MINGTU_1 = 28,
    VSB_HYUNDAI_MINGYU_1 = 29,
    VSB_HYUNDAI_SHENGDAFEI_1 = 30,
    VSB_HYUNDAI_YUXIANG_1 = 31,
    VSB_HYUNDAI_YUXIANG_2 = 32,
    VSB_HYUNDAI_YUEDONG_1 = 33,
    VSB_HYUNDAI_YUEDONG_2 = 34,
    VSB_HYUNDAI_SHENGDA_2 = 35,
    VSB_HYUNDAI_SHENGDA_3 = 36,
    VSB_HYUNDAI_LANGDONG_1 = 37,
    VSB_HYUNDAI_GERUI_1 = 38,
    VSB_HYUNDAI_RUIYI_1 = 39,
    VSB_HYUNDAI_RUINA_1 = 40,
    VSB_HYUNDAI_RUINA_2 = 41,
    VSB_HYUNDAI_RUIFENG_1 = 42,
    VSB_HYUNDAI_SUONATA_1 = 43,
    VSB_HYUNDAI_SUONATA_2 = 44,
    VSB_HYUNDAI_SOUNATA_3 = 45,
    VSB_HYUNDAI_WEILAKESI_1 = 46,
    VSB_HYUNDAI_MEIJIA_1 = 47,
    VSB_HYUNDAI_JINKOUHUIYI_1 = 48,
    VSB_HYUNDAI_TUSHENG_1 = 49,
    VSB_HYUNDAI_TUSHENG_2 = 50,
    VSB_HYUNDAI_TUSHENG_3 = 51,
    VSB_HYUNDAI_KUPAI_1 = 52,
    VSB_HYUNDAI_YASHENTE_1 = 53,
    VSB_HYUNDAI_YASHENTE_2 = 54,
    VSB_HYUNDAI_LINGXIANG_1 = 55,
    VSB_HYUNDAI_FEISI_1 = 56
}VSB_HYUNDAI_CLASS;


typedef enum _VSB_CHERY_CLASS
{
    VSB_CHERY_OTHER = 0,
    VSB_CHERY_A1 = 1,
    VSB_CHERY_A3 = 2,
    VSB_CHERY_EASTAR = 3,
    VSB_CHERY_FULWIN = 4,
    VSB_CHERY_QQ = 5,
    VSB_CHERY_E5 = 6,
    VSB_CHERY_COWIN = 7,
    VSB_CHERY_TIGGO = 8,
    VSB_CHERY_A5 = 9,
    VSB_CHERY_S16 = 10,
    VSB_CHERY_YOUYA = 11,
    VSB_CHERY_V5 = 12,
    VSB_CHERY_E3 = 13,
    VSB_CHERY_A1_1 = 14,
    VSB_CHERY_A3LIANGXIANG_1 = 15,
    VSB_CHERY_A5_1 = 16,
    VSB_CHERY_QQ_1 = 17,
    VSB_CHERY_QQ_2 = 18,
    VSB_CHERY_QQ_3 = 19,
    VSB_CHERY_QQ_4 = 20,
    VSB_CHERY_QQ_5 = 21,
    VSB_CHERY_DONGFANGZHIZI_1 = 22,
    VSB_CHERY_DONGFANGZHIZI_2 = 23,
    VSB_CHERY_DONGFANGZHIZI_3 = 24,
    VSB_CHERY_YOUYA_1 = 25,
    VSB_CHERY_E3_1 = 26,
    VSB_CHERY_E5_1 = 27,
    VSB_CHERY_QIYUN1_1 = 28,
    VSB_CHERY_QIYUN1_2 = 29,
    VSB_CHERY_QIYUN_1 = 30,
    VSB_CHERY_QIYUN_2 = 31,
    VSB_CHERY_QIYUN2_1 = 32,
    VSB_CHERY_QIYUN2_2 = 33,
    VSB_CHERY_QIYUN3_1 = 34,
    VSB_CHERY_RUIHU_1 = 35,
    VSB_CHERY_RUIHU_2 = 36,
    VSB_CHERY_RUIHU_3 = 37,
    VSB_CHERY_RUIHU_4 = 38,
    VSB_CHERY_RUIHU_5 = 39,
    VSB_CHERY_FENGYUN2SANXIANG_1 = 40,
    VSB_CHERY_AIRUIZE7_1 = 41
}VSB_CHERY_CLASS;


typedef enum _VSB_KIA_CLASS
{
    VSB_KIA_OTHER = 0,
    VSB_KIA_K2 = 1,
    VSB_KIA_K3 = 2,
    VSB_KIA_K5 = 3,
    VSB_KIA_RIO = 4,
    VSB_KIA_CERATO = 5,
    VSB_KIA_SPORTAGER = 6,
    VSB_KIA_SOUL = 7,
    VSB_KIA_ZHIPAO = 8,
    VSB_KIA_CARENS = 9,
    VSB_KIA_CARNIVAL = 10,
    VSB_KIA_OPTIMA = 11,
    VSB_KIA_OPIRUS = 12,
    VSB_KIA_MAXIMA = 13,
    VSB_KIA_FORTE = 14,
    VSB_KIA_SORENTO = 15,
    VSB_KIA_K2_1 = 16,
    VSB_KIA_K3_1 = 17,
    VSB_KIA_K5_1 = 18,
    VSB_KIA_RUIOU_1 = 19,
    VSB_KIA_QIANLIMA_1 = 20,
    VSB_KIA_QIANLIMA_2 = 21,
    VSB_KIA_JIAHUA_1 = 22,
    VSB_KIA_XINJIALE_1 = 23,
    VSB_KIA_ZHIPAO_1 = 24,
    VSB_KIA_SHIPAO_1 = 25,
    VSB_KIA_SHIPAO_2 = 26,
    VSB_KIA_SHIPAO_3 = 27,
    VSB_KIA_SHIPAO_4 = 28,
    VSB_KIA_FURUIDI_1 = 29,
    VSB_KIA_FURUIDI_2 = 30,
    VSB_KIA_XIUER_1 = 31,
    VSB_KIA_SUOLANTUO_1 = 32,
    VSB_KIA_SUOLANTUO_2 = 33,
    VSB_KIA_SAILATU_1 = 34,
    VSB_KIA_SAILATU_2 = 35,
    VSB_KIA_SAILATU_3 = 36,
    VSB_KIA_YUANJIAN_1 = 37
}VSB_KIA_CLASS;


typedef enum _VSB_BENZ_CLASS
{
    VSB_BENZ_OTHER = 0,
    VSB_BENZ_C = 1,
    VSB_BENZ_E = 2,
    VSB_BENZ_GLK = 3,
    VSB_BENZ_WEITING = 4,
    VSB_BENZ_SPRINTER = 5,
    VSB_BENZ_VIANO = 6,
    VSB_BENZ_M = 7,
    VSB_BENZ_CLK = 8,
    VSB_BENZ_G = 9,
    VSB_BENZ_GL = 10,
    VSB_BENZ_R = 11,
    VSB_BENZ_S = 12,
    VSB_BENZ_A = 13,
    VSB_BENZ_SMART = 14,
    VSB_BENZ_B = 15,
    VSB_BENZ_SLK = 16,
    VSB_BENZ_MB100 = 17,
    VSB_BENZ_VITO = 18,
    VSB_BENZ_CLS = 19,
    VSB_BENZ_SL = 20,
    VSB_BENZ_AJI_1 = 21,
    VSB_BENZ_AJI_2 = 22,
    VSB_BENZ_BJI_1 = 23,
    VSB_BENZ_CJI_1 = 24,
    VSB_BENZ_CJI_2 = 25,
    VSB_BENZ_CJI_3 = 26,
    VSB_BENZ_EJI_1 = 27,
    VSB_BENZ_EJI_2 = 28,
    VSB_BENZ_EJI_3 = 29,
    VSB_BENZ_EJI_4 = 30,
    VSB_BENZ_GLKJI_1 = 31,
    VSB_BENZ_GLKJI_2 = 32,
    VSB_BENZ_GLKJI_3 = 33,
    VSB_BENZ_GLJI_1 = 34,
    VSB_BENZ_GLJI_2 = 35,
    VSB_BENZ_GLJI_3 = 36,
    VSB_BENZ_GJI_1 = 37,
    VSB_BENZ_MB100_1 = 38,
    VSB_BENZ_MLJI_1 = 39,
    VSB_BENZ_MLJI_2 = 40,
    VSB_BENZ_MLJI_3 = 41,
    VSB_BENZ_RJI_1 = 42,
    VSB_BENZ_RJI_2 = 43,
    VSB_BENZ_RJI_3 = 44,
    VSB_BENZ_SLKJI_2 = 45,
    VSB_BENZ_SLKJI_3 = 46,
    VSB_BENZ_SLKJI_1 = 47,
    VSB_BENZ_SJI_1 = 48,
    VSB_BENZ_SJI_2 = 49,
    VSB_BENZ_SJI_3 = 50,
    VSB_BENZ_SJI_4 = 51,
    VSB_BENZ_LINGTE_1 = 52,
    VSB_BENZ_WEIYANUO_1 = 53,
    VSB_BENZ_WEIYANUO_2 = 54,
    VSB_BENZ_WEITING_1 = 55,
    VSB_BENZ_KECHE_1 = 56
}VSB_BENZ_CLASS;


typedef enum _VSB_SKODA_CLASS
{
    VSB_SKODA_OTHER = 0,
    VSB_SKODA_HAORUI = 1,
    VSB_SKODA_FABIA = 2,
    VSB_SKODA_OCTAVIA = 3,
    VSB_SKODA_SUPERB = 4,
    VSB_SKODA_SPACEBACK = 5,
    VSB_SKODA_RAPID = 6,
    VSB_SKODA_YETI = 7,
    VSB_SKODA_HAORUI_1 = 8,
    VSB_SKODA_MINGRUI_1 = 9,
    VSB_SKODA_MINGRUI_2 = 10,
    VSB_SKODA_MINGRUI_3 = 11,
    VSB_SKODA_XINRUI_1 = 12,
    VSB_SKODA_JINGRUI_1 = 13,
    VSB_SKODA_JINGRUI_2 = 14,
    VSB_SKODA_JINGRUI_3 = 15,
    VSB_SKODA_SUPAI_1 = 16,
    VSB_SKODA_YEDI_1 = 17
}VSB_SKODA_CLASS;


typedef enum _VSB_DONGFENG_CLASS
{
    VSB_DONGFENG_OTHER = 0,
    VSB_DONGFENG_JOYEARX5 = 1,
    VSB_DONGFENG_LINGZHI = 2,
    VSB_DONGFENG_JOYEARX3 = 3,
    VSB_DONGFENG_JOYEAR = 4,
    VSB_DONGFENG_FENGXINGCM7 = 5,
    VSB_DONGFENG_YUFENG = 6,
    VSB_DONGFENG_FENGSHENA60 = 7,
    VSB_DONGFENG_FENGSHENS30 = 8,
    VSB_DONGFENG_FENGSHENH30CROSS = 9,
    VSB_DONGFENG_PICKUP = 10,
    VSB_DONGFENG_ZHONGXINGMIANBAOCHE = 11,
    VSB_DONGFENG_XIAOXINGMIANBAOCHE = 12,
    VSB_DONGFENG_ZHONGXINGVAN = 13,
    VSB_DONGFENG_QINGXINGXIANGSHIVAN = 14,
    VSB_DONGFENG_QINGZHONGXINGVAN = 15,
    VSB_DONGFENG_FENGSHENMERCURY = 16,
    VSB_DONGFENG_SUCCE = 17,
    VSB_DONGFENG_ODIN = 18,
    VSB_DONGFENG_YUMSUN = 19,
    VSB_DONGFENG_RUIQI = 20,
    VSB_DONGFENG_FENGGUANG = 21,
    VBR_DONGFENG_C35_1 = 22,
    VBR_DONGFENG_K07_1 = 23,
    VBR_DONGFENG_K07_2 = 24,
    VBR_DONGFENG_V21_1 = 25,
    VBR_DONGFENG_JIALONG_1 = 26,
    VBR_DONGFENG_XKFG_1 = 27,
    VBR_DONGFENG_CV03_1 = 28,
    VBR_DONGFENG_KAIPUTE_1 = 29,
    VBR_DONGFENG_DUOLIKA_1 = 30,
    VBR_DONGFENG_DUOLIKA_2 = 31,
    VBR_DONGFENG_DUOLIKA_3 = 32,
    VBR_DONGFENG_TIANJIN_1 = 33,
    VBR_DONGFENG_TIANJIN_2 = 34,
    VBR_DONGFENG_XBW_1 = 35,
    VBR_DONGFENG_XBW_2 = 36,
    VBR_DONGFENG_MENGKA_1 = 37,
    VBR_DONGFENG_FURUIKA_1 = 38,
    VBR_DONGFENG_RUIQI_1 = 39,
    VBR_DONGFENG_A60_1 = 40,
    VBR_DONGFENG_H30_1 = 41,
    VBR_DONGFENG_H30_2 = 42,
    VBR_DONGFENG_H30_3 = 43,
    VBR_DONGFENG_JINGYI_1 = 44,
    VBR_DONGFENG_JINGYI_2 = 45,
    VBR_DONGFENG_JINGYI_3 = 46,
    VBR_DONGFENG_LINGZHI_1 = 47,
    VBR_DONGFENG_LINGZHI_2 = 48,
    VBR_DONGFENG_LINGZHI_3 = 49,
    VBR_DONGFENG_LINGZHI_4 = 50,
    VBR_DONGFENG_LINGZHI_5 = 51
}VSB_DONGFENG_CLASS;


typedef enum _VSB_BYD_CLASS
{
    VSB_BYD_OTHER = 0,
    VSB_BYD_F0 = 1,
    VSB_BYD_F3 = 2,
    VSB_BYD_F3R = 3,
    VSB_BYD_F6 = 4,
    VSB_BYD_G3 = 5,
    VSB_BYD_G3R = 6,
    VSB_BYD_G6 = 7,
    VSB_BYD_L3 = 8,
    VSB_BYD_M6 = 9,
    VSB_BYD_S6 = 10,
    VSB_BYD_SURUI = 11,
    VSB_BYD_FOLEL = 12,
    VSB_BYD_SIRUI = 13,
    VSB_BYD_MT5 = 14,
    VSB_BYD_F0_1 = 15,
    VSB_BYD_F3R_1 = 16,
    VSB_BYD_F6_1 = 17,
    VSB_BYD_G3R_1 = 18,
    VSB_BYD_G6_1 = 19,
    VSB_BYD_L3_1 = 20,
    VSB_BYD_M6_1 = 21,
    VSB_BYD_S6_1 = 22,
    VSB_BYD_FULAIER_1 = 23,
    VSB_BYD_SURUI_1 = 24
}VSB_BYD_CLASS;


typedef enum _VSB_SUZUKI_CLASS
{
    VSB_SUZUKI_OTHER = 0,
    VSB_SUZUKI_ALTO = 1,
    VSB_SUZUKI_SCROSS = 2,
    VSB_SUZUKI_SWIFT = 3,
    VSB_SUZUKI_SX4 = 4,
    VSB_SUZUKI_LINGYANG = 5,
    VSB_SUZUKI_BEIDOUXING = 6,
    VSB_SUZUKI_LIANAA6 = 7,
    VSB_SUZUKI_LANDY = 8,
    VSB_SUZUKI_SPLASH = 9,
    VSB_SUZUKI_GRANDVITARA = 10,
    VSB_SUZUKI_JIMNY = 11,
    VSB_SUZUKI_KAZASHI = 12,
    VSB_SUZUKI_LIANA = 13,
    VSB_SUZUKI_LIANA_1 = 14,
    VSB_SUZUKI_LIANA_2 = 15,
    VSB_SUZUKI_BEIDOUXING_1 = 16,
    VSB_SUZUKI_BEIDOUXING_2 = 17,
    VSB_SUZUKI_BEIDOUXING_3 = 18,
    VSB_SUZUKI_BEIDOUXING_4 = 19,
    VSB_SUZUKI_JIMUNI_1 = 20,
    VSB_SUZUKI_JIMUNI_2 = 21,
    VSB_SUZUKI_SX4_1 = 22,
    VSB_SUZUKI_SX4_2 = 23,
    VSB_SUZUKI_SX4_3 = 24,
    VSB_SUZUKI_SX4_4 = 25,
    VSB_SUZUKI_SX4_5 = 26,
    VSB_SUZUKI_ALTO_1 = 27,
    VSB_SUZUKI_ALTO_2 = 28,
    VSB_SUZUKI_ALTO_3 = 29,
    VSB_SUZUKI_ALTO_4 = 30,
    VSB_SUZUKI_SPLASH_1 = 31,
    VSB_SUZUKI_LANDY_1 = 32,
    VSB_SUZUKI_LINGYANG_2 = 33,
    VSB_SUZUKI_LINGYANG_3 = 34,
    VSB_SUZUKI_LINGYANG_4 = 35,
    VSB_SUZUKI_LINGYANG_5 = 36,
    VSB_SUZUKI_GRANDVITARA_1 = 37,
    VSB_SUZUKI_FENGYU_1 = 38,
    VSB_SUZUKI_SWIFT_1 = 39,
    VSB_SUZUKI_SWIFT_2 = 40,
    VSB_SUZUKI_KINGCHANG_1 = 41,
    VSB_SUZUKI_LINGYANG_1 = 42
}VSB_SUZUKI_CLASS;


typedef enum _VSB_SGMW_CLASS
{
    VSB_SGMW_OTHER = 0,
    VSB_SGMW_HONGGUANG = 1,
    VSB_SGMW_HONGGUANGS = 2,
    VSB_SGMW_ZHIGUANG = 3,
    VSB_SGMW_RONGGUANGS = 4,
    VSB_SGMW_RONGGUANG = 5,
    VSB_SGMW_HONGTU = 6,
    VSB_SGMW_XINGWANG = 7,
    VSB_SGMW_YANGGUANG = 8,
    VSB_SGMW_XIAOXUANFENG = 9,
    VSB_SGMW_WULINGZHIGUANG_1 = 10,
    VSB_SGMW_WULINGZHIGUANG_2 = 11,
    VSB_SGMW_WULINGZHIGUANG_3 = 12,
    VSB_SGMW_XINGWANG_1 = 13,
    VSB_SGMW_XINGWANG_2 = 14,
    VSB_SGMW_XINGWANG_3 = 15,
    VSB_SGMW_HONNGUANG_1 = 16,
    VSB_SGMW_HONNGUANG_2 = 17,
    VSB_SGMW_XIAOXUANFENG_1 = 18,
    VSB_SGMW_YANGGUANG_1 = 19,
    VSB_SGMW_YANGGUANG_2 = 20,
    VSB_SGMW_YANGGUANG_3 = 21,
    VSB_SGMW_RONGGUANG_1 = 22,
    VSB_SGMW_RONGGUANG_2 = 23,
    VSB_SGMW_HONGTU_1 = 24
}VSB_SGMW_CLASS;


typedef enum _VSB_CHANA_CLASS
{
    VSB_CHANA_OTHER = 0,
    VSB_CHANA_HONOR = 1,
    VSB_CHANA_XINGKA = 2,
    VSB_CHANA_ZHIXING = 3,
    VSB_CHANA_PICKUP = 4,
    VSB_CHANA_ZHIXING2 = 5,
    VSB_CHANA_TAURUS = 6,
    VSB_CHANA_XINGGUANG = 7,
    VSB_CHANA_BENNI = 8,
    VSB_CHANA_ALSVIN = 9,
    VSB_CHANA_CX20 = 10,
    VSB_CHANA_CX30 = 11,
    VSB_CHANA_EADO = 12,
    VSB_CHANA_ZHIXINGS460 = 13,
    VSB_CHANA_CM8 = 14,
    VSB_CHANA_XINBAO = 15,
    VSB_CHANA_XUNLONG = 16,
    VSB_CHANA_YUNTONG = 17,
    VSB_CHANA_LEIMENG = 18,
    VSB_CHANA_XINGYUN = 19,
    VSB_CHANA_OULIWEI = 20,
    VSB_CHANA_EADOXT = 21,
    VSB_CHANA_XINGYUN_1 = 22,
    VSB_CHANA_OULIWEI_1 = 23,
    VSB_CHANA_YUNTONG_1 = 24,
    VSB_CHANA_TAURUS_1 = 25,
    VSB_CHANA_LEIMENG_1 = 26,
    VSB_CHANA_ZHIXING_1 = 27,
    VSB_CHANA_ZHIXING_2 = 28,
    VSB_CHANA_ZHIXING_3 = 29,
    VSB_CHANA_ZHIXING_4 = 30,
    VSB_CHANA_ZHIXING_5 = 31,
    VSB_CHANA_ZHIXING_6 = 32,
    VSB_CHANA_PICKUP_1 = 33,
    VSB_CHANA_XINGGUANG_1 = 34,
    VSB_CHANA_XINGGUANG_2 = 35,
    VSB_CHANA_HONOR_1 = 36
}VSB_CHANA_CLASS;


typedef enum _VSB_EADO_CLASS
{
    VSB_EADO_OTHER = 0,
    VSB_EADO_CS_1 = 1,
    VSB_EADO_CX_1 = 2,
    VSB_EADO_CX_2 = 3,
    VSB_EADO_BENBEN_1 = 4,
    VSB_EADO_BENBEN_2 = 5,
    VSB_EADO_BENBEN_3 = 6,
    VSB_EADO_BENBEN_4 = 7,
    VSB_EADO_BENBEN_5 = 8,
    VSB_EADO_YUEXIANG_1 = 9,
    VSB_EADO_YUEXIANG_2 = 10,
    VSB_EADO_YUEXIANG_3 = 11,
    VSB_EADO_YUEXIANG_4 = 12,
    VSB_EADO_YIDONG_1 = 13
}VSB_EADO_CLASS;


typedef enum _VSB_JINBEI_CLASS
{
    VSB_JINBEI_OTHER = 0,
    VSB_JINBEI_GRACE = 1,
    VSB_JINBEI_HIACE = 2,
    VSB_JINBEI_HAIXING = 3,
    VSB_JINBEI_BADAO = 4,
    VSB_JINBEI_LINGQI = 5,
    VSB_JINBEI_JINQI = 6,
    VSB_JINBEI_LINGCHI = 7,
    VSB_JINBEI_QIYUN = 8,
    VSB_JINBEI_ZHISHANG_1 = 9,
    VSB_JINBEI_HAIXING_1 = 10,
    VSB_JINBEI_HAIXING_2 = 11,
    VSB_JINBEI_HIACE_1 = 12,
    VSB_JINBEI_HIACE_2 = 13,
    VSB_JINBEI_HIACE_3 = 14,
    VSB_JINBEI_JINDIAN_1 = 15,
    VSB_JINBEI_GRACE_1 = 16,
    VSB_JINBEI_GRACE_2 = 17,
    VSB_JINBEI_BADAO_1 = 18

}VSB_JINBEI_CLASS;


typedef enum _VSB_GEELY_CLASS
{
    VSB_GEELY_OTHER = 0,
    VSB_GEELY_EC7 = 1,
    VSB_GEELY_EC8 = 2,
    VSB_GEELY_SC3 = 3,
    VSB_GEELY_SC5RV = 4,
    VSB_GEELY_SC6 = 5,
    VSB_GEELY_JINGYING = 6,
    VSB_GEELY_JINGGANG = 7,
    VSB_GEELY_SX7 = 8,
    VSB_GEELY_HAOQING = 9,
    VSB_GEELY_MEIRI = 10,
    VSB_GEELY_YINGLUNSC7 = 11,
    VSB_GEELY_PANDA = 12,
    VSB_GEELY_YUANJING = 13,
    VSB_GEELY_ZIYOUJIAN = 14
}VSB_GEELY_CLASS;


typedef enum _VSB_MITSUBISHI_CLASS
{
    VSB_MITSUBISHI_OTHER = 0,
    VSB_MITSUBISHI_GALANT = 1,
    VSB_MITSUBISHI_ZINGER = 2,
    VSB_MITSUBISHI_LANCER = 3,
    VSB_MITSUBISHI_LANCEREX = 4,
    VSB_MITSUBISHI_PAJERO = 5,
    VSB_MITSUBISHI_PAJEROSPORT = 6,
    VSB_MITSUBISHI_JINGXUANASX = 7,
    VSB_MITSUBISHI_GRANDIS = 8,
    VSB_MITSUBISHI_OUTLANDER = 9,
    VSB_MITSUBISHI_QINXINGYUEYE = 10,
    VSB_MITSUBISHI_GTO = 11,
    VSB_MITSUBISHI_SOVERAN = 12,
    VSB_MITSUBISHI_LIONVEL = 13,
    VSB_MITSUBISHI_HAFEISIMBO = 14,
    VSB_MITSUBISHI_LANCEREX_1 = 15,
    VSB_MITSUBISHI_JINGXUAN_1 = 16,
    VSB_MITSUBISHI_ZINGER_1 = 17,
    VSB_MITSUBISHI_PAJERO_1 = 18,
    VSB_MITSUBISHI_PAJERO_2 = 19,
    VSB_MITSUBISHI_PAJERO_3 = 20,
    VSB_MITSUBISHI_PAJEROSPORT_1 = 21,
    VSB_MITSUBISHI_GALANT_1 = 22,
    VSB_MITSUBISHI_GALANDI_1 = 23,
    VSB_MITSUBISHI_GALANDI_2 = 24,
    VSB_MITSUBISHI_OUTLANDER_1 = 25,
    VSB_MITSUBISHI_OUTLANDER_2 = 26,
    VSB_MITSUBISHI_LINGYUE_1 = 27,
    VSB_MITSUBISHI_LANCER_1 = 28
}VSB_MITSUBISHI_CLASS;


typedef enum _VSB_LEXUS_CLASS
{
    VSB_LEXUS_OTHER = 0,
    VSB_LEXUS_ES = 1,
    VSB_LEXUS_CT = 2,
    VSB_LEXUS_RX = 3,
    VSB_LEXUS_IS = 4,
    VSB_LEXUS_LX = 5,
    VSB_LEXUS_GS = 6,
    VSB_LEXUS_GX = 7,
    VSB_LEXUS_LS = 8,
    VSB_LEXUS_CT_1 = 9,
    VSB_LEXUS_ES_1 = 10,
    VSB_LEXUS_ES_2 = 11,
    VSB_LEXUS_ES_3 = 12,
    VSB_LEXUS_GS_1 = 13,
    VSB_LEXUS_GX_1 = 14,
    VSB_LEXUS_IS_1 = 15,
    VSB_LEXUS_LS_1 = 16,
    VSB_LEXUS_LS_2 = 17,
    VSB_LEXUS_LS_3 = 18,
    VSB_LEXUS_LX_1 = 19,
    VSB_LEXUS_RX_1 = 20,
    VSB_LEXUS_RX_2 = 21,
    VSB_LEXUS_RX_3 = 22
}VSB_LEXUS_CLASS;


typedef enum _VSB_ROEWE_CLASS
{
    VSB_ROEWE_OTHER = 0,
    VSB_ROEWE_350 = 1,
    VSB_ROEWE_550 = 2,
    VSB_ROEWE_W5 = 3,
    VSB_ROEWE_950 = 4,
    VSB_ROEWE_750 = 5,
    VSB_ROEWE_350_1 = 6,
    VSB_ROEWE_350_2 = 7,
    VSB_ROEWE_550_1 = 8,
    VSB_ROEWE_750_1 = 9,
    VSB_ROEWE_750_2 = 10,
    VSB_ROEWE_950_1 = 11
}VSB_ROEWE_CLASS;



typedef enum _VSB_HAIMA_CLASS
{
    VSB_HAIMA_OTHER = 0,
    VSB_HAIMA_PREMARIN = 1,
    VSB_HAIMA_S7 = 2,
    VSB_HAIMA_PRINCE = 3,
    VSB_HAIMA_CUPID = 4,
    VSB_HAIMA_HATCHBACK = 5,
    VSB_HAIMA_KNIGHT = 6,
    VSB_HAIMA_HAPPIN = 7,
    VSB_HAIMA_FAMILY = 8,
    VSB_HAIMA_M3 = 9,
    VSB_HAIMA_CUPID_1 = 10,
    VSB_HAIMA_PREMARIN_1 = 11,
    VSB_HAIMA_PREMARIN_2 = 12,
    VSB_HAIMA_HATCHBACK_1 = 13,
    VSB_HAIMA_HAPPIN_1 = 14,
    VSB_HAIMA_HAPPIN_2 = 15,
    VSB_HAIMA_M3_1 = 16,
    VSB_HAIMA_FAMILY_1 = 17,
    VSB_HAIMA_FAMILY_2 = 18,
    VSB_HAIMA_FAMILY_3 = 19,
    VSB_HAIMA_FAMILY_4 = 20,
    VSB_HAIMA_KNIGHT_1 = 21,
    VSB_HAIMA_KNIGHT_2 = 22,
    VSB_HAIMA_NEWHONGDA_1 = 23,
    VSB_HAIMA_NEWHONDGA_2 = 24,
    VSB_HAIMA_PRINCE_1 = 25,
    VSB_HAIMA_RONGDA_1 = 26

}VSB_HAIMA_CLASS;


typedef enum _VSB_GREATWALL_CLASS
{
    VSB_GREATWALL_OTHER = 0,
    VSB_GREATWALL_SING = 1,
    VSB_GREATWALL_SAIJUN = 2,
    VSB_GREATWALL_HAVAL = 3,
    VSB_GREATWALL_SAFE = 4,
    VSB_GREATWALL_SAIKU = 5,
    VSB_GREATWALL_SAILING = 6,
    VSB_GREATWALL_KINGDEER = 7,
    VSB_GREATWALL_DEER = 8,
    VSB_GREATWALL_WINGLE = 9,
    VSB_GREATWALL_COOLBEAR = 10,
    VSB_GREATWALL_LINGAO = 11,
    VSB_GREATWALL_CROSS = 12,
    VSB_GREATWALL_GWPERI = 13,
    VSB_GREATWALL_COWRY = 14,
    VSB_GREATWALL_M4 = 15,
    VSB_GREATWALL_LINGAO_1 = 16,
    VSB_GREATWALL_HAVAL_1 = 17,
    VSB_GREATWALL_HAVAL_2 = 18,
    VSB_GREATWALL_HAVAL_3 = 19,
    VSB_GREATWALL_HAVAL_4 = 20,
    VSB_GREATWALL_HAVAL_5 = 21,
    VSB_GREATWALL_HAVAL_6 = 22,
    VSB_GREATWALL_HAVAL_8 = 23,
    VSB_GREATWALL_HAVAL_9 = 24,
    VSB_GREATWALL_HAVAL_10 = 25,
    VSB_GREATWALL_HAVAL_11 = 26,
    VSB_GREATWALL_HAVAL_12 = 27,
    VSB_GREATWALL_CROSS_1 = 28,
    VSB_GREATWALL_CROSS_2 = 29,
    VSB_GREATWALL_JINGLING_1 = 30,
    VSB_GREATWALL_SING_1 = 31,
    VSB_GREATWALL_SAIKU_1 = 32,
    VSB_GREATWALL_SAILING_1 = 33,
    VSB_GREATWALL_DIER_1 = 34,
    VSB_GREATWALL_COOLBEAR_1 = 35,
    VSB_GREATWALL_KINGDEER_1 = 36,
    VSB_GREATWALL_GREATWALL_1 = 37,
    VSB_GREATWALL_GREATWALL_2 = 38,
    VSB_GREATWALL_GREATWALL_3 = 39,
    VSB_GREATWALL_GREATWALL_4 = 40,
    VSB_GREATWALL_GREATWALL_5 = 41,
    VSB_GREATWALL_GREATWALL_6 = 42,
    VSB_GREATWALL_WINGLE_1 = 43,
    VSB_GREATWALL_WINGLE_2 = 44,
    VSB_GREATWALL_HAVAL_7 = 45
}VSB_GREATWALL_CLASS;


typedef enum _VSB_DS_CLASS
{
    VSB_DS_OTHER = 0,
    VSB_DS_KUBO_1 = 1,
    VSB_DS_KUWEI_1 = 2,
    VSB_DS_KUWEI_2 = 3
}VSB_DS_CLASS;


typedef enum _VSB_LANDROVER_CLASS
{
    VSB_LANDROVER_OTHER = 0,
    VSB_LANDROVER_FAXIAN_1 = 1,
    VSB_LANDROVER_FAXIAN_2 = 2,
    VSB_LANDROVER_LANSHENG_1 = 3,
    VSB_LANDROVER_LANSHENG_2 = 4,
    VSB_LANDROVER_LANSHENG_3 = 5,
    VSB_LANDROVER_LANSHENG_4 = 6,
    VSB_LANDROVER_SXZ_1 = 7
}VSB_LANDROVER_CLASS;


typedef enum _VSB_MG_CLASS
{
    VSB_MG_OTHER = 0,
    VSB_MG_3SW_1 = 1,
    VSB_MG_MG3_1 = 2,
    VSB_MG_MG5_1 = 3,
    VSB_MG_MG6_1 = 4,
    VSB_MG_MG7_1 = 5,
}VSB_MG_CLASS;


typedef enum _VSB_FAW_CLASS
{
    VSB_FAW_OTHER = 0,
    VSB_FAW_501_1 = 1,
    VSB_FAW_N3_1 = 2,
    VSB_FAW_N3_2 = 3,
    VSB_FAW_JIABAO_1 = 4,
    VSB_FAW_JIABAO_2 = 5,
    VSB_FAW_JIABAO_3 = 6,
    VSB_FAW_JIABAO_4 = 7,
    VSB_FAW_JIABAO_5 = 8,
    VSB_FAW_JIABAO_6 = 9,
    VSB_FAW_JIABAO_7 = 10,
    VSB_FAW_XIALI_1 = 11,
    VSB_FAW_XIALI_2 = 12,
    VSB_FAW_XIALI_3 = 13,
    VSB_FAW_XIALI_4 = 14,
    VSB_FAW_XIALI_5 = 15,
    VSB_FAW_XIALI_6 = 16,
    VSB_FAW_AOWEI_1 = 17,
    VSB_FAW_AOWEI_2 = 18,
    VSB_FAW_AOWEI_3 = 19,
    VSB_FAW_AOWEI_4 = 20,
    VSB_FAW_AOXING_1 = 21,
    VSB_FAW_WEILE_1 = 22,
    VSB_FAW_WEILE_2 = 23,
    VSB_FAW_WEIZI_1 = 24,
    VSB_FAW_WEIZHI_1 = 25,
    VSB_FAW_WEIZHI_2 = 26,
    VSB_FAW_WEIZHI_3 = 27,
    VSB_FAW_WEIZHI_4 = 28,
    VSB_FAW_WEIZHI_5 = 29,
    VSB_FAW_XIAOJIEFANG_1 = 30,
    VSB_FAW_HANWEI_1 = 31,
    VSB_FAW_HANWEI_2 = 32,
    VSB_FAW_HANWEI_3 = 33,
    VSB_FAW_XINDAWEI_1 = 34,
    VSB_FAW_XINHANWEI_1 = 35,
    VSB_FAW_SENYA_1 = 36,
    VSB_FAW_TENGWEI_1 = 37,
    VSB_FAW_JIEFANG_1 = 38,
    VSB_FAW_JIEFANG_2 = 39,
    VSB_FAW_JIEFANG_3 = 40,
    VSB_FAW_JIEFANG_4 = 41,
    VSB_FAW_JIEFANG_5 = 42,
    VSB_FAW_JIEFANG_6 = 43,
    VSB_FAW_SAILONG_1 = 44,
    VSB_FAW_JUNWEI_1 = 45,
    VSB_FAW_B50_1 = 46,
    VSB_FAW_B50_2 = 47
}VSB_FAW_CLASS;



typedef enum _VSB_SAICMOTOR_CLASS
{
    VSB_SAICMOTOR_OTHER = 0,
    VSB_HONGYAN_JIESHI_1 = 1,
    VSB_DATONG_V80_1 = 2
}VSB_SAICMOTOR_CLASS;


typedef enum _VSB_SOUEAST_CLASS
{
    VSB_SOUEAST_OTHER = 0,
    VSB_SOUEAST_V3_1 = 1,
    VSB_SOUEAST_V3_2 = 2,
    VSB_SOUEAST_V3_3 = 3,
    VSB_SOUEAST_V3_4 = 4,
    VSB_SOUEAST_V5_1 = 5,
    VSB_SOUEAST_XIWANG_1 = 6,
    VSB_SOUEAST_DELIKA_1 = 7,
    VSB_SOUEAST_DELIKA_2 = 8,
    VSB_SOUEAST_DELIKA_3 = 9,
    VSB_SOUEAST_DELIKA_4 = 10,
    VSB_SOUEAST_LINGSHUAI_1 = 11,
    VSB_SOUEAST_FULIKA_1 = 12,
    VSB_SOUEAST_FULIKA_2 = 13
}VSB_SOUEAST_CLASS;



typedef enum _VSB_ZTE_CLASS
{
    VSB_ZTE_OTHER = 0,
    VSB_ZTE_WEIHU_1 = 1,
    VSB_ZTE_WEIHU_2 = 2,
    VSB_ZTE_WUXIAN_1 = 3,
    VSB_ZTE_WUXIAN_2 = 4
}VSB_ZTE_CLASS;



typedef enum _VSB_ZHONGHUA_CLASS
{
    VSB_ZHONGHUA_OTHER = 0,
    VSB_ZHONGHUA_H230_1 = 1,
    VSB_ZHONGHUA_H320_1 = 2,
    VSB_ZHONGHUA_H330_1 = 3,
    VSB_ZHONGHUA_H530_1 = 4,
    VSB_ZHONGHUA_V5_1 = 5,
    VSB_ZHONGHUA_ZUNCHI_1 = 6,
    VSB_ZHONGHUA_ZUNCHI_2 = 7,
    VSB_ZHONGHUA_KUBAO_1 = 8,
    VSB_ZHONGHUA_JUNJIE_1 = 9,
    VSB_ZHONGHUA_JUNJIE_2 = 10,
    VSB_ZHONGHUA_JUNJIECROSS_1 = 11,
    VSB_ZHONGHUA_JUNJIEFRV_1 = 12,
    VSB_ZHONGHUA_JUNJIEFRV_2 = 13,
    VSB_ZHONGHUA_JUNJIEFSV_1 = 14,
    VSB_ZHONGHUA_JUNJIEFSV_2 = 15,
    VSB_ZHONGHUA_JUNJIEFSV_3 = 16
}VSB_ZHONGHUA_CLASS;



typedef enum _VSB_CNHTC_CLASS
{
    VSB_CNHTC_OTHER = 0,
    VSB_CNHTC_HOKA_2 = 1,
    VSB_CNHTC_HOWO_1 = 2,
    VSB_CNHTC_HOWO_2 = 3,
    VSB_CNHTC_HOWO_3 = 4,
    VSB_CNHTC_HOWO_4 = 5,
    VSB_CNHTC_HOWO_5 = 6,
    VSB_CNHTC_HOWO_6 = 7,
    VSB_CNHTC_HOWO_7 = 8,
    VSB_CNHTC_HOWO_8 = 9,
    VSB_CNHTC_SITAIERWANG_1 = 10,
    VSB_CNHTC_HAOHAN_1 = 11,
    VSB_CNHTC_HAOYUN_1 = 12,
    VSB_CNHTC_JINWANGZI_1 = 13,
    VSB_CNHTC_HOKA_1 = 14
}VSB_CNHTC_CLASS;


typedef enum _VSB_ZHONGTONG_CLASS
{
    VSB_ZHONGTONG_OTHER = 0,
    VSB_ZHONGTONG_KAICHI_1 = 1,
    VSB_ZHONGTONG_LINGYU_1 = 2,
    VSB_ZHONGTONG_LINGXIU_1 = 3,
    VSB_ZHONGTONG_LINGHANG_1 = 4,
    VSB_ZHONGTONG_SHIJI_1 = 5,
    VSB_ZHONGTONG_KAIXUAN_1 = 6,
    VSB_ZHONGTONG_LINGYUN_1 = 7,
    VSB_ZHONGTONG_YANGGUANG_1 = 8
}VSB_ZHONGTONG_CLASS;



typedef enum _VSB_JIULONG_CLASS
{
    VSB_JIULONG_OTHER = 0,
    VSB_JIULONG_JIULONGA5_1 = 1,
}VSB_JIULONG_CLASS;


typedef enum _VSB_ZOTYE_CLASS
{
    VSB_ZOTYE_OTHER = 0,
    VSB_ZOTYE_2008_2 = 1,
    VSB_ZOTYE_5008_1 = 2,
    VSB_ZOTYE_Z300_1 = 3,
    VSB_ZOTYE_2008_1 = 4
}VSB_ZOTYE_CLASS;


typedef enum _VSB_NAVECO_CLASS
{
    VSB_NAVECO_OTHER = 0,
    VSB_NAVECO_Daily_1 = 1,
    VSB_NAVECO_Power_1 = 2,
    VSB_NAVECO_Turbo_1 = 3,
    VSB_NAVECO_Venice_1 = 4,
    VSB_NAVECO_BAODI_1 = 5,
    VSB_NAVECO_DEYIHUOCHE_1 = 6,
    VSB_NAVECO_DULING_1 = 7
}VSB_NAVECO_CLASS;


typedef enum _VSB_PORSCHE_CLASS
{
    VSB_PORSCHE_OTHER = 0,
    VBR_PORSCHE_PANAMERA_1 = 1,
    VBR_PORSCHE_CAYENNE_1 = 2,
}VSB_PORSCHE_CLASS;



typedef enum _VSB_CHRYSLER_CLASS
{
    VSB_CHRYSLER_OTHER = 0,
    VSB_CHRYSLER_300C_1 = 1,
    VSB_CHRYSLER_PTMANBUZHE_1 = 2,
}VSB_CHRYSLER_CLASS;


typedef enum _VSB_CADILLAC_CLASS
{
    VSB_CADILLAC_OTHER = 0,
    VSB_CADILLAC_ATS_1 = 1,
    VSB_CADILLAC_CTS_1 = 2,
    VSB_CADILLAC_CTS_3 = 3,
    VSB_CADILLAC_SLS_1 = 4,
    VSB_CADILLAC_SLS_2 = 5,
    VSB_CADILLAC_SRX_1 = 6,
    VSB_CADILLAC_CTS_2 = 7,
    VSB_CADILLAC_KAILEIDE_1 = 8
}VSB_CADILLAC_CLASS;



typedef enum _VSB_KAMA_CLASS
{
    VSB_KAMA_OTHER = 0,
    VSB_KAMA_QINGKA_2 = 1,
    VSB_KAMA_FULAIKA_1 = 2,
    VSB_KAMA_JINYUNKA_1 = 3,
    VSB_KAMA_JUNWEIKA_1 = 4,
    VSB_KAMA_QINGKA_1 = 5
}VSB_KAMA_CLASS;


typedef enum _VSB_LIFAN_CLASS
{
    VSB_LIFAN_OTHER = 0,
    VSB_LIFAN_320_1 = 1,
    VSB_LIFAN_520_1 = 2,
    VSB_LIFAN_520_2 = 3,
    VSB_LIFAN_620_1 = 4,
    VSB_LIFAN_X60_1 = 5,
    VSB_LIFAN_FENGSHUN_1 = 6
}VSB_LIFAN_CLASS;



typedef enum _VSB_BEIJING_CLASS
{
    VSB_BEIJING_OTHER = 0,
    VSB_BEIJING_E_1 = 1,
}VSB_BEIJING_CLASS;


typedef enum _VSB_BEIBEN_CLASS
{
    VSB_BEIBEN_OTHER = 0,
    VSB_BEIBEN_NG80_1 = 1,
    VSB_BEIBEN_NG80_2 = 2,
    VSB_BEIBEN_NG80_3 = 3,
    VSB_BEIBEN_V3_1 = 4,
    VSB_BEIBEN_V3_2 = 5
}VSB_BEIBEN_CLASS;


typedef enum _VSB_BEIFANG_CLASS
{
    VSB_BEIFANG_OTHER = 0,
    VSB_BEIFANG_A_1 = 1
}VSB_BEIFANG_CLASS;



typedef enum _VSB_BAW_CLASS
{
    VSB_BAW_OTHER = 0,
    VSB_BAW_YUSHENG007_1 = 1,
    VSB_BAW_QILING_1 = 2,
    VSB_BAW_LUBA_1 = 3,
    VSB_BAW_QISHI_1 = 4
}VSB_BAW_CLASS;


typedef enum _VSB_BQWEIWANG_CLASS
{
    VSB_BQWEIWANG_OTHER = 0,
    VSB_BQWEIWANG_205_1 = 1,
    VSB_BQWEIWANG_306_1 = 2
}VSB_BQWEIWANG_CLASS;



typedef enum _VSB_SMA_CLASS
{
    VSB_SMA_OTHER = 0,
    VSB_SMA_HAIYU_1 = 1,
    VSB_SMA_HAIYU_2 = 2,
    VSB_SMA_HAISHANG_1 = 3,
    VSB_SMA_HAIJING_1 = 5,
    VSB_SMA_HAIXUN_1 = 4,
    VSB_SMA_HAIXUN_2 = 6,
}VSB_SMA_CLASS;


typedef enum _VSB_XINGMA_CLASS
{
    VSB_XINGMA_OTHER = 0,
    VSB_XINGMA_XINGKAIMA_1 = 1
}VSB_XINGMA_CLASS;


typedef enum _VSB_SHUANGHUAN_CLASS
{
    VSB_SHUANGHUAN_OTHER = 0,
    VSB_SHUANGHUAN_SCEO_1 = 1,
}VSB_SHUANGHUAN_CLASS;


typedef enum _VSB_JEEP_CLASS
{
    VSB_JEEP_OTHER = 0,
    VSB_JEEP_DAQIENUOJI_1 = 1,
    VSB_JEEP_DAQIENUOJI_2 = 2,
    VSB_JEEP_ZHINANZHE_1 = 3,
    VSB_JEEP_ZHINANZHE_2 = 4,
    VSB_JEEP_MUMAREN_1 = 5,
    VSB_JEEP_MUMAREN_2 = 6,
    VSB_JEEP_ZIYOUKE = 7,
}VSB_JEEP_CLASS;


typedef enum _VSB_VENUCIA_CLASS
{
    VSB_VENUCIA_OTHER = 0,
    VSB_VENUCIA_D50_1 = 1
}VSB_VENUCIA_CLASS;


typedef enum _VSB_HAFEI_CLASS
{
    VSB_HAFEI_OTHER = 0,
    VSB_HAFEI_XINMINYI_1 = 1,
    VSB_HAFEI_XINMINYI_2 = 2,
    VSB_HAFEI_MINYI_1 = 3,
    VSB_HAFEI_MINYI_2 = 4,
    VSB_HAFEI_SAIBAO_1 = 5,
    VSB_HAFEI_SAIMA_1 = 6,
    VSB_HAFEI_SAIMA_2 = 7,
    VSB_HAFEI_SAIMA_3 = 8,
    VSB_HAFEI_LUBAO_1 = 9,
    VSB_HAFEI_LUBAO_2 = 10,
    VSB_HAFEI_LUBAO_3 = 11,
    VSB_HAFEI_LUZUNXIAOBAWANG_1 = 12,
    VSB_HAFEI_RUIYI_1 = 13,
    VSB_HAFEI_JUNYI_1 = 14
}VSB_HAFEI_CLASS;


typedef enum _VSB_TKING_CLASS
{
    VSB_TKING_OTHER = 0,
    VSB_TKING_OUGUAN_1 = 1,
    VSB_TKING_OUGUAN_2 = 2,
    VSB_TKING_OUTENG_1 = 3,
    VSB_TKING_FUXING_1 = 4,
    VSB_TKING_QINGKAWANG_1 = 5,
    VSB_TKING_AFANDA_1 = 6,
    VSB_TKING_JUNQI_1 = 7
}VSB_TKING_CLASS;


typedef enum _VSB_DAEWOO_CLASS
{
    VSB_DAEWOO_OTHER = 0,
    VBR_DAEWOO_6960H3_1 = 1
}VSB_DAEWOO_CLASS;


typedef enum _VSB_DAYUN_CLASS
{
    VSB_DAYUN_OTHER = 0,
    VBR_DAYUN_ZHONGKA_1 = 1
}VSB_DAYUN_CLASS;


typedef enum _VSB_BESTURN_CLASS
{
    VSB_BESTURN_OTHER = 0,
    VSB_BESTURN_B70_1 = 1,
    VSB_BESTURN_B70_2 = 2,
    VSB_BESTURN_B70_3 = 3,
    VSB_BESTURN_B70_4 = 4,
    VSB_BESTURN_B90_1 = 5,
    VSB_BESTURN_AOXING_1 = 6
}VSB_BESTURN_CLASS;


typedef enum _VSB_WEILIN_CLASS
{
    VSB_WEILIN_OTHER = 0,
    VSB_WEILIN_H3_1 = 1,
    VSB_WEILIN_V5_1 = 2,
    VSB_WEILIN_X5_1 = 3
}VSB_WEILIN_CLASS;


typedef enum _VSB_YUTONG_CLASS
{
    VSB_YUTONG_OTHER = 0,
    VSB_YUTONG_8XI_1 = 1,
    VSB_YUTONG_KECHE_1 = 2,
    VSB_YUTONG_KECHE_3 = 3,
    VSB_YUTONG_KECHE_4 = 4,
    VSB_YUTONG_KECHE_5 = 5,
    VSB_YUTONG_KECHE_2 = 6
}VSB_YUTONG_CLASS;


typedef enum _VSB_ANKAI_CLASS
{
    VSB_ANKAI_OTHER = 0,
    VSB_ANKAI_KECHE_1 = 1,
    VSB_ANKAI_KECHE_2 = 2
}VSB_ANKAI_CLASS;


typedef enum _VSB_BAOJUN_CLASS
{
    VSB_BAOJUN_OTHER = 0,
    VSB_BAOJUN_630_1 = 1
}VSB_BAOJUN_CLASS;


typedef enum _VSB_BINLI_CLASS
{
    VSB_BINLI_OTHER = 0,
    VSB_BINLI_OULU_1 = 1
}VSB_BINLI_CLASS;


typedef enum _VSB_TRUMPCHE_CLASS
{
    VSB_TRUMPCHE_OTHER = 0,
    VSB_TRUMPCHE_GA5_1 = 1,
    VSB_TRUMPCHE_GA5_2 = 3,
    VSB_TRUMPCHE_GS5_1 = 2
}VSB_TRUMPCHE_CLASS;


typedef enum _VSB_GONOW_CLASS
{
    VSB_GONOW_OTHER = 0,
    VSB_GONOW_G3_1 = 1,
    VSB_GONOW_G5_1 = 2,
    VSB_GONOW_SHUAIJIAN_1 = 4,
    VSB_GONOW_XINGWANGM1_1 = 3,
    VSB_GONOW_CAIYUN500_1 = 5
}VSB_GONOW_CLASS;


typedef enum _VSB_ISUZU_CLASS
{
    VSB_ISUZU_OTHER = 0,
    VSB_ISUZU_ZHONGXINGSHANGYONG_1 = 1,
    VSB_ISUZU_WUSHILINGPIKA_1 = 2,
    VSB_ISUZU_WUSHILINGPIKA_2 = 3,
    VSB_ISUZU_JINGJIZHE_1 = 4
}VSB_ISUZU_CLASS;



typedef enum _VSB_KARRY_CLASS
{
    VSB_KARRY_OTHER = 0,
    VSB_KARRY_YOU_2 = 1,
    VSB_KARRY_YOUJIN_1 = 2,
    VSB_KARRY_YOUSHENG_1 = 3,
    VSB_KARRY_YOUSHENG_2 = 4,
    VSB_KARRY_YOUYA = 5,
    VSB_KARRY_YOU_1 = 6
}VSB_KARRY_CLASS;


typedef enum _VSB_GAGUAR_CLASS
{
    VSB_GAGUAR_OTHER = 0,
    VSB_GAGUAR_XF_1 = 1,
    VSB_GAGUAR_XJ_1 = 2
}VSB_GAGUAR_CLASS;


typedef enum _VSB_SUBARU_CLASS
{
    VSB_SUBARU_OTHER = 0,
    VSB_SUBARU_AOHU_1 = 1,
    VSB_SUBARU_LISHI_1 = 2,
    VSB_SUBARU_LISHI_2 = 3,
    VSB_SUBARU_XV_1 = 4,
    VSB_SUBARU_SENLINREN_1 = 5,
    VSB_SUBARU_SENLINREN_2 = 6
}VSB_SUBARU_CLASS;


typedef enum _VSB_ERA_CLASS
{
    VSB_ERA_OTHER = 0,
    VSB_ERA_XIAOKA_1 = 1,
    VSB_ERA_XIAOKA_3 = 2,
    VSB_ERA_XIAOKA_4 = 3,
    VSB_ERA_KANGRUI_1 = 4,
    VSB_ERA_KANGRUI_2 = 5,
    VSB_ERA_KANGRUI_3 = 6,
    VSB_ERA_RUIWO_1 = 7,
    VSB_ERA_RUIWO_2 = 8,
    VSB_ERA_RUIWO_3 = 9,
    VSB_ERA_JINGANG = 10,
    VSB_ERA_LINGHANG_1 = 11,
    VSB_ERA_LINGHANG_2 = 12,
    VSB_ERA_YULING_1 = 13,
    VSB_ERA_YULING_2 = 14,
    VSB_ERA_YULING_3 = 15,
    VSB_ERA_YULING_4 = 17,
    VSB_ERA_XIAOKA_2 = 17,
}VSB_ERA_CLASS;


typedef enum _VSB_CHANGHE_CLASS
{
    VSB_CHANGHE_OTHER = 0,
    VSB_CHANGHE_CH6321_1 = 1,
    VSB_CHANGHE_DANSHUANGPAI_1 = 2,
    VSB_CHANGHE_AIDIER_1 = 3,
    VSB_CHANGHE_AIDIER_2 = 4,
    VSB_CHANGHE_FURUIDA_1 = 5
}VSB_CHANGHE_CLASS;


typedef enum _VSB_OPEL_CLASS
{
    VSB_OPEL_OTHER = 0,
    VSB_OPEL_YATE_1 = 1
}VSB_OPEL_CLASS;


typedef enum _VSB_JONWAY_CLASS
{
    VSB_JONWAY_OTHER = 0,
    VSB_JONWAY_A380_1 = 1
}VSB_JONWAY_CLASS;


typedef enum _VSB_JIANGNAN_CLASS
{
    VSB_JIANGNAN_OTHER = 0,
    VSB_JIANGNAN_TT_1 = 1
}VSB_JIANGNAN_CLASS;


typedef enum _VSB_GLEAGLE_CLASS
{
    VSB_GLEAGLE_OTHER = 0,
    VSB_GLEAGLE_EAGLE_GC7_1 = 1,
    VSB_GLEAGLE_EAGLE_GX2_1 = 2,
    VSB_GLEAGLE_EAGLE_GX7_1 = 3,
    VSB_GLEAGLE_EAGLE_PANDA_1 = 4,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1 = 5,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2 = 6,
    VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3 = 7,
    VSB_GLEAGLE_EAGLE_YUANJING_1 = 8,
    VSB_GLEAGLE_EAGLE_YUANJING_2 = 9,
}VSB_GLEAGLE_CLASS;


typedef enum _VSB_EMGRAND_CLASS
{
    VSB_EMGRAND_OTHER = 0,
    VSB_EMGRAND_EC7_2 = 1,
    VSB_EMGRAND_EC7_3 = 2,
    VSB_EMGRAND_EC8_1 = 3,
    VSB_EMGRAND_EC7_1 = 4
}VSB_EMGRAND_CLASS;



typedef enum _VSB_ENGLON_CLASS
{
    VSB_ENGLON_OTHER = 0,
    VSB_ENGLON_SC3_1 = 1,
    VSB_ENGLON_SC5_1 = 2,
    VSB_ENGLON_SC6_1 = 3,
    VSB_ENGLON_SC7_1 = 4,
    VSB_ENGLON_SX7_1 = 5,
    VSB_ENGLON_JINGANG_1 = 6,
    VSB_ENGLON_JINYING_1 = 7
}VSB_ENGLON_CLASS;



typedef enum _VSB_JAC_CLASS
{
    VSB_JAC_OTHER = 0,
    VSB_JAC_TONGYUE_1 = 1,
    VSB_JAC_HEYUE_1 = 2,
    VSB_JAC_HEYUEA30_2 = 3,
    VSB_JAC_HEYUERS_3 = 4,
    VSB_JAC_HAOYUN_1 = 5,
    VSB_JAC_WEILING_2 = 6,
    VSB_JAC_WEILING_3 = 7,
    VSB_JAC_WEILING_4 = 8,
    VSB_JAC_KECHE_1 = 9,
    VSB_JAC_BINYUE_1 = 10,
    VSB_JAC_SHUAILING_2 = 11,
    VSB_JAC_KANGLING_1 = 12,
    VSB_JAC_KANGLING_2 = 13,
    VSB_JAC_YUEYUE_1 = 14,
    VSB_JAC_XINGRUI_1 = 15,
    VSB_JAC_GEERFA_H_1 = 16,
    VSB_JAC_GEERFA_K_2 = 17,
    VSB_JAC_GEERFA_K_3 = 18,
    VSB_JAC_GEERFA_M_4 = 19,
    VSB_JAC_RUIFENG_1 = 20,
    VSB_JAC_RUIFENG_2 = 21,
    VSB_JAC_RUIFENG_3 = 22,
    VSB_JAC_RUIFENG_4 = 23,
    VSB_JAC_RUIYING_1 = 24,
    VSB_JAC_RUIYING_2 = 25,
    VSB_JAC_JUNLING_2 = 26,
    VSB_JAC_WEILING_1 = 27,
    VSB_JAC_SHUAILING_1 = 28,
    VSB_JAC_RUILING_1 = 29,
    VSB_JAC_JUNLING_1 = 30
}VSB_JAC_CLASS;



typedef enum _VSB_JMC_CLASS
{
    VSB_JMC_OTHER = 0,
    VSB_JMC_KAIYUN_1 = 1,
    VSB_JMC_KAIYUN_2 = 2,
    VSB_JMC_YUHU_1 = 3,
    VSB_JMC_BAODIAN_1 = 4,
    VSB_JMC_BAODIAN_2 = 5,
    VSB_JMC_BAODIAN_3 = 6,
    VSB_JMC_BAOWEI_1 = 7,
    VSB_JMC_BAOWEI_2 = 8,
    VSB_JMC_QUANSHUN_1 = 9,
    VSB_JMC_QUANSHUN_2 = 10,
    VSB_JMC_QUANSHUN_3 = 11,
    VSB_JMC_SHUNDA_1 = 12,
    VSB_JMC_SHUNDA_2 = 13,
    VSB_JMC_YUSHENG_1 = 14,
    VSB_JMC_YUSHENG_2 = 15
}VSB_JMC_CLASS;


typedef enum _VSB_VOLVO_CLASS
{
    VSB_VOLVO_OTHER = 0,
    VSB_VOLVO_C30_1 = 1,
    VSB_VOLVO_S40_1 = 2,
    VSB_VOLVO_S60_1 = 3,
    VSB_VOLVO_S60_2 = 4,
    VSB_VOLVO_S80L_1 = 5,
    VSB_VOLVO_XC60_1 = 6,
    VSB_VOLVO_XC90_1 = 7
}VSB_VOLVO_CLASS;


typedef enum _VSB_HIGER_CLASS
{
    VSB_HIGER_OTHER = 0,
    VSB_HIGER_H8_1 = 1,
    VSB_HIGER_H92_1 = 2,
    VSB_HIGER_V7_1 = 3,
    VSB_HIGER_KECHE_1 = 4,
    VSB_HIGER_LONGWEI_1 = 5,
    VSB_HIGER_H7V_1 = 6
}VSB_HIGER_CLASS;


typedef enum _VSB_RUILIN_CLASS
{
    VSB_RUILIN_OTHER = 0,
    VSB_RUILIN_G3_1 = 1,
    VSB_RUILIN_G5_1 = 2,
    VSB_RUILIN_M1_1 = 3,
    VSB_RUILIN_X1_1 = 4,
    VSB_RUILIN_X1_2 = 5
}VSB_RUILIN_CLASS;


typedef enum _VSB_SHENLONG_CLASS
{
    VSB_SHENLON_OTHER = 0,
    VSB_SHENLONG_KECHE_1 = 1
}VSB_SHENLONG_CLASS;


typedef enum _VSB_FOTON_CLASS
{
    VSB_FOTON_OTHER = 0,
    VSB_FOTON_AOLING_1 = 1,
    VSB_FOTON_AOLING_2 = 2,
    VSB_FOTON_AOLING_3 = 3,
    VSB_FOTON_OUMAN_1 = 4,
    VSB_FOTON_OUMAN_2 = 5,
    VSB_FOTON_OUMAN_3 = 6,
    VSB_FOTON_OUMAN_4 = 7,
    VSB_FOTON_OUHUI_1 = 8,
    VSB_FOTON_OUMAKE_1 = 9,
    VSB_FOTON_OUMAKE_2 = 10,
    VSB_FOTON_SAPU_1 = 11,
    VSB_FOTON_SAPU_3 = 12,
    VSB_FOTON_MENGPAIKE_1 = 13,
    VSB_FOTON_MIDI_1 = 14,
    VSB_FOTON_FENGJING_1 = 15,
    VSB_FOTON_SAPU_2 = 16
}VSB_FOTON_CLASS;


typedef enum _VSB_FODAY_CLASS
{
    VSB_FODAY_OTHER = 0,
    VSB_FODAY_CHAOREN_1 = 1,
    VSB_FODAY_CHAOREN_2 = 2,
    VSB_FODAY_TANSUOZHE_1 = 3,
    VSB_FODAY_TANSUOZHE_2 = 4,
    VSB_FODAY_TANSUOZHE_3 = 5,
    VSB_FODAY_XIONGSHI_1 = 6
}VSB_FODAY_CLASS;


typedef enum _VSB_HONGQI_CLASS
{
    VSB_HONGQI_OTHER = 0,
    VSB_HONGQI_MINGSHI_1 = 1
}VSB_HONGQI_CLASS;



typedef enum _VSB_LUXGEN_CLASS
{
    VSB_LUXGEN_OTHER = 0,
    VSB_LUXGEN_DASEVEN_1 = 1
}VSB_LUXGEN_CLASS;


typedef enum _VSB_XIALI_CLASS
{
    VSB_XIALI_OTHER = 0,
    VSB_XIALI_QIBING_1 = 1,
}VSB_XIALI_CLASS;


typedef enum _VSB_SHUCHI_CLASS
{
    VSB_SHUCHI_OTHER = 0,
    VSB_SHUCHI_A_1 = 1
}VSB_SHUCHI_CLASS;


typedef enum _VSB_INFINITI_CLASS
{
    VSB_INFINITI_OTHER = 0,
    VSB_INFINITI_EX_1 = 1,
    VSB_INFINITI_FX_1 = 2,
    VSB_INFINITI_FX_2 = 3,
    VSB_INFINITI_FX_3 = 4,
    VSB_INFINITI_G_1 = 5,
    VSB_INFINITI_JX_1 = 6
}VSB_INFINITI_CLASS;



typedef enum _VSB_LOTUS_CLASS
{
    VSB_LOTUS_OTHER = 0,
    VSB_LOTUS_L3_1 = 1,
    VSB_LOTUS_L3_2 = 2
}VSB_LOTUS_CLASS;


typedef enum _VSB_FIAT_CLASS
{
    VSB_FIAT_OTHER = 0,
    VSB_FIAT_FEIYUE_1 = 1
}VSB_FIAT_CLASS;


typedef enum _VSB_OGA_CLASS
{
    VSB_OGA_OTHER = 0,
    VSB_OGA_MDX_1 = 1,
    VSB_OGA_MDX_2 = 2
}VSB_OGA_CLASS;




typedef enum _VSB_YUEJIN_CLASS
{
    VSB_YUEJIN_OTHER = 0,
    VSB_YUEJIN_SHUAIHU_1 = 1,
    VSB_YUEJIN_CAISHEN_1 = 2,
    VSB_YUEJIN_CAISHEN_2 = 3,
    VSB_YUEJIN_CAISHEN_3 = 4
}VSB_YUEJIN_CLASS;


typedef enum _VSB_YEMA_CLASS
{
    VSB_YEMA_OTHER = 0,
    VSB_YEMA_F99_1 = 1
}VSB_YEMA_CLASS;


typedef enum _VSB_SZKINGLONG_CLASS
{
    VSB_SZKINGLONG_OTHER = 0,
    VSB_SZKINGLONG_BUS11_1 = 1,
    VSB_SZKINGLONG_BUS12_1 = 2,
    VSB_SZKINGLONG_BUS13_1 = 3,
    VSB_SZKINGLONG_BUS14_1 = 4,
    VSB_SZKINGLONG_BUS16_1 = 5,
    VSB_SZKINGLONG_BUS18_1 = 6,
    VSB_SZKINGLONG_BUS1_1 = 7,
    VSB_SZKINGLONG_BUS20_1 = 8,
    VSB_SZKINGLONG_BUS2_1 = 9,
    VSB_SZKINGLONG_BUS5_1 = 10,
    VSB_SZKINGLONG_BUS6_1 = 11,
    VSB_SZKINGLONG_BUS9_1 = 12,
    VSB_SZKINGLONG_BUS10_1 = 13,
    VSB_SZKINGLONG_BUS15_1 = 14
}VSB_SZKINGLONG_CLASS;


typedef enum _VSB_CHANGFENG_CLASS
{
    VSB_CHANGFENG_OTHER = 0,
    VSB_CHANGFENG_CS7_1 = 1,
    VSB_CHANGFENG_QIBING_1 = 2,
    VSB_CHANGFENG_LIEBAO_1 = 3,
    VSB_CHANGFENG_FULING_1 = 4,
    VSB_CHANGFENG_FEIYANG_1 = 5,
    VSB_CHANGFENG_FEITENG_1 = 6,
    VSB_CHANGFENG_BLACKJINGANG_1 = 7,
}VSB_CHANGFENG_CLASS;


typedef enum _VSB_LUFENG_CLASS
{
    VSB_LUFENG_OTHER = 0,
    VSB_LUFENG_X6_1 = 1,
    VSB_LUFENG_X6_2 = 2,
    VSB_LUFENG_X6_3 = 3,
    VSB_LUFENG_LUFENGX5_1 = 4,
    VSB_LUFENG_LUFENGX8_1 = 5,
    VSB_LUFENG_LUFENGX8_2 = 6,
    VSB_LUFENG_FENGHUA_1 = 7,
    VSB_LUFENG_X6_4 = 8,
    VSB_LUFENG_FENGSHANG_1 = 9
}VSB_LUFENG_CLASS;


typedef enum _VSB_SHANQI_CLASS
{
    VSB_SHANQI_OTHER = 0,
    VSB_SHANQI_AOLONG_1 = 1,
    VSB_SHANQI_AOLONG_2 = 2,
    VSB_SHANQI_DELONG_1 = 3,
    VSB_SHANQI_DELONG_2 = 4,
    VSB_SHANQI_DELONG_3 = 5,
}VSB_SHANQI_CLASS;



typedef enum _VSB_RENAULT_CLASS
{
    VSB_RENAULT_OTHER = 0,
    VSB_RENAULT_MEIGANNA_1 = 1,
    VSB_RENAULT_KELEIAO_1 = 2,
    VSB_RENAULT_KELEIAO_2 = 3,
    VSB_RENAULT_SCENE_1 = 4,
    VSB_RENAULT_FENGLANG_1 = 5,
    VSB_RENAULT_TAFEIKE_1 = 6
}VSB_RENAULT_CLASS;


typedef enum _VSB_HUANGHAI_CLASS
{
    VSB_HUANGHAI_OTHER = 0,
    VSB_HUANGHAI_DACAISHEN_1 = 1,
    VSB_HUANGHAI_DACAISHEN_2 = 2,
    VSB_HUANGHAI_BUS4_1 = 3,
    VSB_HUANGHAI_CHALLENGER_1 = 4,
    VSB_HUANGHAI_AOLONGCUV_1 = 5,
    VSB_HUANGHAI_AOJUN_1 = 6,
    VSB_HUANGHAI_AOJUN_2 = 7,
    VSB_HUANGHAI_QISHENGV3_1 = 8,
    VSB_HUANGHAI_LINGHANGZHE_1 = 9,
    VSB_HUANGHAI_FENGCHI_1 = 10
}VSB_HUANGHAI_CLASS;
/********************Vehicle Brand Sub Type End*************************/

//LPR sub structure

typedef struct tagNET_DVR_PLATE_PARAM
{
    BYTE    byPlateRecoMode;   
    BYTE    byBelive;         
    BYTE    byRes[22];        
}NET_DVR_PALTE_PARAM, *LPNET_DVR_PALTE_PARAM;

typedef struct tagNET_DVR_PLATECFG
{
    DWORD        dwSize;
    DWORD    dwEnable;
    BYTE    byPicProType; 
    BYTE    byRes1[3];  
    NET_DVR_JPEGPARA struPictureParam;   
    NET_DVR_PALTE_PARAM struPlateParam;   
    NET_DVR_HANDLEEXCEPTION struHandleType;  
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];
    BYTE    byRelRecordChan[MAX_CHANNUM];  
    BYTE   byRes[20];  
}NET_DVR_PLATECFG, *LPNET_DVR_PLATECFG;

typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;                     //license type
    BYTE  byColor;                         //License color
    BYTE  byBright;                         //License brightness
    BYTE  byLicenseLen;                     //Character number of the license plate
    BYTE  byEntireBelieve;                     //Accuracy of the license plate (percentage)
    BYTE  byRegion;         //Region index value, 0 reserved, 1 Europe, 2 Russia(Russian regions), 3-EU&CIS,4-Middle East,5-APAC,6-AfandAM,0xff- all
    BYTE  byCountry;        //Country INdex,Reference :COUNTRY_INDEX(not support "COUNTRY_ALL = 0xff, //ALL")
    BYTE  byArea;           //Area,refer to EMI_AREA
    BYTE  byPlateSize;      //PlateSize,0~unknown,1~long,2~short
    /*Additional information(NET_DVR_VEHICLE_ADDINFO),0-No, 1-With*/
    BYTE  byAddInfoFlag;
    WORD  wCRIndex; //country/region Index, Reference : _CR_ INDEX_
    BYTE  byRes[4];
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//Win64 and linux64 under the pointer to 8 bytes
    BYTE*  pAddInfoBuffer;
#else
    /*Additional information pointer to the NET_DVR_VEHICLE_ADDINFO*/
    BYTE*   pAddInfoBuffer;
    BYTE  byRes2[4];
#endif 
    char  sPlateCategory[MAX_CATEGORY_LEN/*8*/];//Plate Category Info
    DWORD dwXmlLen;         //XML Alarm length
    char* pXmlBuf;          // XML content,valid when alarm is COMM_ITS_PLATE_RESUL, XML refer to <EventNotificationAlert> XML Block
    NET_VCA_RECT    struPlateRect;         //License plate position
    char sLicense[MAX_LICENSE_LEN];         //license content
    BYTE byBelieve[MAX_LICENSE_LEN];     //Accuracy of each letter
}NET_DVR_PLATE_INFO, *LPNET_DVR_PLATE_INFO;

typedef struct tagNET_DVR_PLATERECO_RESULE
{
    DWORD dwSize;
    DWORD    dwRelativeTime;
    DWORD    dwAbsTime;
    NET_VCA_DEV_INFO struDevInfo;
    NET_DVR_PLATE_INFO struPlateInfo;
    DWORD dwPicDataLen;
    DWORD dwRes[4];
    BYTE  *pImage;
}NET_DVR_PLATERECO_RESULE, *LPNET_DVR_PLATERECO_RESULE;

//Vehicle info
typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;                     //Vehicle index
    BYTE  byVehicleType;         //Vehicle type
    BYTE  byColorDepth;         //Vehicle color (dark/light)
    BYTE  byColor;                     //Vehicle color,refer to VCR_CLR_CLASS
    BYTE  byRadarState;  //Radar State
    WORD  wSpeed;                     //Speed (km/h)
    WORD  wLength;                     //Vehicle length of the previous one
    /*0- normal; 1- low speed, 2- High speed, 3- traverse travelling,4-run red light,5-drive line,6-direction,
    7 - intersection stranded, 8 - machines accounting for non-9 - illegal lane change,10-no with line 11-violate ban,
    12-park in cross ,13-park with green, 14-Not let the pedestrians, 15-Illegal parking, 16-Illegal turn around, 17-Take up an emergency Lane,
    18-ban turn right, 19-ban turn left, 20-press Yellow line, 21-Non - fastened seat belt, 22-Pedestrians run a red light, 23-gasser,
    24-Illegal using high beam, 25-drving&uphone, 26-turn left do not give precedence to going straight, 27-turn right do not give precedence to going straight,
    28-turn around do not give precedence to going straight, 29-Big bend small turn, 30-run green light, 31-dont wear helmet, 32-nonMotor pickup human,
    33-nonMotor on motor lane, 34-nonMotor have shed, 35-black smoke, 36-whistle,37-parking in line,38-parking straddle,39-parking in line&parking straddle,
    40-not yield to vehicles from right roads,41-vehicles about to enter a roundabout not yield to vehicles in the roundabout,42-vehicles from ramp not yield to vehicles from main road,
    43-large vehicle occupy line, 44-roar, 45-smoke*/
    BYTE  byIllegalType;
    BYTE  byVehicleLogoRecog; //
    BYTE  byVehicleSubLogoRecog; //
    BYTE  byVehicleModel; //
    BYTE  byCustomInfo[16];  //Custom information
    WORD  wVehicleLogoRecog;  //
    BYTE  byIsParking;
    BYTE  byRes;
    DWORD dwParkingTime; //Parking time, unit: s
    BYTE  byBelieve; //byIllegalType believe,1-100
    BYTE  byCurrentWorkerNumber;//Current Operating Number
    BYTE  byCurrentGoodsLoadingRate;//Current cargo loading rate 0-empty 1-less 2-medium 3-more 4-full
    BYTE  byDoorsStatus;//Door status 0 - Door closure 1 - Door opening
    BYTE  byRes3[4];
}NET_DVR_VEHICLE_INFO, *LPNET_DVR_VEHICLE_INFO;


//License Recognition
typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;                         //Structure length
    BYTE    byResultType;             //0- video recognition result, 1- Image  recognition result
    BYTE    byChanIndex;             //Channel number
    WORD    wAlarmRecordID;        //The alarm recording ID (used to query video only when byResultType 2)
    DWORD   dwRelativeTime;         //relative time   
    BYTE    byAbsTime[32];         //Relative time, yyyymmddhhmmssxxx, e.g.20090810235959999 (unit: ms) 
    DWORD   dwPicLen;                     //Picture length
    DWORD    dwPicPlateLen;             //License plate snapshot length 
    DWORD   dwVideoLen;                     //recoding video length
    BYTE    byTrafficLight;                 //0- non traffic light snapshot, 1- Green light snapshot; 2- Red light snapshot
    BYTE    byPicNum;                 //Picture index on multi-shot mode
    BYTE    byDriveChan;                 //Traffic lane index
    BYTE     byVehicleType;     //Vehicle type, refer to VTR_RESULT
    DWORD   dwBinPicLen; //Bin picture length
    DWORD   dwCarPicLen;//car picture length
    DWORD   dwFarCarPicLen;  //far car picture length
    BYTE    *pBuffer3;   //bin picture
    BYTE    *pBuffer4;  //car picture 
    BYTE    *pBuffer5;  //far car picture
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //Car Direction Type
    BYTE    byRes3[6];
    NET_DVR_PLATE_INFO  struPlateInfo;     //License plate info structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;  //Vehicle info
    BYTE    *pBuffer1;                    // Pointer to the upload snapshot or video, set it as NULL if no upload is required
    BYTE    *pBuffer2;                   // Pointer to the snapshot picture
}NET_DVR_PLATE_RESULT, *LPNET_DVR_PLATE_RESULT;
//For snapshot, the data would be arranged as video scene snapshot picture + license snapshot picture 

typedef struct tagNET_VPD_SHUTTER
{
    DWORD dwCommmand;
    DWORD dwCode;
    BYTE  byRes[60]; 
}NET_VPD_SHUTTER, *LPNET_VPD_SHUTTER;

//Picture overlay info configuration      
typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD        dwSize;
    BYTE        byOverlayInfo; //0- disable overlay 1- enable overlay
    BYTE        byOverlayMonitorInfo; //Overlay info of the monitor spot, 0- disable, 1- enable
    BYTE        byOverlayTime; //Overlay time, 0- disable, 1- enable
    BYTE        byOverlaySpeed; //Overlay speed, 0- disable, 1- enable
    BYTE        byOverlaySpeeding; //Overlay over-speed proportion, 0- disable, 1- enable
    BYTE        byOverlayLimitFlag; //Overlay speed-limitation mark, 0- disable, 1- enable
    BYTE        byOverlayPlate; //Overlay license plate, 0- disable, 1- enable
    BYTE        byOverlayColor; //Overlay vehicle color, 0- disable, 1- enable
    BYTE        byOverlayLength; //Overlay vehicle length, 0- disable, 1- enable
    BYTE        byOverlayType; //Overlay vehicle type, 0- disable, 1- enable
    BYTE        byOverlayColorDepth; //Overlay vehicle color depth, 0- disable, 1- enable
    BYTE        byOverlayDriveChan; //Overlay traffic lane info, 0- disable, 1- enable
    BYTE        byOverlayMilliSec;  //Overlay millisecond info: 0- disable, 1- enable
    BYTE        byOverlayIllegalInfo;  //Overlay illegal record info: 0- disable, 1- enable
    BYTE        byOverlayRedOnTime;   //Overlay time duration after red Light is on: 0- disable, 1- enable
    BYTE        byFarAddPlateJpeg;      //Far picture overlay plate jpeg,0- disable, 1- enable
    BYTE        byNearAddPlateJpeg;      //Near picture overlay plate jpeg,0- disable, 1- enable
    BYTE        byRes1[3];     //Reserved
    BYTE        byMonitorInfo1[32];     //Monitor spot info 1
    BYTE        byMonitorInfo2[44];  //Monitor spot info 2
    BYTE        byRes2[52];     //Reserved
}NET_DVR_IMAGEOVERLAYCFG, *LPNET_DVR_IMAGEOVERLAYCFG;

//Single IO Triggering 
typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE    byRelatedDriveWay; //Traffic lane
    BYTE     bySnapTimes;  //Snapshot time 0- disable, else- snapshot time (up to 5)  
    WORD    wSnapWaitTime;   //Snapshot wait time (unit: ms) , [67, 60000]
    WORD    wIntervalTime[4]; //multi-shot interval 1, (unit:ms)
    DWORD   dwSnapVehicleNum; //Snap Vehicle Num
    NET_DVR_JPEGPARA  struJpegPara;//Snap Picture Param
    BYTE    byRes2[16];
}NET_DVR_SNAPCFG, *LPNET_DVR_SNAPCFG;

typedef enum _ITC_MAINMODE_ABILITY_
{
    ITC_MODE_UNKNOW = 0x0,
    ITC_POST_MODE = 0x1,  //post
    ITC_EPOLICE_MODE = 0x2,  //epolice
    ITC_POSTEPOLICE_MODE = 0x4  //post epolice
}ITC_MAINMODE_ABILITY;

typedef enum _ITC_RECOG_REGION_TYPE_
{
    ITC_REGION_RECT = 0x0,  //rect
    ITC_REGION_POLYGON = 0x1,  //polygon
}ITC_RECOG_REGION_TYPE;

typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum; //IO input number
    BYTE  byIoOutNum; //IO output number
    BYTE  bySingleSnapNum; //Group number of Single IO triggering 
    BYTE  byLightModeArrayNum; //Group number of Traffic Light Mode 
    BYTE  byMeasureModeArrayNum; //Speed Measure mode group number
    BYTE  byPlateEnable;  //LPR ability
    BYTE  byLensMode; //Lens mode: 0- CCD, 1- CMOS
    BYTE  byPreTriggerSupport; //Support original trigger mode,0-yes,1-no
    DWORD dwAbilityType; //Trigger ability, bit Express, see ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //IO speed group number
    BYTE  byIoLightGroup; //IO light group number
    BYTE  byRecogRegionType; //Plate region type, see ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //The equipment capacity bitwise 0 - not support - Support
    // bySupport&0x1,Indicates whether the support extended characters superimposed configuration
    // bySupport&0x2,Indicates whether to support the expansion of the school allocation structure
    // bySupport&0x4, Indicates whether to support multiple network interface cards (multi network isolation)
    // bySupport&0x8, Indicates whether the support network card bonding function (network fault tolerance)
    // bySupport&0x10, Indicates whether to support voice intercom
    WORD wSupportMultiRadar;
    // wSupportMultiRadar&0x1,Said bayonet RS485 radar support Lane associated radar processing
    // wSupportMultiRadar&0x2,Said bayonet virtual coil support Lane associated radar processing
    // wSupportMultiRadar&0x4,Said mixed bayonet support Lane associated radar processing
    // wSupportMultiRadar&0x8,Said video detection support Lane associated radar processing
    BYTE  byICRPresetNum;
    // Said ICR preset point support (filter offset point) number
    BYTE  byICRTimeSlot;//That period of time in support of the ICR number (1 ~ 8)
    BYTE  bySupportRS485Num;//Said support RS485 port number
    BYTE  byExpandRs485SupportSensor;
    // byExpandRs485SupportSensor &0x1,Said support sensors electric car detector
    // byExpandRs485SupportSensor &0x2,Said card support sensors electric car detector
    BYTE  byExpandRs485SupportSignalLampDet;
    // byExpandRs485SupportSignalLampDet &0x1,Said electric cars detector support external signal detector
    // byExpandRs485SupportSignalLampDet &0x2,Said cassette electric car detector support external signal detector
    BYTE  byRelayNum;// Relay Num 2013-11-04
    BYTE  bySupport1;
    // bySupport1&amp; 0x1, indicating whether or not the support custom timing information configuration
    // bySupport1&amp; 0x2, said whether to support video trigger optimization scheme
    // bySupport1&amp; 0x4, said whether to support the DDNS configuration scheme
    // bySupport1&amp; 0x8, said whether to support the access equipment current trigger mode interface command
    // bySupport1&amp; 0x10, said whether to support the entrance configuration 2014-03-03
    BYTE  bySupport2;// bySupport2&0x01,  Stream With Vca Info
    // bySupport2&0x02, Support "byOSDMilliSecondEnable"(INTER_PICCFG_V30)
    // bySupport2&0x04, "NET_DVR_BARRIERGATE_CFG" in the "byBarrierGateCtrl" field to support the index 4~ unlock, and support" byUnlock" unlock enable.
    BYTE  bySupportWhiteBalance; //Support WhiteBalance.
    // bySupportWhiteBalance &0x01,  Support Fluorescent Lamp
    // bySupportWhiteBalance &0x02,  Support Natural Light
    // bySupportWhiteBalance &0x04,  Support Warm Light Lamp
    // bySupportWhiteBalance &0x08,  SupportIncandescent Lamp
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY, *LPNET_DVR_SNAP_ABILITY;


typedef struct tagNET_DVR_TRANSFER_CAP
{
    BYTE  byAbility;
    BYTE  byRes[63];
}NET_DVR_TRANSFER_CAP, *LPNET_DVR_TRANSFER_CAP;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//The preset number 1 to 8, 0 for no
    BYTE   bySubSwitchMode;//1~day,2~night (when byAssociateRresetNo == 0)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//Automatic switching time (time automatic switching under effective now supports 4 group, 4 group reservation)
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display array subscript said preset number 1 ~ 8 (0 ~ 7 relative)
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display
    BYTE  bySubSwitchMode;//1~day,2~night
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //According to the actual effective capacity set [0~100] dynamic display array subscript said preset number 1 ~ 8 (0 ~ 7 relative)
    BYTE  byICRAutoSwitch; // ICR Auto Switch[0 100]
    BYTE  byRes[147];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

//algAotoSwitch
typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//Detect Threshold [0,100],default 58
    BYTE  byAbBrightnessThreshold; //Abnormal brightness threshold,[0,100] default 12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;

typedef union tagNET_ITC_ICR_PARAM_UNION
{
    BYTE uLen[156];
    NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
    NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
    NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
    NET_ITC_ICR_ALGAOTOSWITCH_PARAM strICRAlgorithmAutoSwitch;
}NET_ITC_ICR_PARAM_UNION, *LPNET_ITC_ICR_PARAM_UNION;

typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~ automatic switching, 2~ manual switch, 3~ switch,4~Algorithm auto Switch
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;

typedef struct
{
    DWORD   dwHandleType;////Way to handle,  result of operation OR   
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    BYTE     byEnable; //0~no enable,1~enable
    BYTE    byRes;
    WORD    wDuration;//(units /s)
    BYTE    byAlarmOutTriggered[MAX_ITC_EXCEPTIONOUT];//triggered Alarm Out
    BYTE    byRes1[8];
} NET_ITC_HANDLEEXCEPTION, *LPNET_ITC_HANDLEEXCEPTION;

typedef struct
{
    DWORD dwSize;
    NET_ITC_HANDLEEXCEPTION struSnapExceptionType[MAX_EXCEPTIONNUM_V30]; //Each element of the array represents an anomaly, an array of 0- hard disk error, a 1- cable fault, 2-IP address conflict, abnormal 3- sensors, 4- signal detector abnormality

}NET_ITC_EXCEPTION, *LPNET_ITC_EXCEPTION;

typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX;  /*X axis coordinate of the coil's upper left corner (2 bytes) */
    WORD wTopLeftY;  /*Y axis coordinate of the coil's upper left corner (2 bytes) */
    WORD wWdith;  /*Coil width (2 bytes) */
    WORD wHeight;  /*Coil height (2 bytes) */
} NET_DVR_TRIGCOORDINATE, *LPNET_DVR_TRIGCOORDINATE;

typedef enum _PROVINCE_CITY_IDX_
{
    ANHUI_PROVINCE = 0,              //An Hui
    AOMEN_PROVINCE = 1,              //Macao 
    BEIJING_PROVINCE = 2,              //Bei Jing
    CHONGQING_PROVINCE = 3,              //Chong Qing
    FUJIAN_PROVINCE = 4,              //Fu Jian
    GANSU_PROVINCE = 5,              //Gan Su
    GUANGDONG_PROVINCE = 6,              //Guang Dong
    GUANGXI_PROVINCE = 7,              //Guang Xi
    GUIZHOU_PROVINCE = 8,              //Gui Zhou
    HAINAN_PROVINCE = 9,              //Hai Nan 
    HEBEI_PROVINCE = 10,             //He Bei
    HENAN_PROVINCE = 11,             //He Nan 
    HEILONGJIANG_PROVINCE = 12,             //Hei Long Jiang
    HUBEI_PROVINCE = 13,             //Hu Bei
    HUNAN_PROVINCE = 14,             //Hu Nan
    JILIN_PROVINCE = 15,             //Ji Lin
    JIANGSU_PROVINCE = 16,             //Jiang Su
    JIANGXI_PROVINCE = 17,             //Jiang Xi
    LIAONING_PROVINCE = 18,             //Liao Ning
    NEIMENGGU_PROVINCE = 19,             //Nei Meng Gu
    NINGXIA_PROVINCE = 20,             //Ning Xia
    QINGHAI_PROVINCE = 21,             //Qing Hai
    SHANDONG_PROVINCE = 22,             //Shan Dong
    SHANXI_JIN_PROVINCE = 23,             //Shan Xi
    SHANXI_SHAN_PROVINCE = 24,             //Shaan Xi
    SHANGHAI_PROVINCE = 25,             //Shang Hai
    SICHUAN_PROVINCE = 26,             //Si Chuan
    TAIWAN_PROVINCE = 27,             //Tai Wan
    TIANJIN_PROVINCE = 28,             //Tian Jin
    XIZANG_PROVINCE = 29,             //Xi Zang
    XIANGGANG_PROVINCE = 30,             //HongKong
    XINJIANG_PROVINCE = 31,             //Xin Jiang
    YUNNAN_PROVINCE = 32,             //Yun Nan
    ZHEJIANG_PROVINCE = 33              //Zhe Jiang
}PROVINCE_CITY_IDX;

typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2];  /*Reserved*/
    DWORD dwCity; /*City, see to PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;

//Scene mode
typedef enum _SCENE_MODE_
{
    UNKOWN_SCENE_MODE = 0,            //Unknown
    HIGHWAY_SCENE_MODE = 1,            //High-speed outdoor scene mode
    SUBURBAN_SCENE_MODE = 2,            //Suburban scene mode
    URBAN_SCENE_MODE = 3,            //Urban scene mode
    TUNNEL_SCENE_MODE = 4             //High-speed tunnel scene mode 
}SCENE_MODE;
typedef enum _PRIDATA_RENDER
{
    RENDER_ANA_INTEL_DATA = 0x00000001,
    RENDER_MD = 0x00000002,
    RENDER_ADD_POS = 0x00000004,
    RENDER_ADD_PIC = 0x00000008,
    RENDER_FIRE_DETCET = 0x00000010,
    RENDER_TEM = 0x00000020,
    RENDER_TRACK_TEM = 0x00000040,
    RENDER_THERMAL = 0x00000080
}PRIDATA_RENDER;

typedef enum _THERMAL_FLAG
{
    THERMAL_FIREMASK = 0x00000001,
    THERMAL_RULEGAS = 0x00000002,
    THERMAL_TARGETGAS = 0x00000004
}THERMAL_FLAG;

typedef enum _FIRE_ALARM{
    FIRE_FRAME_DIS = 0x00000001,
    FIRE_MAX_TEMP = 0x00000002,
    FIRE_MAX_TEMP_POSITION = 0x00000004,
    FIRE_DISTANCE = 0x00000008
}FIRE_ALARM;

typedef enum _TEM_FLAG{
    TEM_REGION_BOX = 0x00000001,
    TEM_REGION_LINE = 0x00000002,
    TEM_REGION_POINT = 0x00000004
}TEM_FLAG;

typedef enum _TRACK_FLAG
{
    TRACK_PEOPLE = 0x00000001,
    TRACK_VEHICLE = 0x00000002
}TRACK_FLAG;

typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;   /* Enable virtual coil: 0- disable, 1- enable*/
    BYTE    byIsDisplay;  /* display virtual coil,0- disable, 1- enable*/
    BYTE    byLoopPos; //night loop position:0-up,1-down
    BYTE    bySnapGain; /*snap gain*/
    DWORD   dwSnapShutter; /*snap shutter*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate;
    NET_DVR_TRIGCOORDINATE struRes[5];
    BYTE    byTotalLaneNum; /*traffic lane 1*/
    BYTE    byPolarLenType;  /*Polar Len type, 0-disable; 1-Schneider Polar len*/
    BYTE    byDayAuxLightMode;  /*Day time aux Lighting, 0- disable; 1-LED; 2- Flash light*/
    BYTE    byLoopToCalRoadBright;  /*Traffic lane used for counting road brightness (Virtual coil) */
    BYTE    byRoadGrayLowTh;  /*Low threshold of road brightness, default:1*/
    BYTE    byRoadGrayHighTh;  /*High threshold of road brightness, default:140*/
    WORD    wLoopPosBias;  /*Loop position bias for Night mode,default: 30*/
    DWORD   dwHfrShtterInitValue;  /*Continuous exposure time, default:2000*/
    DWORD   dwSnapShtterInitValue;  /*Exposure time, default:500*/
    DWORD   dwHfrShtterMaxValue;  /*Max. Exposure time for multi-shot*/
    DWORD   dwSnapShtterMaxValue;  /*Max. Exposure time for snapshot*/
    DWORD   dwHfrShtterNightValue;  /*Exposure time for multi-shot at night: default: 3000*/
    DWORD   dwSnapShtterNightMinValue;  /*Min. Exposure time for multi-shot at night: default: 3000*/
    DWORD   dwSnapShtterNightMaxValue;  /*Max. Exposure time for multi-shot at night: default: 5000*/
    DWORD   dwInitAfe;  /*Gain, default:200*/
    DWORD   dwMaxAfe;  /*Max. Gain: default: 400*/
    WORD    wResolutionX; /* Resolution (horizontal)*/
    WORD    wResolutionY; /* Resolution (height)*/
    DWORD   dwGainNightValue; /*night gain:default:70*/
    DWORD   dwSceneMode; /*scene type, see SCENE_MODE */
    DWORD   dwRecordMode; /*record flag: 0-disable,1-enable*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*geolocation*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*trigger flag,0-car front;1-car end;2-car front and car end all*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*sensitive 1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM, *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD        dwSize;
    BYTE        byPlateEnable; //0- disable LPR 1- enable
    BYTE        byRes1[2];   //Reserved
    BYTE        byFrameFlip;    //Flip image 0- disable; 1- enable
    WORD        wFlipAngle;     //Flip angle: 0, 90, 180, 270
    WORD        wLightPhase;    //Phase, [0,  360]
    BYTE        byLightSyncPower;   //Power synchronize for the flash light, 0- disable; 1- enable
    BYTE        byFrequency;        //signal frequency
    BYTE        byUploadSDEnable;  //upload SD picture,0-no,1-yes
    BYTE        byPlateMode; //recognition mode:0-video trigger,1-IO trigger
    BYTE        byUploadInfoFTP; //UploadInfoFTP,0-no,1-yes
    BYTE        byAutoFormatSD; //Auto Format SD,0-no,1-yes
    WORD        wJpegPicSize; //Jpeg pic size[64-8196]
    BYTE        bySnapPicResolution;  //Snap Picture Resolution
    BYTE        byRes[55];
}NET_DVR_SNAPENABLECFG, *LPNET_DVR_SNAPENABLECFG;

/* ftp Upload*/
typedef struct
{
    DWORD    dwSize;
    DWORD    dwEnableFTP;             /*Enable FTP upload*/
    char    sFTPIP[16];                 /*FTP IP*/
    DWORD    dwFTPPort;                 /*FTP port number*/
    BYTE    sUserName[NAME_LEN];     /*User name*/
    BYTE    sPassword[PASSWD_LEN];     /*Password*/
    DWORD    dwDirLevel;     /*0 - Save in root directory, 1 - 1st directory, 2= 2nd directory*/
    WORD     wTopDirMode;     /* 1st directory, 0x1 = device name, 0x2 = device ID, 0x3 = device IP, 0x4=Monitor spot, 0x5= time (YM)Custom 0x=6, 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    WORD     wSubDirMode;     /* 2nd directory, 0x1 = channel name, 0x2 = Channel number, , 0x3= time (YMD) , 0x4=traffic lane number,Custom 0x=5, 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE    byEnableAnony; //anony enable,0-no,1-yes
    BYTE    byPicArchivingInterval;//Picture Archiving Interval[1~30]
    BYTE    byRes[22];
}NET_DVR_FTPCFG, *LPNET_DVR_FTPCFG;

/*Snapshot naming elements*/
#define PICNAME_ITEM_DEV_NAME         1        /*device name*/
#define PICNAME_ITEM_DEV_NO         2        /*Device ID*/
#define PICNAME_ITEM_DEV_IP         3        /*IP*/
#define PICNAME_ITEM_CHAN_NAME         4        /*channel name*/
#define PICNAME_ITEM_CHAN_NO         5        /*Channel number*/
#define PICNAME_ITEM_TIME             6        /*time*/
#define PICNAME_ITEM_CARDNO            7        /*card number*/
#define PICNAME_ITEM_PLATE_NO       8       /*license number*/
#define PICNAME_ITEM_PLATE_COLOR    9       /*license color*/
#define PICNAME_ITEM_CAR_CHAN       10      /*traffic lane*/
#define PICNAME_ITEM_CAR_SPEED      11      /*speed*/
#define PICNAME_ITEM_CARCHAN        12      /*monitor spot*/
#define PICNAME_ITEM_PIC_NUMBER     13      //picture number
#define PICNAME_ITEM_CAR_NUMBER     14      //car number
#define PICNAME_MAXITEM             15

#define PICNAME_ITEM_SPEED_LIMIT_VALUES    15 //Speed limit
#define PICNAME_ITEM_ILLEGAL_CODE          16 //illegal Code
#define PICNAME_ITEM_CROSS_NUMBER          17 //cross number
#define PICNAME_ITEM_DIRECTION_NUMBER      18 //direction number

typedef struct
{
    BYTE     byItemOrder[PICNAME_MAXITEM];
    BYTE     byDelimiter;         /*delimiter'_'*/
}NET_DVR_PICTURE_NAME, *LPNET_DVR_PICTURE_NAME;

//Naming rules 2013-09-27
#define PICNAME_ITEM_PARK_DEV_IP             1        /*Device IP*/
#define PICNAME_ITEM_PARK_PLATE_NO          2       /*Plate number*/
#define PICNAME_ITEM_PARK_TIME                 3        /*Park Time*/
#define PICNAME_ITEM_PARK_INDEX             4       /*Park Index*/
#define PICNAME_ITEM_PARK_STATUS            5       /*park status*/
#define PICNAME_ITEM_BUILDING_NUMBER        6       /*building number*/
#define PICNAME_ITEM_OUTDOOR_UNIT_ID        7       /*outdoor uint id*/
#define PICNAME_ITEM_UNLOCK_TYPE            8       /*unlock type*/
#define PICNAME_ITEM_DEVICE_NAME            9       //device name
#define PICNAME_ITEM_PERIOD_NO              10      //period no
#define PICNAME_ITEM_DEV_INDEX              11      //device index
#define PICNAME_PREFIX                      32      /*Pictrue Name Prefix*/
// 2013-09-27
typedef struct
{
    BYTE     byItemOrder[PICNAME_MAXITEM];
    BYTE     byDelimiter;                     /*delimiter'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //Pictrue Name Prefix                    
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

/* Serial port snapshot*/
typedef struct
{
    BYTE    byStrFlag;     /*serial port data start*/
    BYTE     byEndFlag;     /*data end*/
    WORD    wCardIdx;     /*card number start digit (relative)*/
    DWORD     dwCardLen;     /*card number length*/
    DWORD   dwTriggerPicChans;     /*Channel number, by bit. Count from the first bit, and 0x2 means channel NO.1*/
}NET_DVR_SERIAL_CATCHPIC_PARA, *LPNET_DVR_SERIAL_CATCHPIC_PARA;

//DVR snapshot
typedef struct
{
    DWORD    dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];     /*image parameter for each channel*/
    WORD    wBurstMode;                             /*snapshot trigger mode, 0x1=alarm in, 0x2=Motion 0x4=232, 0x8=485, 0x10=network*/
    WORD    wUploadInterval;                     /*snapshot upload interval (seconds) [0, 65535]*/
    NET_DVR_PICTURE_NAME     struPicNameRule;     /* snapshot naming rule */
    BYTE    bySaveToHD;         /*Save to HD*/
    BYTE    byRes1;
    WORD    wCatchInterval;         /*Snapshot interval (unit: ms) [0, 65535]*/
    BYTE    byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];     /* Snapshot number for each channel */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30];  /*Alarm linked snapshot channel*/
}NET_DVR_JPEGCFG_V30, *LPNET_DVR_JPEGCFG_V30;

//Reserved 
typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-not close,1-close
    BYTE   byLaneNo;//Lane No.
    BYTE   byChannel;//channel number
    BYTE   byRes[21]; //res
}NET_DVR_MANUALSNAP, *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG
{
    DWORD dwSize;
    BYTE byDefaultCHN[3];  /*Set short-form of province name*/
    BYTE byPlateOSD;     /*license snapshot: 0-disable , 1- enable*/
    BYTE bySendJPEG1;    /*Send JPEG snapshot 1:  0-disable , 1- enable*/
    BYTE bySendJPEG2;    /*Send JPEG snapshot 2:  0-disable , 1- enable*/
    WORD wDesignedPlateWidth;    /*license width*/
    BYTE byTotalLaneNum;   /*Traffic lane number*/
    BYTE byRes1;       /*Reserved*/
    WORD wRecognizedLane;  /*Recognized lane, represented by bit. Bit0: whether lane 1 is recognized or not, 0- no, 1- yes*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];   /*Traffic lane region*/
    DWORD dwRecogMode;  /*Recognition type,
                        bit0- Recognition direction: 0- from front,1- from back ;
                        bit1- Big plate of little plate: 0- small plate,1- big plate ;
                        bit2- Color recognition: 0- disable color recognition, when recognizing from back or recognizing small plate, 1- enable color recognition;
                        bit3- Agricultural car recognition: 0-disable,1-enable;
                        bit4- Blur recognition: 0-disable,1-enable;
                        bit5- Frame or scene location: 0-fram location,1-scene location;
                        bit6- Frame or scene recognition: 0-fram recognition,1-scene recognition;
                        bit7- Day or night: 0-Day,1-Night */
    BYTE  bySendPRRaw;           //Send raw picture:0-disable,1-enable
    BYTE  bySendBinImage;      //Send bin picture:0-disable,1-enable
    BYTE  byDelayCapture;  //snap delay,uint:frame
    BYTE  byUseLED;    //LED control:0-no,1-yes
    BYTE  byRes2[68];    //Reserved
}NET_DVR_SPRCFG, *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;    //Whether to open brightness compensation of license plate or not(default:open): 0-close, 1-open 
    BYTE byPlateExpectedBright;    //Expected brightness of license plate(default:50),range:[0, 100]
    BYTE byRes1[2];
    BYTE byTradeoffFlash;     //Whether to consider flashlight: 0 - no;  1 - yes(default); 
    //When flash works, if consider to weaken brightness compensation of flashlight, set it to 1, or to 0
    BYTE byCorrectFactor;     //Correct factor, range:[0, 100], default:50 (resume to default when cut tradeoff_flash)
    WORD wLoopStatsEn;  //Whether to count loop brightness, represented by bit, 0- no, 1- yes
    BYTE byPlcBrightOffset;
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

#define NET_DVR_GET_DEVICESTATECFG              1096   //Get current state parameters of device

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //Preview number
    WORD wFortifyLinkNum; //Fortify link number
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //User IP address of preview
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //User IP address of fortify
    DWORD dwVideoFrameRate;    //Frame rate:0-all; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;      //Resolution:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5(reserved),16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA (800*600),19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;      //Resolution of snap:0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5(reserved),16-VGA(640*480), 17-UXGA(1600*1200), 18-SVGA (800*600),19-HD720p(1280*720),20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //Stream type:0-major stream;1-minor stream
    BYTE byTriggerType; //Trigger mode:0-video trigger;1-normal trigger
    DWORD dwSDVolume;  //Volume of SD card
    DWORD dwSDFreeSpace; //Free space of SD card
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //State of magnetic vehicle detector: 0-unused;1-normal;2-exceptional 
    BYTE byDetectorLinkState; //Connection state of magnetic vehicle detector: 0-disconnected;1-connected 
    BYTE bySDStatus;    //SD state 0-activity,1-Dormancy,2-Abnormal, 3-no sd
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //Fortify level,0-no,1-level 1(high),2-level 2(middle),3-level 3(low)
    BYTE byRes2[116]; //Reserved
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//Coil distance, cm, [0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];    // Channel number of signal light
    BYTE  byCapSpeed;//Sign speed limit, unit: km/h, value range: [0,255]
    BYTE  bySpeedLimit;//Speed limit value, unit: km/h, value range:[0,255]
    BYTE  byTrafficDirection;//Traffic direction: 0-from east to west, 1-from west to east, 2-from south to north, 3-from north to south
    BYTE  byRes1; //Reserved
    WORD  wLoopPreDist;        /*Trigger delay distance,unit:dm*/
    WORD  wTrigDelay;             /*Trigger delay time,unit: ms*/
    BYTE  byRes[124];//Reserved
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;


//Signal lamp for anomaly detection
typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;
    //Absolute time,yyyymmddhhmmssxxx,e.g.20090810235959999  The last three for the number of milliseconds
    BYTE    byAbsTime[32];
    NET_DVR_IPADDR    struAlarmCamIP;//Alarm camera IP
    DWORD   dwPic1Len;     //Abnormal image 1 length
    DWORD   dwPic2Len;     //Abnormal image 2 length
    char    *pPic1Buffer;    //Superposition Lane
    char    *pPic2Buffer;    //Superposition Lamp
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize;
    DWORD         dwChannel;        //Channel    
    BYTE          byExternalDevType;// 0-Invalid value (reserved);1-Signal lamp;2-flash
    BYTE          byRes[63];
}NET_DVR_EXDEVDET_COND, *LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize;
    BYTE          byExternalDevStatus;// 0-Normal;1-Abnormal
    BYTE          byRes[63];
} NET_DVR_EXDEVDET_CFG, *LPNET_DVR_EXDEVDET_CFG;

/***************************** end *********************************************/

#define IPC_PROTOCOL_NUM      50   //max number of ipc protocol

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P parameters (level parameter)
    DWORD    dwTiltPos;    // T parameter (vertical parameters)
    DWORD    dwZoomPos;  // Z parameters (zoom parameters)
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;
#define MAX_ALERTLINE_NUM    8 //max number of alterline     

typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;
    BYTE bySex;
    BYTE byEyeGlass;
    //Capture images face age use, such as byAge 15, byAgeDeviation 1, and the actual age is between 14 - 16 face images
    BYTE byAge;//age
    BYTE byAgeDeviation;//deviation
    BYTE byRes0;
    BYTE byMask;
    BYTE bySmile;
    BYTE byFaceExpression;    /*FACE_EXPRESSION_GROUP_ENUM*/
    BYTE byRes1;
    BYTE byRes2;
    BYTE byHat; //hat
    BYTE byRes[4];
}NET_VCA_HUMAN_FEATURE, *LPNET_VCA_HUMAN_FEATURE;


typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;
    BYTE  byRed;
    BYTE  byGreen;
    BYTE  byBlue;
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE, *LPNET_DVR_OBJECT_FEATURE;


typedef union tagNET_DVR_ADVANCE_COND_UNION
{
    BYTE                  byLen[36];
    NET_VCA_HUMAN_FEATURE      struHumanFeature;
    NET_DVR_OBJECT_FEATURE     struObjectFeature;
}NET_DVR_ADVANCE_COND_UNION, *LPNET_DVR_ADVANCE_COND_UNION;

typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];
    DWORD dwPreTime;   /*Alarm ahead of time units: seconds*/
    DWORD dwDelayTime; /*Alarm delay time units: seconds*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;   //PTZ Info
    BYTE  byAdvanceType;//type,0-no use, 1-humu feature,2-object color
    BYTE  byRes1[3];
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;
    BYTE byRes[5604];
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND;

#define MAX_INTRUSIONREGION_NUM    8 //max number of intrusion region
typedef struct tagNET_DVR_INTRUSION_SEARCHCOND
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/];
    DWORD dwPreTime;   /*Alarm ahead of time units: seconds*/
    DWORD dwDelayTime; /*Alarm delay time units: seconds*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ Info
    BYTE  byAdvanceType;//type,0-no use, 1-humu feature,2-object color
    BYTE  byRes1[3];
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;
    BYTE byRes[5348];
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND;

typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //Face Polygon
    DWORD           dwPreTime;   //PreTime
    DWORD           dwDelayTime; //DelayTime
    BYTE byRes[5972];
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND;

typedef union tagNET_DVR_AREA_SMARTSEARCH_COND_UNION
{
    BYTE    byLen[6144];  //union Len
    BYTE    byMotionScope[64][96]; //Detect region: 96*64 macro blocks, 1-enable; 0-disable 
    NET_DVR_TRAVERSE_PLANE_SEARCHCOND struTraversPlaneCond; //Travers plane 
    NET_DVR_INTRUSION_SEARCHCOND struIntrusionCond; //Intrusion 
    NET_DVR_FACEDETECTION_SEARCHCOND struFaceSnapCond; //Face Snap
}NET_DVR_AREA_SMARTSEARCH_COND_UNION,
*LPNET_DVR_AREA_SMARTSEARCH_COND_UNION;
//Smart search 
typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE      byChan;                   //Channel number
    BYTE      bySearchCondType;       //Find Cond NET_DVR_AREA_SMARTSEARCH_COND_UNION's Index,     
    /*0-Detect region ,1-traverse plane search cond, 2-intrusion search cond*/
    WORD      wChan;                  //chan no,you can use this wchan replace byChan
    NET_DVR_TIME struStartTime;         //Recording start time
    NET_DVR_TIME struEndTime;         //Recording stop time
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //Find Cond
    BYTE  bySensitivity;                //sensitivity,  1- >80%,  2-40%~80%,  3-1%~40%
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM, *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{
    DWORD                   dwSize;
    NET_DVR_STREAM_INFO   struIDInfo;
    BYTE                   bySearchCondType;      //Find Cond NET_DVR_AREA_SMARTSEARCH_COND_UNION's Index,     
    /*0-Detect region ,1-traverse plane search cond, 2-intrusion search cond*/
    BYTE                  bySensitivity; //Detect sensitivity,1- >80%,  2-40%~80%,  3-1%~40%
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;
    BYTE   	              byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char           cStartTimeDifferenceH;   
    char           cStartTimeDifferenceM;   
    char           cStopTimeDifferenceH;    
    char           cStopTimeDifferenceM;    
    BYTE                  byRes2[251];
}NET_DVR_SMART_SEARCH_PARAM_V40, *LPNET_DVR_SMART_SEARCH_PARAM_V40;

typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;     //Motion detect start time
    NET_DVR_TIME struEndTime;    //event stop time
    BYTE   	     byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char  cStartTimeDifferenceH;  //Start time difference from device to UTC(Hour)
    char  cStartTimeDifferenceM;  //Start time difference from device to UTC(Minute)
    char  cStopTimeDifferenceH;  //Stop time difference from device to UTC(Hour)
    char  cStopTimeDifferenceM;  //Stop time difference from device to UTC(Minute)
    BYTE         byRes[59];           
}NET_DVR_SMART_SEARCH_RET, *LPNET_DVR_SMART_SEARCH_RET;

// IPSAN search directory
typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IPaddress
    WORD            wPort;      // IPSAN  port
    BYTE            byRes[10];  // 
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // Directory
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;

//DVR device parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];      //DVR name
    DWORD dwDVRID;                 //DVR ID //V1.4 (0- 99) ,  V1.5 (0- 255) 
    DWORD dwRecycleRecord;         //cycle record, 0-disable, 1-enable
    //Read-only
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    DWORD dwSoftwareVersion;             //Software version
    DWORD dwSoftwareBuildDate;             //Build, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;             //DSP Version: 16 high bit is the major version, and 16 low bit is the minor version
    DWORD dwDSPSoftwareBuildDate;         // DSP Build, 0xYYYYMMDD
    DWORD dwPanelVersion;                 // Front panel version
    DWORD dwHardwareVersion;     // Hardware version
    BYTE byAlarmInPortNum;         //DVR Alarm input
    BYTE byAlarmOutPortNum;         //DVR Alarm output
    BYTE byRS232Num;             //DVR 232 port number
    BYTE byRS485Num;             //DVR 485 port number
    BYTE byNetworkPortNum;         //Network port number
    BYTE byDiskCtrlNum;             //DVR HDD number
    BYTE byDiskNum;                 //DVR disk number
    BYTE byDVRType;                 //DVR type,  1: DVR 2: ATM DVR 3: DVS ......- - 
    BYTE byChanNum;                 //DVR channel number
    BYTE byStartChan;             //start Channel number, DVS- 1, DVR -  1
    BYTE byDecordChans;             //DVR decoding
    BYTE byVGANum;                 //VGA number 
    BYTE byUSBNum;                 //USB number
    BYTE byAuxoutNum;             //Aux output number
    BYTE byAudioNum;             //voice interface number
    BYTE byIPChanNum;             //Max. IP channel number 
    BYTE byZeroChanNum;             //Zero channel number
    BYTE bySupport;         //Ability set
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  compression ability set
    //bySupport & 0x8,  multiple network adapter
    //bySupport & 0x10, remote SADP
    //bySupport & 0x20  support Raid
    //bySupport & 0x40  support IPSAN
    //bySupport & 0x80, support RTP over RTSP
    BYTE byEsataUseage;         //Default E-SATA: 0- backup, 1- record
    BYTE byIPCPlug;             //0- disable plug-and-play, 1- enable plug-and-play
    BYTE byStorageMode;          //Hard Disk Mode:0-group,1-quota,2-drawframe,3-Auto
    BYTE bySupport1;          //Ability set
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2,support distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension 
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    WORD wDevType;//Device type
    BYTE  byDevTypeName[DEV_TYPE_NAME_LEN];//Device model name
    BYTE bySupport2; //The ability to set extension, bit 0 indicates does not support one expressed support for
    //bySupport2 & 0x1, Whether to support extended the OSD character overlay (terminal and capture machine expansion distinguish)
    BYTE byAnalogAlarmInPortNum; //Analog alarm in number
    BYTE byStartAlarmInNo;    //Analog alarm in Start No.
    BYTE byStartAlarmOutNo;  //Analog alarm Out Start No.
    BYTE byStartIPAlarmInNo;  //IP alarm in Start No.  0-Invalid
    BYTE byStartIPAlarmOutNo; //IP Alarm Out Start No.  0-Invalid
    BYTE byHighIPChanNum;     //Ip Chan Num High 8 Bit 
    BYTE byEnableRemotePowerOn;//enable the equipment in a dormant state remote boot function, 0- is not enabled, the 1- enabled
    WORD wDevClass; //device class 
    BYTE byRes2[6];    //res    
}NET_DVR_DEVICECFG_V40, *LPNET_DVR_DEVICECFG_V40;

//DVR device parameters
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NET_DEV_NAME_LEN];      //DVR name
    DWORD dwDVRID;                 //DVR ID //V1.4 (0- 99) ,  V1.5 (0- 255) 
    DWORD dwRecycleRecord;         //cycle record, 0-disable, 1-enable
    //Read-only
    BYTE sSerialNumber[SERIALNO_LEN];   //SN
    DWORD dwSoftwareVersion;             //Software version
    DWORD dwSoftwareBuildDate;             //Build, 0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;             //DSP Version: 16 high bit is the major version, and 16 low bit is the minor version
    DWORD dwDSPSoftwareBuildDate;         // DSP Build, 0xYYYYMMDD
    DWORD dwPanelVersion;                 // Front panel version
    DWORD dwHardwareVersion;     // Hardware version
    BYTE byAlarmInPortNum;         //DVR Alarm input
    BYTE byAlarmOutPortNum;         //DVR Alarm output
    BYTE byRS232Num;             //DVR 232 port number
    BYTE byRS485Num;             //DVR 485 port number
    BYTE byNetworkPortNum;         //Network port number
    BYTE byDiskCtrlNum;             //DVR HDD number
    BYTE byDiskNum;                 //DVR disk number
    BYTE byDVRType;                 //DVR type,  1: DVR 2: ATM DVR 3: DVS ......- - 
    BYTE byChanNum;                 //DVR channel number
    BYTE byStartChan;             //start Channel number, DVS- 1, DVR -  1
    BYTE byDecordChans;             //DVR decoding
    BYTE byVGANum;                 //VGA number 
    BYTE byUSBNum;                 //USB number
    BYTE byAuxoutNum;             //Aux output number
    BYTE byAudioNum;             //voice interface number
    BYTE byIPChanNum;             //Max. IP channel number 
    BYTE byZeroChanNum;             //Zero channel number
    BYTE bySupport;         //Ability set
    //bySupport & 0x1,  smart search
    //bySupport & 0x2,  backup
    //bySupport & 0x4,  compression ability set
    //bySupport & 0x8,  multiple network adapter
    //bySupport & 0x10, remote SADP
    //bySupport & 0x20  support Raid
    //bySupport & 0x40  support IPSAN
    //bySupport & 0x80, support RTP over RTSP
    BYTE byEsataUseage;         //Default E-SATA: 0- backup, 1- record
    BYTE byIPCPlug;             //0- disable plug-and-play, 1- enable plug-and-play
    BYTE byStorageMode;          //Hard Disk Mode:0-group,1-quota,2-drawframe
    BYTE bySupport1;          //Ability set
    // bySupport1 & 0x1, support snmp v30
    // bySupport1& 0x2,support distinguish download and playback
    //bySupport1 & 0x4, support deployment level
    //bySupport1 & 0x8, support vca alarm time extension 
    //bySupport1 & 0x10, support muti disks(more than 33)
    //bySupport1 & 0x20, support rtsp over http
    WORD wDevType;//Device type
    BYTE  byDevTypeName[NET_DEV_TYPE_NAME_LEN];//Device model name
    BYTE bySupport2; //The ability to set extension, bit 0 indicates does not support one expressed support for
    //bySupport2 & 0x1, Whether to support extended the OSD character overlay (terminal and capture machine expansion distinguish)
    BYTE byAnalogAlarmInPortNum; //Analog alarm in number
    BYTE byStartAlarmInNo;    //Analog alarm in Start No.
    BYTE byStartAlarmOutNo;  //Analog alarm Out Start No.
    BYTE byStartIPAlarmInNo;  //IP alarm in Start No.  0-Invalid
    BYTE byStartIPAlarmOutNo; //IP Alarm Out Start No.  0-Invalid
    BYTE byHighIPChanNum;     //Ip Chan Num High 8 Bit 
    BYTE byEnableRemotePowerOn;//enable the equipment in a dormant state remote boot function, 0- is not enabled, the 1- enabled
    BYTE byRes2[256];
}NET_DVR_DEVICECFG_V50, *LPNET_DVR_DEVICECFG_V50;
#define MAX_ZEROCHAN_NUM    16
//Zero Channel 
typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;             //Structure length
    BYTE  byEnable;             //0- Disable 0 channel encoding, 1-enable  0 channel encoding
    BYTE  byRes1[3];             //Reserved
    DWORD dwVideoBitrate;      //Video bit rate: 0- Reserved; 1- 16K (Reserved);  2- 32K; 3- 48k; 4- 64K; 5- 80K; 6- 96K; 7- 128K; 8- 160k; 9- 192K; 10- 224K; 11- 256K; 12- 320K
    // 13- 384K; 14- 448K; 15- 512K; 16- 640K; 17- 768K; 18- 896K; 19- 1024K; 20- 1280K; 21- 1536K; 22- 1792K; 23- 2048K
    //If the 31st digit is set as 1, then the 0- 30th digit stands for customized bit rate value (MIN- 32K MAX- 8192K) 
    DWORD dwVideoFrameRate;     //Frame rate 0- full;  1- 1/16;  2- 1/8;  3- 1/4;  4- 1/2;  5- 1;  6- 2;  7- 4;  8- 6;  9- 8;  10- 10;  11- 12;  12- 16;  13- 20,  //V2.0: 14- 15,  15- 18,  16- 22; 
    BYTE  byRes2[32];         //Reserved
}NET_DVR_ZEROCHANCFG, *LPNET_DVR_ZEROCHANCFG;

//0 Channel zooming
typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;                 //Structure length
    NET_VCA_POINT  struPoint;     //point
    BYTE byState;                 //status, 0- zoom in, 1- zoom out 
    BYTE byPreviewNumber;        //Live view, 0- 1 screen-split, 1- 4 screen-split, 2- 9 screen-split, 3- 16 screen-split (read-only)
    BYTE byPreviewSeq[MAX_WINDOW_V30]; //channel info (read-only)
    BYTE byRes[30];                 //Reserved 
}NET_DVR_ZERO_ZOOMCFG, *LPNET_DVR_ZERO_ZOOMCFG;

#define DESC_LEN_64 64
typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;             //Structure length
    BYTE    byEnable;             //0- disable SNMP, 1- enable SNMP
    BYTE    byRes1[3];             //Reserved
    WORD    wVersion;         //snmp version v1 = 1,  v2 =2,  v3 =3 (V3 is reserved)
    WORD    wServerPort;  //snmp port, default: 161
    BYTE    byReadCommunity[NAME_LEN];  //Read community, max: 31bytes, default: "public"
    BYTE    byWriteCommunity[NAME_LEN]; //Write community: max: 31 bytes, default:  "private"
    BYTE     byTrapHostIP[DESC_LEN_64];     //Trap host ip   
    WORD    wTrapHostPort;    // trap host port
    BYTE    byTrapName[NAME_LEN];
    BYTE    byRes2[70];         // Reserved
}NET_DVR_SNMPCFG, *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE    byUserName[NAME_LEN];
    BYTE    bySecLevel;                        // Secure level 0:reserved 1: no auth, 2: no Privacy auth, 3: Privacy auth
    BYTE    byAuthtype;                        // auth type 0: MD5 1: SHA; 2: none
    BYTE    byPrivtype;                        // private type 0: DES; 1: AES; 2: none;
    BYTE    byRes[5];
    BYTE    byAuthpass[PASSWD_LEN];
    BYTE    byPrivpass[PASSWD_LEN];
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

// snmpv30
typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD            dwSize;                        // Structure length
    BYTE            byEnableV1;                    //0-disable SNMP V1,1-enable SNMP V1
    BYTE            byEnableV2;                    //0-disable SNMP V2,1-enable SNMP V2
    BYTE            byEnableV3;                    //0-disable SNMP V3,1-enable SNMP V3
    BYTE            byRes1[3];
    WORD            wServerPort;                // snmp port, default: 161
    BYTE            byReadCommunity[NAME_LEN];    // Read community, max: 31bytes, default: "public"
    BYTE            byWriteCommunity[NAME_LEN];    // Write community: max: 31 bytes, default:  "private"
    BYTE             byTrapHostIP[DESC_LEN_64];    // Trap host ip    
    WORD            wTrapHostPort;                // trap host port
    BYTE            byRes2[2];                    // reserve
    NET_DVR_SNMPv3_USER    struRWUser;                // Read&Write user
    NET_DVR_SNMPv3_USER    struROUser;                // Read only user
    BYTE            byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

#define  PROCESSING          0     //on processing
#define  PROCESS_SUCCESS     100   //complete
#define  PROCESS_EXCEPTION   400   //processing exception
#define  PROCESS_FAILED      500   //processing failed
#define  PROCESS_QUICK_SETUP_PD_COUNT 501 //A configuration requires at least three idle hard disk

#define  SOFTWARE_VERSION_LEN 48
#define  NET_SDK_DEVICE_MODEL_LEN 24 //Device model length
typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;      // IP
    WORD            wPort;       // port number
    WORD            wFactoryType;    // manufacture
    char        chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char        chSerialNo[16];  // SN
    WORD       wEncCnt;        // Encoding channel number
    BYTE        byMACAddr[MACADDR_LEN];         // MAC
    NET_DVR_IPADDR  struSubDVRIPMask;    // DVR IP
    NET_DVR_IPADDR  struGatewayIpAddr;   // Gateway
    NET_DVR_IPADDR    struDnsServer1IpAddr;             /* IP of DNS1*/
    NET_DVR_IPADDR    struDnsServer2IpAddr;             /* IP of DNS2 */
    BYTE        byDns;
    BYTE        byDhcp;
    BYTE        szGB28181DevID[DEV_ID_LEN];  //GB28181 protocol access device for ID, IPC to GB28181 protocol access
    BYTE        byActivated;//0-invalid,1-activated,2-not activated
    BYTE        byDeviceModel[NET_SDK_DEVICE_MODEL_LEN/*24*/];//Device model
    BYTE        byRes[101];      // Reserved
}NET_DVR_SADPINFO, *LPNET_DVR_SADPINFO;

#define  MAX_SADP_NUM   256   // Max device number for searching
typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD               dwSize;    //  Structure size
    WORD                wSadpNum;    // detected device number
    BYTE                byRes[6];    // Reserved
    NET_DVR_SADPINFO    struSadpInfo[MAX_SADP_NUM];
}NET_DVR_SADPINFO_LIST, *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY, *LPNET_DVR_SADP_VERIFY;

/*******************************Backup begin********************************/

#define DESC_LEN_32          32   //description length
#define MAX_NODE_NUM         256  //node number

typedef struct tagNET_DVR_DESC_NODE
{
    int  iValue;
    BYTE  byDescribe[DESC_LEN_32];  //description
    DWORD  dwFreeSpace;            //unit:Mbps
    BYTE  byRes[12];               //Reserved  
}NET_DVR_DESC_NODE, *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{
    DWORD     dwSize;             //Structure length
    DWORD     dwNodeNum;          //ability node number
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];   //description  
}NET_DVR_DISKABILITY_LIST, *LPNET_DVR_DISKABILITY_LIST;

//backup process
#define BACKUP_SUCCESS                100  //complete
#define BACKUP_CHANGE_DEVICE          101  //backup device is full, change the device and contiue backup

#define BACKUP_SEARCH_DEVICE          300  //Search backup device
#define BACKUP_SEARCH_FILE            301  //Search recording files
#define BACKUP_SEARCH_LOG_FILE        302  //Search log files
#define BACKUP_CHANGE_DISK            303  //Replace disks

#define BACKUP_EXCEPTION              400  //Backup exception
#define BACKUP_FAIL                      500  //Backup failed

#define BACKUP_TIME_SEG_NO_FILE       501  //No recording files
#define BACKUP_NO_RESOURCE            502  //Not enough resource
#define BACKUP_DEVICE_LOW_SPACE       503  //NOt enough space on backup device
#define BACKUP_DISK_FINALIZED         504  //Backup disk finalized
#define BACKUP_DISK_EXCEPTION         505  //Backup disk exception
#define BACKUP_DEVICE_NOT_EXIST       506  //Backup disk not exist
#define BACKUP_OTHER_BACKUP_WORK      507  //Other backup on progress
#define BACKUP_USER_NO_RIGHT          508  //No user right
#define BACKUP_OPERATE_FAIL           509  //Operation failure
#define BACKUP_NO_LOG_FILE            510  //No log files


typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;    //File number
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM];  //File list
    BYTE byDiskDes[DESC_LEN_32];    //Backup disk
    BYTE byWithPlayer;       //Backup with player
    BYTE byContinue;    //Continue backup or not
    BYTE byRes[34];     //Reserved
}NET_DVR_BACKUP_NAME_PARAM, *LPNET_DVR_BACKUP_NAME_PARAM;

//Backup by time
typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;         //Channel number
    NET_DVR_TIME    struStartTime;    //Start time
    NET_DVR_TIME    struStopTime;     //End time
    BYTE byDiskDes[DESC_LEN_32];      //Backup disk
    BYTE byWithPlayer;                //0 not backup with player 1  backup with player
    BYTE byContinue;                  //0 not continue 1 continue
    BYTE            byDrawFrame;
    BYTE            byUseBackCfgParam;   //user backup cfg Param, 0-invalid,1-enable,2-disable
    DWORD           dwStreamType;
    BYTE            byRes[28];
}NET_DVR_BACKUP_TIME_PARAM, *LPNET_DVR_BACKUP_TIME_PARAM;

/********************************* end *******************************************/

typedef enum _COMPRESSION_ABILITY_TYPE_
{
    COMPRESSION_STREAM_ABILITY = 0,  //Stream type
    MAIN_RESOLUTION_ABILITY = 1,  //Main stream resolution
    SUB_RESOLUTION_ABILITY = 2,  //Sub stream resolution
    EVENT_RESOLUTION_ABILITY = 3,  //Event encoding resolution
    FRAME_ABILITY = 4,  //Frame rate capability set
    BITRATE_TYPE_ABILITY = 5,  //bit rate type capability set
    BITRATE_ABILITY = 6,  //Max. bit rate
    THIRD_RESOLUTION_ABILITY = 7,     //Third resolution ability
    STREAM_TYPE_ABILITY = 8,  //Stream type ability
    PIC_QUALITY_ABILITY = 9,  //Pic quality ability
    INTERVAL_BPFRAME_ABILITY = 10, //BP interval ability
    VIDEO_ENC_ABILITY = 11, //Video encode ability
    AUDIO_ENC_ABILITY = 12, //Audio encode ability
    VIDEO_ENC_COMPLEXITY_ABILITY = 13, //video encode complexity ability
    FORMAT_ABILITY = 14, //Video format ability
}COMPRESSION_ABILITY_TYPE;

//Capability
typedef struct tagNET_DVR_ABILITY_LIST
{
    DWORD     dwAbilityType;         // COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];            //Reserved
    DWORD     dwNodeNum;            //node number
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];   //Description 
}NET_DVR_ABILITY_LIST, *LPNET_DVR_ABILITY_LIST;

#define MAX_ABILITYTYPE_NUM  12   //Max. ability set

//Compression parameter capability set 
typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{
    DWORD     dwSize;             //Structure length
    DWORD     dwAbilityNum;         //capability  number
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM];  //description  
}NET_DVR_COMPRESSIONCFG_ABILITY, *LPNET_DVR_COMPRESSIONCFG_ABILITY;


/********************************9000RH begin****************************************/
#define SUPPORT_PD_NUM            16
#define SUPPORT_ARRAY_NUM        8
#define SUPPORT_VD_NUM            128
#define SUPPORT_PD_NUM_            16
#define SUPPORT_PD_NUM_PARTTWO    8


typedef enum tagRAID_MODE
{
    RAID0 = 1,
    RAID1,
    RAID10,
    RAID1E,
    RAID5,
    RAID6,
    RAID50,
    JBOD,
    RAID60
}RAID_MODE;

typedef enum tagHD_SUPPORT_TYPE
{
    HD_TYPE_SATA = 0x01,
    HD_TYPE_PATA = 0x02,
    HD_TYPE_SAS = 0x04,
    HD_TYPE_ATAPI = 0x08,
    HD_TYPE_TAPE = 0x10,
    HD_TYPE_SES = 0x20
}HD_SUPPORT_TYPE;

// 0-do not support; 1-support
typedef enum tagSUPPORT_RAID_TYPE
{
    RAID0_ABILITY = 0x0001,
    RAID1_ABILITY = 0x0002,
    RAID10_ABILITY = 0x0004,
    RAID1E_ABILITY = 0x0008,
    RAID5_ABILITY = 0x0010,
    RAID6_ABILITY = 0x0020,
    RAID50_ABILITY = 0x0040,
    JBOD_ABILITY = 0x0080,
    RAID60_ABILITY = 0x0100
}SUPPORT_RAID_TYPE;

// Physical HD
typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;          // HD slot 
    BYTE    byType;          // HD info; 0 -normal, 1-global hot-swap, 2- array hot-swap 3-raid array, 4-offline 5-Secondary normal  6-external 7-abnormal 8-SMART status abnormal 9-dormancy 10-have bad block 11-SMR harddisk not support raid,0xff-non-existent
    BYTE    byStatus;        // HD status;
    BYTE    byMode[40];    // HD type
    DWORD   dwHCapacity;     //  HD capacity (Highest 32bit) Unit:kb
    DWORD   dwLCapacity;     //   HD capacity (Lowest 32bit) 
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;           // Array ID
    BYTE    byArrayInformation;   //Contain array information: 0 no, 1 is.
    BYTE    byRes[101];          // Reserved  
}NET_DVR_PHY_DISK_INFO, *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_BASE_STATION_INFO_ALARM
{
    DWORD        dwSize;
    DWORD        dwChannel;//channel num
    char         sNetBarWaCode[16];//area num
    char         sCollectionEquipmentID[24];//dev num
    char         sMCC[4];//MCC
    char         sMNC[4];//MNC
    char         sLAC[36];
    char         sCI[36];
    char         sBSCI[36];
    char         sBCCH[36];
    char         sLEV[36];
    char         sCollectionEquipmentLongitude[12];
    char         sCollectionEquipmentLatitude[12];
    char         sCaptureTime[20];//time: yyyy-MM-dd hh:mm:ss
    BYTE         byRes[256];
}NET_DVR_BASE_STATION_INFO_ALARM, *LPNET_DVR_BASE_STATION_INFO_ALARM;


typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST, *LPNET_DVR_PHY_DISK_LIST;

typedef enum tagBGA_TYPE
{
    BGA_REBUILD = 0x01,     // Rebuild
    BGA_CONSISTENCY_FIX = 0x02,     //Consistency fix
    BGA_CONSISTENCY_CHECK = 0x04,     // Consistency check
    BGA_INIT_QUICK = 0x08,     // Fast init
    BGA_INIT_BACK = 0x10,     // Full init 
    BGA_MIGRATION = 0x20,     // Migration
    BGA_INIT_FORE = 0x40,     // Init
    BGA_COPYBACK = 0x80      // Copy back
}BGA_TYPE;

typedef enum tagBGA_STATE
{
    BGA_STATE_NONE = 0,      //  no bga task
    BGA_STATE_RUNNING,       //  bga is running
    BGA_STATE_ABORTED,       //  bga is aborted
    BGA_STATE_PAUSED       //  bga is pause   
}BGA_STATE;

typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;   // Background task
    BYTE    byBgaState;            /*FunctionReturn- - Background task status*/
    WORD    wBgaPercentage;      /*FunctionReturn- - Background task process in percentage, if it's 65535, pecentage is invalid */
    BYTE    byRes[4];   // Reserved
}NET_DVR_BGA_INFO, *LPNET_DVR_BGA_INFO;

// Array info
typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID;  // Array ID
    BYTE    byRaidMode;  //Please refer to RAID_MODE
    BYTE    byStatus;   // 0- on-line; 1- No HD; 2- off-line 
    DWORD   dwHCapacity;  // Array capacity (Highest 32 bit)
    DWORD   dwLCapacity;  // Array capacity (Lowest 32 bit)
    DWORD   dwHFreeSpace;    // Array free space  (Highest 32 bit)
    DWORD   dwLFreeSpace;    // Array free space  (Lowest 32 bit)
    BYTE    byArrayName[MAX_NAMELEN];  // Array name
    BYTE    byPDCount;   // Physical HD number
    BYTE    bySpareCount;    // Spare count
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];     // Physical HD index
    WORD    wSparePDSlots[SUPPORT_PD_NUM];     // Spare HD index
    NET_DVR_BGA_INFO    struBgaInfo;     // Background task status
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];   //If the value is 0, which indicates invalid 
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //If the value is 0, which indicates invalid 
    BYTE    byRes2[48];
}NET_DVR_ARRAY_INFO, *LPNET_DVR_ARRAY_INFO;

typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;      // Structure size
    DWORD   dwCount;     // Array number
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST, *LPNET_DVR_ARRAY_LIST;

//Virtual HD info
typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;     //Virtual HD slot
    BYTE    byStatus;  // Status: 0- normal 1- Demote 2- deleted 3- HD not found 4- off-line 5- sub-normal 6- foreign 7-Exception 0xff-not exist
    BYTE    byRaidMode;  // Please refer to RAID_MODE
    WORD    wArrayID;       // array ID
    BYTE    byRepair;   // Need repair  0 -don not need repair 1-need repair
    BYTE    byUsage;          //  0-IPSAN 1-FCSAN 2-DVR net disk 3-NAS 4-record volume
    BYTE    byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];     // virtual disk name
    DWORD   dwHCapacity;     // Virtual disk capacity (Highest 32 bit)
    DWORD   dwLCapacity;     //  Virtual disk capacity (lowest 32 bit)
    DWORD   dwHFreeSpace;    //  Virtual disk free space (Highest 32 bit)
    DWORD   dwLFreeSpace;    //  Virtual disk capacity (lowest 32 bit)
    NET_DVR_BGA_INFO    struBgaInfo;     // Background running status
    DWORD                dwBlockSize;    // block size
    NET_DVR_IPADDR        struWarrantIP;    // warrant ip
    char                szArrayGroup[NAME_LEN];     //Array group
    BYTE                byRes[20];
}NET_DVR_VD_INFO, *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;      // Structure size
    DWORD   dwCount;     // VD number
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];   //Virtual HD info
}NET_DVR_VD_LIST, *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION, *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD wVDSlot;
    BYTE  byAlloc;   // Allocated status
    BYTE    byRes[5];
    DWORD dwHVDSlotSize;     // Virtual disk space  (Highest 32 bit)
    DWORD dwLVDSlotSize;     //  Virtual disk space  (Lowest 32 bit)
}NET_DVR_VD_SLOT, *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;                         /*current number of slots in DG*/
    BYTE    byRes1[3];               // Reserved
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO, *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;     // Structure size
    NET_DVR_ADAPTER_VERSION struVersion;     // Adapter version
    BYTE    bySlotCount;     //Slot count
    BYTE    bySupportMigrate;   // Migrate (1- support  0- not support) 
    BYTE    bySupportExpand;    // Expand (1- support  0- not support) 
    BYTE    bySupportRebuild;   // Array rebuild  (1- support  0- not support) 
    WORD    wSlotSupportType;  //  HD_SUPPORT_TYPE
    WORD    wSupportRaidType;       // Support RAID type  
    BYTE    byAutoRebuild;       // Auto-rebuild 0-disable  1-enable
    BYTE    byRes[27];       // Reserved
}NET_DVR_RAID_ADAPTER_INFO, *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    BYTE    byRaidMode;      // RAID type
    BYTE    byPDCount;   // Physical HD number
    WORD    wArrayID;    // Array ID      
    WORD    wPDSlots[SUPPORT_PD_NUM]; // Physical disk 
    BYTE    byName[MAX_NAMELEN];   // array name
    BYTE    byInitMode;              //init mode
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];//Physical disk, If the value is 0, which indicates invalid 
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM, *LPNET_DVR_OPERATE_ARRAY_PARAM;


typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;         // Array ID
    BYTE    bySlot;         // Slot for virtual disk
    BYTE    byInitType;     // Type of initialization when creating virtual disk, 0 - fast initialization, 1 - full initialization in foreground, 2 - full initialization in background
    DWORD    dwHCapacity;     // Virtual disk capacity (Highest 32 bit)
    DWORD    dwLCapacity;     // Virtual disk capacity (Lowest 32 bit)
    BYTE    byName[MAX_NAMELEN];  // Virtual disk name
    BYTE    byRes2[16];           // Reserved 
}NET_DVR_OPERATE_VD_PARAM, *LPNET_DVR_OPERATE_VD_PARAM;


typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;         // Virtual disk slot
    WORD    wArrayID;        // Array
    BYTE    bySpareType;     // Spare type 1- global  2- array
    BYTE    byRes[7];        // Reserved
}NET_DVR_SPARE_DISK_PARAM, *LPNET_DVR_SPARE_DISK_PARAM;


/********************************9000RH End****************************************/

#define MATRIX_MAXDECSUBSYSTEMCHAN    4//Decoding system channel number of Video management system's 

//Linkage status for decoding sub system
typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE        byJoinStatus; //link status, 0- not linked, 1- linked
    BYTE        byJoinSubSystem; //linked sub system slot number
    BYTE        byJoinDispNum; // display channel number
    BYTE        byJoinSubWindowNum; //sub-window number
    BYTE        byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS, LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE    bySubSystemType; //sub-system type, 0- no sub-system, 1- decoding sub-system, 2- encoding sub-system
    BYTE    byRes1[3];
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub[MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE  byRes[8];
}NET_DVR_SINGLESUBSYSTEMJOININFO, LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM]; //80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V40
{
    BYTE   bySubSystemType;
    BYTE   byConnectStatus;
    BYTE   byMatrixNum;
    BYTE   bySubSystemNum;
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub[MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE   byBindStatus;
    BYTE   bySlotNum;
    BYTE   byDecodeAbility;
    BYTE   byUsedTrunk;
    BYTE   byRes[64];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V40, LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40;

//2010- 04- 13 NAT configuration
typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD                  dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2]; //NAT IP
    BYTE                byNATEnable; //0- disable NAT, not 0- enable NAT
    BYTE   byNATCfgMode; //NAT configuration mode, 0-manual, 1-auto
    BYTE   byRes[62];
}NET_DVR_NATASSOCIATECFG, *LPNET_DVR_NATASSOCIATECFG;

//2010- 06- 01 Video management system alarm
typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE     byEnableTemperatureAlarm; //Over temperature alarm: 0- disable, 1- enable
    BYTE     byRes1[3];
    int      iTemperatureUpLimited;     //2 digit after the decimal, i.e. 1234 stands for 12.34 degree
    int      iTemperatureDownLimited;
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;     /* handle mode */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];  /*Arm schedule*/
    BYTE     byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG, *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm; //hot-swap alarm,  0- disable, 1- enable
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;     /* handle mode */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];  /*Arm schedule*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG, *LPNET_DVR_BOARDALARMCFG;


typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD                          dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;
    NET_DVR_BOARDALARMCFG          struBoardAlarmCfg;
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM]; //Exception type: 0- fan 1- sub-system, 2- IP conflict, 3- network disconnect, 4- illegal access
    BYTE                         byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG, *LPNET_DVR_VIDEOPLATFORMALARMCFG;
//2010- 05- 17
typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD        dwSize;
    NET_DVR_IPADDR   struIP;         /*encoder IP*/
    WORD        wPort;         //port number
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];     /* user  */
    BYTE        sPassword[PASSWD_LEN];     /*password */
    BYTE        byChan; //encoder's Channel number
    BYTE        byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE, *LPNET_DVR_CODESPLITTERASSOCIATE;

//2010- 06- 01 Alarm upload for VMS
typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;       //Structure size
    BYTE   byAlarmType;     // 0- unplug sub-board , 1- plug sub-board , 2- temperature too high, 3- temperature too low, 4- fan exception, 5- sub-system exception 6- illegal access
    BYTE   byBoardNum;     //board number,start from 1,0xff-invalid
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8];  //sub-system channel number. There are 8 sub-system for the sub board     
    int    iTemperature;   //Temperature (valid when there is temperature alarm)
    BYTE   byMainboardSeq; // 1- main board, 2-else (valid when there is temperature alarm)
    BYTE   byRes2[3];
    BYTE   byFanSequence[32]; //Exception fan, byFanSequence[i] = 1,fan i+1 unnormal; byFanSequence[i] = 0, fan i+1 normal
    BYTE   byRes3[100];
}NET_DVR_VIDEOPLATFORM_ALRAMINFO, *LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

/*************************** Trial DVR begin *****************************/
#define MAX_INQUEST_PIP_NUM     3     //Picture-split number for the channel
#define MAX_INQUEST_CDRW_NUM    4     //Max. CD/DVD writer number
#define MAX_INQUEST_PIP_NUM_EX    16        //Picture-split number for the channel

typedef struct
{
    DWORD      dwSize;
    DWORD      dwNum;                        //CD/DVD writer number
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30]; // Select the CD/DVD writer
    DWORD      dwModeSelect;                 //0-cycle mode 1-Parallel mode (default) 
    BYTE       byRes[24];                    //Reserved
    DWORD       dwStartCDRW;                  //DVR local writing started
    DWORD      dwHdExcp;                     //HD exception
    DWORD       dwInterval;                   //Time interval, 0-10 min, 1- 20 min , 2- 30 min 
    char        sLable[64];                   //Disc number
}NET_DVR_INQUEST_CDRW_CFG, *LPNET_DVR_INQUEST_CDRW_CFG;

typedef struct
{
    char      sFileName[36];              //file name
    DWORD     dwFileLen;                  //file length
}NET_DVR_INQUEST_FILEINFO, *LPNET_DVR_INQUEST_FILEINFO;

typedef struct
{
    DWORD     dwFileNum;                      // Delete or copy file number, Max.20
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //For CD/DVD writing
    DWORD     dwCDIndex;                     //CD/DVD writer index : 1: 1st CD/DVD writer; 2: 2nd CD/DVD writer;  3: 3rd CD/DVD writer, 4: 4th CD/DVD writer, 5: all
    DWORD      bFinalizeDisc;                  // Finalize the CD/DVD after writing finished: 0-disable; 1-enable
}NET_DVR_INQUEST_FILES, *LPNET_DVR_INQUEST_FILES;

typedef struct {
    DWORD     dwEnable;            //0-Invalid,1-Valid    
    DWORD     dwStatus;            /* when dwType=0,
                                0-CD Normal, 1-No CD or CD Exception,
                                when dwType=1 or 2,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                4-Exception caused Inquest stop(81not support)
                                when dwType=3,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                when dwType=4,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space,
                                when dwType=5,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support)
                                when dwType=6 or 7,
                                0-Normal, 1-No CD or CD Exception,
                                2-CD is covered(81not support), 3-CD low space*/
    DWORD    dwVolumn;            //Disk volume, M
    DWORD    dwFreeSpace;        //Disk free space,M    
    DWORD    dwTimeLeft;     // Time left second
    BYTE          byCDType;         // cd type
    BYTE       byRes[3];
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct {
    DWORD    dwType;         /*State: 0-Inquest begin,
                             1-CD write while inquest, 2-Inquest stop,
                             3-Write inquest file,
                             4-Backup
                             5-Empty
                             6-Initialize hard disk
                             7-Resume inquest event*/
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];
    NET_DVR_TIME_EX            struInquestStartTime;        //Inquest start time
    BYTE                    byRes[16];
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;

typedef struct
{
    BYTE     byPipChan;               //channel of picture-in-picture mode, 0xFF-close
    BYTE     byRes[3];               //Reserved
    WORD     wTopLeftX;               //X coordinate of picture-in-picture 
    WORD     wTopLeftY;               //Y coordinate of picture-in-picture 
}NET_DVR_INQUEST_PIP_PARAM, *LPNET_DVR_INQUEST_PIP_PARAM;

typedef struct
{
    BYTE     byBaseChan;           //Display channel of picture-in-picture mode
    BYTE     byBackChan;           //Display background channel of picture-in-picture mode
    BYTE     byPIPMode;            //picture-in-picture mode,  0-disable; 1-enable
    BYTE     byRes;                //Reserved
    NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];   //position 
}NET_DVR_INQUEST_PIP_STATUS, *LPNET_DVR_INQUEST_PIP_STATUS;

typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*channel of picture-in-picture mode, 0xFF-close*/
    BYTE     byRes1[3];
    WORD     wTopLeftX;         /*X coordinate of picture-in-picture*/
    WORD     wTopLeftY;         /*Y coordinate of picture-in-picture*/
    WORD     wHeight;            /*Height coordinate of picture-in-picture*/
    WORD     wWidth;            /*Width oordinate of picture-in-picture*/
    BYTE     byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD    wLength;        //struct size 
    BYTE    byVersion;        /*High and low 4 respectively represent the high and low version,
                            subsequent editions and length to extend the length of the different versions of limit*/
    BYTE    byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD    struStructHead;
    BYTE             byBaseChan;     /*Display channel of picture-in-picture mode*/
    BYTE             byBackChan;     /*Display background channel of picture-in-picture mode*/
    BYTE             byPIPMode;      /*picture-in-picture mode, 0-disable
                                            1 one pictrue
                                            2 two pictrue
                                            3 three pictrue
                                            5 five picture
                                            7 seven pictrue
                                            255  close pictrue*/
    BYTE                         byPipCount;          /*pictrue count*/
    BYTE                        byPicShowMode;
    BYTE                        byRes[31];
    NET_DVR_INQUEST_PIP_PARAM_V40     strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*position*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct
{
    BYTE    sSecretKey[16];         //secrete key
    BYTE    byRes[64];              /*Reserved*/
}NET_DVR_INQUEST_SECRET_INFO, *LPNET_DVR_INQUEST_SECRET_INFO;

/***************************DVR end *****************************/
/********************************Interface Parameter Structure (end) *********************************/


/************************************************************************/
#define MAX_ALARMHOST_ALARMIN_NUM            512 //Max number of alarm host alarm input ports
#define MAX_ALARMHOST_ALARMOUT_NUM            512 //Max number of alarm host alarm output ports
#define ALARMHOST_MAX_AUDIOOUT_NUM            32  //Max number of alarm host audio output ports
#define ALARMHOST_MAX_ELECTROLOCK_NUM        32  //Max number of alarm host electric locks
#define ALARMHOST_MAX_MOBILEGATE_NUM        32  //Max number of alarm host mobile gate
#define ALARMHOST_MAX_SIREN_NUM             8   //Max number of sirens 
#define MAX_ALARMHOST_SUBSYSTEM             32// Max number of subsystem
#define ALARMHOST_DETECTOR_SERIAL_LEN       9    //Detector serial len
#define ALARMHOST_DETECTOR_SERIAL_LEN_V50       16   //Detector serial len V50
#define MAX_DETECTOR_NUM                    128
#define MAX_DETECTOR_NUM_V51        256
#define MAX_REPEATER_NUM        16
#define MAX_OUTPUT_MODULE_NUM        64
#define MAX_ELECTRIC_LOCK_NUM        64     
typedef enum tagSENSOR_TYPE
{
    SENSOR_TYPE_NONE = 0,        //None
    SENSOR_TYPE_TEMPERATURE = 1, //Temperature
    SENSOR_TYPE_HUMIDITY,       //Humidity
    SENSOR_TYPE_WINDSPEED,       //Wind speed
    SENSOR_TYPE_GAS,             //Gas
    SENSOR_AC_VOLTAGE,                // AC Voltage
    SENSOR_AC_CURRENT,                // AC Current
    SENSOR_DC_VOLTAGE,                // DC Voltage
    SENSOR_DC_CURRENT,                // DC Current
    SENSOR_WATER_PRESSURE,            // Water pressure
    SENSOR_PRESSURE_TRANSMITTER,    // Pressure transmitter
    SENSOR_FLOW_TRANSMITTER,        // Flow Transmitter
    SENSOR_WATER_LEAKAGE,            // Water leakage
    SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,    //Intergrated temerature detector
    SENSOR_ISOLATION_TEMPERATURE_DETECTOR,        //Isolation temperature detector
    SENSOR_RESIDUAL_CHLORINE,                    //Residual chlorine
    SENSOR_TYPE_AC_TERMINAL = 16,           //AC Terminal              
    SENSOR_TYPE_AC_SOCKET = 17,             //AC Socket
    SENSOR_TYPE_HUMITURE,                   //humiture
    SENSOR_TYPE_FLOW,                       //flow
    SENSOR_LIQUID_LEVEL,                    //liquid level
    SENSOR_TYPE_ARC,                        //electric arc
    SENSOR_TYPE_UNKNOW = 255     //Undefined
}SENSOR_TYPE;

typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD   dwSize;                  //Structure size
    BYTE    byName[NAME_LEN];       //Sensor name
    BYTE    byEnable;               //Enable or not 
    BYTE    byValid;                //Valid or not, sensor is normal or abnormal(read-only) 
    BYTE    byType;                 //Type
    BYTE    byAlarmMode;            //Alarm mode, five kinds: 15-HHHH, 14-HHHL, 12-HHLL, 8-HLLL, 0-LLLL,
    //that is, 1111(UP UP UP UP), 1110(UP UP UP DOWN), 1100(UP UP DOWN DOWN), 1000(UP DOWN DOWN DOWN), 0000(DOWN DOWN DOWN DOWN)
    float   fMeasureHigh;           //Upper limit of measuring range
    float   fMeasureLow;            //Lower limit of measuring range
    //Alarm limit 1-4, increases in turn
    float    fAlarm1;           //Alarm limit 1
    float    fAlarm2;           //Alarm limit 2
    float    fAlarm3;           //Alarm limit 3
    float    fAlarm4;           //Alarm limit 4
    DWORD   dwOsdCfg;          //Analog OSD, indicated by bit, 0-15 corresponds to video channel 1-16
    float    fSensitive;           //Sensitivity
    BYTE    bySensorStandard;    //Sensor standard,0- 0~20mA,1- 0~5V,2- 0~2.5Mpa,3- 0~1.6Mpa,4- 0~5m
    BYTE    byChan;                //sensor chan
    BYTE    byRes3[114];       // Reserved
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;             //Structure size
    BYTE    byName[NAME_LEN];   //Name
    WORD    wDelay;             //Output delay, unit: s, 0 means output all the time 0~5999
    DWORD   dwOverallEventJointSirenOn;    //Overall event joint siren on,every bit means a event type,bit0-Tamper Alarm, bit1-overall keypad emergency alarm, bit2-AC power off,bit3-Low battery voltage,bit4-The phone off line,bit5-The wired network anomaly,bit6-Wireless network anomaly,bit7-Keyboard 485 break  ,bit8- WIFI fault,bit9-RF signal fault
    DWORD    dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//subsystem event joint siren on,every bit means a event type, the array index is subsystem no,bit0-Emergency Keypad Alarms
    BYTE    byRes2[448];
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD    dwSize;            //Structure size
    BYTE    byEnable;        //0- open, 1- shutdown
    BYTE    byMode;            //Air conditioning mode
    BYTE    byTemperature;    //Temperature, general value is 16-30
    BYTE	byAirConditionNo;	// air Number
    BYTE    byRes[8];        //Reserved
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;

typedef struct tagNET_DVR_PUSHMODEPARAM
{
    BYTE byUdpPreviewMode;
    BYTE byVoiceWorkMode;
    BYTE byRes[18];
}NET_DVR_PUSHMODEPARAM, *LPNET_DVR_PUSHMODEPARAM;

typedef enum tagDETECTOR_TYPE
{
    PANIC_BUTTON = 0,               //Panic button
    MAGNETIC_CONTACT,               //Magnetic contact
    SMOKE_DETECTOR,                 //Smoke detector
    ACTIVE_INFRARED_DETECTOR,       //Active infrared detector 
    PASSIVE_INFRARED_DETECTOR,      //Passive infrared detector 
    GLASS_BREAK_DETECTOR,           //Glass break detector
    VIBRATION_DETECTOR,             //Vibration detector
    DUAL_TECHNOLOGY_PIR_DETECTOR,   //Dual technology motion detector
    TRIPLE_TECHNOLOGY_PIR_DETECTOR, //Triple technology detector
    HUMIDITY_DETECTOR,              //Humidity detector
    TEMPERATURE_DETECTOR,           //Temperature detector
    COMBUSTIBLE_GAS_DETECTOR,       //Combustible gas detector
    DYNAMIC_SWITCH,                    //dynamic switch
    CONTROL_SWITCH,                    //control switch
    SMART_LOCK,                        //smart lock
    WATER_DETECTOR,                 //water detector
    DISPLACEMENT_DETECTOR,      //displacement detector
    SINGLE_INFRARED_DETECTOR,    //sigle infrared detector
    SINGLE_ZONE_MODULE,    //single zone
    CURTAIN_INFRARED_DETECTOR,   //curtain infrared detector19
    UNKNOWN,//unknown20
    DOORBELL_SWITCH = 21,              //door bell switch 21
    MEDICAL_HELP_BUTTON,			//medical help button
    OUTDOOR_DUAL_TECH,				//the sensor of detecting inside and outside

    OTHER_DETECTOR = 0xffff         //Other detector 
}DETECTOR_TYPE;

typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; //see to DETECTOR_TYPE
    BYTE    byType;        //Alarm in type,0: immediately alarm in,1-24hour audible alarm in,2-delay alarm in ,3-inside alarm in,4-key alarm in 5-Fire alarm in 6-perimeter Alarm in 7. 24-hour silent alarm in 8-24 hour auxiliary alarm in,9-24hour vibration alarm in,10 - door emergency open protection zones, 11 - door emergency shutdown protection zones,12-time out zone,13-emergency zone, 0xff - no Alarm in
    BYTE    byUploadAlarmRecoveryReport;    //upload alarm recovery report,0-no,1-yes      
    DWORD    dwParam;       //Area parameter, the delay time of delay area 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*Time period of fortification*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //Alarm output channel associated with the alarm input
    BYTE    byAssociateSirenOut[8];        //Siren output, subscript 0 means siren NO.1, the value equals to 1 means output, 0 means not output
    BYTE    bySensitivityParam;//Sensitivity parameter, 0-10ms,1-250ms,2-500ms,3-750ms
    BYTE    byArrayBypass; //0-not support bypass,1-support bypass
    BYTE    byJointSubSystem; //subsystem no. this parameter can not be set 
    BYTE    byModuleStatus;    //Module status 1-on-line 2-off-line
    WORD    wModuleAddress;    //Module address,external module from 0 to 255,0xFFFF means invalid
    BYTE    byModuleChan;    //Module Channel,Max number is decide by the module type,0xFF means invalid
    BYTE    byModuleType;   //Module type,1-local zone,2-single zone,3-double zone,4-8 zone,5-8 sensor zone, 6-1Zone&Trigger 7-1 door controller 8-2 doors controller 9-4 doors controller 11-keyboard 12-8ZoneWired 13-ExtendedZone
    WORD    wZoneIndex;        //zone no.       this parameter can not be set
    WORD    wInDelay;      //delay in,0-255s
    WORD    wOutDelay;    //delay out,0-255s
    BYTE    byAlarmType;     //Alarm type 0- is invalid, 1- 2- normally open, normally close
    BYTE    byZoneResistor;    // 0-invalid 1--2.2 ,2--3.3,3--4.7,4--5.6 , 5--8.2 ,0xff--manual
    float    fZoneResistorManual;
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //detector serial number,read only
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDisableDetectorTypeCfg;    //0-enable,1-disable
    BYTE    byTimeOutRange;      // time out range,0:1-599s,1:1-65535s
    BYTE    byAssociateLampOut[8];//   array-0 represents lamp-1, value-1:output, value-0:do not output
    WORD   wTimeOut;  //time out(second)
    BYTE    byDetectorSignalIntensity;      // detector signal intensity(read only),0-100
    BYTE    byTimeOutMethod;    //Time out zone record time method:0-trigger,1-recovery
    BYTE    byRes3[8];
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; //see to DETECTOR_TYPE
    BYTE    byType;        //Alarm in type,0: immediately alarm in,1-24hour audible alarm in,2-delay alarm in ,3-inside alarm in,4-key alarm in 5-Fire alarm in 6-perimeter Alarm in 7. 24-hour silent alarm in 8-24 hour auxiliary alarm in,9-24hour vibration alarm in, 12-time out zone,13-emergency zone,14-fuel gas zone,0xff-no Alarm in
    BYTE    byUploadAlarmRecoveryReport;    //upload alarm recovery report,0-no,1-yes      
    DWORD    dwParam;       //Area parameter, the delay time of delay area 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*Time period of fortification*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //Alarm output channel associated with the alarm input
    BYTE    byAssociateSirenOut[8];        //Siren output, subscript 0 means siren NO.1, the value equals to 1 means output, 0 means not output
    BYTE    bySensitivityParam;//Sensitivity parameter, 0-10ms,1-250ms,2-500ms,3-750ms
    BYTE    byArrayBypass; //0-not support bypass,1-support bypass
    BYTE    byJointSubSystem; //subsystem no. this parameter can not be set 
    BYTE    byModuleStatus;    //Module status 1-on-line 2-off-line
    WORD    wModuleAddress;    //Module address,external module from 0 to 255,0xFFFF means invalid
    BYTE    byModuleChan;    //Module Channel,Max number is decide by the module type,0xFF means invalid
    BYTE    byModuleType;    //Module type,1-local zone,2-single zone,3-double zone,4-8 zone,5-8 sensor zone, 6-1Zone&Trigger, 11-keyboard 12-8ZoneWired 13-ExtendedZone
    WORD    wZoneIndex;        //zone no.       this parameter can not be set
    WORD    wInDelay;      //delay in,0-255s
    WORD    wOutDelay;    //delay out,0-255s
    BYTE    byAlarmType;     //Alarm type 0- is invalid, 1- 2- normally open, normally close
    BYTE    byZoneResistor;    // 0-invalid 1--2.2 ,2--3.3,3--4.7,4--5.6 , 5--8.2 ,0xff--manual
    float    fZoneResistorManual;
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN_V50]; //detector serial number,read only
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDisableDetectorTypeCfg;    //0-enable,1-disable
    WORD   wTimeOut;  //time out,second
    BYTE    byAssociateLampOut[8];//     array-0 represents lamp-1, value-1:output, value-0:do not output
    BYTE    byVoiceFileName[32];   //audio file name
    BYTE    byTimeOutRange;      // time out range,0:1-599s,1:1-65535s
    BYTE    byDetectorSignalIntensity;      // detector signal intensity(read only),0-100
    BYTE    byTimeOutMethod;    //Time out zone record time method:0-trigger,1-recovery
    BYTE    byAssociateFlashLamp;//associate flash lamp:0-invalid,1-not output,2-output
    BYTE    byStayAwayEnabled;//stay away enabled:0-invalid,1-disable,2-enable
    BYTE    bySilentModeEnabled;//silent mode enabled:0-invalid,1-disable,2-enable
    BYTE    byRelativeChannel[RELATIVE_CHANNEL_LEN];//Relative channel No,0-invalid
    BYTE    byDetectorVersion[VERSION_INFO_LEN];   //detector version,read only
    BYTE    byDetectorMAC[MACADDR_LEN];    //detector MAC,read on
    BYTE    byLinkageAlarmType;    //LinkageAlarmType:1-FireAlarm,2-supervise,3-linkage,4-shield,5-abnormal
    BYTE    byRes3[465];
}NET_DVR_ALARMIN_PARAM_V50, *LPNET_DVR_ALARMIN_PARAM_V50;

#define MAX_MAX_ALARMIN_NUM            64    /* Maximum number of sectors */
typedef    struct tagNET_DVR_MULTI_ALARMIN_COND
{
    DWORD    dwSize;
    int        iZoneNo[MAX_MAX_ALARMIN_NUM];    //sector number
    BYTE    byRes[256];
}NET_DVR_MULTI_ALARMIN_COND, *LPNET_DVR_MULTI_ALARMIN_COND;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM
{
    DWORD   dwSize;
    WORD    wZoneNo;        //sector number
    BYTE    byJointSubSystem; //subsystem number of sectors
    BYTE    byType;            //sector type
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //Enter the time delay, 0-255 seconds 
    WORD    wOutDelay;        //Leave the time delay, 0-255 seconds 
    BYTE    byAlarmType;    //Alarm type
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //detector serial number,read only
    BYTE    byDisableDetectorTypeCfg;    //0-enable,1-disable
    BYTE    byTimeOutRange;      // time out range,0:1-599s,1:1-65535s
    BYTE    byDetectorSignalIntensity;      // detector signal intensity(read only),0-100
    WORD   wTimeOut;  //time out,second
    BYTE    byTimeOutMethod;    //Time out zone record time method:0-trigger,1-recovery
    BYTE    byAssociateFlashLamp;//associate flash lamp:0-invalid,1-not output,2-output
    BYTE    byStayAwayEnabled;//stay away enabled:0-invalid,1-disable,2-enable
    BYTE    bySilentModeEnabled;//silent mode enabled:0-invalid,1-disable,2-enable
    BYTE    byRes3[110];
}NET_DVR_SINGLE_ALARMIN_PARAM, *LPNET_DVR_SINGLE_ALARMIN_PARAM;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    WORD    wZoneNo;        //sector number
    BYTE    byJointSubSystem; //subsystem number of sectors
    BYTE    byType;            //sector type
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //Enter the time delay, 0-255 seconds 
    WORD    wOutDelay;        //Leave the time delay, 0-255 seconds 
    BYTE    byAlarmType;    //Alarm type
    BYTE    byZoneSignalType;    //0-wired zone,1-wireless zone
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //detector serial number,read only
    BYTE    byDisableDetectorTypeCfg;    //0-enable,1-disable
    BYTE    byTimeOutRange;      // time out range,0:1-599s,1:1-65535s
    BYTE    byDetectorSignalIntensity;      // detector signal intensity(read only),0-100
    WORD   wTimeOut;  //time out,second
    BYTE    byTimeOutMethod;    //Time out zone record time method:0-trigger,1-recovery
    BYTE    byAssociateFlashLamp;//associate flash lamp:0-invalid,1-not output,2-output
    BYTE    byStayAwayEnabled;//stay away enabled:0-invalid,1-disable,2-enable
    BYTE    bySilentModeEnabled;//silent mode enabled:0-invalid,1-disable,2-enable
    BYTE    byRes3[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE    byRes2[128];
}NET_DVR_SINGLE_ALARMIN_PARAM_V50, *LPNET_DVR_SINGLE_ALARMIN_PARAM_V50;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST
{
    DWORD    dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM    struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST, *LPNET_DVR_ALARMIN_PARAM_LIST;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST_V50
{
    DWORD	dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM_V50	struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE	byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST_V50, *LPNET_DVR_ALARMIN_PARAM_LIST_V50;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             //Structure size
    BYTE    byName[NAME_LEN];   //Name
    WORD    wDelay;             //Output delay, unit: s, 0 means output all the time
    WORD    wTriggerIndex;        //trigger no. this parameter can not be set 
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //Alarm input channel followed by siren(multi alarm inputs trigger one siren output)
    //Subscript 0 means alarm input 1, 0- not follow, 1- follow
    BYTE    byModuleType;    //trigger type,1-local trigger, 2-4-way trigger ,3 8-way trigger, 4-1Zone&trigger , 5-32Trigger, 6-1 door controller 7-2 doors controller 8-4 doors controller,9-two way trigger,10-keyboard,11-extended trigger
    BYTE    byModuleStatus;    //Trigger status 1 on-line 2-off-line
    WORD    wModuleAddress;    //Trigger address,0~255,0xFFFF means invalid
    BYTE    byModuleChan;    //channel no. of trigger,0xFF means invalid
    BYTE    byWorkMode;        //work mode,1-linkage,2-dynamic
    BYTE    byAlarmOutMode;    //alarmout,1-none pulse,2-pulse
    BYTE    byTimeOn;        //time on 1~60s
    BYTE    byTimeOff;        //time off 1~60s
    BYTE    byDurationConstOutputEnable; //
    BYTE       byRes2[50];
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//Alarm input channel, subscript 0 corresponds to channel NO.1
    BYTE byRes[100];//Reserved
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];   //Arming status of alarm input port(support to query max 512 alarm input ports), 0- disarmed, 1- armed
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];      //Alarm status of alarm input port(support to query max 512 alarm input ports), 0- without alarm, 1- with alarm
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];    //Status of alarm output port(support to query max 512 alarm output ports), 0- without alarm, 1- with alarm
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];       //Bypass status
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //subsystem status, 0-close state,1-setup state
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];// fault status of alarm in. 0-Noarmal status,1-Fault status
    BYTE   byRes[56];
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM];
    BYTE   byRes[448];
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V51
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/];
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM];
    BYTE   bySubSystemAlarm[MAX_ALARMHOST_SUBSYSTEM];
    BYTE   byAlarmOutCharge[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byAlarmInShieldedStatus[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE   byAlarmOutLinkage[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE   byRes[512];
}NET_DVR_ALARMHOST_MAIN_STATUS_V51, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V51;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    //Siren output status, 0- in the status without alarm, 1- in the status with alarm
    BYTE   byRes[92];             // Reserved
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V50
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];
    BYTE   byDetetorPower[MAX_DETECTOR_NUM];
    BYTE   byDetetorConnection[MAX_DETECTOR_NUM];
    BYTE   bySirenPower[ALARMHOST_MAX_SIREN_NUM];
    BYTE   bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM];
    BYTE   byPowerStausEnabled[MAX_DETECTOR_NUM / 8];
    BYTE   byDetetorPowerStatus[MAX_DETECTOR_NUM / 8];
    BYTE   byDetetorPowerType;
    BYTE   byRes[975];
}NET_DVR_ALARMHOST_OTHER_STATUS_V50, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V50;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V51
{
    DWORD  dwSize;
    //for DS-PEA,array subscript0-alarm lamp status,1-electric lock status,2-siren status
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    //Siren output status, 0- in the status without alarm, 1- in the status with alarm
    BYTE   byDetetorPower[MAX_DETECTOR_NUM_V51];   //0-100,low power when less than 20
    BYTE   byDetetorConnection[MAX_DETECTOR_NUM_V51];   //0-unregedited,1-offline, 2-online
    BYTE   bySirenPower[ALARMHOST_MAX_SIREN_NUM];
    BYTE   bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM];
    BYTE   byPowerStausEnabled[MAX_DETECTOR_NUM_V51 / 8];
    BYTE   byDetetorPowerStatus[MAX_DETECTOR_NUM_V51 / 8];
    BYTE   byDetetorPowerType;
    BYTE   byRes2[3];
    BYTE   byRepeaterStatus[MAX_REPEATER_NUM];
    BYTE   byRepeaterTamperStatus[MAX_REPEATER_NUM / 8];
    BYTE   byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM / 8];
    BYTE   byOutputModuleTamperStatus[MAX_OUTPUT_MODULE_NUM / 8];
    BYTE    byElectricLockStatus[MAX_ELECTRIC_LOCK_NUM]; 
    BYTE    byRes[274]; 
}NET_DVR_ALARMHOST_OTHER_STATUS_V51, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V51;

//Enable status configuration
typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//Enable audio output or not, 0- disable, 1- enable
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//Enable electronic lock or not, 0- disable, 1- enable
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//Enable mobile gateway or not, 0- disable, 1- enable
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//Enable siren or not, 0- disable, 1- enable
    BYTE  bySerialPurpose;//Serial purpose, 0- used to cascade with alarm host, 1- used to PTZ control
    BYTE  byRes[63];
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;                    //Structure size
    WORD    wTotalAlarmInNum;       //Total number of alarm input ports(alarm areas), including cascade
    WORD    wLocalAlarmInNum;       //Total number of local alarm input ports
    WORD    wExpandAlarmInNum;      //Total number of expandable alarm input ports
    WORD    wTotalAlarmOutNum;      //Total number of alarm output ports(supported by device)
    WORD    wLocalAlarmOutNum;      //Total number of local alarm output ports
    WORD    wExpandAlarmOutNum;     //Total number of expandable alarm output ports
    WORD    wTotalRs485Num;         //Total number of RS-485 ports(supported by device)
    WORD    wLocalRs485Num;         //Total number of local RS-485 ports
    WORD    wExpandRs485Num;        //Total number of expandable RS-485 ports
    WORD    wFullDuplexRs485Num;    //Total number of full duplex RS-485 ports
    WORD    wTotalSensorNum;        //Total number of analog(supported by device)
    WORD    wLocalSensorNum;        //Total number of local analog
    WORD    wExpandSensorNum;       //Total number of expandable local analog
    WORD    wAudioOutNum;            //Total number of audio outputs
    WORD    wGatewayNum;            //Total number of mobile gateways
    WORD    wElectroLockNum;        //Total number of electronic locks
    WORD    wSirenNum;                 //Total number of sirens
    WORD    wSubSystemNum;            //Total number of divided subsystems
    WORD    wNetUserNum;            //Total number of network users
    WORD    wKeyboardNum;            //Total number of keyboard
    WORD    wOperatorUserNum;       //Total number of operator users

    BYTE    bySupportDetector;        //Is support detector,1-support,0-not support
    BYTE    bySupportSensitivity;   //Is support sensitivity,1-support,0-not support
    BYTE    bySupportArrayBypass;   //Is support array Bypass,1-support,0-not support
    BYTE    bySupportAlarmInDelay;  //Is support alarm in delay,1-support,0-not support
    BYTE    bySupportAlarmInType[16];//Alarm in type,0: immediately alarm in,1-24hour audible alarm in,2-delay alarm in ,3-inside alarm in,4-key alarm in 5-Fire alarm in 6-perimeter Alarm in 7. 24-hour silent alarm in 8-24 hours auxiliary sectors, 9-24 hours vibration protection zones, 10 - door emergency open protection zones, 11 - door emergency shutdown protection zones  15-no
    BYTE    byTelNum;                //Total number of telephone
    BYTE    byCenterGroupNum;        //Total number of center group number
    BYTE    byGPRSNum;                //Total number of GPRS number ,the max number is 4
    BYTE    byNetNum;                //Total number of net number ,the max number is 4
    BYTE    byAudioNum;                //Total Audio number
    BYTE    by3GNum;                //Total 3G module number
    BYTE    byAnalogVideoChanNum;    //Channel number of analog video.
    BYTE    byDigitalVideoChanNum;        //Channel number of digital video.
    BYTE    bySubSystemArmType;        //arm type of subsystem,0-not support,1-support.bit0-normal arm,bit1-Quick arm,bit2-stay arm.    
    BYTE    byPublicSubSystemNum;    //Public subsystem number
    DWORD    dwSupport1;    //0-not support,1-support
    // bit0:    event cause alarm out open
    // bit1:    event cause alarm out close
    // bit2:    subsystem enable
    // bit3;    ZONE arm
    // bit4;    auto arm and disarm
    // bit5:    fault cause sound output
    // bit6:    ZONE code
    // bit7:    trigger code
    // bit8:    search fault status
    // bit9:    subsystem external config
    // bit12:   support LED screen config
    // bit13:   support fault link LED
    DWORD    dwSubSystemEvent;        //subsystem event,bit0-enter delay time,bit1-exit delay time,bit2-arm,bit3-disarm,bit4-alarm, bit5-clear alarm
    DWORD    dwOverallEvent;            //overall event,0- not support, 1-support,,bit0-AC outage,bit1-low voltage of battery,bit2-telephone off_line,bit3-network abnormal,bit4-Wireless network abnormal
    DWORD    dwFaultType;            //fault type,0- not support, 1-support, bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormal
    BYTE    byPublicSubsystemAssociateSubsystemNum;    //number of associate subsystem by public subsystem
    BYTE    byOverallKeyboard;
    WORD    wSafetyCabinSupport; //safety cabin ablity,0-not support,1-support    
    //bit0: work mode config
    //bit1: person signal sensor config
    //bit2: curtain sensor config
    //bit3: infrared sensor
    //bit4: safety cabin using time out config
    BYTE    by485SlotNum;        //  485 slot number
    BYTE    bySubSystemAttributeAbility;    //forbid No.1-subsystem enable closed
    WORD    wKeyboardAddrNum;      // keyboard address num
    BYTE     byAlarmLampNum;         //alarm lamp num
    BYTE    byRes[117];            //  res    
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-not all,1-all
    BYTE        byres[3];
    BYTE        byIndex[256];            //485 chan
    BYTE           byRes[64];      //res
}NET_DVR_485LIST_INFO, *LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-not all,1-all
    BYTE        byres[3];
    BYTE        byIndex[256];            //485 chan
    BYTE           byRes[64];      //res
}NET_DVR_485_SLOT_LIST_INFO, *LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 //Structure size
    BYTE    sDeviceName[NAME_LEN];  //Front-end device name 
    WORD    wDeviceType;            //Device type, get from NET_DVR_GetDeviceTypeList
    WORD    wDeviceProtocol;        //Device protocol, got from protocol list    
    DWORD   dwBaudRate;             //Baud rate(bps), 0- 50, 1- 75, 2- 110, 3- 150, 4- 300, 5- 600, 6-1200, 7- 2400, 
    //8- 4800, 9- 9600, 10- 19200, 11- 38400, 12- 57600, 13- 76800, 14-115.2k 
    BYTE    byDataBit;              //Data bit: 0- 5 bit, 1- 6 bit, 2- 7 bit, 3- 8 bit 
    BYTE    byStopBit;              //Stop bit: 0- 1 bit, 1- 2bit 
    BYTE    byParity;               //Parity or not: 0- no parity, 1- odd parity, 2- even parity 
    BYTE    byFlowcontrol;          //Flow control or not: 0- none, 1- soft flow control, 2- hard flow control 
    BYTE    byDuplex;                //0 - half-duplex, 1- full-duplex, only channel no.1 supports full duplex, others support half duplex only
    BYTE    byWorkMode;                //work mode, 0- console, 1- transparent channel
    BYTE    byChannel;                //485 chan
    BYTE    bySerialType;            //serial type: 0--485, 1--232
    BYTE    byMode;                 //mode 0-Connect card reader  1-Connect client  2-Connect extension module   3-access control host  4-elevator control host 0xff-disabled
    BYTE    byOutputDataType;  //0-invalid 1-cardno 2-employeeno
    BYTE    byAddress;               //serial address
    BYTE    byStairsOutputDataType;   //0-invalid, 1-floorno, 2-cardno, valid only byMode is 4-elevator control host
    BYTE    byRes[32];                // Reserved
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

#define MAX_DEVICE_PROTO_NUM       256
#define MAX_DEVICE_TYPE_NUM            256

// Protocol list supported by RS-485 front-end device
typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             //Structure size
    DWORD   dwProtoNum;         //Total number of protocol
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  //Protocol type
    BYTE    byRes[12];          // Reserved
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD    dwType;
    BYTE    byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD    dwSize;                //Structure size
    DWORD    dwTypeNum;            //Total number of types
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE    byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

#define ALARMHOST_ABILITY     0x500 //Network alarm host ability

#define    MAX_ALARMHOST_VIDEO_CHAN    64
typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                  //Structure size
    BYTE   sUserName[NAME_LEN];     //User name
    BYTE    sPassword[PASSWD_LEN];    //Password
    NET_DVR_IPADDR    struUserIP;        //User IP (0 stands for no IP restriction) 
    BYTE    byMACAddr[MACADDR_LEN];    //MAC
    BYTE        byUserType;         //0- general user(operator), 1- administrator user, 2-installers users, 3-manufacturer user
    BYTE   byAlarmOnRight;          //Arming authority
    BYTE   byAlarmOffRight;         //Disarming authority
    BYTE   byBypassRight;           //Bypass authority
    BYTE   byOtherRight[MAX_RIGHT]; //Other authority 
    // 0 -- log
    // 1 -- reboot/shutdown
    // 2 -- set parameter
    // 3 -- get parameter
    // 4 -- resume
    // 5 -- siren 
    // 6 -- PTZ
    // 7 -- remote upgrade
    // 8 -- preview
    // 9 -- manual record
    // 10 -- remote playback
    // 11 -- fire alarm
    // 12 -- forced deployment
    // 13 -- permanent bypass
    // 14 -- add and change personal authorization code
    // 15 -- debug mode
    BYTE    byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN / 8];    // preview channels,eg. bit0-channel 1,0-no permission 1-permission enable
    BYTE    byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN / 8];    // record channels,eg. bit0-channel 1,0-no permission 1-permission enable
    BYTE    byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN / 8]; // playback channels,eg. bit0-channel 1,0-no permission 1-permission enable
    BYTE    byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN / 8];        // PTZ channels,eg. bit0-channel 1,0-no permission 1-permission enable
    BYTE        sOriginalPassword[PASSWD_LEN];        // Original password
    BYTE        sKeypadPassword[PASSWD_LEN];        // keyboard password
    BYTE        byUserEnabled;        // user enable: 0-invalid, 1-open, 2-close
    BYTE        byRes2[135];                  // Reserved
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;


typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD     dwSize;     //Structure size
    DWORD    dwID;        //Keyboard user ID
    BYTE    byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //Area authority, indicated by subscript, it supports max 512 areas. 0 - no authority, 1 - privileged
    BYTE    byRes[560];        // Reserved
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;


typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD    dwSize;
    BYTE    sUserName[NAME_LEN];    // UserName
    BYTE    sPassword[PASSWD_LEN];  // Password
    BYTE    bySubSystemPermission;
    BYTE    byRes[63];              // res
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD    dwSize;                //Structure size
    BYTE    byName[NAME_LEN];    //Access control name    
    BYTE    byEnable;            //Enable or not
    BYTE    byLocalEnable;      //Disabled or enabled in local
    WORD    wDelayTime;            //Delay time of opening, unit:s, value range: 0-65535, 0 means open all the time
    BYTE    byLockWorkMode;        //lock work mode,0- start when power on,1- start when power off
    BYTE    byRes2[31];            // Reserved
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD dwSize;        //Structure size
    DWORD dwAbsTime;    //Absolute time, OSD display information

    BYTE   byName[NAME_LEN];   //Analog name
    BYTE   bySensorChannel;    //Analog channel
    BYTE   byType;             //Analog type
    BYTE    byAlarmType;       //1- UP4, 2- UP3, 3- UP2, 4- UP1, 5- DOWN1, 6- DOWN2, 7- DOWN3, 8- DOWN4, related to current mode
    //E.g. when it equals to 1000, there are four alarm types: UP1 and DOWN1,2,3.
    BYTE    byAlarmMode;       //Alarm mode, five kinds: -HHHH, -HHHL, -HHLL, HLLL, -LLLL, used to judge function alarm level for platform
    //That is: 1111(UP UP UP UP), 1110(UP UP UP DOWM), 1100(UP UP DOWM DOWM), 1000(UP DOWM DOWM DOWM), 0000(DOWM DOWM DOWM DOWM)
    float        fValue;           // Current analog value
    float   fOriginalValue; //original value,Retain three decimal places,according NET_DVR_SENSOR_INFO(bySensorStandard)to judge voltage or current
    BYTE    byRes2[28];		    // Reserve
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;
typedef struct
{
    /*Reserved,currently alarm of alarm host has no type(fortification network sequence, listening host sequence)*/
    DWORD  dwAlarmType;
    /*Array 0 is corresponding to NO.1 input pot*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE    byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO, *LPNET_DVR_ALARMHOST_ALARMINFO;

#define PROTOCOL_VERTION_LEN    32

typedef struct tagNET_DVR_RS485_PROTOCOL_VERSION
{
    DWORD  dwSize;
    BYTE   byProtocleVersion[PROTOCOL_VERTION_LEN];//RS485 protocol version infomation
    BYTE   byRes[128];
}NET_DVR_RS485_PROTOCOL_VERSION, *LPNET_DVR_RS485_PROTOCOL_VESRION;

//Switch alarm upload

typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN];     //Switch name
    WORD  wSwitchChannel;       //Switch channel
    BYTE    byAlarmType;        //Alarm type
    BYTE     byRes[41];            //Reserved
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;

typedef union tagNET_DVR_ALARMHOST_EXCEPTION_PARAM
{
    DWORD   dwUnionSize[20];        //Union size    
}NET_DVR_ALARMHOST_EXCEPTION_PARAM, *LPNET_DVR_ALARMHOST_EXCEPTION_PARAM;


typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // structure size
    //Exception parameter, 1- device tamper alarm, 2- resume to normal after device tamper, 3- alarm of major power off, 4- resume after major power off
    //5- internal communication failure alarm, 6- resume after internal communication failure, 7- telephone line dropped,
    //8- resume telephone line dropped, 9- self-test failure alarm,  10- resume after self-test failure   11-storage battery low voltage 
    //12- voltage of storage battery resume 13- storage battery trouble 14- MBUS module dropped 15-MBUS module dropped resume 16-keyboard dropped 17-keyboard dropped resume
    //18-device moved, 19-device moved resume, 20-485 peripheral circuit broken alarm, 21-resume after peripheral circuit broken
    //25-daughter board1 inserted on,26-daughter board1 pulled out, 27-daughter board2 inserted on,28-daughter board1 pulled out
    DWORD   dwExceptionType;
    BYTE   byRes[36];          // reserved
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

//
#define MAX_CENTERNUM                4        //G1,G2 G3 G4 or N1,N2,N3,N4 or T1,T2,T3,T4
#define MAX_PHONE_NUM                32
typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //center number  
    BYTE byRepeatCall;          //time of repeat call ,1~15times
    BYTE byPstnProtocol;        //protocol,0-CID;
    BYTE byDialDelay;           //time of dial delay, max time is 150s
    BYTE byPstnTransMode;       //trans mode,0-DTMF 5/S,1-DTMF 10/S;
    BYTE byEnable;       //0-close,1-open
    BYTE byRes1[5];
    BYTE byReceiverId[6];         //receive account ID;
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//parameter of center 
    WORD wReportPeriod;      //period of report:hour (max period is 168 hour)
    WORD wFirstReportTime;     //the time of sending first report,1~3600min
    BYTE  byReportValid;    //turn on the report mode 0-valid 1-invalidation
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//enable mode 0:close,1:open ,2:open while the net is cutted down,close while natural;
    BYTE byCallType; //report mode,1-one center,2-two centers,3,one is main center and the other is standby
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

#define  MAX_PU_CHAN_NUM    512

typedef struct tagNET_DVR_PU_CHAN_INFO
{
    NET_DVR_IPADDR  struIpAddr;    
    WORD            wPort;      
    WORD            wChannel;      
    BYTE            byRes[24];    
}NET_DVR_PU_CHAN_INFO, *LPNET_DVR_PU_CHAN_INFO;

typedef struct tagNET_DVR_PU_CHAN_LIST
{
    DWORD   dwSize;    
    DWORD   dwNum;      
    NET_DVR_PU_CHAN_INFO struPuChanInfo[MAX_PU_CHAN_NUM];
}NET_DVR_PU_CHAN_LIST, *LPNET_DVR_PU_CHAN_LIST;

#define  MAX_ALARM_CAM_NUM    32        // Total number of alarm triggered CAMs

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   //Enable PTZ control or not
    BYTE    byType;     //PTZ control type: 1- preset, 2- cruise  3- track
    BYTE    byPtzNo;    //Preset, cruise, or track number of PTZ control
    BYTE    byRes[5];   //Reserved
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD            dwCamID;         //Operation of triggered CAM channel
    DWORD           dwRecordTime;    //Triggered record time, unit: s, -1- continuously record, 0- do not record
    DWORD           dwMonID;         //Trigger Cam to Mon display
    DWORD           dwResidentTime;  //Polling stay time, unit: s  -1- continuously stay, 0- do not stay
    NET_DVR_PTZ_CTRL    struPtzCtrl; //PTZ control information
    BYTE            byAlarmOffMode;  //Canceling mode of alarm switching to the wall, 0- cancel immediately, 1- cancel automatically, 2- cancel manually
    BYTE            byDevType;         //When it is intelligent device, valid means stream resource of intelligent alarmer: 1- decode card, 2- encode card
    BYTE            byDecChan;         //When the channel is decoding channel, it is decoding channel number
    BYTE            byRes[17];       //Reserved
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD        dwSize;            //Structure size
    BYTE        byEnable;       //Enable alarm triggering CAM interaction or not, default: disabled
    BYTE        byRes[7];       //Reserved
    DWORD        dwNum;            //The number of triggering CAM interaction, that is, take the first few data of array to handle  
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

#define MAX_GATEWAY_NUM         8  // max gateway num
typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD         dwSize;
    BYTE        byEnterDoor[8];    // Subscript is number of enter door, the value is assiociate information,0-not associated, 1-8 is the audio index of associated
    BYTE        byExitDoor[8];     //  Subscript is number of exit door, the value is assiociate information,0-not associated, 1-8 is the audio index of associated
    BYTE         byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  // Subscript is number of alarm in, the value is assiociate information,0-not associated, 1-8 is the audio index of associated
    BYTE         byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byUploadType;    /*Upload type,1-get data by reading file, 2-get data from buffer*/
    BYTE        byDataType;        //data type:1-audio type
    BYTE        byDataNum;        //data index
    BYTE        byAudioType;        //audio type,0-wave
    char        sFileName[260];        //path of data file
    char        *lpBuffer;            //data buffer
    DWORD        dwBufferSize;        //length of the buffer
    BYTE        byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*type of saving data,1-save data to the file by path, 2-get data by callaback function*/
    BYTE        byDataType;        //data type:1-audio type
    BYTE        byDataNum;        //data index
    BYTE        byRes1;
    char        sFileName[260];        //path of file
    DATADOWNLOAD lpDataCallBack; //handle of callback function
    void*        pUserData;    //user data
    BYTE        byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;
    BYTE        byDataType;
    BYTE        byDataNum;
    BYTE        byRes1;
    char        sFileName[260];
    DATADOWNLOAD lpDataCallBack;
    void*        pUserData;
    BYTE        byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;

/*************************************SELF SERVICE BANK V2.0 begin***********************************/
typedef  struct tagNET_DVR_LED_SCREEN_CFG
{
    DWORD         dwSize;
    BYTE        sLEDName[NAME_LEN/*32*/];    // LED Screen name
    BYTE        byTransMode;                 //  1-seiral port communication
    BYTE        byProtocolType;                // protocol type,LED factories
    BYTE        byLEDColor;                 // 1-one color, 2-two-color, 3-256 grayscale dual color, 4- Full-color
    BYTE        byDataPolarity;                // Data polarity .0-Negative electrode,1-positive electrode
    BYTE        byOEPolarity;                // 0-Active-low 1-Active-high
    BYTE        byScanMode;                 // 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-static
    BYTE        byRes1[2];
    //Minimum width and height is 16*16,interval is 8 points    
    WORD        wLEDWidth;                     // 16~2048
    WORD         wLEDHeight;                    // 16~2048
    BYTE        byRes2[64];
}NET_DVR_LED_SCREEN_CFG, *LPNET_DVR_LED_SCREEN_CFG;


#define  MAX_CONTENT_LEN  512
typedef  struct tagNET_DVR_LED_CONTENT_CFG
{
    DWORD         dwSize;
    BYTE        sLEDContent[MAX_CONTENT_LEN];    // LED content
    BYTE        byContentAct;                    // 1-static,2-Quick play,3-Move to the left,4-Move to the right, 5-Move up, 6-Move down
    BYTE        byContentSpeed;                    // 1-24(1-The fastest,24-The slowest)    
    BYTE        byContentStayTime;                 // 0-127.5s(Accuracy 0.5s, SDK will Multiply 2 when transmission
    BYTE        byRes[33];
}NET_DVR_LED_CONTENT_CFG, *LPNET_DVR_LED_CONTENT_CFG;

#define     LED_TIMER_NUM             3            // LED time which use for turn on and turn off
#define        TIME_SEGMENT_A_DAY        48            // segment in a day , every half hour is a segment

typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE    byValid;                // enable or disable, time is use in a time-group
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTimeOn;     // time of turn on
    NET_DVR_TIME_EX struTimeOff;     // time of turn off
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;


typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD        dwSize;//time of Timer switch,the  parameter byHour and byMinute is valid, the other parameters is invalid. boot time should earlier than off time
    NET_DVR_SWITCH_TIME      struTimer[LED_TIMER_NUM /*3*/];
    BYTE        byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD         dwSize;
    BYTE        byValid;        //use for Time-sharing brightness adjustment
    BYTE        byRes1[3];
    BYTE         byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/];     //total levels is 16,0~15
    BYTE        byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD    dwSize;
    BYTE    bySwitchState;        //1-status of turn on 2-status of turn off
    BYTE    byBrightness;        //brightness,0-15
    BYTE    byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;

#define        MAX_DECODE_CARD_NUM            6  

typedef enum _HD_DISPLAY_FORMAT
{
    HD_DISPLAY_FORMAT_INVALID = 0x00000000,
    HD_DISPLAY_FORMAT_CVBS = 0x00000001,
    HD_DISPLAY_FORMAT_DVI = 0x00000002,
    HD_DISPLAY_FORMAT_VGA = 0x00000004,
    HD_DISPLAY_FORMAT_HDMI = 0x00000008,
    HD_DISPLAY_FORMAT_YPbPr = 0x00000010
}HD_DISPLAY_FORMAT, *LPHD_DISPLAY_FORMAT;


typedef struct tagNET_DVR_DECCARD_ABILITY     
{
    BYTE byCardType;     
    BYTE byDecNums;     
    BYTE byDispNums;     
    BYTE byDecStartIdx;    
    BYTE byDispStartIdx;     
    BYTE byDispResolution[80]; 
    BYTE byDispFormat[8];    
    BYTE byWindowMode[4][8]; 
    BYTE byRes[35];
} NET_DVR_DECCARD_ABILITY, *LPNET_DVR_DECCARD_ABILITY;

typedef struct tagNET_DVR_DECODESVR_ABILITY
{
    DWORD dwSize;     
    BYTE byCardNums;      
    BYTE byStartChan;     
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY, *LPNET_DVR_DECODESVR_ABILITY;

typedef struct tagNET_MATRIX_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            
    WORD     wDVRPort;                 
    BYTE     byChannel;                
    BYTE    byTransProtocol;        
    BYTE    byTransMode;            
    BYTE    byFactoryType;          
    BYTE    byUsedSlotNum;           
    BYTE    bySlotNum;
    BYTE    byRes[68];
    BYTE    sUserName[NAME_LEN];   
    BYTE    sPassword[PASSWD_LEN];    
}NET_MATRIX_DEV_CHAN_INFO, *LPNET_MATRIX_DEV_CHAN_INFO;

typedef struct tagNET_MATRIX_PU_STREAM_CFG
{
    DWORD                            dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_MATRIX_DEV_CHAN_INFO        struDevChanInfo;
} NET_MATRIX_PU_STREAM_CFG, LPNET_MATRIX_PU_STREAM_CFG;


typedef struct tagNET_DVR_MATRIX_CAMERACFG
{
    DWORD                    dwGlobalIndex;
    DWORD                    dwInterIndex;
    BYTE                    sCamName[NAME_LEN];
    NET_MATRIX_PU_STREAM_CFG struPuStreamCfg;
} NET_DVR_MATRIX_CAMERACFG, *LPNET_DVR_MATRIX_CAMERACFG;

typedef struct tagNET_DVR_MATRIX_CAMERALIST
{
    DWORD            dwSize;
    BYTE            byRes[12];
    DWORD            dwCamNum;
    BYTE              *pBuffer;
    DWORD             dwBufLen;
} NET_DVR_MATRIX_CAMERALIST, *LPNET_DVR_MATRIX_CAMERALIST;

typedef struct tagNET_DVR_DISP_CHAN_INFO
{
    NET_DVR_IPADDR    struIP;                
    WORD     wDVRPort;                
    BYTE     byDispChannel;          
    BYTE    byUsedSlotNum;           
    BYTE    bySlotNum;
    BYTE    byRes[7];
    BYTE    sUserName[NAME_LEN];    
    BYTE    sPassword[PASSWD_LEN];   
}NET_DVR_DISP_CHAN_INFO, *LPNET_DVR_DISP_CHAN_INFO;


typedef struct tagNET_DVR_MATRIX_MONITORCFG
{
    DWORD                        dwGlobalIndex;
    DWORD                        dwInterIndex;
    BYTE                        sMonName[NAME_LEN];
    NET_DVR_DISP_CHAN_INFO        struDispChanCfg;
} NET_DVR_MATRIX_MONITORCFG, *LPNET_DVR_MATRIX_MONITORCFG;

typedef struct tagNET_DVR_MATRIX_MONITORLIST
{
    DWORD        dwSize;
    BYTE        byRes[12];
    DWORD        dwMonNum;
    BYTE          *pBuffer;
    DWORD         dwBufLen;
} NET_DVR_MATRIX_MONITORLIST, *LPNET_DVR_MATRIX_MONITORLIST;

#define     MAX_SUBMATRIX_NUM        8
typedef struct tagNET_DVR_SUBMATRIXINFO
{
    BYTE        byMainMatrix;
    BYTE        bySubMatrixSequence;
    BYTE        byLoginType;
    BYTE        byRes1[9];
    NET_DVR_IPADDR  struSubMatrixIP;        
    WORD        wSubMatrixPort;       
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubMatrixIPMask;   
    NET_DVR_IPADDR    struGatewayIpAddr;        
    BYTE        sUserName[NAME_LEN];   
    BYTE        sPassword[PASSWD_LEN];    
    char        sDomainName[MAX_DOMAIN_NAME];
    char         sDnsAddress[MAX_DOMAIN_NAME];
    BYTE        sSerialNumber[SERIALNO_LEN];
    BYTE        byRes3[16];
}NET_DVR_SUBMATRIXINFO, *LPNET_DVR_SUBMATRIXINFO;

typedef struct tagNET_DVR_ALLUNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBMATRIXINFO struSubMatrixInfo[MAX_SUBMATRIX_NUM];
    BYTE  byRes2[32];
}NET_DVR_ALLUNITEDMATRIXINFO, *LPNET_DVR_ALLUNITEDMATRIXINFO;

#define    MAX_GATEWAYTRUNKNUM        1024 
typedef struct tagNET_DVR_MATRIXSUBSYSTEMINFO
{
    BYTE   byMatrixNum;
    BYTE    bySubSystemNum;
    BYTE   byRes[14];
} NET_DVR_MATRIXSUBSYSTEMINFO, *LPNET_DVR_MATRIXSUBSYSTEMINFO;
typedef struct tagNET_DVR_MATRIXGATEWAYNOTE
{
    WORD    wTrunkInToOutAbility;
    WORD    wTrunkOutToInAbility;
    BYTE    byRes[4];
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;
}NET_DVR_MATRIXGATEWAYNOTE, *LPNET_DVR_MATRIXGATEWAYNOTE;

typedef struct tagNET_DVR_MATRIXGATEWAYINFO
{
    DWORD dwSize;
    NET_DVR_MATRIXGATEWAYNOTE struGatewayNote[MAX_GATEWAYTRUNKNUM];
    BYTE  byRes[32];
}NET_DVR_MATRIXGATEWAYINFO, *LPNET_DVR_MATRIXGATEWAYINFO;

typedef struct tagNET_DVR_MATRIXCODESYSTEMINFO
{
    BYTE   byMatrixNum;
    BYTE    bySubSystemNum;
    BYTE    byChan;
    BYTE   byRes[13];
}NET_DVR_MATRIXCODESYSTEMINFO, *LPNET_DVR_MATRIXCODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXDECODESYSTEMINFO
{
    BYTE    byMatrixNum;
    BYTE    bySubSystemNum;
    BYTE    byDispChan;
    BYTE    bySubDispChan;
    BYTE    byRes[12];
}NET_DVR_MATRIXDECODESYSTEMINFO, *LPNET_DVR_MATRIXDECODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXSWITCH
{
    NET_DVR_MATRIXCODESYSTEMINFO struInputNote;
    NET_DVR_MATRIXDECODESYSTEMINFO struOutputNote;
    BYTE    byRes[32];
}NET_DVR_MATRIXSWITCH, *LPNET_DVR_MATRIXSWITCH;

typedef enum {
    ENC_CARD = 0,
    DEC_CARD,
    SD_DEC_CARD,
    FPGA_CARD,
    CS_CARD,
    ALERTOR_CARD,
    NAT_0,
    NAT_1,
    VCA_CARD,
    VGA_DEC_CARD,
    VGA_ENC_CARD,
    ERR_CARD,
} DEV_TYPE;

typedef struct tagNET_DVR_MATRIXSWITCHCTRL
{
    DWORD dwCamId;
    DWORD dwMonId;
    BYTE  bySubWindowNum;
    BYTE   bySwitchType;
    WORD   wAlarmType;
    DWORD  dwResidentTime;
    BYTE   byVcaDevType;
    BYTE   byWallNo;
    BYTE   byRes[18];
}NET_DVR_MATRIXSWITCHCTRL, *LPNET_DVR_MATRIXSWITCHCTRL;


/*************************************SELF SERVICE BANK V2.0 end***********************************/
/************************************************************************/
/*********************************9000 2.0 begin***************************************/

//Mode A 
typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;    // Start month, starting from 1
    BYTE    byStartDay;        // Start day, starting from 1
    BYTE    byEndMonth;        // End month 
    BYTE    byEndDay;        // End day
    BYTE    byRes[4];        // Reserved
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE    byStartMonth;    // Start month, starting from 1
    BYTE    byStartWeekNum;    // Start week, starting from 1 
    BYTE    byStartWeekday;    // Day of the week
    BYTE    byEndMonth;        // End month, starting from 1
    BYTE    byEndWeekNum;    // End week, starting from 1 
    BYTE    byEndWeekday;    // Day of the week    
    BYTE    byRes[2];        // Reserved
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD    wStartYear;        // Year
    BYTE    byStartMon;        // Month
    BYTE    byStartDay;        // Day
    WORD    wEndYear;        // Year
    BYTE    byEndMon;        // Month
    BYTE    byEndDay;        // Day
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;

typedef union tagNET_DVR_HOLIDATE_UNION
{
    // Union size: 12 bytes
    DWORD                    dwSize[3];
    NET_DVR_HOLIDATE_MODEA    struModeA;    // Mode A
    NET_DVR_HOLIDATE_MODEB    struModeB;    // Mode B
    NET_DVR_HOLIDATE_MODEC    struModeC;    // Mode C
}NET_DVR_HOLIDATE_UNION, *LPNET_DVR_HOLIDATE_UNION;

typedef enum tagHOLI_DATE_MODE
{
    HOLIDATE_MODEA = 0,
    HOLIDATE_MODEB,
    HOLIDATE_MODEC
}HOLI_DATE_MODE;

typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE    byEnable;            // Enable or not
    BYTE    byDateMode;            // Date mode: 0- mode A, 1- mode B, 2- mode C
    BYTE    byRes1[2];            // Reserved
    NET_DVR_HOLIDATE_UNION uHolidate;    // Holiday date 
    BYTE    byName[NAME_LEN];    // Holiday name
    BYTE    byRes2[20];            // Reserved
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

#define  MAX_HOLIDAY_NUM    32

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD    dwSize;            //Structure size
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];    //Holiday parameter
    DWORD    byRes[40];        // Reserved
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

//Holiday alarm handling mode
typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD    dwSize;                //Structure size
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];    //Arming schedule
    BYTE    byRes2[240];        // Reserved
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwSMDHandleType;
    BYTE     byRes2[32];
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD                 dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // Record parameter
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // Record schedule
    BYTE                  byRes[20];      //  Reserved
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

#define  MAX_LINK_V30  128

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // Client IP
    LONG            lChannel;   // Channel number
    BYTE            byRes[32];  // Reserved
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      //Structure size
    WORD    wLinkNum;    //Total number of connections
    BYTE    byRes1[2];   // Reserved
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   //Information of the client connecting to the device
    BYTE    byRes[32];   // Reserved
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

#define MAX_BOND_NUM  2

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;                //Work mode: 0 - network fault tolerance, 1 - load balancing
    BYTE    byUseDhcp;            //Enable dhcp or not
    BYTE    byMasterCard;        //Assign which network card to be master card        
    BYTE    byStatus;           //BONDING status: 0 - exception, 1- normal. It is read only, and it is not supported to modify
    BYTE    byBond[MAX_NETWORK_CARD];//byBond[0]== 1 means to use eh0, byBond[0]== 0 means not to use eh0
    NET_DVR_ETHERNET_V30    struEtherNet; //Ethernet parameter
    NET_DVR_IPADDR    struGatewayIpAddr;    //IP address of Gateway
    BYTE  byEnableDNS; //DNS Enabled, 0-close,1-open 
    BYTE  byBondMode; //Binding way, 0 - Invalid,  1 - main standby mode, 2 - rotation mode, 3 - XOR mode, 4 - broadcasting mode, 5 - 802.3ad model, 6 - T1b mode, 7 - virtualization mode 
    BYTE  byRes1[2];
    BYTE  byBond2[MAX_NETWORK_CARD_EX/*12*/];// ByBond2 [0] = = 1 means use eh4 0 means no use eh4, based on byBond extension 
    BYTE  byRes[4];
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         //Structure size
    BYTE    byEnable;       //Enable bonding or not
    BYTE    byNum;          //The number of bonding network cards
    BYTE    byRes1[2];      //Reserved
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE    byRes2[40];        //Reserved
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;


//Disk quota 
typedef struct tagNET_DVR_DISK_QUOTA
{
    BYTE    byQuotaType;     //Disk quota: 1- by capacity of disk 2-by Ratio 3-by Time
    BYTE    byRes1[5];       //Reserved
    WORD    wStoragePeriod;  //Video storage period, the unit day, by the time when the quota is valid type
    DWORD   dwHCapacity;     //High 32 bits of the allocated disk capacity, unit:MB
    DWORD   dwLCapacity;     //Low 32 bits of the allocated disk capacity, unit:MB
    DWORD   dwHUsedSpace;    //High 32 bits of used disk capacity, unit:MB
    DWORD   dwLUsedSpace;    //Low 32 bits of used disk capacity, unit:MB
    BYTE    byQuotaRatio;    //The proportion of the allocated disk, unit:%
    BYTE    byRes2[21];      //Reserved
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         //Structure size
    NET_DVR_DISK_QUOTA    struPicQuota;       //Picture quota
    NET_DVR_DISK_QUOTA    struRecordQuota;    //Record quota
    NET_DVR_DISK_QUOTA    struAddInfoQuota; //  Add Info Quota
    BYTE    byRes[12];      //Reserved
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_DISK_QUOTA_V60
{
    BYTE    byQuotaType;
    BYTE    byRes1[5];
    WORD    wStoragePeriod;
    DWORD   dwHCapacity;
    DWORD   dwLCapacity;
    DWORD   dwHUsedSpace;
    DWORD   dwLUsedSpace;
    BYTE    byQuotaRatio;
    BYTE    byRes2[23];
}NET_DVR_DISK_QUOTA_V60, *LPNET_DVR_DISK_QUOTA_V60;

typedef struct tagNET_DVR_DISK_QUOTA_CFG_V60
{
    DWORD  dwSize;
    NET_DVR_DISK_QUOTA_V60    struPicQuota;
    NET_DVR_DISK_QUOTA_V60    struRecordQuota;
    NET_DVR_DISK_QUOTA_V60   struAddInfoQuota;
    NET_DVR_DISK_QUOTA_V60   struPubInfoFile;
    BYTE   byRes[256];
}NET_DVR_DISK_QUOTA_CFG_V60, *LPNET_DVR_DISK_QUOTA_CFG_V60;


typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of timing capture
    DWORD      dwPicInterval;         //Interval of timing capture, unit: s  
    BYTE       byRes[12];             //Reserved
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    //Indicated by bit
    BYTE    byRes[20];     //Reserved
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

#define MAX_PIC_EVENT_NUM  32
#define MAX_ALARMIN_CAPTURE   16

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //Associated channel number maximum can trigger (read-only  )
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //Capture trigger associated channel number, according to the values, the compact arrangement, 0xFFFFFFFF said the following invalid
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of event capture
    DWORD   dwPicInterval;   //Interval of event capture, unit: s 
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   ///hat array subscript = 0 means motion detection triggering capture, array subscript = 1 means video tampering triggering capture,2-video lost capture,3-PIR alarm capture,4-wireless alarm capture,5-callhelp alarm capture,6-VCA capture,7- face detetct
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    //Alarm in triggering capture. That array subscript = 0 means the NO.1 alarm in, and so forth

    DWORD   dwMaxGroupNum;  //The maximum number of alarm input device support, each group of 16 alarm input
    BYTE      byCapTimes; //capture times
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   //Picture quality of event capture
    DWORD       dwPicInterval;        //Interval of event capture, unit: s
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM]; //That array subscript = 0 means motion detection triggering capture, array subscript = 1 means video tampering triggering capture,2-video lost capture,3-PIR alarm capture,4-wireless alarm capture,5-callhelp alarm capture,6-VCA capture,7- face detetct
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    //Alarm in triggering capture. That array subscript = 0 means the NO.1 alarm in, and so forth
    BYTE       byCapTimes; //capture times
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         //Structure size
    NET_DVR_TIMING_CAPTURE struTimingCapture;
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;
    BYTE       byRes3[19];     // Reserved
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD                             dwSize;
    NET_DVR_TIMING_CAPTURE        struTimingCapture;
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;
    BYTE       byRes3[19];
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE    byAllDayCapture;    //Enable all-day capture or not
    BYTE    byCaptureType;        //Capture type: 0- scheduled capture, 1- motion detection capture, 2- alarm capture, 3- motion detection | alarm capture, 4- motion detection & alarm capture, 6- intelligent alarm capture,7-Intelligent detection capture ,8-All,39-thermometry Off Line Alarm capture ,40-aralrmInAlarm,41-emergencyAlarm,42-consultAlarm
    BYTE    byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;  //Time segment
    BYTE        byCaptureType;          //Capture type: 0- scheduled capture, 1- motion detection capture, 2- alarm capture, 3- motion detection | alarm capture, 4- motion detection & alarm capture, 6- intelligent alarm capture,7-Intelligent detection capture ,8-All ,39-thermometry Off Line Alarm capture ,40-aralrmInAlarm,41-emergencyAlarm,42-consultAlarm
    BYTE        byRes[3];               //Reserved
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

// Channel capture scheme
typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     //Structure size
    BYTE    byEnable;    //Capture or not
    BYTE    byRes1[3];    // Reserved
    NET_DVR_CAPTURE_DAY    struCaptureDay[MAX_DAYS];    //All-day capture
    NET_DVR_CAPTURE_SCHED    struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //Capture schedule
    NET_DVR_CAPTURE_DAY    struCaptureHoliday;            //Holiday capture schedule
    NET_DVR_CAPTURE_SCHED    struHolidaySched[MAX_TIMESEGMENT_V30];    //Holiday schedule
    DWORD    dwRecorderDuration;    //Max keeping time for captured pictures, unit: day. 0xffffffff means the value is invalid
    DWORD    dwDelayTime;           /* Capture delay time 0- no delay, 1-3 seconds, 2-4 seconds, 3-5 seconds, 4-10 seconds, 5-30 seconds, 6-60 seconds, 7-120 seconds, 8-300 seconds*/
    BYTE    byRes[36];            // Reserved
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;

typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;             //Structure size
    LONG   lCardIndex;         //NIC index
    DWORD  dwInterval;         //Uploading time interval, unit: 100 ms
    BYTE   byRes[8];           //Reserved
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //Structure size
    DWORD  dwSendFlowSize;     //Size of sending flow, unit: kbps
    DWORD  dwRecvFlowSize;     //Size of receiving flow, unit: kbps
    BYTE   byRes[20];          //Reserved
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

//Record label
#define LABEL_NAME_LEN 40
typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;                        //Structure size
    NET_DVR_TIME  struTimeLabel;        //Label time 
    BYTE    byQuickAdd;                    //Whether quickly add label. Label name is invalid when quickly adding
    BYTE    byRes1[3];                    //Reserved
    BYTE    sLabelName[LABEL_NAME_LEN];    //Label name. Its length is 40 bytes  
    BYTE    byRes2[40];                    //Reserved
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

#define  LABEL_IDENTIFY_LEN     64
typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64 bytes identify
    BYTE    byRes[8];               // Reserved
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

#define MAX_DEL_LABEL_IDENTIFY  20// Max number of label identifies to be deleted

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       //Structure size
    BYTE    byMode;          //Expressed by bit, 0x01 means deleting by identify 
    BYTE    byRes1;
    WORD    wLabelNum;      //Total number of labels      
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; //Label identify
    BYTE    byRes2[160];   //Reserved   
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //Label identify to be modified
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];    //Modified label name
    BYTE byRes2[40];
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

//Record label searching structure
typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;                     //Structure size
    LONG        lChannel;                    //Searching channel
    NET_DVR_TIME    struStartTime;           //Start time
    NET_DVR_TIME    struStopTime;            //End time
    BYTE        sLabelName[LABEL_NAME_LEN];    //Record label name. If the name is NULL, it will search all labels in the set period
    BYTE        byDrawFrame;        //0:not draw frame,1:draw frame
    BYTE   	    byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char cStartTimeDifferenceH;   
    char cStartTimeDifferenceM;   
    char cStopTimeDifferenceH;    
    char cStopTimeDifferenceM;    
    BYTE        byRes[34];                    
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

//Label information structure
typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE    sLabelName[LABEL_NAME_LEN];          //Label name
    NET_DVR_TIME struTimeLabel;                  //Label time 
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; //Label identify
    BYTE   	    byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char cTimeDifferenceH;   
    char cTimeDifferenceM;   
    BYTE    byRes[29];                          //Reserved
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;

#define CARDNUM_LEN_V30 40
//country enum
typedef enum _COUNTRY_INDEX_
{
    COUNTRY_NONSUPPORT = 0,   //0-not support
    /*235 */
    /*48*/
    COUNTRY_CZE = 1, //Czech Republic 
    COUNTRY_FRA = 2, //France 
    COUNTRY_DEU = 3, //Germany 
    COUNTRY_ESP = 4, //Spain 
    COUNTRY_ITA = 5, //Italy 
    COUNTRY_NLD = 6, //Netherlands 
    COUNTRY_POL = 7, //Poland 
    COUNTRY_SVK = 8, //Slovakia 
    COUNTRY_BLR = 9, //Belarus 
    COUNTRY_MDA = 10, //Moldova 
    COUNTRY_RUS = 11, //Russia 
    COUNTRY_UKR = 12, //Ukraine 
    COUNTRY_BEL = 13, //Belgium 
    COUNTRY_BGR = 14, //Bulgaria 
    COUNTRY_DNK = 15, //Denmark 
    COUNTRY_FIN = 16, //Finland 
    COUNTRY_GBR = 17, //United Kingdom 
    COUNTRY_GRC = 18, //Greece 
    COUNTRY_HRV = 19, //Croatia 
    COUNTRY_HUN = 20, //Hungary 
    COUNTRY_ISR = 21, //Israel 
    COUNTRY_LUX = 22, //Luxembourg 
    COUNTRY_MKD = 23, //Macedonia 
    COUNTRY_NOR = 24, //Norway  
    COUNTRY_PRT = 25, //Portuga 
    COUNTRY_ROU = 26, //Romania 
    COUNTRY_SRB = 27, //Serbia 
    COUNTRY_AZE = 28, //Azerbaijan 
    COUNTRY_GEO = 29, //Georgia  
    COUNTRY_KAZ = 30, //Kazakhstan 
    COUNTRY_LTU = 31, //Lithuania 
    COUNTRY_TKM = 32, //Turkmenistan 
    COUNTRY_UZB = 33, //Uzbekistan 
    COUNTRY_LVA = 34, //Latvia 
    COUNTRY_EST = 35, //Estonia 
    COUNTRY_ALB = 36, //Albania 
    COUNTRY_AUT = 37, //Austria 
    COUNTRY_BIH = 38, //Bosnia and Herzegovina 
    COUNTRY_IRL = 39, //Ireland 
    COUNTRY_ISL = 40, //Iceland 
    COUNTRY_VAT = 41, //Vatican 
    COUNTRY_MLT = 42, //Malta 
    COUNTRY_SWE = 43, //Sweden 
    COUNTRY_CHE = 44, //Switzerland 
    COUNTRY_CYP = 45, //Cyprus 
    COUNTRY_TUR = 46, //Turkey 
    COUNTRY_SVN = 47, //Slovenia 
    COUNTRY_MTG = 48, //Montenegro 
    COUNTRY_KOV = 49, //Kosovo 
    COUNTRY_ADR = 50, //Andorra 
    COUNTRY_ARM = 51, //Armenia 
    COUNTRY_MON = 52, //Monaco 
    COUNTRY_LIE = 53, //Liechtenstein 
    COUNTRY_SMO = 54, //San Marino 
    COUNTRY_ORN = 55, //Aland 
    COUNTRY_RES2 = 56, //Res
    COUNTRY_RES3 = 57, //Res
    COUNTRY_RES4 = 58, //Res

    /*48*/
    COUNTRY_CHI = 59, //China 
    COUNTRY_IBN = 60, //In bahrain 
    COUNTRY_SKR = 61, //South Korea 
    COUNTRY_LEB = 62, //Lebanon 
    COUNTRY_NEP = 63, //Nepal  
    COUNTRY_THA = 64, //Thailand 
    COUNTRY_PAK = 65, //Pakistan 
    COUNTRY_EMI = 66, //The united Arab emirates 
    COUNTRY_BHU = 67, //Bhutan 
    COUNTRY_OMA = 68, //Oman 
    COUNTRY_KOR = 69, //North Korea 
    COUNTRY_PHI = 70, //The Philippines 
    COUNTRY_CAM = 71, //Cambodia 
    COUNTRY_QAT = 72, //Qatar 
    COUNTRY_KYR = 73, //Kyrgyzstan 
    COUNTRY_MAL = 74, //The maldives 
    COUNTRY_MLY = 75, //Malaysia 
    COUNTRY_MOG = 76, //Mongolia 
    COUNTRY_ARA = 77, //Saudi Arabia 
    COUNTRY_BRU = 78, //brunei 
    COUNTRY_LAO = 79, //Laos 
    COUNTRY_JAP = 80, //Japan 
    COUNTRY_RES19 = 81, //Res
    COUNTRY_PAS = 82, //Palestinian state 
    COUNTRY_TAJ = 83, //Tajikistan 
    COUNTRY_KUW = 84, //Kuwait 
    COUNTRY_SYR = 85, //Syria 
    COUNTRY_IND = 86, //India 
    COUNTRY_ISA = 87, //Indonesia 
    COUNTRY_AFG = 88, //Afghanistan 
    COUNTRY_LAN = 89, //Sri Lanka 
    COUNTRY_IRQ = 90, //Iraq 
    COUNTRY_VIE = 91, //Vietnam 
    COUNTRY_IRA = 92, //Iran 
    COUNTRY_YEM = 93, //yemen 
    COUNTRY_JOR = 94, //Jordan 
    COUNTRY_BUR = 95, //Burma 
    COUNTRY_SIK = 96, //Sikkim 
    COUNTRY_BAN = 97, //Bangladesh 
    COUNTRY_SGA = 98, //Singapore 
    COUNTRY_EAT = 99, //East timor 
    COUNTRY_RES5 = 100, //Res
    COUNTRY_RES6 = 101, //Res
    COUNTRY_RES7 = 102, //Res
    COUNTRY_RES8 = 103, //Res

    /*60*/
    COUNTRY_EGT = 104, //Egypt 
    COUNTRY_LIY = 105, //Libya 
    COUNTRY_SUA = 106, //Sudan 
    COUNTRY_TUN = 107, //Tunisia 
    COUNTRY_ALG = 108, //Algeria 
    COUNTRY_MCC = 109, //Morocco 
    COUNTRY_ETH = 110, //Ethiopia 
    COUNTRY_ERI = 111, //Eritrea 
    COUNTRY_SDE = 112, //Somalia Democratic 
    COUNTRY_DJI = 113, //Djibouti 
    COUNTRY_KEN = 114, //Kenya 
    COUNTRY_TAI = 115, //Tanzania 
    COUNTRY_UGA = 116, //Uganda 
    COUNTRY_RWA = 117, //Rwanda 
    COUNTRY_BUD = 118, //Burundi 
    COUNTRY_SEY = 119, //Seychelles 
    COUNTRY_CHA = 120, //Chad 
    COUNTRY_CEA = 121, //Central African
    COUNTRY_CON = 122, //Cameroon 
    COUNTRY_EQG = 123, //Equatorial Guinea
    COUNTRY_GAB = 124, //Gabon
    COUNTRY_TCO = 125, //the Congo
    COUNTRY_DRC = 126, //Democratic Republic of the Congo
    COUNTRY_STP = 127, //Sao Tome and Principe 
    COUNTRY_MAN = 128, //Mauritania
    COUNTRY_WSA = 129, //Western Sahara
    COUNTRY_SEL = 130, //Senegal
    COUNTRY_TGA = 131, //the Gambia
    COUNTRY_MAI = 132, //Mali
    COUNTRY_BUF = 133, //Burkina Faso 
    COUNTRY_GUI = 134, //Guinea
    COUNTRY_GUB = 135, //Guinea-Bissau 
    COUNTRY_CAV = 136, //Cape Verde
    COUNTRY_SLE = 137, //Sierra Leone 
    COUNTRY_LIR = 138, //Liberia 
    COUNTRY_IVC = 139, //Ivory Coast
    COUNTRY_GHA = 140, //Ghana
    COUNTRY_TGO = 141, //Togo
    COUNTRY_BEN = 142, //Benin
    COUNTRY_NIG = 143, //Niger
    COUNTRY_ZAB = 144, //Zambia
    COUNTRY_ANG = 145, //Angola
    COUNTRY_ZBE = 146, //Zimbabwe
    COUNTRY_MAW = 147, //Malawi
    COUNTRY_MOQ = 148, //Mozambique
    COUNTRY_BOT = 149, //Botswana
    COUNTRY_NAM = 150, //Namibia
    COUNTRY_SAF = 151, //South Africa
    COUNTRY_SWD = 152, //Swaziland 
    COUNTRY_LES = 153, //Lesotho
    COUNTRY_MAG = 154, //Madagasca
    COUNTRY_UOC = 155, //Union of Comoros 
    COUNTRY_MAT = 156, //Mauritius 
    COUNTRY_NGE = 157, //Nigeria
    COUNTRY_SSD = 158, //South Sudan 
    COUNTRY_SAH = 159, //Saint Helena 
    COUNTRY_MYT = 160, //Mayotte 
    COUNTRY_REN = 161, //Reunion 
    COUNTRY_CAI = 162, //Canary 
    COUNTRY_AZO = 163, //AZORES 
    COUNTRY_MAD = 164, //Madeira 
    COUNTRY_RES9 = 165, //Res
    COUNTRY_RES10 = 166, //Res
    COUNTRY_RES11 = 167, //Res
    COUNTRY_RES12 = 168, //Res

    /*55*/
    COUNTRY_CAD = 169, //Canada 
    COUNTRY_GRE = 170, //Greenland Nuuk 
    COUNTRY_PIE = 171, //Pierre and Miquelon 
    COUNTRY_USA = 172, //United States 
    COUNTRY_BER = 173, //Bermuda 
    COUNTRY_MEX = 174, //Mexico 
    COUNTRY_GUA = 175, //Guatemala 
    COUNTRY_BLI = 176, //Belize 
    COUNTRY_SAR = 177, //El Salvador 
    COUNTRY_HOR = 178, //Honduras 
    COUNTRY_NIC = 179, //Nicaragua 
    COUNTRY_COR = 180, //Costa Rica 
    COUNTRY_PAN = 181, //Panama 
    COUNTRY_TBM = 182, //The Bahamas 
    COUNTRY_TCI = 183, //The Turks and Caicos Islands 
    COUNTRY_CUB = 184, //Cuba 
    COUNTRY_JAM = 185, //Jamaica 
    COUNTRY_CAY = 186, //Cayman Islands 
    COUNTRY_HAT = 187, //Haiti 
    COUNTRY_TDO = 188, //The Dominican 
    COUNTRY_PUR = 189, //Puerto Rico 
    COUNTRY_VIL = 190, //The United States Virgin Islands
    COUNTRY_BVI = 191, //The British Virgin Islands 
    COUNTRY_ATV = 192, //Anguilla The Valley 
    COUNTRY_ANB = 193, //Antigua and Barbuda 
    COUNTRY_CSM = 194, //Collectivit de Saint-Martin 
    COUNTRY_ACY = 195, //Autonomous country 
    COUNTRY_SBY = 196, //Saint-Barthlemy 
    COUNTRY_SKN = 197, //Saint Kitts and Nevis 
    COUNTRY_MOT = 198, //Montserrat 
    COUNTRY_GLP = 199, //Guadeloupe
    COUNTRY_DOM = 200, //Dominica 
    COUNTRY_MTE = 201, //Martinique 
    COUNTRY_LUC = 202, //St. Lucia 
    COUNTRY_SVG = 203, //Saint Vincent and the Grenadines 
    COUNTRY_GRD = 204, //Grenada 
    COUNTRY_BAR = 205, //Barbados 
    COUNTRY_TRT = 206, //Trinidad and Tobago 
    COUNTRY_CUR = 207, //Curacao 
    COUNTRY_ARB = 208, //Aruba 
    COUNTRY_NEA = 209, //Netherlands Antilles 
    COUNTRY_COL = 210, //Colombia 
    COUNTRY_VEN = 211, //Venezuela 
    COUNTRY_GUY = 212, //Guyana 
    COUNTRY_SUR = 213, //Suriname 
    COUNTRY_FRN = 214, //Guyane Francaise 
    COUNTRY_ECU = 215, //Ecuador 
    COUNTRY_PER = 216, //Peru 
    COUNTRY_BOL = 217, //Bolivia 
    COUNTRY_PAR = 218, //Paraguay 
    COUNTRY_CLE = 219, //Chile 
    COUNTRY_BRA = 220, //Brazil 
    COUNTRY_UGY = 221, //Uruguay 
    COUNTRY_ARG = 222, //Argentina 
    COUNTRY_RES13 = 223, //Res
    COUNTRY_RES14 = 224, //Res
    COUNTRY_RES15 = 225, //Res
    COUNTRY_RES16 = 226, //Res

    /*25*/
    COUNTRY_ATN = 227, //Australien 
    COUNTRY_NED = 228, //Neuseeland 
    COUNTRY_PNG = 229, //Papua New Guinea 
    COUNTRY_SAN = 230, //Salomonen 
    COUNTRY_VAU = 231, //Vanuatu 
    COUNTRY_NCN = 232, //New Caledonia
    COUNTRY_PAU = 233, //Palau
    COUNTRY_FSM = 234, //Federated States of Micronesia
    COUNTRY_MRI = 235, //Marshall Island
    COUNTRY_CNM = 236, //Commonwealth of the Northern Mariana Islands
    COUNTRY_TEG = 237, //The Territory of Guahan
    COUNTRY_NUR = 238, //Nauru
    COUNTRY_KIB = 239, //Kiribati
    COUNTRY_FID = 240, //Fidschi
    COUNTRY_TNG = 241, //Tonga
    COUNTRY_TUV = 242, //Tuvalu
    COUNTRY_WEF = 243, //Wallis et Futuna
    COUNTRY_TIS = 244, //The Independent State of Samoa
    COUNTRY_EAS = 245, //Eastern Samoa
    COUNTRY_TOE = 246, //Tokelau
    COUNTRY_NUE = 247, //Niue
    COUNTRY_TCD = 248, //The Cook Islands
    COUNTRY_PFP = 249, //Polynsie francaiseFrench Polynesia
    COUNTRY_PID = 250, //Pitcairn Islands 
    COUNTRY_HAW = 251, //Hawaii State 
    COUNTRY_RES17 = 252, //Res
    COUNTRY_INVALID = 0xfd, //byCountryIndex extended, Try _CRIndex_
    COUNTRY_UNRECOGNIZED = 0xfe, //Unrecognized 
    COUNTRY_ALL = 0xff, //ALL  
}COUNTRY_INDEX;

typedef enum _CR_INDEX_
{
    CR_NONSUPPORT = 0,   //0-not support
    /*235 */
    /*48*/
    CR_CZE = 1, //Czech Republic 
    CR_FRA = 2, //France 
    CR_DEU = 3, //Germany 
    CR_ESP = 4, //Spain 
    CR_ITA = 5, //Italy 
    CR_NLD = 6, //Netherlands 
    CR_POL = 7, //Poland 
    CR_SVK = 8, //Slovakia 
    CR_BLR = 9, //Belarus 
    CR_MDA = 10, //Moldova 
    CR_RUS = 11, //Russia 
    CR_UKR = 12, //Ukraine 
    CR_BEL = 13, //Belgium 
    CR_BGR = 14, //Bulgaria 
    CR_DNK = 15, //Denmark 
    CR_FIN = 16, //Finland 
    CR_GBR = 17, //United Kingdom 
    CR_GRC = 18, //Greece 
    CR_HRV = 19, //Croatia 
    CR_HUN = 20, //Hungary 
    CR_ISR = 21, //Israel 
    CR_LUX = 22, //Luxembourg 
    CR_MKD = 23, //Macedonia 
    CR_NOR = 24, //Norway  
    CR_PRT = 25, //Portuga 
    CR_ROU = 26, //Romania 
    CR_SRB = 27, //Serbia 
    CR_AZE = 28, //Azerbaijan 
    CR_GEO = 29, //Georgia  
    CR_KAZ = 30, //Kazakhstan 
    CR_LTU = 31, //Lithuania 
    CR_TKM = 32, //Turkmenistan 
    CR_UZB = 33, //Uzbekistan 
    CR_LVA = 34, //Latvia 
    CR_EST = 35, //Estonia 
    CR_ALB = 36, //Albania 
    CR_AUT = 37, //Austria 
    CR_BIH = 38, //Bosnia and Herzegovina 
    CR_IRL = 39, //Ireland 
    CR_ISL = 40, //Iceland 
    CR_VAT = 41, //Vatican 
    CR_MLT = 42, //Malta 
    CR_SWE = 43, //Sweden 
    CR_CHE = 44, //Switzerland 
    CR_CYP = 45, //Cyprus 
    CR_TUR = 46, //Turkey 
    CR_SVN = 47, //Slovenia 
    CR_MTG = 48, //Montenegro 
    CR_KOV = 49, //Kosovo 
    CR_ADR = 50, //Andorra 
    CR_ARM = 51, //Armenia 
    CR_MON = 52, //Monaco 
    CR_LIE = 53, //Liechtenstein 
    CR_SMO = 54, //San Marino 
    CR_ORN = 55, //Aland 
    CR_RES2 = 56, //Res
    CR_RES3 = 57, //Res
    CR_RES4 = 58, //Res

    /*48*/
    CR_CHI = 59, //China 
    CR_IBN = 60, //In bahrain 
    CR_SKR = 61, //South Korea 
    CR_LEB = 62, //Lebanon 
    CR_NEP = 63, //Nepal  
    CR_THA = 64, //Thailand 
    CR_PAK = 65, //Pakistan 
    CR_EMI = 66, //The united Arab emirates 
    CR_BHU = 67, //Bhutan 
    CR_OMA = 68, //Oman 
    CR_KOR = 69, //North Korea 
    CR_PHI = 70, //The Philippines 
    CR_CAM = 71, //Cambodia 
    CR_QAT = 72, //Qatar 
    CR_KYR = 73, //Kyrgyzstan 
    CR_MAL = 74, //The maldives 
    CR_MLY = 75, //Malaysia 
    CR_MOG = 76, //Mongolia 
    CR_ARA = 77, //Saudi Arabia 
    CR_BRU = 78, //brunei 
    CR_LAO = 79, //Laos 
    CR_JAP = 80, //Japan 
    CR_RES19 = 81, //Res
    CR_PAS = 82, //Palestinian state 
    CR_TAJ = 83, //Tajikistan 
    CR_KUW = 84, //Kuwait 
    CR_SYR = 85, //Syria 
    CR_IND = 86, //India 
    CR_ISA = 87, //Indonesia 
    CR_AFG = 88, //Afghanistan 
    CR_LAN = 89, //Sri Lanka 
    CR_IRQ = 90, //Iraq 
    CR_VIE = 91, //Vietnam 
    CR_IRA = 92, //Iran 
    CR_YEM = 93, //yemen 
    CR_JOR = 94, //Jordan 
    CR_BUR = 95, //Burma 
    CR_SIK = 96, //Sikkim 
    CR_BAN = 97, //Bangladesh 
    CR_SGA = 98, //Singapore 
    CR_EAT = 99, //East timor 
    CR_RES5 = 100, //Res
    CR_RES6 = 101, //Res
    CR_RES7 = 102, //Res
    CR_RES8 = 103, //Res

    /*60*/
    CR_EGT = 104, //Egypt 
    CR_LIY = 105, //Libya 
    CR_SUA = 106, //Sudan 
    CR_TUN = 107, //Tunisia 
    CR_ALG = 108, //Algeria 
    CR_MCC = 109, //Morocco 
    CR_ETH = 110, //Ethiopia 
    CR_ERI = 111, //Eritrea 
    CR_SDE = 112, //Somalia Democratic 
    CR_DJI = 113, //Djibouti 
    CR_KEN = 114, //Kenya 
    CR_TAI = 115, //Tanzania 
    CR_UGA = 116, //Uganda 
    CR_RWA = 117, //Rwanda 
    CR_BUD = 118, //Burundi 
    CR_SEY = 119, //Seychelles 
    CR_CHA = 120, //Chad 
    CR_CEA = 121, //Central African
    CR_CON = 122, //Cameroon 
    CR_EQG = 123, //Equatorial Guinea
    CR_GAB = 124, //Gabon
    CR_TCO = 125, //the Congo
    CR_DRC = 126, //Democratic Republic of the Congo
    CR_STP = 127, //Sao Tome and Principe 
    CR_MAN = 128, //Mauritania
    CR_WSA = 129, //Western Sahara
    CR_SEL = 130, //Senegal
    CR_TGA = 131, //the Gambia
    CR_MAI = 132, //Mali
    CR_BUF = 133, //Burkina Faso 
    CR_GUI = 134, //Guinea
    CR_GUB = 135, //Guinea-Bissau 
    CR_CAV = 136, //Cape Verde
    CR_SLE = 137, //Sierra Leone 
    CR_LIR = 138, //Liberia 
    CR_IVC = 139, //Ivory Coast
    CR_GHA = 140, //Ghana
    CR_TGO = 141, //Togo
    CR_BEN = 142, //Benin
    CR_NIG = 143, //Niger
    CR_ZAB = 144, //Zambia
    CR_ANG = 145, //Angola
    CR_ZBE = 146, //Zimbabwe
    CR_MAW = 147, //Malawi
    CR_MOQ = 148, //Mozambique
    CR_BOT = 149, //Botswana
    CR_NAM = 150, //Namibia
    CR_SAF = 151, //South Africa
    CR_SWD = 152, //Swaziland 
    CR_LES = 153, //Lesotho
    CR_MAG = 154, //Madagasca
    CR_UOC = 155, //Union of Comoros 
    CR_MAT = 156, //Mauritius 
    CR_NGE = 157, //Nigeria
    CR_SSD = 158, //South Sudan 
    CR_SAH = 159, //Saint Helena 
    CR_MYT = 160, //Mayotte 
    CR_REN = 161, //Reunion 
    CR_CAI = 162, //Canary 
    CR_AZO = 163, //AZORES 
    CR_MAD = 164, //Madeira 
    CR_RES9 = 165, //Res
    CR_RES10 = 166, //Res
    CR_RES11 = 167, //Res
    CR_RES12 = 168, //Res

    /*55*/
    CR_CAD = 169, //Canada 
    CR_GRE = 170, //Greenland Nuuk 
    CR_PIE = 171, //Pierre and Miquelon 
    CR_USA = 172, //United States 
    CR_BER = 173, //Bermuda 
    CR_MEX = 174, //Mexico 
    CR_GUA = 175, //Guatemala 
    CR_BLI = 176, //Belize 
    CR_SAR = 177, //El Salvador 
    CR_HOR = 178, //Honduras 
    CR_NIC = 179, //Nicaragua 
    CR_COR = 180, //Costa Rica 
    CR_PAN = 181, //Panama 
    CR_TBM = 182, //The Bahamas 
    CR_TCI = 183, //The Turks and Caicos Islands 
    CR_CUB = 184, //Cuba 
    CR_JAM = 185, //Jamaica 
    CR_CAY = 186, //Cayman Islands 
    CR_HAT = 187, //Haiti 
    CR_TDO = 188, //The Dominican 
    CR_PUR = 189, //Puerto Rico 
    CR_VIL = 190, //The United States Virgin Islands
    CR_BVI = 191, //The British Virgin Islands 
    CR_ATV = 192, //Anguilla The Valley 
    CR_ANB = 193, //Antigua and Barbuda 
    CR_CSM = 194, //Collectivit de Saint-Martin 
    CR_ACY = 195, //Autonomous country 
    CR_SBY = 196, //Saint-Barthlemy 
    CR_SKN = 197, //Saint Kitts and Nevis 
    CR_MOT = 198, //Montserrat 
    CR_GLP = 199, //Guadeloupe
    CR_DOM = 200, //Dominica 
    CR_MTE = 201, //Martinique 
    CR_LUC = 202, //St. Lucia 
    CR_SVG = 203, //Saint Vincent and the Grenadines 
    CR_GRD = 204, //Grenada 
    CR_BAR = 205, //Barbados 
    CR_TRT = 206, //Trinidad and Tobago 
    CR_CUR = 207, //Curacao 
    CR_ARB = 208, //Aruba 
    CR_NEA = 209, //Netherlands Antilles 
    CR_COL = 210, //Colombia 
    CR_VEN = 211, //Venezuela 
    CR_GUY = 212, //Guyana 
    CR_SUR = 213, //Suriname 
    CR_FRN = 214, //Guyane Francaise 
    CR_ECU = 215, //Ecuador 
    CR_PER = 216, //Peru 
    CR_BOL = 217, //Bolivia 
    CR_PAR = 218, //Paraguay 
    CR_CLE = 219, //Chile 
    CR_BRA = 220, //Brazil 
    CR_UGY = 221, //Uruguay 
    CR_ARG = 222, //Argentina 
    CR_RES13 = 223, //Res
    CR_RES14 = 224, //Res
    CR_RES15 = 225, //Res
    CR_RES16 = 226, //Res

    /*25*/
    CR_ATN = 227, //Australien 
    CR_NED = 228, //Neuseeland 
    CR_PNG = 229, //Papua New Guinea 
    CR_SAN = 230, //Salomonen 
    CR_VAU = 231, //Vanuatu 
    CR_NCN = 232, //New Caledonia
    CR_PAU = 233, //Palau
    CR_FSM = 234, //Federated States of Micronesia
    CR_MRI = 235, //Marshall Island
    CR_CNM = 236, //Commonwealth of the Northern Mariana Islands
    CR_TEG = 237, //The Territory of Guahan
    CR_NUR = 238, //Nauru
    CR_KIB = 239, //Kiribati
    CR_FID = 240, //Fidschi
    CR_TNG = 241, //Tonga
    CR_TUV = 242, //Tuvalu
    CR_WEF = 243, //Wallis et Futuna
    CR_TIS = 244, //The Independent State of Samoa
    CR_EAS = 245, //Eastern Samoa
    CR_TOE = 246, //Tokelau
    CR_NUE = 247, //Niue
    CR_TCD = 248, //The Cook Islands
    CR_PFP = 249, //Polynsie francaiseFrench Polynesia
    CR_PID = 250, //Pitcairn Islands 
    CR_HAW = 251, //Hawaii State 
    CR_RES17 = 252, //Res
    CR_RES18 = 253, //Res
    CR_UNRECOGNIZED = 0xfe, //Unrecognized 
    CR_ALL = 0xff, //ALL  

    //region
    CR_TAIWAN = 256, //Taiwan(China) 
}CR_INDEX;


//Area of The United Arab Emirates emun
typedef enum _EMI_AREA_
{
    EMI_AREA_UNKNOWN = 0,        //Unknown Area
    EMI_AREA_AD,                //Abu Dhabi
    EMI_AREA_FJR,               //Fuchayiha
    EMI_AREA_DB,                //Dubai
    EMI_AREA_RAK,               //Ras al Khaimah
    EMI_AREA_AM,                //Ajman
    EMI_AREA_SJ,                // Sharjah
    EMI_AREA_UMW,               //Umm al Qaiwain
    EMI_AREA_OTHER = 0xff,       //Unrecognized
} EMI_AREA;

typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         //Structure size
    LONG   lChannel;       //Channel number
    BYTE   byFileType;
    /*Image type to search: 0- scheduled capture, 1- motion detection capture, 2- alarm capture,
    3- motion detection or alarm capture, 3-motion detection and alarm capture, 6- manual capture,
    9-VCA, 0x0d facedetect,0xe NULL,Oxf field detection,0x25-face snap,0x26-Offline temperature alarm,
    0x2a-getup,0x2b-advreschheight,0x2c-toilettarry,0x2d-safetyHelmet,0x2e-perimeterCapture,0x2f-humanRecognition,
    0x30-faceSnapModeling, 0x31-mixedTargetDetection,0x32-alarmInAlarm,0x33-emergenceCall,0x34-consultAlarm,
    0x35-unregisteredStreetVendor,0x36-personDensity,0x37-leavePosition,0x38-people number change, 0x39-violent motion,
    0x3a-illegalParking,0x3b-wrongDirection,0x3c-crossLane,0x3d-vehicleExist,0x3e-laneChange,0x3f-turnRound,0x40-pedestrian,
    0x41-roadBlock,0x42-abandonedObject,0x43-fogDetection,0x44-construction,0x45-congestion,0x46-trafficAccident,
    0x47-parallelParking,0x48-manualTriggerAlarm,0x49-playCellphone,0x4a- face recognition,0x4b- driver driving behavior,
    0x4c- advanced auxiliary driving,0x4d- sand-dredging ship detection and alarm,0x4e- license plate recognition,
    0x52-personQueueCounting,0x53-personQueueTime,0x54-vehicleMonitor(three Types of vehicleMonitor),0x55-timingArousingCapture,
    0x58-vibrationDetection,0x59-running,0x5a-retention,0x5b-spacingChange,0x5c-failDown, 0x5d-smokeDetectAlarm,0x5e-vehiclepass,0x5f-breakban,
    0x60-ocplane,0x61-largeVehicleOccupyLine,0x62-plateblack,0x63-occupylane,0x64-smokeDetection,0x65-ReID people track,0x66-channel timing recording,
    0x67-AI open platform, 0x68-methane concentration exception, 0x69-methane light intensity exception,0x70-Professional channel image Schedule Capture, 0xff-All types*/
    BYTE   byNeedCard;     //Whether need card number
    BYTE   byProvince;     //Province
    BYTE   byEventType;      // 0-Res,1-Traffic incident;2-Illegal evidence;3-other
    BYTE   sCardNum[CARDNUM_LEN_V30];     //Card number
    NET_DVR_TIME  struStartTime;//Start time of image search
    NET_DVR_TIME  struStopTime;//End time of image search
    //ITC3.7 Newly added
    DWORD    dwTrafficType; //Image retrieval; Reference  VCA_OPERATE _TYPE 
    DWORD    dwVehicleType; //Vehicle Type; Reference VCA_VEHICLE_TYPE
    //Illegal Type; Reference VCA_ILLEGAL_TYPE ;Not support check
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //Lane No. (1~99)
    BYTE     bySubHvtType;//0- retention, 1- vehiclem, 2- Non-Motor Vehicle, 3- Pedestrians
    BYTE     bySubDriveType;  //Driver subtype
    // when byFileType is 0x4b - the driver driving behavior, meaning for the driver driving behavior type, specific definition : 0 to retain, answer a smoke 1 - , 2 - , 3 - fatigue, distraction to remind, 5 - 4 - the pilot abnormalities, 6 - not wearing a seatbelt, 7 - infrared blocking, sunglasses, 8 - both hands off the steering wheel, 9 - one hand from the steering wheel, the 10 - driver abnormal status, 11 - 12 - driving, the driver overtime changes
    // when byFileType is 0x4c - advanced auxiliary driving, meaning for advanced auxiliary driving type, specific definition : 0 - keep, 1 - to collision, 2 - lane departure(left), 3 - lane departure(right), 4 - too close to the vehicles, 5 - pedestrian crash, 6 - blind spot detection(right rear), 7 - blind spot detection(left behind), 8 - blind spot detection(rear)    
    BYTE   byRes2;//reserve
    char     sLicense[MAX_LICENSE_LEN/*16*/];    //License No
    BYTE     byRegion;     //Region index value, 0 reserved, 1 Europe, 2 Russia(Russian regions), 3-EU&&CIS,4-Middle East,0xff- all
    BYTE     byCountry;     // Country INdex ,Reference:COUNTRY_INDEX
    BYTE     byArea;        //Area of Country
    BYTE     byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char cStartTimeDifferenceH;  
    char cStartTimeDifferenceM;  
    char cStopTimeDifferenceH;   
    char cStopTimeDifferenceM;   
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

typedef struct tagNET_DVR_FIND_FILE_PCNVR
{
    DWORD           dwSize;     
    NET_DVR_IPADDR  struIpAddr; 
    WORD            wIpPort;    
    BYTE            byRes[2];   
    char            sDomainName[MAX_DOMAIN_NAME];
    char            sSerial[SERIALNO_LEN];
    DWORD           lChannel;               
    DWORD           dwFileType;           
    DWORD           dwIsLocked;            
    DWORD           dwUseCardNo;          
    BYTE            sCardNumber[CARDNUM_LEN_V30];
    NET_DVR_TIME    struStartTime;     
    NET_DVR_TIME    struStopTime;    
}NET_DVR_FILE_COND_PCNVR, *LPNET_DVR_FILE_COND_PCNVR;

typedef struct tagNET_DVR_FINDDATA_PCNVR
{
    char sFileName[100];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struStopTime;
    DWORD dwFileSize;
    char sCardNum[CARDNUM_LEN_V30];
    BYTE byLocked;
    BYTE byFileType;  
    BYTE byRes[2];
}NET_DVR_FINDDATA_PCNVR, *LPNET_DVR_FINDDATA_PCNVR;

#define PICTURE_NAME_LEN 64
#define PICTURE_INFO_MAX_SIZE 640*960*1.5

typedef struct
{
    char    sFileName[PICTURE_NAME_LEN];//Picture name
    NET_DVR_TIME struTime;              //Time of picture capture
    DWORD dwFileSize;                   //Picture size 
    char    sCardNum[CARDNUM_LEN_V30];    //Card number
    BYTE   byPlateColor;               //Reference  VCA_PLATE_COLOR
    BYTE   byVehicleLogo;               //Reference  VLR_VEHICLE_CLASS
    BYTE   byEventSearchStatus; //0-back without pic info,1-next with pic info
    BYTE   byRecogResult;//Recog RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //Car Liscense
    BYTE   byRes[12];
}NET_DVR_FIND_PICTURE, *LPNET_DVR_FIND_PICTURE;

#define MAX_RECORD_PICTURE_NUM  50      //  Max number of backup pictures 

typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         //Structure size
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*Whether continue to backup or not: 0-no, 1-yes*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct
{
    DWORD dwSize;           //Structure size
    DWORD dwChannel;        //Channel number
    BYTE  byCompressType;   //Compression type to be got: 1- main stream, 2- sub stream, 3- event 
    BYTE  byRes[15];        //Reserved
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //Current compression configuration
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

#define   STEP_READY       0    //Ready to upgrade
#define   STEP_RECV_DATA   1    //Receive upgrade package data
#define   STEP_UPGRADE     2    //Upgrade system
#define   STEP_BACKUP      3    //Backup system
#define   STEP_SEARCH      255  //Search upgrade file

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //Brightness value[0,255]
    DWORD dwContrastValue;    //Contrast value[0,255]
    DWORD dwSaturationValue;  //Saturation value[0,255]
    DWORD dwHueValue;         //Hue value[0,255]
    DWORD dwSharpness;          //Sharpness[0,255]
    DWORD dwDenoising;          //Denoising[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{
    DWORD                    dwSize;             //Structure size
    WORD                    wEffectMode;        //Mode: 0-Standard, 1-In door,  2-Dim light, 3-Out door,  255-customized 
    BYTE                    byRes1[146];        //Reserved
    NET_DVR_VIDEO_EFFECT    struVideoEffect;    //Video effect
    BYTE                    byRes2[60];         //Reserved
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;

typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD    dwChannel;            // Channel number
    DWORD    dwVideoParamType;      // Video param type 0-bright 1-contrast 2-saturation 3-hue 4-sharpness 5-denoising
    DWORD    dwVideoParamValue;  // Video param value
    BYTE     byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwVideoMode;
    BYTE    byRes[32];
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

/*********************************9000 2.0 end***************************************/

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD    dwSize;            //Structure size
    BYTE    byJointed;        //0- not associated  1- associated
    BYTE    byDevType;        //Associated device type, 1- intelligent device
    BYTE    byRes1[2];        //Reserved
    NET_DVR_IPADDR    struIP;    //IP address of associated device to be taken stream 
    WORD    wPort;            //Port of associated device to be taken stream  
    WORD    wChannel;        //Associated device channel to be taken stream   
    BYTE    byRes2[20];        //Reserved
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE    byJointed;                //0- not associated  1- associated
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;            //IP address of associated device to take stream 
    WORD    wPort;                    //Port of associated device to take stream  
    WORD    wChannel;                //Associated device channel to take stream  
    BYTE    byVcaChanStatus;        //0 - disable, 1 - enable
    BYTE    byRes2[19];                //Reserved
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD    dwSize;            //Structure size
    BYTE    byDeviceStatus;    //Device status: 0- normal, 1- abnormal
    BYTE    byCpuLoad;        //CPU usage: 0-100 means percentage
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD    dwRes[40];        // Reserved
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

/*****************************65dvs**************************************/
typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //History data total number
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;
/************************************************************************/

/********************************Thermal Imager********************************/
typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //Command: 0- enter bad point  mode, 1- add bad point, 2- save bad point, 3- exit bad point 
    DWORD dwDeadPixelX; //X coordinate of bad point
    DWORD dwDeadPixelY; //Y coordinate of bad point
    BYTE byRes[12]; //Reserved
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

#define MAX_REDAREA_NUM   6   

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;
    BYTE byDigTrafficLight;
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS, *LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable;
    DWORD dwCorrectLevel;
    DWORD dwAreaNum;
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM];
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/];
    BYTE   byRes2[8];
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

/********************************Thermal Imager end****************************/

/***********************************81 Inquest DVR*****************************/
#define INQUEST_MESSAGE_LEN     44    //Length of inquest key tag message
#define INQUEST_MAX_ROOM_NUM    2     //Max number of inquest rooms
#define MAX_RESUME_SEGMENT      2     //Number of segments supported to resume simultaneously

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE        byRoomIndex;     //Inquest room index
    BYTE        byFileType;
    BYTE        byMode;     // normal mode when mode=0, else 1-filmMode  2-pinpR  3- pinpL  4-split2    5-L1R2  6-L2R1  7-L1R3   8-L3R1
    BYTE        byQuick;     //quickConfig,  Works only when mode>0
    BYTE        byRes[20];       //Reserved
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char     sMessage[INQUEST_MESSAGE_LEN]; //Key marker information
    BYTE    byRes[46];                     //Reserved
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD    wDeviceType;    //Data collection device type: 1: Mera, 2:Leicai, 3:Leicai
    WORD    wDeviceAddr;    //Data collection device address    
    BYTE     byRes[28];        //Reserved
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //Supported protocol type, described by bit
    //0x1:Mera, 0x2:Leicai, 0x4:Youli
    BYTE    byRes[120];        //Reserved
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char        szCDName[NAME_LEN];    //cd name
    union
    {
        BYTE     byBitRate;
        BYTE    byInquestTime;
    }uCalcMode;
    BYTE        byCalcType;            //0-Bit 1-time
    BYTE        byAutoDelRecord;    // Auto del record 0-not del,1-del
    BYTE        byAlarmThreshold;        // Alarm threshold
    BYTE        byInquestChannelResolution;     //0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE        byAutoOpenTray;        //Whether automatic open tray 0 - no, 1 - yes 
    BYTE        byCDPrintEnabled;      //CDPrintEnabled  0-no 1-yes
    BYTE        byRes[9];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD    dwRecordMode;         //Burning mode: 1 Single room and double burned mode, 2- Single room and round burned mode, 3- double room and double burned mode
    DWORD    dwWorkMode;           //Working mode: 0- standard mode, 1- general mode
    DWORD    dwResolutionMode;     //Device resolution, 0: standard definition 1:D1 2:720P 3:1080P
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //Temperature and humidity sensor configuration
    NET_DVR_INQUEST_ROOM_INFO     struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE    byEnableHashCheck;        //enable HASH check or not, 0-invalid,1-disable,2-enable
    BYTE    byEnableInitCD;        //enable initial disk or not, 0-invalid,1-disable,2-enable
    BYTE    byCDProcessingMode;    //CD Processing Mode,1-,2-
    BYTE    byRes[21];             //Reserved
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //Start time of event
    NET_DVR_TIME  struStopTime;  //End time of event
    BYTE    byRoomIndex;         //Inquest room index, start from 1
    BYTE    byDriveIndex;        //Burner index, start from 1
    WORD    wSegmetSize;         //Segment size, unit:M 
    DWORD   dwSegmentNo;         //Segment number of this inquest event, start from 1 
    BYTE    byRes[24];           //Reserved
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct _NET_DVR_TRAY_ABNORMAL_ALARM_
{
    DWORD dwSize;
    DWORD dwAlarmType;    /*Alarm type 0-tray full 1-tray error  2-Inquest Over Time Notification*/
    BYTE byTrayNo;     /*Tray No.*/
    BYTE byRes[3];
    DWORD dwInquestTime;   /*Inquested Time. unit:sec*/
    DWORD dwNotifyChannel; /*Channel of Inquest Over Time Notification */
    BYTE byRes1[244];
}NET_DVR_INQUEST_ALARM, *LPNET_DVR_TRAY_ABNORMAL_ALARM;

typedef struct _NET_DVR_VIDEO_PARKING_POLE_ALARM_
{
    DWORD  dwSize;  //size
    NET_DVR_TIME_V30  struTime;  //time
    BYTE  byParkingNum[32];  //parking number
    BYTE  byAlarmType;  //alarm type 0-unknown,1-lensOcclusion, 2-button alarm, 3-illegalOccupation, 4-vehicle Enter State
    BYTE  byVehicleEnterState; //vehicle Enter State, 0-unknown, 1-enter, 2-leave
    BYTE  byRes[78];
}NET_DVR_VIDEO_PARKING_POLE_ALARM, *LPNET_DVR_VIDEO_PARKING_POLE_ALARM;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //Number of events requiring to be resumed
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE    byResumeMode;
    BYTE    byCDPrintEnbled;    //CD Print Enbled 0-no  1-yes
    BYTE    byRes[198];        //Reserved
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
    BYTE  byMainVersion;         /* Baseline major version
                                   0 : unknown
                                   1 : 8000 inquest DVR
                                   minor version: 1 : 8000HD-S
                                   2 : 8100 inquest DVR
                                   minor version: 1 : inquest 81SNL
                                   2 : inquest 81SH
                                   3 : inquest 81SFH
                                   3 : 8608 NVR
                                   minor version: 1 : DS-8608SN-SP
                                   2 : DS-8608SN-ST
                                   */
    BYTE  bySubVersion;          //Baseline minor version
    BYTE  byUpgradeVersion;      //Upgrade version, it is 0 if have not upgraded
    BYTE  byCustomizeVersion;    //Customized version, it is 0 if the device is not customized
    BYTE  byRes[60];             //Reserved
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

/***********************************81 Inquest DVR*****************************/


typedef struct tagNET_DVR_DISK_RAID_INFO
{
    DWORD dwSize;       //Structure length
    BYTE byEnable;      //Is enbale of disk raid.
    BYTE bySleepStatus;
    BYTE byRes[34];     //reserved
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;

typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //Structure length
    BYTE  byEnable;  //Do synchronize IPC.
    BYTE  byRes[7];  //reserved
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //Structure length
    char sOldPasswd[PASSWD_LEN];  //the old passward of IPC.
    char sNewPasswd[PASSWD_LEN];  //the new passward of IPC
    BYTE byRes[32];               //reserved
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

//Get the using information of device net. (bps)
typedef struct tagNET_DEVICE_NET_USING_INFO
{
    DWORD dwSize;      //Structure length
    DWORD dwPreview;   //preview
    DWORD dwPlayback;  //playback
    DWORD dwIPCModule; //IPC
    DWORD dwNetDiskRW; //net disk reading or writing.
    BYTE res[32];      //reserved
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

//Set the IP of IPC.
typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;           //Structure length
    NET_DVR_IPADDR struIP;  //IP
    WORD wPort;             //Port
    char res[126];          //reserved
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

//lock by time
typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //size
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //channel no., 0xff: all channel
    DWORD   dwRecordType;     //record type
    DWORD   dwLockDuration;   //duration time, 0xffffffff: always lock
    NET_DVR_TIME_EX strUnlockTimePoint;
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //size
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    BYTE         byISO8601;     
    char         cTimeDifferenceH;    
    char         cTimeDifferenceM;    
    BYTE         byRes[17];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;

//***channel record state*****//
typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE byValid;       //Enable
    BYTE byRecord;      //(only read)record type:0: not recording; 1: recording
    WORD wChannelNO;    //Channel NO.
    DWORD dwRelatedHD;  //Disk NO.
    BYTE    byOffLineRecord;  // 0-off 1-on
    BYTE byRes[7];      //Reserved
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;


typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //Structure size
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //One group has 64 channel
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;

typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; //X Coordinate of upper left corner point in rectangle
    WORD wYCoordinate; //Y Coordinate of upper left corner point in rectangle
    WORD wWidth;       //width of rectangle
    WORD wHeight;      //height of rectangle
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;
typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;
    BYTE  byLayerIdx;
    BYTE  byTransparency;
    NET_DVR_RECTCFG  struWin;
    WORD wScreenHeight;
    WORD wScreenWidth;
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

#define  MAX_LAYERNUMS    32

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

typedef struct tagNET_MATRIX_TRUNKPARAM
{
    DWORD    dwSize;
    DWORD    dwTrunkId;
    BYTE    sTrunkName[NAME_LEN];
    DWORD    dwSrcMonId;
    DWORD    dwDstCamId;
    BYTE    byTrunkType;  
    BYTE    byAbility;     
    BYTE    bySubChan; 
    BYTE    byLevel;    
    WORD    wReserveUserID;
    BYTE   byRes[18];
} NET_MATRIX_TRUNKPARAM, *LPNET_MATRIX_TRUNKPARAM;

typedef struct tagNET_DVR_MATRIX_TRUNKLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwTrunkNum;
    BYTE    *pBuffer;
    DWORD   dwBufLen;
}NET_DVR_MATRIX_TRUNKLIST, *LPNET_DVR_MATRIX_TRUNKLIST;

#define MATRIX_PROTOCOL_NUM    20   
#define KEYBOARD_PROTOCOL_NUM  20   
typedef struct tagNET_DVR_PROTO_TYPE_EX
{
    WORD wType;             
    WORD wCommunitionType;        
    BYTE  byDescribe[DESC_LEN]; 
}NET_DVR_PROTO_TYPE_EX, LPNET_DVR_PROTO_TYPE_EX;

typedef struct tagNET_DVR_MATRIXMANAGE_ABIILITY
{
    DWORD    dwSize;
    DWORD    dwMaxCameraNum;
    DWORD    dwMaxMonitorNum;
    WORD    wMaxMatrixNum;
    WORD    wMaxSerialNum;
    WORD    wMaxUser;
    WORD    wMaxResourceArrayNum;
    WORD    wMaxUserArrayNum;
    WORD    wMaxTrunkNum;
    BYTE    nStartUserNum;
    BYTE    nStartUserGroupNum;
    BYTE    nStartResourceGroupNum;
    BYTE    nStartSerialNum;
    DWORD   dwMatrixProtoNum;    
    NET_DVR_PROTO_TYPE_EX struMatrixProto[MATRIX_PROTOCOL_NUM];
    DWORD   dwKeyBoardProtoNum;     
    NET_DVR_PROTO_TYPE_EX struKeyBoardProto[KEYBOARD_PROTOCOL_NUM];
    BYTE   byDelMonitorLongCfg;  
    BYTE   byDelCamonitorLongCfg;
    BYTE   byAudioSwitchContorl;
    BYTE    byRes[29];
} NET_DVR_MATRIXMANAGE_ABILITY, *LPNET_DVR_MATRIXMANAGE_ABILITY;


/********************************Intelligent Face Recognition****************************/
//Face snapshot rule(single)
typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;       //Whether to activate the rule: 0- no, 1- yes
    /********* IPC5.1.7 parameters Begin 2014-03-21***********/
    //Automatic Face ROI Enables
    BYTE byAutoROIEnable;//0-Close,1-Open
    BYTE byRes[2];
    /********* IPC5.1.7 parameters End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //Size filter
    NET_VCA_POLYGON     struVcaPolygon;      //Face recognition region
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

//Face snapshot rules
typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;                    //Total snapshot number of single target face: 0-10
    BYTE bySnapInterval;                //Snapshot interval, unit: frame
    BYTE bySnapThreshold;               //Snapshot threshold: 0-100
    BYTE byGenerateRate;                 //Target generation speed, value range: [1, 5]    
    BYTE bySensitive;                    //Target detection sensitivity, value range: [1, 5]
    BYTE byReferenceBright; //2012-3-27Reference bright[0,100]
    BYTE byMatchType;         //2012-5-3match alarm type,0-target disappear alarm,1-real time alarm
    BYTE byMatchThreshold;  //2012-5-3real time match threshold,0~100
    NET_DVR_JPEGPARA  struPictureParam; //JPEG picture specification structure
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //Face snapshot rule
    //Face exposure shortest duration
    WORD wFaceExposureMinDuration;//(1~3600s, Default 60)Effective in automatic mode
    //Face exposure Mode
    BYTE byFaceExposureMode;//1-Close,2-Open,0-automatic
    BYTE byBackgroundPic;//Back Ground Pic Upload Enable 0-open,1-close
    DWORD dwValidFaceTime;    //Effective face the shortest duration, unit: second
    DWORD dwUploadInterval; //Face capture statistical data upload time interval, the unit: seconds, the default 900 seconds
    DWORD dwFaceFilteringTime;//0-100s
    BYTE  bySceneID;     //Scene ID,1~4
    BYTE byInvalCapFilterEnable;   //Face Invalid CapFilter Enable, 0-close, 1-open, default:0
    BYTE byInvalCapFilterThreshold;//Face Invalid CapFilter Threshold, range:[0,100], worked when byInvalCapFilterEnable is 1 
    BYTE byRes2[81];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

typedef struct tagNET_DVR_FIRMWARE_VERSION_IFNO
{
    DWORD       dwSize;
    char        szFirmwareVersion[LEN_PROPERTY/*128*/];
    BYTE        byRes2[128];
}NET_DVR_FIRMWARE_VERSION_IFNO, *LPNET_DVR_FIRMWARE_VERSION_IFNO;

//Age Group
typedef enum tagHUMAN_AGE_GROUP_ENUM
{
    ENUM_AGE_GROUP_INFANT = 1,   //Infant
    ENUM_AGE_GROUP_CHILD = 2,   //Children        
    ENUM_AGE_GROUP_YOUNGSTER = 3,   //Youngster
    ENUM_AGE_GROUP_ADOLESCENT = 4,   //Adolescent
    ENUM_AGE_GROUP_YOUTH = 5,   //Youth
    ENUM_AGE_GROUP_PRIME = 6,   //Prime
    ENUM_AGE_GROUP_MIDLIFE = 7,   //Midlife
    ENUM_AGE_GROUP_MIDAGE = 8,   //Midage
    ENUM_AGE_GROUP_OLD = 9,    //Old
    ENUM_AGE_GROUP_ALL = 0xfe,    //all
    ENUM_AGE_GROUP_UNKNOW = 0xff   //unknown
} HUMAN_AGE_GROUP_ENUM;

//faceExpression
typedef enum tagFACE_EXPRESSION_GROUP_ENUM
{
    ENUM_EXPRESSION_GROUP_SURPRISED = 1,   //surprised
    ENUM_EXPRESSION_GROUP_PANIC = 2,   //panic
    ENUM_EXPRESSION_GROUP_DISGUUSTED = 3,   //disgusted
    ENUM_EXPRESSION_GROUP_HAPPY = 4,   //happy
    ENUM_EXPRESSION_GROUP_SAD = 5,   //sad
    ENUM_EXPRESSION_GROUP_ANGRY = 6,   //angry
    ENUM_EXPRESSION_GROUP_POKER = 7,   //poker-faced
    ENUM_EXPRESSION_GROUP_ALL = 0xfe,    //all
    ENUM_EXPRESSION_GROUP_UNKNOW = 0xff   //unknown
}FACE_EXPRESSION_GROUP_ENUM;

typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//Seconds [0.000,60.000]
    BYTE byDegree;//Degree :Latitude[0,90] Longitude[0,180]
    BYTE byMinute;//Minute[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

typedef struct tagNET_DVR_LLPOS_PARAM
{
    BYTE   byLatitudeType;
    BYTE   byLongitudeType;
    BYTE   byRes1[2];
    NET_DVR_LLI_PARAM    struLatitude;
    NET_DVR_LLI_PARAM    struLongitude;
    BYTE   byRes[16];
}NET_DVR_LLPOS_PARAM, *LPNET_DVR_LLPOS_PARAM;

//face snap additional information structure
typedef struct tagNET_VCA_FACESNAP_ADDINFO
{
    //face small picture rectangle
    NET_VCA_RECT  struFacePicRect;
    int    iSwingAngle;//Swing Angle, -90-90
    int    iTiltAngle;//Tilt Angle, -90-90
    DWORD  dwPupilDistance;//Pupil Distance,min = 10,max=current resolution/1.6
    BYTE   byBlockingState;//byBlockingState, 0-not support, 1-no, 2-mid, 3-countinue, 4-serious, 5~OSD
    BYTE   byFaceSnapThermometryEnabled;//1-open 0-close
    BYTE   byIsAbnomalTemperature;//1-yes 0-no
    BYTE   byThermometryUnit;//
    NET_DVR_TIME_EX  struEnterTime;   // enter Time
    NET_DVR_TIME_EX  struExitTime;    // exit Time
    float       fFaceTemperature; 
    float       fAlarmTemperature;
    DWORD   dwThermalPicLen;
    BYTE    *pThermalPicBuff;
    BYTE    szCustomChanID[65];// CustomChanID  string  max.len = 64
    BYTE    byRes1[3];// res
    NET_DVR_LLPOS_PARAM struLLPos;//Longitude and latitude location information of the device
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*    pEventNotificationAlertBuff;//EventNotificationAlert JSON Block("eventType":  "faceCapture")
#else
    char*   pEventNotificationAlertBuff;//EventNotificationAlert JSON Block("eventType":  "faceCapture")
    BYTE  byRes2[4];
#endif
    DWORD   dwEventNotificationAlertLen;
    BYTE    byRes[340];// res
}NET_VCA_FACESNAP_ADDINFO, *LPNET_VCA_FACESNAP_ADDINFO;

//Face snapshot result
typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;             //Structure size
    DWORD     dwRelativeTime;     //Relative time
    DWORD    dwAbsTime;            //Absolute time
    DWORD   dwFacePicID;        //Face picture ID
    DWORD   dwFaceScore;        //Face score: 0-100
    NET_VCA_TARGET_INFO  struTargetInfo;    //Alarm target information
    NET_VCA_RECT         struRect;          //Face subgraph area 
    NET_VCA_DEV_INFO       struDevInfo;        //Front-end device information
    DWORD   dwFacePicLen;        //The length of face subgraph: 0- no picture, larger than 0- there is related picture
    DWORD   dwBackgroundPicLen; //The length of background picture: 0- no picture, larger than 0- there is related picture(reserved)
    BYTE    bySmart;//IDS Return 0(default),Smart Return 1
    BYTE    byAlarmEndMark;//Alarm End Mark;0-Retain,1-Alarm End Mark
    BYTE    byRepeatTimes;
    BYTE    byUploadEventDataType;//pBuffer1 images Upload Type: 0-binaty,1-URL
    NET_VCA_HUMAN_FEATURE   struFeature;  //Human attributes
    float   fStayDuration; //Stay in the picture time (unit: s)
    char    sStorageIP[16];
    WORD    wStoragePort;
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byFacePicQuality;//face picture quality
    BYTE    byUIDLen;     //Upload alarm ID length
    BYTE    byLivenessDetectionStatus;// LivenessDetectionStatus 0-res, 1-unknown, 2-notLive, 3-live, 4-unopen liveness detection
    BYTE    byAddInfo;//additional information 0-no 1-yes
    BYTE    *pUIDBuffer;  //pointer 
    BYTE   *pAddInfoBuffer;//additional information pointer
    BYTE    byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char    cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char    cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE    byBrokenNetHttp;     //Broken Net Http,0-Not a retransmission data,1- retransmission data
    BYTE*   pBuffer1;           //Picture data of face subgraph
    BYTE*   pBuffer2;           //Picture data of background picture(reserved)
    //(can be got by the API of searching background picture--NET_DVR_FindBackgroundPic)
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD      dwSize;
    DWORD        dwRelativeTime; //Relative Time
    DWORD       dwAbsTime; //Abs Time
    DWORD      dwBackgroundPicLen; //Background Pictrue Len
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//Face Pictrue
    BYTE   byFacePicNum;//Pictru NUm
    BYTE   byUploadEventDataType;//Image data long transmission way: 0-binary data, 1-url
    WORD   wDevInfoIvmsChannelEx; //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE   byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char   cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char   cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE   byRes[249];
    BYTE*  pBackgroundPicpBuffer; //Background Pictrue Buffer
}NET_DVR_FACE_DETECTION, *LPNET_DVR_FACE_DETECTION;

typedef struct tagNET_DVR_UPGRADE_PARAM
{
    DWORD dwUpgradeType;
    char *sFileName;
    void *pInbuffer;
    DWORD dwBufferLen;
    char *pUnitIdList[64];
    BYTE  byRes[112];
}NET_DVR_UPGRADE_PARAM, *LPNET_DVR_UPGRADE_PARAM;

//defous result
typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     //Structure size
    NET_VCA_DEV_INFO       struDevInfo;    //Front-end device information
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes1[2];     //reserved
    DWORD  dwRelativeTime; //relative
    DWORD     dwAbsTime; //absolute    
    BYTE   byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char   cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char   cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE   byRes[49];    //Reserved
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

//dense fog result
typedef struct  tagNET_DVR_DENSEFOGDETECTION_ALARM
{
    DWORD   dwSize;     //Structure size
    NET_VCA_DEV_INFO       struDevInfo; //device information
    DWORD  dwRelativeTime; //relative
    DWORD     dwAbsTime; //absolute
    BYTE    byFogLevel; //fog level,0-none-mist ,1-mist, 2-dense fog, 3-thick fog
    BYTE    byRes[259];
}NET_DVR_DENSEFOGDETECTION_ALARM, *LPNET_DVR_DENSEFOGDETECTION_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     //Structure size
    BYTE  byAlarmType;//alarmType,1-audio input exception,2-audio input changed,3-audio steep fall ,4-audio Loss
    BYTE  byRes1;
    WORD wAudioDecibel;//the voice (for audio input changed)
    NET_VCA_DEV_INFO       struDevInfo;//Structure info
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byRes[62];        //Reserved
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct  tagNET_BUTTON_DOWN_EXCEPTION_ALARM
{
    DWORD      dwSize;                   //Structure size
    NET_VCA_DEV_INFO       struDevInfo;  //Device Info
    BYTE    byRes[64];                   // Reserved
}NET_BUTTON_DOWN_EXCEPTION_ALARM, *LPNET_BUTTON_DOWN_EXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //Width of gray image data
    DWORD   dwHeight;                 //Heigth of gray image
    DWORD   dwImageLen;  //Length of gray image data
    BYTE     byRes[20];  //Reserved
    BYTE     *pImage;    //Gray image data
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //Structure size
    BYTE     byEnable;         //Whether to activate the rule
    BYTE     bySensitivity;    //Detection sensitivity, value range: [0,5]
    BYTE     byRes1[22];       //Reserved 
    NET_VCA_SIZE_FILTER  struSizeFilter;  //Size filter
    NET_VCA_POLYGON   struPolygon;        //Polygon
    NET_VCA_FD_IMAGE_CFG struFDImage;     //Image information
    BYTE     byRes2[20];       //Reserved
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;         //Length of image data
    DWORD dwFaceScore;          //Face score, value range: 0-100
    NET_VCA_RECT struVcaRect; //Face subgraph area
    BYTE  byRes[20];          //Reserved
    BYTE  *pImage;            //Image data
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
    DWORD dwImageLen;
    DWORD dwFaceScore;
    NET_VCA_RECT struVcaRect;
    NET_VCA_POINT struLeftEyePoint;
    NET_VCA_POINT struRightEyePoint;
    BYTE       byDistance;
    BYTE       bySex;
    BYTE       byAgeGroup;
    BYTE       byEyeGlass;
    NET_VCA_RECT struPosRect;
    BYTE       byRes[20];
    BYTE       *pImage;
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;             //Structure size
    DWORD dwImageId;          //Large picture ID
    BYTE byRes[20];           //Reserved
    DWORD dwSubImageNum;      //The total number of face subgraphs
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //Single face subgraph information
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
    DWORD dwSize;
    DWORD dwImageId;
    BYTE byRes[20];
    DWORD dwSubImageNum;
    NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //Length of image data
    DWORD dwModelLen;  //Length of model data
    BYTE  byRes[20];   //Reserved
    BYTE  *pImage;     //The pointer to face picture data
    BYTE  *pModel;     ///The pointer to model data
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //Large picture ID
    DWORD dwFaceScore;        //Face score: 0-100
    NET_VCA_RECT struVcaRect;  //Face subgraph area
    BYTE  byRes[20];  //Reserved
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

#define MAX_HUMAN_PICTURE_NUM   10   //The total number of pictures
#define MAX_HUMAN_BIRTHDATE_LEN 10   //The max length of birthday

typedef struct tagNET_DVR_AREAINFOCFG
{
    WORD wNationalityID; //Nationality
    WORD wProvinceID; //Province
    WORD wCityID; //City
    WORD wCountyID; //County
    DWORD dwCode; //government standard code
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //Gender: 0- man, 1- woman, 0xff-unknown
    BYTE   byCertificateType; //Certificate type: 0- identity card,1- police certificate,2 - military officer certificate, 3 - passport, 4 - other, 0xff-unknown
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //Birthday, for example: 201106
    BYTE   byName[NAME_LEN]; //Name
    NET_DVR_AREAINFOCFG struNativePlace; //Birthplace parameter
    BYTE   byCertificateNumber[NAME_LEN];  //Certificate number
    DWORD  dwPersonInfoExtendLen;// PersonInfoExtendLen
    BYTE  *pPersonInfoExtend;  //PersonInfoExtend
    BYTE   byAgeGroup;//age group, 0xff-unknown
    BYTE   byRes2[3];
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    BYTE*  pThermalData;//Thermal image pointer
#else
    BYTE*  pThermalData;//Thermal image pointer
    BYTE   byRes3[4];
#endif

}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //Gender: 0- disabled, 1- man, 2- woman
    BYTE   byCertificateType; //Certificate type: 0- disabled, 1- identity card, 2- police certificate
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //Start birthday, for example: 201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //End birthday, for example: 201106
    BYTE   byName[NAME_LEN]; //Name
    NET_DVR_AREAINFOCFG struNativePlace; //Birthplace parameter
    BYTE   byCertificateNumber[NAME_LEN];  //Certificate number
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;


typedef struct tagNET_VCA_BLOCKLIST_INFO
{
    DWORD  dwSize;   //Structure size 
    DWORD  dwRegisterID;  //Register ID (read-only)
    DWORD  dwGroupNo; //Group number
    BYTE   byType; //block and allow list flag: 0- all, 1- allow list, 2- block list
    BYTE   byLevel; //block list level: 0- all, 1- low, 2- middle, 3- high
    BYTE   byRes1[2];  //Reserved
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //Personnel information
    BYTE   byRemark[NAME_LEN]; //Remark information
    DWORD  dwFDDescriptionLen;//face lib desc len
    BYTE   *pFDDescriptionBuffer;//face lib desc ptr
    DWORD  dwFCAdditionInfoLen;//Snapshot library additional information length
    BYTE   *pFCAdditionInfoBuffer;//Snapshot library additional information data pointer
    DWORD  dwThermalDataLen;//Thermal image length
}NET_VCA_BLOCKLIST_INFO, *LPNET_VCA_BLOCKLIST_INFO;

typedef struct tagNET_VCA_BLOCKLIST_PARA
{
    DWORD dwSize;   //Structure size 
    NET_VCA_BLOCKLIST_INFO struBlockListInfo;  //block list information
    DWORD dwRegisterPicNum;  //The total number of blocklist pictures
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //blocklist picture information
    BYTE  byRes[40]; //Reserved
}NET_VCA_BLOCKLIST_PARA, *LPNET_VCA_BLOCKLIST_PARA;

typedef struct tagNET_VCA_BLOCKLIST_COND
{
    LONG  lChannel; //Channel number 
    DWORD dwGroupNo; //Group number
    BYTE  byType; //Block and allow list flag: 0- all, 1- allow list, 2- Block list
    BYTE  byLevel; //Block list level: 0- all, 1- low, 2- middle, 3- high
    BYTE  byRes1[2];  //Reserved
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //Personnel information
    BYTE  byRes[20];
}NET_VCA_BLOCKLIST_COND, *LPNET_VCA_BLOCKLIST_COND;

typedef struct tagNET_VCA_BLOCKLIST_PIC
{
    DWORD dwSize;   //Structure size
    DWORD dwFacePicNum;  //Face picture number
    BYTE  byRes[20]; //Reserved
    NET_VCA_PICMODEL_RESULT  struBlockListPic[MAX_HUMAN_PICTURE_NUM];  //Single picture information
}NET_VCA_BLOCKLIST_PIC, *LPNET_VCA_BLOCKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//Channel number
    NET_DVR_TIME struStartTime;//Start time
    NET_DVR_TIME struStopTime;//End time
    BYTE byRes[12]; //Reserved
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

#define MAX_FACE_PIC_LEN   6144   //The max length of face picture data
typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //Face picture ID
    DWORD dwFacePicLen;  //Length of face picture data
    NET_DVR_TIME struSnapTime;  //Snapshot time
    DWORD dwSimilarity; //Similarity
    BYTE  byRes[16];  //Reserved
    char  sPicBuf[MAX_FACE_PIC_LEN];  //Picture data
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //Face picture ID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //Large picture ID
    DWORD dwFaceScore;  //Face score 
    NET_VCA_RECT struVcaRect; //Face subgraph area
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;

typedef union tagNET_VCA_FIND_SNAPPIC_UNION
{
    NET_VCA_NORMAL_FIND  struNormalFind; //Common search
    NET_VCA_ADVANCE_FIND struAdvanceFind; //Advanced search
}NET_VCA_FIND_SNAPPIC_UNION, *LPNET_VCA_FIND_SNAPPIC_UNION;

typedef enum _VCA_FIND_SNAPPIC_TYPE_
{
    VCA_NORMAL_FIND = 0x00000000,   //Common search
    VCA_ADVANCE_FIND = 0x00000001    //Advanced search
}VCA_FIND_SNAPPIC_TYPE;

typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//Channel number
    NET_DVR_TIME struStartTime;//Start time
    NET_DVR_TIME struStopTime;//End time
    BYTE byThreshold;  //Threshold: 0-100
    BYTE byRes[23]; //Reserved
    VCA_FIND_SNAPPIC_TYPE dwFindType;//Retrieving type, see to VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //Retrieving parameter
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;       //Relative time
    DWORD dwAbsTime;            //Absolute time
    DWORD dwSnapFacePicID;      //Snapshot face picture ID
    DWORD dwSnapFacePicLen;        //Length of face subgraph: 0- no picture, larger than 0- there is related picture
    NET_VCA_DEV_INFO struDevInfo;        //Front-end device information
    BYTE  byFaceScore;        //FaceScore,0-100
    BYTE bySex;//Sex,0-unknow, 1-boy,2-girl
    BYTE byGlasses;//Glasses,0-unknow, 1-y, 2-n, 3-sunglasses
    BYTE byAge;//Age
    BYTE byAgeDeviation;//AgeDeviation
    BYTE byAgeGroup;//age group, 0xff - unknown
    BYTE byFacePicQuality;//face snap subpicture quality
    BYTE  byRes;
    DWORD dwUIDLen; //UIDLen
    BYTE  *pUIDBuffer; //UIDBuffer
    float   fStayDuration;  //stay duration
    BYTE  *pBuffer1;  //Snapshot face subgraph data
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLOCKLIST_INFO_ALARM
{
    NET_VCA_BLOCKLIST_INFO struBlockListInfo; //Blocklist basic information
    DWORD dwBlockListPicLen;       //Length of blocklist face subgraph: 0- no picture, larger than 0- there is related picture
    DWORD  dwFDIDLen;// Face library length ID
    BYTE  *pFDID;  //Face library ID buffer
    DWORD  dwPIDLen;//Face library P length ID
    BYTE  *pPID;  //Face library PID buffer
    WORD  wThresholdValue; //ThresholdValue[0,100]
    BYTE  byIsNoSaveFDPicture;//0-save FD picture 1-not save FD picture
    BYTE  byRealTimeContrast;//Whether real time alarm 0- real time 1- non-real time
    BYTE  *pBuffer1;  //Blocklist face subgraph data
}NET_VCA_BLOCKLIST_INFO_ALARM, *LPNET_VCA_BLOCKLIST_INFO_ALARM;

typedef struct NET_DVR_FD_DATA_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];
    char        szCheckCode[NET_SDK_CHECK_CODE_LEN/*128*/];
    BYTE         byCover;//cover enable 0-n, 1-y
    BYTE        byRes[127];
}NET_DVR_FD_DATA_COND, *LPNET_DVR_FD_DATA_COND;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;             //Structure size 
    float fSimilarity; //Similarity, value range: [0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //Snapshot information
    NET_VCA_BLOCKLIST_INFO_ALARM struBlockListInfo; //Blocklist information
    char         sStorageIP[16];
    WORD   wStoragePort;
    BYTE  byMatchPicNum; //MatchPicNum
    BYTE  byPicTransType;//PicTransType: 0-byte;1-url
    DWORD dwSnapPicLen;//SnapPicLen
    BYTE  *pSnapPicBuffer;//SnapPicBuffer
    NET_VCA_RECT  struRegion;//Region
    DWORD dwModelDataLen;//ModelDataLen
    BYTE  *pModelDataBuffer;//ModelDataBuffer
    BYTE  byModelingStatus;//Modeling status
    BYTE  byLivenessDetectionStatus;//LivenessDetectionStatus
    char  cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char  cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE  byMask;                //Whether to wear a mask, 0- retention, 1- unknown, 2- no mask, 3- wear a mask.
    BYTE  bySmile;               //Whether the snapshot is smiling, 0- retention, 1- unknown, 2- not smiling, 3- smile.
    BYTE  byContrastStatus;      //Contrast results, 0- retention, 1- contrast success, 2- contrast failure.
    BYTE  byBrokenNetHttp;     //Broken Net Http,0-Not a retransmission data,1- retransmission data
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;


typedef struct tagNET_VCA_BLOCKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLOCKLIST_INFO struBlockListInfo; //Blocklist basic information
    DWORD dwBlockListPicID;       //Blocklist face subgraph ID, used to search pictures
    BYTE  byRes[20];              //Reserved
}NET_VCA_BLOCKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLOCKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;        //Relative time
    DWORD dwAbsTime;             //Absolute time
    DWORD dwSnapFacePicID;       //Snapshot face picture ID
    NET_VCA_DEV_INFO       struDevInfo;        //Front-end device information
    BYTE  byRes[20];              // Reserved
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;             //Structure size 
    float fSimilarity;      //Similarity, value range: [0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //Snapshot information
    NET_VCA_BLOCKLIST_INFO_ALARM_LOG struBlockListInfoLog; //Blocklist information
    BYTE  byRes[60];              // Reserved
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;


typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;             // Structure size 
    DWORD dwSnapFaceID; //Blocklist face subgraph ID
    DWORD dwBlockListID; //Matched blocklist ID
    DWORD dwBlockListFaceID; //Compared blocklist face subgraph ID
    BYTE  byRes[20];              // Reserved
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;             //Structure size 
    DWORD dwSnapFaceLen; //Length of face subgraph
    DWORD dwBlockListFaceLen; //Length of compared blocklist face subgraph
    BYTE  byRes[20];              //Reserved
    BYTE *pSnapFace;  //Picture data of face subgraph
    BYTE *pBlockListFace;  //Picture data of compared blocklist face subgraph
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLOCKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //Structure size
    NET_VCA_BLOCKLIST_INFO struBlockListInfo;  //Blocklist information
    DWORD dwImageLen;  //Length of image data
    BYTE  byRes[124];  //Reserved
    BYTE  *pImage;    //Image data
}NET_VCA_BLOCKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLOCKLIST_FASTREGISTER_PARA;


/*******PJ01C20170209084 super-brainNVS customization dedicated******/
//Single frame people count result upload 
typedef struct tagNET_DVR_FRAMES_PEOPLE_COUNTING
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO   struDevInfo;//Device Information
    DWORD  dwRelativeTime;
    DWORD  dwAbsTime;
    DWORD  dwPeopleCountingNum; //Number of people counting in picture
    DWORD  dwPicLen;       //Panoramic image data length 
    BYTE   *pPicBuffer;    //Panoramic image data point 
    BYTE   byRes[512];
}NET_DVR_FRAMES_PEOPLE_COUNTING, *LPNET_DVR_FRAMES_PEOPLE_COUNTING;
/*******PJ01C20170209084 super-brainNVS customization dedicated******/

//Single partition configuration
typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  //Whether it is available: 0- no, 1- yes
    BYTE  byType;    //0- save snapshot, 1- save blocklist comparison alarm, 2- save snapshot and blocklist comparison alarm,0xff-invalid
    BYTE  bySaveAlarmPic; //save alarm picture,0-no,1-yes
    BYTE  byRes1[5]; //Reserved
    DWORD dwDiskDriver;   //Disk sign, start from 0
    DWORD dwLeftSpace;   //Reserved capacity (unit:G)
    BYTE  byRes2[8]; //Reserved
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

//Set saving path
typedef struct tagNET_VCA_SAVE_PATH_CFG
{
    DWORD dwSize;   //Structure size 
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //Single partition
    BYTE  byRes[40]; //Reserved
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR     struIP;        //access device ip
    WORD     wDevicePort;                 //port
    BYTE    byEnable;                 //enable,0-no,1-yes
    BYTE     byRes1;                //
    BYTE    sUserName[NAME_LEN];    //access user name
    BYTE    sPassword[PASSWD_LEN];    //access password
    BYTE    byRes2[60];
}NET_DVR_DEV_ACCESS_CFG, *LPNET_DVR_DEV_ACCESS_CFG;

/********************************Intelligent Face Recognition end****************************/

typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize;
    DWORD dwIPAlarmInGroup;
    DWORD dwIPAlarmInNum;
    DWORD dwIPAlarmOutGroup;
    DWORD dwIPAlarmOutNum;
    BYTE byRes[64];
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;                // Structure length
    char  sCameraInfo[32];        // Access camera info
    BYTE  byInterfaceType;        // Access camer type 1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
    BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //Audio in type,0-mic in,1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter;
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-disenable,1-auto mode,2-enable
    BYTE byLevel; //level,0-100
    BYTE byRes[6];
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{
    DWORD    dwSize;
    BYTE   byAudio;            /*Whether the audio is enabled*/
    BYTE   byAudioWindowIdx;      /*Sub window index to enable audio*/
    BYTE     byVgaResolution;      /*Resolution, got from ability set*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwWindowMode;        /*Screen mode, got from ability set*/
    BYTE      byJoinDecChan[MAX_WINDOWS];/*The decode channel joined with each sub-window*/
    BYTE    byEnlargeStatus;          /*Whether enlarge the window: 0- no, 1- yes*/
    BYTE    byEnlargeSubWindowIndex;//Enlarged sub window index
    BYTE    byScale; /*Display mode: 0--real display,1--scaling display (for BNC)*/
    /*Distinguish between the union: 0- display channel configuration of the decoder inner video integrated platform,
    1- display channel configuration of other decoder*/
    BYTE    byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*Decode sub-system slot number corresponded to the decode channel joined with each sub-window(valid for decode sub-system in video integrated platform)*/
            BYTE    byJoinDecoderId[MAX_WINDOWS];
            //Video resolution of display window: 1- D1, 2- 720P, 3- 1080P, 
            //Device set decode channel according to the resolution. For example, if 1 screen is configured to 1080P, the device will set 4 decode channels
            //to the display channel
            BYTE    byDecResolution;
            BYTE    byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE    byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE    byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40, *LPNET_DVR_VGA_DISP_CHAN_CFG_V40;


typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE        bySerialTrans;//Serial Transport,0-no,1-yes
    BYTE        byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;

// long config status

// pull disk status
#define PULL_DISK_SUCCESS        1   
#define PULL_DISK_FAIL            2   
#define PULL_DISK_PROCESSING    3   
#define PULL_DISK_NO_ARRAY         4 
#define PULL_DISK_NOT_SUPPORT    5     

// scan raid state
#define SCAN_RAID_SUC            1     
#define SCAN_RAID_FAIL            2     
#define SCAN_RAID_PROCESSING    3    
#define SCAN_RAID_NOT_SUPPORT    4     

// set access camera type status
#define SET_CAMERA_TYPE_SUCCESS            1   
#define SET_CAMERA_TYPE_FAIL            2   
#define SET_CAMERA_TYPE_PROCESSING        3


//9000 2.2
typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD    dwSize;    //Structure size
    BYTE    byType;    //0- normal audio and video recording, 1- picture channel recording, 
    //2- ANR channel recording, 3- frame extracting channel recording
    BYTE     byRes[63]; //Reserved
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD          dwSize;        //Structure size
    NET_DVR_TIME  strBeginTime;  //Start time
    NET_DVR_TIME  strEndTime;    //End time
    BYTE          byType;        //0- normal audio and video recording, 1- picture channel recording, 
    //2- ANR channel recording, 3- frame extracting channel recording
    BYTE           byRes[35];     //Reserved
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;                    //Structure size
    BYTE     byPicQuota;                //Picture percentage                    [0%,  30%]
    BYTE     byRecordQuota;                //Record percentage                        [20%, 40%]
    BYTE     byDrawFrameRecordQuota;    //Frame extracting record percentage    [30%, 80%]
    BYTE     byRes[61];                //Reserved
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //Whether the port is enabled to be mapped
    WORD wExtPort;        //External port
    BYTE byRes[12];       //Reserved
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //Structure size
    WORD wEnableUpnp;     //Whether to enable UPNP
    WORD wEnableNat;        //Whether to enable UPNP port mapping(NAT) function(same as wEnableUpnp)
    NET_DVR_IPADDR  struIpAddr;      //LAN IP address of NAT router
    NET_DVR_NAT_PORT    struHttpPort;   //mapping configuration of web server http port
    NET_DVR_NAT_PORT    struCmdPort; //mapping configuration of command port
    NET_DVR_NAT_PORT    struRtspPort;  //mapping configuration of rtsp port 
    BYTE byFriendName[64]; //Friend name
    BYTE byNatType; //UPNP NAT type,0-manual,1-auto
    BYTE                 byRes1[3];    //Reserved
    NET_DVR_NAT_PORT    struHttpsPort; //mapping configuration of  httpsport
    NET_DVR_NAT_PORT    struSDKOverTLSPort; //mapping configuration of SDKOverTLS
    NET_DVR_NAT_PORT    struRtspsPort; //mapping configuration of Rtsps
    BYTE                byres[44];    //Reserved             
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;

typedef struct
{
    DWORD  dwEnabled;               //Whether enable the port to be mapped
    WORD   wInternalPort;           //internal port
    WORD   wExternalPort;           //External port
    DWORD  dwStatus;                 /*Port mapping state:
                                     0 Not effective
                                     1 Not effective: mapped source port should be same with destination port
                                     2 Not effective: mapped port has been used
                                     3 Effect
                                     */
    NET_DVR_IPADDR    struNatExternalIp;       //Mapped external IP address
    NET_DVR_IPADDR    struNatInternalIp;       //LAN IP address of NAT router
    BYTE   byRes[16];               //Reserved
}NET_DVR_UPNP_PORT_STATE, *LPNET_DVR_UPNP_PORT_STATE;

typedef struct
{
    NET_DVR_UPNP_PORT_STATE strUpnpPort[UPNP_PORT_NUM];     //Port mapping state, array 0- web server port, array 1- management port, array 2- rtsp port
    BYTE   byRes[200];              //Reserved
}NET_DVR_UPNP_NAT_STATE, *LPNET_DVR_UPNP_NAT_STATE;

typedef struct tagNET_DVR_PLAYCOND
{
    DWORD             dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE             byDrawFrame;  //0- not extract frame, 1- extract frame
    BYTE             byStreamType; //0-main 1-sub 2-three
    BYTE             byStreamID[STREAM_ID_LEN];  //Stream ID
    BYTE             byCourseFile;    //Course file 0 - no, 1 - yes
    BYTE             byDownload;    //Download 0- no, 1- yes.
    BYTE             byOptimalStreamType;  //Whether to play back according to the optimal code stream type. 0 - no, 1 - yes
    BYTE             byVODFileType; //Saving file format, 0-PS stream, 1-3GP
    BYTE             byRes[26];    //Reserved
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //Trade Tye 0-All,1-Search, 2-Withdraw 3-Deposit, 4-Edit Password 5-Transfer,
    //6-No Card Withdraw 7-No Card Deposit 8-Swallow money 9-Swallow Card 10-seldefine
    BYTE    byRes[3];
    DWORD  dwTransationAmount;     //trade money ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO;

typedef union  tagNET_DVR_SPECIAL_FINDINFO_UNION
{
    BYTE  byLenth[8];
    NET_DVR_ATMFINDINFO      struATMFindInfo;           //ATM search
}NET_DVR_SPECIAL_FINDINFO_UNION, *LPNET_DVR_SPECIAL_FINDINFO_UNION;

typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0- not extract frame, 1- extract frame
    BYTE        byFindType;
    BYTE        byQuickSearch;
    BYTE        bySpecialFindInfoType;    //special Find Info Type,     indicate NET_DVR_SPECIAL_FINDINFO_UNION 0-Invalid, 1-Find With ATM Cond  
    DWORD       dwVolumeNum;
    BYTE        byWorkingDeviceGUID[GUID_LEN];
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo;   //special Find Info 
    BYTE        byStreamType;
    BYTE        byAudioFile;
    BYTE        byRes2[30];
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

//Record Query Condition V50
typedef struct tagNET_DVR_FILECOND_V50
{
    NET_DVR_STREAM_INFO struStreamID; //stream ID or channel number
    NET_DVR_TIME_SEARCH_COND struStartTime; //start time 
    NET_DVR_TIME_SEARCH_COND struStopTime; //end time 
    BYTE  byFindType; //0-Query normal volume,1-Query archive volume 2-Query the N + 1 video file
    BYTE  byDrawFrame; // 0-no draw frame 1-Draw frame
    BYTE  byQuickSearch; //0-normal,1-fast(calendar)search
    BYTE  byStreamType; //0- main stream ,1- sub-stream,2-third stream,0xff-all
    DWORD  dwFileType; // file type
    DWORD  dwVolumeNum; //volume number,which valid when byFindType set to 1 
    BYTE  byIsLocked; //whether file is locked,  0- normal;  1- locked;  0xff- all
    BYTE  byNeedCard; //search card is necessary? 0-no 1-yes
    BYTE  byOnlyAudioFile;        //audio file? 0- vedio file 1-audio file
    BYTE  bySpecialFindInfoType; //0-invalid 1-with ATM search conditions
    char  szCardNum[32];  //card no. byNeedCard should set to 1
    char  szWorkingDeviceGUID[16]; //working machine GUID,through access to the N + 1.byNeedCard should set to 2
    NET_DVR_SPECIAL_FINDINFO_UNION  uSpecialFindInfo; //Proprietary complex query conditions
    DWORD dwTimeout; //
    BYTE             byRes[252];
}NET_DVR_FILECOND_V50, *LPNET_DVR_FILECOND_V50;

typedef struct
{
    BYTE    sAESKey[16];        //Stream key
    BYTE    byRes[64];          //Reserved
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;

typedef struct
{
    NET_DVR_IPADDR struIP;     //IP address
    BYTE  byRes[128]; //Reserved
}NET_DVR_POE_CFG, *LPNET_DVR_POE_CFG;

#define MAX_PRO_PATH         256    //The max length of protocol path

typedef struct
{
    DWORD dwSize;              //Structure size
    DWORD dwEnabled;           //Whether enable the protocol: 0- no, 1- yes
    char  sProtocalName[DESC_LEN];   //Customized protocol name, 16 bits
    BYTE  byRes1[64];          //Reserved, used for extending protocol name
    DWORD dwEnableSubStream;   //Whether enable the sub stream: 0- no, 1- yes

    BYTE  byMainProType;        //Main stream protocol type: 1- RTSP
    BYTE  byMainTransType;       //Main stream transport type 0:Auto 1:udp 2:rtp over rtsp
    WORD  wMainPort;           //Main stream port
    char  sMainPath[MAX_PRO_PATH];  //Main stream path 

    BYTE  bySubProType;         //Sub stream protocol type: 1- RTSP
    BYTE  bySubTransType;        //Main stream transport type 0:Auto 1:udp 2:rtp over rtsp
    WORD  wSubPort;             //Sub stream port
    char  sSubPath[MAX_PRO_PATH];   //Sub stream path 

    BYTE  byRes2[200];          //Reserved
}NET_DVR_CUSTOM_PROTOCAL, *LPNET_DVR_CUSTOM_PROTOCAL;


typedef struct tagNET_DVR_VOD_PARA
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO struIDInfo;
    NET_DVR_TIME        struBeginTime;
    NET_DVR_TIME        struEndTime;
    HWND                hWnd;
    BYTE                byDrawFrame;
    BYTE                byVolumeType;  //0-common volume   1-backup volme
    BYTE                byVolumeNum;  //backup volme number
    BYTE                byStreamType;
    DWORD                   dwFileIndex;      //file index
    BYTE                byAudioFile;
    BYTE                byCourseFile;    //Course file 0 - no, 1 - yes
    BYTE                byDownload;    //Download 0- no, 1- yes.
    BYTE                byOptimalStreamType;  //Whether to play back according to the optimal code stream type. 0 - no, 1 - yes
    BYTE                byUseAsyn;       //0-SynIO1-AsynIO 
    BYTE                byRes2[19];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

typedef struct tagNET_DVR_VOD_PARA_V50
{
    DWORD                   dwSize;
    NET_DVR_STREAM_INFO     struIDInfo;
    NET_DVR_TIME_V50        struBeginTime;
    NET_DVR_TIME_V50        struEndTime;
    HWND                    hWnd;
    BYTE                    byDrawFrame; 
    BYTE                    byVolumeType;  
    BYTE                    byVolumeNum;  
    BYTE                    byStreamType;   
    DWORD                   dwFileIndex;
    BYTE                    byAudioFile;    
    BYTE                    byCourseFile;   
    BYTE                    byPlayMode;   
    BYTE                    byLinkMode;   
    BYTE                    byDownload;    //Download 0- no, 1- yes.
    BYTE                    byOptimalStreamType;  //Whether to play back according to the optimal code stream type. 0 - no, 1 - yes
    BYTE                    byDisplayBufNum;
    BYTE                    byNPQMode;
    BYTE                    sUserName[NAME_LEN/*32*/]; //Double verification user name
    BYTE                    sPassword[PASSWD_LEN/*16*/]; //Double verification password
    BYTE                    byRemoteFile;    //Play back the remote file 0- no, 1- yes
    BYTE                    byUseAsyn;       //0-SynIO1-AsynIO 
    BYTE                    byRes2[201];
    BYTE                    byHls;          //HLS play back0- no, 1- yes
    char*                   pSavedFileName;	//it works when 'byDownload' is 1
}NET_DVR_VOD_PARA_V50, *LPNET_DVR_VOD_PARA_V50;

//B10 can support PSIA.
//cycle to wall
typedef struct
{
    DWORD dwEnable; //0-disable 1-enable
    BYTE  byType;   //device type 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    BYTE byRes[3];  //reserved
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; //the information of cycle decoding channel
    BYTE sRtspUrl[128]; //stream address
}NET_DVR_MATRIX_CHAN_INFO_EX, *LPNET_DVR_MATRIX_CHAN_INFO_EX;

typedef struct
{
    DWORD                    dwSize;
    DWORD                    dwPoolTime;        //the gap of cycle time
    NET_DVR_MATRIX_CHAN_INFO_EX        struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                   byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_EX, *LPNET_DVR_MATRIX_LOOP_DECINFO_EX;

//realtime preview
typedef struct
{
    DWORD dwSize;
    BYTE byType;         //device type: 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    BYTE byRes[3];       //reserve
    NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO struDevChanInfo;
    BYTE sRtspUrl[128];  //stream address
}NET_DVR_PU_STREAM_CFG_EX, *LPNET_DVR_PU_STREAM_CFG_EX;
/////***********************************64-T decoder*************************************//////
//resolution
#define MAKE_RESOLUTION(_interlace_, _width_, _height_, _fps_) \
    (((_interlace_) << 28) \
    | ((((_width_) >> 3) & 0x1ff) << 19) | \
    ((((_height_) >> 1) & 0x7ff) << 8) | \
    ((_fps_)& 0xff))
#define GET_RES_INTERLACE(_res_) \
    (((_res_) >> 28) & 0x1)
#define GET_RES_WIDTH(_res_) \
    ((((_res_) >> 19) & 0x1ff) << 3)
#define GET_RES_HEIGHT(_res_) \
    ((((_res_) >> 8) & 0x7ff) << 1)
#define GET_RES_FPS(_res_) \
    ((_res_)& 0xff)

#define NOT_AVALIABLE    MAKE_RESOLUTION (0,0,0,0)
#define SVGA_60HZ         MAKE_RESOLUTION(0, 800, 600, 60)
#define SVGA_75HZ         MAKE_RESOLUTION(0, 800, 600, 75)
#define XGA_60HZ         MAKE_RESOLUTION(0, 1024, 768, 60) 
#define XGA_75HZ         MAKE_RESOLUTION(0, 1024, 768, 75)
#define SXGA_60HZ          MAKE_RESOLUTION(0, 1280, 1024, 60)
#define SXGA2_60HZ      MAKE_RESOLUTION(0, 1280, 960, 60) 
#define _720P_24HZ      MAKE_RESOLUTION(0, 1280, 720, 24)
#define _720P_25HZ      MAKE_RESOLUTION(0, 1280, 720, 25)
#define _720P_30HZ      MAKE_RESOLUTION(0, 1280, 720, 30)  
#define _720P_60HZ      MAKE_RESOLUTION(0, 1280, 720, 60)
#define _720P_50HZ      MAKE_RESOLUTION(0, 1280, 720, 50) 
#define _1080I_60HZ     MAKE_RESOLUTION(1, 1920, 1080, 60)
#define _1080I_50HZ      MAKE_RESOLUTION(1, 1920, 1080, 50)
#define _1080P_60HZ     MAKE_RESOLUTION(0, 1920, 1080, 60)
#define _1080P_50HZ     MAKE_RESOLUTION(0, 1920, 1080, 50)
#define _1080P_30HZ     MAKE_RESOLUTION(0, 1920, 1080, 30)
#define _1080P_25HZ     MAKE_RESOLUTION(0, 1920, 1080, 25)
#define _1080P_24HZ     MAKE_RESOLUTION(0, 1920, 1080, 24)
#define UXGA_60HZ          MAKE_RESOLUTION(0, 1600, 1200, 60)
#define UXGA_30HZ          MAKE_RESOLUTION(0, 1600, 1200, 30)
#define WSXGA_60HZ         MAKE_RESOLUTION(0, 1680, 1050, 60)
#define WUXGA_60HZ      MAKE_RESOLUTION(0, 1920, 1200, 60)
#define WUXGA_30HZ         MAKE_RESOLUTION(0, 1920, 1200, 30)
#define WXGA_60HZ          MAKE_RESOLUTION(0, 1360, 768, 60)
#define SXGA_PLUS_60HZ    MAKE_RESOLUTION(0, 1400, 1050, 60)
#define VGA_MODE_3840x2160_30HZ MAKE_RESOLUTION(0, 3840, 2160, 30)
#define VGA_MODE_3840x2160_60HZ MAKE_RESOLUTION(0, 3840, 2160, 60)

#define  MAX_WINDOWS_NUM 12        //number of menu partition mode
#define  MAX_SUPPORT_RES 32
#define  MAX_DISPNUM_V41 32
#define  MAX_SDI_RES     16     //
typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//Display channel type:0-BNC, 1-VGA, 2-HDMI, 3-DVI
    BYTE byDispChanSeq;//sequence of display channel, if the byDispChanType is VGA, byDispChanSeq mean the sequence of VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;


typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//channel numbers
    BYTE  byStartChan;//start channel
    BYTE  byRes[2];
    DWORD    dwSupportResolution[MAX_SUPPORT_RES/*32*/];//support resolution
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//Max numbers of big screen
    BYTE  byStartBigScreenNum;//start index of screen 
    BYTE  byMaxScreenX;//the mode of making up big screen
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//
    BYTE  byStartChan;//
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//
}NET_DVR_SDI_INFO, *LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD    dwMaxXAcc;
    DWORD    dwMaxYAcc;
    DWORD    dwMaxZAcc;
    BYTE    byRes[4];
}NET_DVR_ACCELERATIONCFG, *LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*module select:0 inside/1 outside*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD     dwHaltDelay; /* shutdown delay time(min) */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*start control parm set*/
    BYTE       byEnableUnderVoltProtect;   /*enable under volt proctect*/
    BYTE       byUnderVoltPercent;   /*under volt percent,(85,90,95) */
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;

//auto Backup
typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* enable auto backup or not 0 stop ,1 start */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30];     /*the channel to auto backup*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*the days to backup*/
    /* the file type to backup
    {0,ALL_RECORD_TYPE,all type},
    {1,TIMING_REC,Schedule},
    {2,MOTION_DETECT_REC,Motion Detection  },
    {3,ALARM_REC,alarm },
    {4,MANUAL_REC,Manual Recording}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];    /* the shedule for auto backup*/
    BYTE  byRes2[36];                        /* res*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;

typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;    /*enable GPS or not*/
    BYTE  byGpsInterface;/*gps receive interface 0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*speed unit,0:km/h,1 mile/h*/
    BYTE  byEnableRetrieve; /* dead zone retrieve(1enable,0disable) */
    int      iAdjustTime;/*time zone*/
    BYTE  byEnableAdjustTime;/*enable GPS Time Synchronization, 1-enable, 0-disable*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;    /* GPS upload interval, second*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD display, */
    DWORD dwSpeedLimit;    /* speed limit alarm*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm;
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;

#define         SENSOR_IN_NUMBER          8
typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*trigger type,the last four type is valid,representing brake,turn left,turn right and reverse,0-high level,1-low level*/
    BYTE  byTriggerChannel[SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay[MAX_CHANNUM_V30];/*OSD display*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;

#define     MAX_UNITEDMATRIX_NUM        8
#define     MAX_SUBDOMAIN_NUM           4
typedef struct tagNET_DVR_SUBSERVERINFO
{
    BYTE        bySequence;
    BYTE        byBelongSubDomain;
    BYTE        byRes1[6];
    DWORD       dwMaxIpcNums;
    NET_DVR_IPADDR struSubMatrixIP;        
    WORD        wSubMatrixPort;       
    BYTE        byRes2[6];
}NET_DVR_SUBSERVERINFO, *LPNET_DVR_SUBSERVERINFO;

typedef struct tagNET_DVR_UNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBSERVERINFO struDomainInfo;
    NET_DVR_SUBSERVERINFO struSubDomainInfo[MAX_SUBDOMAIN_NUM];
    NET_DVR_SUBSERVERINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXINFO, *LPNET_DVR_UNITEDMATRIXINFO;

typedef struct tagNET_DVR_REGCALLBACKPARAM
{
    char sDeviceID[NAME_LEN];
    char sPassword[PASSWD_LEN];
    BYTE sSerialNumber[SERIALNO_LEN]; 
    DWORD dwDeviceType;
    BYTE nStatus;
    /* net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks */
    BYTE byNetType;
    BYTE byRes[14];
}NET_DVR_REGCALLBACKPARAM, *LPNET_DVR_REGCALLBACKPARAM;

typedef struct tagNET_DVR_LOGONREPONSEPARAM
{
    WORD wHeartbeatTime;
    BYTE byOvertimes;
    BYTE byRes[13];
}NET_DVR_LOGONREPONSEPARAM, *LPNET_DVR_LOGONREPONSEPARAM;


typedef struct tagNET_DVR_PREVIEWPARAM
{
    BYTE byTransProtol;   
    BYTE byTransMode;      
    NET_DVR_IPADDR struCuIp; 
    WORD wPort;
    WORD wUdpPort;
    BYTE bySupportQos;
    BYTE  byNatRequest;
    BYTE  byPreviewType;
    BYTE  byRes[7];
}NET_DVR_PREVIEWPARAM, *LPNET_DVR_PREVIEWPARAM;
typedef struct tagNET_DVR_DEVICENATINFO
{
    NET_DVR_IPADDR struPuIp; 
    WORD    wOuterPort;
    WORD    wInterPort;
    DWORD   nSessionID;
    BYTE    byRes[4];
}NET_DVR_DEVICENATINFO, *LPNET_DVR_DEVICENATINFO;


typedef struct tagNET_DVR_PREVIEWCALLBACKPARAM
{
    LONG lChannel;
    BYTE nLinkProtocol;
    BYTE nTransMode;
    BYTE byPreviewType;
    BYTE byRes[5];
    DWORD nSessionID;
}NET_DVR_PREVIEWCALLBACKPARAM, *LPNET_DVR_PREVIEWCALLBACKPARAM;

typedef struct tagNET_DVR_PLAYBACKREQUESTPARAM
{
    BYTE byPlayBackMode;        
    BYTE byRes1[3];
    union
    {
        char sFileName[100];       
        struct
        {
            LONG    lChannel;              
            NET_DVR_TIME struStartTime;           
            NET_DVR_TIME struStopTime;          
            BYTE    byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    NET_DVR_IPADDR struCuIp; 
    WORD    wPort;
    BYTE    byRes2[2];
    DWORD   dwSessionID;
    BYTE    byRes3[16];
}NET_DVR_PLAYBACKREQUESTPARAM, *LPNET_DVR_PLAYBACKREQUESTPARAM;

//2010-10-06
typedef struct tagNET_DVR_PLAYBACKCALLBACKPARAM
{
    BYTE byPlayBackMode;        
    BYTE byRes1[3];
    union
    {
        char sFileName[100];        
        struct
        {
            LONG        lChannel;                
            NET_DVR_TIME struStartTime;           
            NET_DVR_TIME struStopTime;           
            BYTE       byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    DWORD nSessionID;
    BYTE byRes2[44];
}NET_DVR_PLAYBACKCALLBACKPARAM, *LPNET_DVR_PLAYBACKCALLBACKPARAM;

typedef struct tagNET_DVR_VOICEREQUESETPARAM
{
    BYTE    nVoiceChannel;       
    BYTE    byRes1[3];
    NET_DVR_IPADDR struCuIp; 
    WORD     wPort;
    BYTE    byRes2[10];
}NET_DVR_VOICEREQUESTPARAM, *LPNET_DVR_VOICEREQUESTPARAM;

typedef struct tagNET_DVR_ALARMSETUPREQUESETPARAM
{
    NET_DVR_IPADDR struCuIp; 
    WORD     wPort;
    BYTE    byRes[2];
}NET_DVR_ALARMSETUPREQUESTPARAM, *LPNET_DVR_ALARMSETUPREQUESTPARAM;

typedef struct tagNET_DVR_GPSALARMINFO
{
    BYTE byDeviceID[NAME_LEN];/*device id*/
    NET_DVR_TIME_EX struGpsTime;    /*GPS upload time*/
    DWORD    dwLongitude;    /* longitude*/
    DWORD    dwLatitude;  /* latitude*/
    int     iTimeZone; /*timezone,In minutes,  +60 stands for the East 1,  +480 for the East 8,  -60 for the west,  -480 for the West 8. This field and the GPSTime form a complete time description*/
    DWORD dwDirection; /*Vehicle direction = actual direction (in degrees, north direction, clockwise direction calculation) *100*/
    WORD  wSatellites; /*satellite num*/
    WORD  wPrecision; /*precision*/
    DWORD dwHeight; /*height,centimeter,reserve*/
    DWORD dwGPSSeq; /*GPS sequense,*/
    WORD  wSpeed;//speed,unit:km/h
    /* direction[0]:'E'or'W', direction[1]:'N'or'S'*/
    char sDirection[2];
    BYTE byLocateMode;/*Location mode (initial value 0), 1, independent positioning, 2, difference 3, estimation 4, data invalid  65,valid location  78,invalid location*/
    BYTE byRes[3];
}NET_DVR_GPSALARMINFO, *LPNET_DVR_GPSALARMINFO;

typedef struct tagNET_DVR_PICINFO
{
    DWORD   dwSize;       
    BYTE    byChanIndex;   
    BYTE    byRes1[3];           
    BYTE     byDeviceID[NAME_LEN];
    BYTE    byAbsTime[32];  
    DWORD   dwPicLen;        
    BYTE    byRes2[32];
    BYTE    *pPicBuffer;
}NET_DVR_PICTUREINFO, *LPNET_DVR_PICTUREINFO;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR    struDownloadSvrIp;        /* auto load server address */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA, *LPNET_DVR_MB_DOWNLOADSVRPARA;

typedef struct tagNET_DVR_PLATERECOG_PARA
{
    DWORD dwSize;
    BYTE byPrMode;
    BYTE byPrScene; 
    BYTE byPrDetRect; 
    BYTE byPrPicQuality; /* picture quality: 0:lowest  3:highest */
    BYTE byPrPicMode; /*picture mode: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF */
    BYTE byPlateOsdDisplay; 
    BYTE byPrProvCharIndex; 
    BYTE byPrProvCharIndex1;    
    BYTE byPrProvCharIndex2;   
    BYTE byRes[7];
}NET_DVR_PLATERECOG_PARA, *LPNET_DVR_PLATERECOG_PARA;

typedef struct tagNET_DVR_SPEEDLMT_PARA
{
    BYTE    bStartMaxSpeedLimit;      
    BYTE    bStartMinSpeedLimit;    
    BYTE    byRes[6];
    DWORD    dwMaxSpeedLimit;        
    DWORD    dwMinSpeedLimit;     
}NET_DVR_SPEEDLMT_PARA, *LPNET_DVR_SPEEDLMT_PARA;

typedef struct tagNET_DVR_PLATECHECK_PARA
{
    BYTE    bAlarmWhenChecked;    
    BYTE    bInformWhenChecked;    
    BYTE    byRes[6];
    NET_DVR_IPADDR struBlockFtpServer;  
}NET_DVR_PLATECHECK_PARA, *LPNET_DVR_PLATECHECK_PARA;

typedef struct tagNET_DVR_ENFORCESYS_PARA
{
    DWORD dwSize;
    NET_DVR_SPEEDLMT_PARA    struSpeedLmtPara;  
    NET_DVR_PLATECHECK_PARA struPlateCheckPara;   
    BYTE    bySelPeccType;  
    BYTE    byEnfOptHabit; 
    BYTE    byAdjPrevFpsMode;
    BYTE    byRes1;
    NET_DVR_IPADDR  struUploadServerIp; 
    WORD    wUploadServerPort;
    BYTE    byRes2[18];
}NET_DVR_ENFORCESYS_PARA, *LPNET_DVR_ENFORCESYS_PARA;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP numbers  
    BYTE  byDecChanNums;//decoder channel numbers
    BYTE  byStartChan;//the start index of decoder channels
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//information of VGA channels
    NET_DVR_DISPINFO struBncInfo;//information of BNC channels
    NET_DVR_DISPINFO struHdmiInfo;//information of HDMI channels
    NET_DVR_DISPINFO struDviInfo;//information of DVI channels
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //auto reboot:0-not support,1-support
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI display channel information 
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;

#define  MAX_WINDOWS                16
#define  MAX_WINDOWS_V41            36

#define  STARTDISPCHAN_VGA            1
#define  STARTDISPCHAN_BNC            9
#define  STARTDISPCHAN_HDMI            25
#define  STARTDISPCHAN_DVI            29



typedef union tagNET_DVR_VIDEO_PLATFORM
{
    BYTE byRes[160];
    struct
    {
        BYTE    byJoinDecoderId[MAX_WINDOWS_V41];
        BYTE    byDecResolution[MAX_WINDOWS_V41];
        NET_DVR_RECTCFG struPosition; //Display channel position in TV wall
        BYTE    byRes[80];
    }struVideoPlatform;
    struct
    {
        BYTE    byRes[160];
    }struNotVideoPlatform;
}NET_DVR_VIDEO_PLATFORM, LPNET_DVR_VIDEO_PLATFORM;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{
    DWORD    dwSize;
    BYTE    byAudio;            //is audio value
    BYTE    byAudioWindowIdx;      /*audio window Index*/
    BYTE    byDispChanType;      /*display channel type:0-BNC,1-VGA,2-HDMI,3-DVI,4-YPbPr(DECODER_SERVER device used)*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwResolution;
    DWORD    dwWindowMode;        /*the max value get from ability*/
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*the decoder channel of every window conjunction*/
    BYTE    byEnlargeStatus;          /*0:zoom in ,1:zoom out*/
    BYTE    byEnlargeSubWindowIndex;//the index of window which is zoom in
    BYTE    byScale; /*0---realty  show,1---zoom show( BNC )*/
    BYTE    byUnionType;/*0-use for the display channels of decoder in video platform,1-use for the other disp channels of decoders*/
    NET_DVR_VIDEO_PLATFORM        struDiff;
    DWORD   dwDispChanNum; //Display channel N0.,only valid for getting all display channels' configure
    WORD     wLEDWidth;     //LED resolution width, 0 means invaild  
    WORD     wLEDHeight;    //LED resolution height, 0 means invaild  
    BYTE      byEnableVideoEffect;  //
    BYTE      byRes[3];  //
    NET_DVR_VIDEOEFFECT struVideoEffect;   //
    BYTE    byRes2[60];
}NET_DVR_MATRIX_VOUTCFG, *LPNET_DVR_MATRIX_VOUTCFG;

typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*0:unshow,1:show*/
    BYTE  byBVGA;              /*0-BNC,1-VGA, 2-HDMI,3-DVI,0xff-invalid*/
    BYTE  byVideoFormat;     /*1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*the decoder channel of every window conjunction*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*rate of frame*/
    BYTE  byScreenMode;        /*screen mode 0-normal 1-big screen*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*only valid for getting all*/
    BYTE  byRes2[24];
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*status of decoder channels*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];   /*status of disp channels*/
    BYTE byAlarmInStatus[32];         /*status of alarm in*/
    BYTE byAlarmOutStatus[32];       /*status of alarm out*/
    BYTE byAudioInChanStatus;          /*status of audio in*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41, *LPNET_DVR_DECODER_WORK_STATUS_V41;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struIP;        /* DVR IP*/
    WORD    wDVRPort;            /* port*/
    BYTE    byChannel;            /* channels */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN];
    DWORD    dwPlayMode;       /* 0-play by file name 1-play by time*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE    byRes[64];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;

#define        MAX_BIGSCREENNUM    100// Max Screen number

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE    byScreenSeq;//screen sequence, 0xff means doesn't use this screen,the first screen is main screen  
    BYTE    bySubSystemNum;//slot index in subsystem of decode, this value is unuseful in 64-T decoder
    BYTE    byDispNum;//display channel index in subsystem of decode
    BYTE    byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE    byEnable;                // 0-Enable,1-Unable
    BYTE    byModeX;                // splice mode :x
    BYTE    byModeY;                // splice mode :y
    BYTE    byMainDecodeSystem;        // slot index of main screen in video platform, decode channel number in 64-T decoder
    BYTE    byMainDecoderDispChan;    // display of main screen,1.1netra decoder has two display channels, each of them can be used as main screen, this value is unuseful in 64-T decoder
    BYTE    byVideoStandard;        // the format of every single screen is same1:NTSC,2:PAL
    BYTE    byRes1[2];
    DWORD  dwResolution;            // the resolution of every single screen is same
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM];
    WORD    wBigScreenX; //Big screen X coordinate
    WORD    wBigScreenY; //Big screem Y coordinate
    BYTE    byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;
/////***********************************64-Tdecoder end*************************************//////


/********************************video platform scene begin*******************************/
#define  MAX_BIGSCREENNUM_SCENE 100
#define  MAX_LAYERNUMS    32


typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; // x Coordinate of the upper left corner
    WORD wYCoordinate; // y Coordinate of the upper left corner
    WORD wWidth;       // width of the box
    WORD wHeight;      // height of the box
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{
    BYTE    byEnable;                // 0-not used,1-used
    BYTE    bySoltNum;                // slot number
    BYTE    byRes1[2];
    BYTE    byDispChanNum;
    BYTE    byAudio;                // 0-close,1-open
    BYTE    byAudioWindowIdx;       // the index of window which open the audio
    BYTE    byVedioFormat;          // 1:NTSC,2:PAL,0-NULL
    BYTE    byWindowMode;            // window mode,get from the ability   
    BYTE    byEnlargeStatus;        // enlarge status, 0: does not enlarge, 1: enlarge
    BYTE    byEnlargeSubWindowIndex;// index of sub window which enlarge    
    BYTE    byScale;                // display mode,0-the real show,1-zoom display(BNC)
    DWORD   dwResolution;            // resolution
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];     // join decoder channel of the sub window
    BYTE    byJoinDecoderId[MAX_WINDOWS_V41];// decoder slot
    //resolution 1-D1,2-720P,3-1080P,the device alloc the decode channel according to this parameter
    BYTE    byDecResolution[MAX_WINDOWS_V41];
    BYTE    byRow;                    // row of the screen in the whole screen wall
    BYTE    byColumn;                // column of the screen in the whole screen wall
    BYTE    byRes2[5];
    NET_DVR_RECTCFG struDisp;        // location of screen wall
} NET_DVR_SCENEDISPCFG, *LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;            // IP address
    WORD     wDVRPort;                 // port
    BYTE     byChannel;                // channel index,the index start from 33 if the device use ip channel as 9000 dvr
    BYTE    byTransProtocol;        // trans protocol 0-TCP,1-UDP ,2-MCAST,3-RTP
    BYTE    byTransMode;            // trans mode 0-main stream 1-sub stream
    BYTE    byFactoryType;            // factory type
    BYTE    byDeviceType;            // device type 1-IPC,2- ENCODER
    BYTE    byRes[5];
    BYTE    sUserName[NAME_LEN];    // user name of the monitor
    BYTE    sPassword[PASSWD_LEN];    // password of the monitor
} NET_DVR_DEV_CHAN_INFO_SCENE, *LPNET_DVR_DEV_CHAN_INFO_SCENE;

typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE    byValid;            // 1-use stream media 0-does not use stream media
    BYTE    byRes1[3];
    NET_DVR_IPADDR struDevIP;    // ip of stream media server
    WORD    wDevPort;            // port of stream media server
    BYTE    byTransmitType;        // transmit type 0-TCP,1-UDP
    BYTE    byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE, *LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE, *LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE                            byEnable;                //enable status: 0-disable 1-enable
    BYTE                            byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE            struDecChanInfo;    //decoder channel information
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE, *LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//loop decode
typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD    wPoolTime;        //time interval of loop
    BYTE    byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE    struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE, *LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//single decode channel information
typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE    byDecodeEnable; //decode mark,0-stop,1-use dynamic decode,2-use loop decode
    BYTE    bySlotNum;        //slot index
    BYTE    byDecChan;        //decoder channel index
    BYTE    byRes[5];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg;        //dynamic decode
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;    //cycle    decode
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE, *LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid;            //roam status: 0:disable 1-enable 
    BYTE byAssociateBaseMap;    //base map index,0:does not associate
    BYTE byEnableSpartan;//enable spartan,1-enable,0-disable
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;    //big screen numbers, the max number should get from the ability
    BYTE  byRes1[3];
    WORD  wDecChanNums;        //decode channel numbers
    WORD  wDispChanNums;    //display channel numbers
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//buffer store big screen struct, byBigScreenNums*sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;    //buffer store decode channel, wDecChanNums*sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;    //buffer store display channel, wDispChanNums*sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;

/********************************video platform scene end*******************************/

/********************************NetAlarmHost begin*******************************/
//////////subsystem config/////////////
#define MAX_ALARMHOSTKEYBOARD 64 //max keyboards of alarmhost
typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //bit0- associate first subsystem.
    DWORD    dwJointSubSystem;
    BYTE    byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //bit0 ,be associated by the first public subsystem
    DWORD    dwBeJoinedSubSystem;
    BYTE    byRes[16];
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;

typedef union tagNET_DVR_JOINT_SUB_SYSTEM
{
    // use this parameter while byPublicAttributeEnable is 0
    NET_DVR_NOAMAL_SUB_SYSTEM     struNormalSubSystem;
    //use this parameter while byPublicAttributeEnable is 1
    NET_DVR_PUBLIC_SUB_SYSTEM        struPublicSubSystem;
    BYTE    byRes[20];
}NET_DVR_JOINT_SUB_SYSTEM, *LPNET_DVR_JOINT_SUB_SYSTEM;

//////////GPRS parameter config/////////////
#define    ACCOUNTNUM_LEN             6
#define ACCOUNTNUM_LEN_32       32
#define ACCOUNTNUM_LEN_V40      9
#define    APN_NAME_LEN            32
#define    APN_USERNAME_LEN        24
#define    APN_USERPASSWORD_LEN    16

#define MAX_SUBSYSTEM_ID_LEN 16 

typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD   dwSize;
    WORD    wEnterDelay;//enter delay  uint:s
    WORD    wExitDelay;//exit delay :s
    BYTE    byHostageReport;//hostage report,0-disable 1-enable
    BYTE        bySubsystemEnable; //subsystem enable
    BYTE        byKeyToneOfArmOrDisarm;// keyboard warn while send arm or disarm report successful,0-no 1-yes
    BYTE        byKeyToneOfManualTestReport;    //keyboard warn while send test report successful,0-no 1-yes
    WORD        wDelayTime;                        //delay time of siren
    BYTE        byEnableAlarmInDelay;//0--disable,1--enable
    BYTE         byPublicAttributeEnable;            //public subsystem enable
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;
    BYTE        byKeyZoneArm;        //arm subsystem by key switch
    BYTE        byKeyZoneArmReport;    //send report while key switch arm subsystem
    BYTE        byKeyZoneDisarm;    //disarm subsystem by key switch
    BYTE        byKeyZoneDisarmReport;    //send report while key switch disarm subsystem    
    BYTE        bySubSystemID[MAX_SUBSYSTEM_ID_LEN];    //subsystem ID
    BYTE        byKeyZoneArmReportEnable;    //0--disable,1--enable
    BYTE      byKeyZoneArmEnable;    //0--disable,1--enable
    BYTE       byOneKeySetupAlarmEnable;          //0--disable,1--enable
    BYTE       bySingleZoneSetupAlarmEnable;       //0--disable,1--enable
    BYTE    byCenterType;                    //0-invalid, 1-center account(length-6), 2-center account(length-9)
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //center account
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //center account V40, sCenterAccount invalid when using it
    BYTE         byRes2[565];
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct  tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;// 0-disable,1-enable
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME, *LPNET_DVR_REMIND_TIME;

#define    MAX_KEYBOARD_USER_NUM    256
typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD     dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //time of arm or disarm
    BYTE    byAlarmInAdvance;            // warn time of advance 0~45
    BYTE    byRes1[3];
    BYTE     byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//subsystem joint alarm in 0-no, 1-yes
    BYTE     byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//subsystem joint keyboard 0-no, 1-yes
    BYTE    byJointOpetaterUser[MAX_KEYBOARD_USER_NUM / 8];//subsystem joint keyboard user 0-no, 1-yes
    NET_DVR_REMIND_TIME    struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    BYTE	    byJointNetUser[NET_SDK_MAX_NET_USER_NUM / 8];//joint net user 0-no, 1-yes
    BYTE    byRes2[280];
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;

typedef struct tagNET_DVR_REGISTER_RS485CFG
{
    DWORD   dwSize;
    WORD    wDeviceProtocol;        // device protocol
    BYTE    byRes[2];
    DWORD   dwBaudRate;             //band rate(bps),0-50,1-75,2-110,3-150,4-300,5-600,6-1200,7-2400,8-4800,9-9600,10-19200,11-38400,12-57600,13-76800,14-115.2k 
    BYTE    byRes1[124];              // res
}NET_DVR_REGISTER_RS485CFG, *LPNET_DVR_REGISTER_RS485CFG;

typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD     dwSize;
    BYTE     byPrinterEnable;        //printer enable
    BYTE    byPrintTime;            //print time
    BYTE     byFaultDetect;            //check fault
    BYTE    byRes1;
    DWORD    dwAlarmInfo;            //alarm information,every bit means a alarm type.bit0-zone alarm,bit1-zone alarm restore,bit2-emergency Keypad Alarms,bit-3-duress alarm
    DWORD    dwDeviceInfo;            //device information,every bit means a alarm type.bit0-AC loss,bit1-AC loss restore,bit2-System low battery,bit3-System low battery restore,bit4-PSTN Fault,bit5-PSTN fault restore,bit6-test report,bit7-tamper alarm,bit8-temper restore,bit9-485 device fault,bit10-485 device restore,bit11-wireless network fault,bit12-wireless network restore,bit13-network fault,bit14-network restore,bit15-BUS Fault,bit16-BUS restore,bit17-hard disk faault,bit18-hard disk restore,bit19-keyboard locked
    DWORD    dwOperateInfo;            //operate information,every bit means a alarm type bit0-arm,bit1-disarm,bit2-clear alarm,bit3-bypass,bit4-bypass restore,bit5-enter program,bit6-exit program,bit7-restart
    BYTE     byRes2[256];
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    byAddressType;    //0 - invalid, 1 - ipv4/ipv6 addres,2 - domain name
    BYTE    byRes1[1];
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //domain name
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //it is valid while the protocol is NAL2300
    BYTE    byRes2[7];
}NET_DVR_ALARMHOST_NETPARAM, *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD    dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //center parameters 
    BYTE     byAPNName[APN_NAME_LEN/*32*/];
    BYTE    byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE    byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE    byReconnTime;    //Reconnect time, it is started when connecting is failed, unit: 10s range:(1-30)
    BYTE    byOverTime;        //Overtime, if there is no valid data in the OverTime,reconnect range: 1-254,unit :30s
    BYTE    byDetectLinkTime;    // range 1-30,unit:10s
    BYTE    byRes1;
    BYTE    bySIMNum[NAME_LEN/*32*/]; //SIM number
    NET_DVR_IPADDR    struSIMIP;      //Get only
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////net parameter config/////////////
typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM     struNetCenter[MAX_CENTERNUM];
    BYTE    byRes1[32];
}NET_DVR_ALARMHOST_NETCFG, *LPNET_DVR_ALARMHOST_NETCFG;

//////////report mode/////////////
#define    MAX_REPORTCHAN_NUM        4
#define    MAX_CENTERGROUP_NUM        16
typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD    dwSize;
    BYTE    byValid;
    BYTE    byRes[3];
    BYTE    byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //alarm channels, 1-T1,2-T2, 3-N1, 4-N2,5-G1, 6-G2
    BYTE    byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //send to these centers while send faile 0-not choose,1-choose
    BYTE    byDataType;    //1-alarm date 2-not alarm data 3-all data
    BYTE    byRes2[15];    //
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

/********************************NetAlarmHost end*********************************/

#define MAX_EVENT_NUM 32// max event number
typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD        dwSize;
    BYTE        byValid;
    BYTE        byDataType;            //1-All alarm data 2-not alarm data 3-all data,4-zone report,5-not zone report
    BYTE        byRes[2];
    BYTE        byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];//alarm channels, 1-T1,2-T2, 3-N1, 4-N2,5-G1, 6-G2 ,7-N3, 8-N4, 9-CMK-4G, 10-CMK-NET
    BYTE        byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //send to these centers while send fail 0-not choose,1-choose
    BYTE         byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];    //zone report type,0-not upload,1-upload 
    BYTE        byNonZoneReport[MAX_EVENT_NUM]; //not zone report, 0-not upload,1-upload byNonZoneReport[0]-soft zone report byNonZoneReport[1]-system status report byNonZoneReport[2]-cancel report byNonZoneReport[3]-test report byNonZoneReport[4]-arm report byNonZoneReport[5]-disarm report byNonZoneReport[6]-duress report byNonZoneReport[7]-alarm recovery report byNonZoneReport[8]-bypass report byNonZoneReport[9]-bypass restore report,byNonZoneReport[10]-detector connect status report(online/offline),byNonZoneReport[11]-detector power status report(normal/low);bit12-video alarm report
    BYTE        byAlarmNetCard[MAX_REPORTCHAN_NUM/*4*/];    //network card center,0-primary card_1,1-primary card_2,2-extend card_1,3-extend card_2
    BYTE        byRes2[252];
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;

// Stream record status
typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD          dwSize;
    BYTE            byRecord;         //(Read only)record type, 0:not record 1:recording
    BYTE            byOffLineRecord;  // 0-off 1-on
    BYTE            byRes1[2];
    DWORD            dwRelatedHD;      //Related hard disk
    BYTE            byRes2[8];
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

#define  CHAN_NO_LEN   24
typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE        byEnable;                    //Enable or not
    BYTE        byProType;                    //Protocol type 0-private(default), need ability to get
    BYTE          byZeroChan;                    //Is zero channel ,0-no,1-yes
    BYTE        byPriority;                //priority                    
    BYTE        sUserName[NAME_LEN];        //User name
    BYTE        sPassword[PASSWD_LEN];        //password
    BYTE        byDomain[MAX_DOMAIN_NAME];    //Domain
    NET_DVR_IPADDR  struIP;                        //IP adrress
    WORD        wDVRPort;                     //Port
    BYTE        byStreamType;               //Stream type 0:Main stream 1: Sub stream
    BYTE        byOnline;                    //Read only,0-offline 1-online                        
    DWORD        dwChannel;                  //Channel number
    BYTE        byTransProtocol;            //Transmition protocol,0-TCP,1-UDP,2-multicast
    BYTE        byLocalBackUp;
    WORD        wDirectLastTime;            //direct last time
    BYTE        byChanNo[CHAN_NO_LEN];     //Chan No
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;


typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE        byEnable;                    //Enable or not
    BYTE        byProType;                    //Protocol type 0-private(default), need ability to get
    BYTE          byZeroChan;                    //Is zero channel ,0-no,1-yes
    BYTE        byRes1;
    BYTE        sUserName[NAME_LEN];        //User name
    BYTE        sPassword[PASSWD_LEN];        //password
    BYTE        byAddress[MAX_DOMAIN_NAME];    //Domain
    WORD        wDVRPort;                     //Port
    BYTE        byStreamType;               //Stream type 0:Main stream 1: Sub stream
    BYTE        byOnline;                    //Read only,0-offline 1-online                        
    DWORD        dwChannel;                  //Channel number
    BYTE        byTransProtocol;            //Transmition protocol,0-TCP,1-UDP,2-multicast
    BYTE        byLocalBackUp;
    BYTE        byRes3[2];
    BYTE        byVAGChanNo[MAX_VAG_CHANNO_LEN];
    BYTE        byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];
    WORD    wStreamMediaPort;
    BYTE    byTransmitType;
    BYTE    byRes1[33];
    BYTE    byDevIP[64];
    WORD    wDevPort;
    BYTE    byChannel;
    BYTE    byTransMode; // 0-main 1- sub 
    BYTE    byProType;
    BYTE    byTransProtocol; //0-TCP,  1-UDP,  2-MultiCast,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byRes2[28];
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];
    WORD    wStreamMediaPort;
    BYTE    byTransmitType; //Transmit Type  0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64];
    WORD    wDevPort;
    BYTE    byChannel;
    BYTE    byTransMode; // 0-main 1- sub 
    BYTE    byProType;
    BYTE    byTransProtocol; //0-TCP,  1-UDP,  2-MultiCast,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byRes2[308];
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable;
    BYTE    byStreamType;
    BYTE    byLocalBackUp;
    BYTE     byRes;
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassWord[PASSWD_LEN];
    BYTE    byAddress[MAX_DOMAIN_NAME];
    WORD    wIPPort;
    WORD    wChanNo;
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];
    BYTE     byRes1[88];
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;

typedef union tagNET_DVR_STREAM_TYPE_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO    struChanInfo;          //IP Channel information
    NET_DVR_PU_STREAM_URL                struStreamUrl;        //Stream url
    NET_DVR_PU_STREAM_URL_CFG           struStreamUrlCfg;     //Get Stream for vqd 6
}NET_DVR_STREAM_TYPE_UNION, *LPNET_DVR_STREAM_TYPE_UNION;

typedef union tagNET_DVR_STREAM_TYPE_V40_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40    struChanInfo;     //IP Channel information 0
    NET_DVR_PU_STREAM_URL struPuStreamUrl;        //Stream url- 4
    NET_DVR_PU_STREAM_URL_CFG_V40   struStreamUrlCfg; //Get Stream for vqd 6
    NET_DVR_RTSP_PROTOCAL_CFG struRtspCfg;        //Get Stream by RTSP 7
    NET_DVR_STREAM_URL_V40  struStreamUrlV40;  // By streaming sources to take the stream flow (supports cascade) 8
}NET_DVR_STREAM_TYPE_V40_UNION, *LPNET_DVR_STREAM_TYPE_V40_UNION;


typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE                    byGetStreamType;    //Stream type 0-direct get stream from device,1-from stream media,2-From IPServer to device ip to get stream, 3.From IPServer find device,then get stream by stream media 4-From stream media by URL
    BYTE                    byRes[3];
    NET_DVR_STREAM_TYPE_UNION    uGetStream;
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

// Stream source information
typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD                    dwSize;
    NET_DVR_STREAM_MODE_TYPE    struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO, *LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD                    dwSize;
    BYTE                    byGetStreamType;    //Stream type 0-direct get stream from device,
    //1-from stream media,2-From IPServer to device ip to get stream, 3.From IPServer find device,then get stream by stream media 
    //4-From stream media by URL 7-RTSP  8-By streaming sources to take the stream flow (supports cascade)
    BYTE                    byRes1[3];
    NET_DVR_STREAM_TYPE_V40_UNION    uGetStream;
    BYTE                    byMonitorName[128];/*Monitor Name*/
    BYTE                    byRes[384];
}NET_DVR_STREAM_SRC_INFO_V40, *LPNET_DVR_STREAM_SRC_INFO_V40;


// Stream record information
typedef struct
{
    DWORD            dwSize;
    NET_DVR_RECORD_V30    struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

//  lock record by time and stream id
typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD            dwSize;
    NET_DVR_TIME        strBeginTime;
    NET_DVR_TIME        strEndTime;
    NET_DVR_STREAM_INFO struStreamInfo;        // Stream info
    DWORD            dwRecordType;
    DWORD            dwLockDuration;      // 0xffffffff: always lock
    NET_DVR_TIME_EX        strUnlockTimePoint;
    BYTE   		 	 byISO8601;      
    char       		 cTimeDifferenceH;   
    char             cTimeDifferenceM;     
    BYTE                byRes[1];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;


typedef struct tagNET_DVR_VOD_DRAWFRAME_PARA
{
    NET_DVR_TIME_EX struTime;
    /*
    dwDrawType
    0:I
    1:drop1/2 P(only svc code stream support)
    2:drop3/4P  (only svc code stream support)
    3:send1/2 I
    4:send1/4 I
    5:send1/8 I
    */
    DWORD  dwDrawType;
    BYTE   byRes[128];
}NET_DVR_VOD_DRAWFRAME_PARA, *LPNET_DVR_VOD_DRAWFRAME_PARA;

typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD            lRecordType;
    BYTE            byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;

typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;
    BYTE  byAssociateBaseMap;
    BYTE  byEnableSpartan;
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;
/*******************************config screen window*******************************/
#define MAX_WIN_COUNT  224 //maximum of windows

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD    dwSize;
    BYTE    byVaild;
    BYTE    byInputType;        //CAM_MDOE
    WORD    wInputIdx;            //index of input
    DWORD    dwLayerIdx;            //index of layer, 0- layer is on the bottom 
    NET_DVR_RECTCFG  struWin;    //window location, relativity to the display wall
    BYTE    byWndIndex;            //index of window
    BYTE    byCBD;                //0-NULL,1-has background,2-no background
    BYTE    bySubWnd;            //0-yes,1-no
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//device index
    BYTE    byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD    dwSize;
    WORD    wScreenSeq;    //index of screen
    BYTE    byRes[10];
    DWORD    dwWinNum;    //window numbers
    BYTE    *pBuffer;    //buffer used for window information, maximum length is 224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;    //length of buffer
}NET_DVR_WINLIST, *LPNET_DVR_WINLIST;

/*******************************Config layout*******************************/

#define MAX_LAYOUT_COUNT 16        //maximun of layout
typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;                                //is the layout valid.  0-not valid , 1-valid
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];            //name of layout            
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];    //window parameter in the plan
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;

/*******************************Config signal source of input******************************/
#define MAX_CAM_COUNT       224
#define MAX_CAM_COUNT_V50    512

typedef enum tagNET_DVR_CAM_MODE
{
    NET_DVR_UNKNOW = 0,
    NET_DVR_CAM_BNC,
    NET_DVR_CAM_VGA,
    NET_DVR_CAM_DVI,
    NET_DVR_CAM_HDMI,
    NET_DVR_CAM_IP,
    NET_DVR_CAM_RGB,
    NET_DVR_CAM_DECODER,
    NET_DVR_CAM_MATRIX,
    NET_DVR_CAM_YPBPR,
    NET_DVR_CAM_USB,
    NET_DVR_CAM_SDI,
    NET_DVR_CAM_HDI,
    NET_DVR_CAM_DP,
    NET_DVR_CAM_HDTVI,
    NET_DVR_CAM_JOINT,
    NET_DVR_CAM_HDBASET,
    NET_DVR_CAM_DVIT,
    NET_DVR_CAM_FUSION,
    NET_DVR_CAM_VSCREEN,
    NET_DVR_CAM_FIBER,
    NET_DVR_CAM_3GSDI, //3G-SDI
    NET_DVR_CAM_DISTRIBUTED_IP,
    NET_DVR_CAM_JONIT_X86,
    NET_DVR_CAM_TVI,
}NET_DVR_CAM_MODE;

typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD    dwSize;
    BYTE    byValid;
    BYTE    byCamMode;                        //the type of signal source
    WORD    wInputNo;                        //the index of signal source0-224
    BYTE    sCamName[NAME_LEN];            //the name of signal source
    NET_DVR_VIDEOEFFECT struVideoEffect;    //video parameter
    NET_DVR_PU_STREAM_CFG    struPuStream;    //stream media parameter
    WORD    wBoardNum;                        //index of board which has this signal source 
    WORD    wInputIdxOnBoard;                //station of signal source in the board
    DWORD   dwResolution;//resolution
    BYTE    byVideoFormat;//video format(VIDEO_STANDARD)
    BYTE    byStatus;    //signal source status, 0-invaild 1-has signal 2-no signal 3-exception
    BYTE    sGroupName[NAME_LEN/*32*/];        //group name of net signal
    BYTE    byJointMatrix;                    // Joint matrix
    BYTE    byRes;
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT];
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

/*******************************config output channels*******************************/
typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;        //output mode,1-BNC,2-VGA,3-DVI,4-HDMI
    BYTE   byRes1[3];
    DWORD  dwResolution;    //resolution;
    NET_DVR_VIDEOEFFECT  struVideoEffect;    //video parameter
    BYTE    byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD dwSize;
    BYTE byScreenLayX;                        //maximum screen numbers in x coordinate of the layout
    BYTE byScreenLayY;                        //maximum screen numbers in x coordinate of the layout
    WORD wOutputChanNum;                    //output channel numbers,0-maximum numbers of the device support,the other value means the output channel numbers
    BYTE byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;    //video parameter of output channels
    BYTE    sWallName[16];                    //wall name
    BYTE    byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

/*******************************ability*******************************/
#define SCREEN_PROTOCOL_NUM      20    //maximum numbers of screen controller's protocol
//ability of screen server
typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;
    BYTE byIsSupportScreenNum; //support numbers of screen
    BYTE bySerialNums;            //serial numbers
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//maximum screen numbers in x coordinate of the layout
    BYTE byMaxScreenLayY;//maximum screen numbers in x coordinate of the layout
    WORD wMatrixProtoNum; //protocol numbers of matrix
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];// maximum protocol lists of screen
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

//ability of screen controller

typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;
    BYTE byLayoutNum;         // numbers of layout
    BYTE byWinNum;             // numbers of window
    BYTE byOsdNum;          //numbers of OSD
    BYTE byLogoNum;         //numbers of Logo
    BYTE byInputStreamNum;  //numbers of input source (local input + net signal)
    BYTE byOutputChanNum;    //numbers of output channel
    BYTE byCamGroupNum;        //numbers of camera group
    BYTE byPlanNum;            //numbers of plan
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  //0-not support playback 1-support playback
    BYTE byMatrixInputNum;  //maximum numbers of matrix
    BYTE byMatrixOutputNum; //maximum numbers of output
    NET_DVR_DISPINFO struVgaInfo;//VGA information
    NET_DVR_DISPINFO struBncInfo;//BNC information
    NET_DVR_DISPINFO struHdmiInfo;//HDMI information
    NET_DVR_DISPINFO struDviInfo;//DVI information
    BYTE byMaxUserNums;        //numbers of user
    BYTE byPicSpan;            //span of the picture,max screen numbers of one basemap overlapped
    WORD wDVCSDevNum;        //numbers of sub device
    WORD wNetSignalNum;        //numbers of net signals
    WORD wBaseCoordinateX;    //base coordinate
    WORD wBaseCoordinateY;
    BYTE byExternalMatrixNum;    //max matrix number
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

/*******************************status of input source*******************************/
typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD    dwLostFrame;        //the number of lost frames
    BYTE    byHaveSignal;        //is there signal? 0-no 1-yes
    BYTE    byVideoFormat;        //video format,1:NTSC,2:PAL,0:null
    BYTE    byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;

typedef union tagNET_DVR_INPUTSTATUS_UNION
{
    NET_DVR_MATRIX_CHAN_STATUS struIpInputStatus;
    NET_DVR_ANALOGINPUTSTATUS struAnalogInputStatus;
} NET_DVR_INPUTSTATUS_UNION, *LPNET_DVR_INPUTSTATUS_UNION;

typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD    wInputNo;        //index of source
    BYTE    byInputType;    //CAM_MODE
    BYTE    byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE    byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwNums;        //the numbers of input source states
    BYTE    *pBuffer;    //buffer
    DWORD   dwBufLen;    //the len of buffer
}NET_DVR_SCREENINPUTSTATUS, *LPNET_DVR_SCREENINPUTSTATUS;

/*******************************alarm of screen*******************************/
typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD    dwSize;
    BYTE    byAlarmType;    //alarm type,1-subboard pull out,2-Insert subboard,3-subsystem abnormal,4-subsystem restoration 5-input source abnormal   6-alarm of temperature 7-FPGA version mismatch 8-begin plan 9-plan over 10-decoder net broken 11-decoder ip confilct,12-fan abnormal
    BYTE    byBoardType;    // 1-input board 2-output board 3-back board 4-main board
    BYTE    bySubException;    //sub exception when input exception occur 1- change resolution normal 2-change interface 3-resolution error 4-resolution change, lead to alloc resource error 5-resolution change, lead to window size is not in the normal range 6-resolution return to normal,7-resolution change, lead to output board data overflow.
    BYTE    byRes1;
    WORD    wStartInputNum; // input source exception , starting point
    WORD    wEndInputNum;    // input source exception , stopping point 
    BYTE    byRes2[16];
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

/*******************************config the screen server*******************************/
typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;                //is the analog platform valid; 0- not valid,  1-valid 
    BYTE  byCommandProtocol;    //the command of platform , 1-MATRIX_COMMAND_V1, 2-MATRIX_COMMAND_V2, 3-MATRIX_COMMAND_V3, 4-MATRIX_COMMAND_V4
    BYTE  byScreenType;
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];    //relation between screen and analog
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;//IP if the device is a digital device
    WORD            wPort;        //port
    BYTE            byRes[26];  //
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;
typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE    byDevSerPortNum;   //serial port numbers
    BYTE    byScreenSerPort;  // the index of serial port
    BYTE    byRes[130];
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;

typedef union tagNET_DVR_SCREEN_UNION
{
    NET_DVR_DIGITALSCREEN struDigitalScreen;
    NET_DVR_ANALOGSCREEN struAnalogScreen;
}NET_DVR_SCREEN_UNION, *LPNET_DVR_SCREEN_UNION;
typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;                //Is the struct valid or not? 0-not valid,  1-valid
    BYTE nLinkMode;                //link mode,0-serial work,1-network
    BYTE byDeviceType;            //device type, get from ability
    BYTE byScreenLayX;            //lay of the screen , x coordinate
    BYTE byScreenLayY;            //lay of the screen, y coordinate
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];    //User name
    BYTE sPassword[PASSWD_LEN]; //password   
    BYTE sDevName[NAME_LEN];    //device name
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;            // input source,used for platform
    BYTE byOutputNum;            // output source , used for platform
    BYTE byCBDNum;                //CBD numbers
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

/*******************************upload background picture*******************************/
typedef struct tagNET_DVR_BASEMAP_CFG
{
    BYTE byScreenIndex;         //screen Index
    BYTE byMapNum;                //map numbers
    BYTE res[2];
    WORD wSourWidth;            //source picture width
    WORD wSourHeight;            //source picture height
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;


typedef struct tagNET_DVR_PICCFG
{
    DWORD    dwSize;
    BYTE    byUseType;    //1use for background picture
    BYTE    bySequence; //picture index
    BYTE    byOverlayEnabled; //picture overlay enabled 1-include overlay param0-not include
    BYTE    byRes[1];
    NET_DVR_BASEMAP_CFG    struBasemapCfg;
    BYTE    sPicName[NAME_LEN];//Pic name
    DWORD   dwVideoWall;       //1 byte WallNo + 1 byte channelNo +2 byte windowNo
    BYTE   	byFlash; //flashEnabled1-yes0-no
    BYTE   	byTranslucent; //translucentEnabled1-yes0-no
    BYTE    byShowEnabled; //showEnabled1-yes0-no
    BYTE    byPictureType; //pictureType1-bmp2-jpg3-png
    BYTE    byRes2[24];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;
/*******************************OSD*******************************/
#define MAX_OSDCHAR_NUM 256
typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*0-invalid,  1-valid*/
    BYTE    byDispMode;  //Display mode ,1-transparent,2-translucent,3-cover
    BYTE    byFontColorY; /*Font colorY,0-255*/
    BYTE    byFontColorU; /*Font colorU,0-255*/
    BYTE    byFontColorV; /*Font colorV,0-255*/
    BYTE    byBackColorY; /**Back colorY,0-255*/
    BYTE    byBackColorU; /**Back colorU,0-255*/
    BYTE    byBackColorV; /**Back colorV,0-255*/
    WORD    wXCoordinate;   /*virtual LED point coordinate x*/
    WORD    wYCoordinate;   /*virtual LED point coordinate y*/
    WORD    wWidth;       /*virtual LED width*/
    WORD    wHeight;      /*virtual LED height*/
    DWORD   dwCharCnt;     /*virtual LED numbers*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM]; /*virtual LED content*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;
/*******************************Get Serial information*******************************/
typedef struct tagNET_DVR_SERIAL_CONTROL
{
    DWORD    dwSize;
    BYTE    bySerialNum;        // serial numbers
    BYTE    byRes1[3];
    BYTE    bySerial[32];        //serial name;
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;

/*******************************control screen*******************************/
typedef enum tagINPUT_INTERFACE_TYPE
{
    INTERFACE_VGA = 0,
    INTERFACE_SVIDEO,    // 2046NL does not support,2046NH support
    INTERFACE_YPBPR,
    INTERFACE_DVI,
    INTERFACE_BNC,
    INTERFACE_DVI_LOOP,    // (loop through) 2046NH not support,2046NL support
    INTERFACE_BNC_LOOP, // (loop through) 2046NH not support,2046NL.support
    INTERFACE_HDMI,
    INTERFACE_IP,
    INTERFACE_USB,
    INTERFACE_SDI,
    INTERFACE_DP,
    INTERFACE_HDBASET
}INPUT_INTERFACE_TYPE;

typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE    byInputSourceType;    //see the struct INPUT_INTERFACE_TYPE
    BYTE    byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;
//control color
typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE    byColorType;        //1-brightness 2-contrast 3-saturation 4-definition
    char    byScale;            //-1 ,0,+1
    BYTE    byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;
//control position
typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE    byPositionType;        //1-horizontal position 2-vertical position
    char    byScale;            //-1,0,+1
    BYTE    byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;



/*******************************Screen Control V41*******************************/
typedef struct tagNET_DVR_RECTCFG_EX
{
    DWORD dwXCoordinate; /*X coordinate*/
    DWORD dwYCoordinate; /*Y coordinate*/
    DWORD dwWidth;       /*width*/
    DWORD dwHeight;      /*height*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;

/*******************************plan manage*******************************/
#define        MAX_PLAN_ACTION_NUM     32     //plan action number
#define        DAYS_A_WEEK                7    //7 days a week
#define        MAX_PLAN_COUNT            16    //plan count

typedef enum
{
    NET_DVR_SWITCH_LAYOUT = 1,         // switch layout
    NET_DVR_SCREEN_POWER_OFF,          // turn off screen
    NET_DVR_SCREEN_POWER_ON,           // turn on screen
    NET_DVR_SWITCH_BASEMAP            //base map switch
}NET_DVR_PLAN_OPERATE_TYPE;

typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE      byValid;          // is the plan valid
    BYTE      byType;           // NET_DVR_PLAN_OPERATE_TYPE
    WORD      wLayoutNo;      // layout number
    BYTE    byScreenStyle;    //the type of screen,1-low bright,2-high bright
    BYTE  byBaseMapType;  //base map type, 1 - picture base map, 2 - UHD base map, valid when byType is NET_DVR_SWITCH_BASEMAP
    BYTE  byRes1[2];
    DWORD      dwDelayTime;      // plan delay time, unit /s
    DWORD   dwSerialNo;        //serial No.,valid for screen control
    DWORD  dwBaseMapWndNo; //base map window number, valid when byType is NET_DVR_SWITCH_BASEMAP
    DWORD  dwBaseMapNo;  //base map number, valid when byType is NET_DVR_SWITCH_BASEMAP; when base map type is 1, it is picture number; when base map type is 2, it is UHD subsystem input channel number.
    BYTE    byRes2[20];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;
typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE    byValid;
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;
/*plan manage*/
typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD     dwSize;
    BYTE      byValid;          // is the plan valid
    BYTE      byWorkMode;      // the plan work mode 1-manual,2-auto,3-cycle
    BYTE    byWallNo;        // wall no.,start from 1
    BYTE    byPlanNo;
    BYTE      byPlanName[NAME_LEN/*32*/]; //plan name
    NET_DVR_TIME_EX struTime; // time when the work mode is auto
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*cycle time*/
    DWORD     dwWorkCount;      // plan work count
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // plan information
    DWORD		dwPlanNo; //4 bytes plan no., client use dwPlanNo, not use byPlanNo
    BYTE		byRes2[60];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;

typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD        dwSize;
    DWORD        dwPlanNums;            //input signal numbers
    BYTE          *pBuffer;            //buffer
    BYTE        byWallNo;            //wall no.,start from 1
    BYTE        byRes1[2];
    DWORD         dwBufLen;            //buffer size
    BYTE        byRes2[64];
} NET_DVR_PLAN_LIST, *LPNET_DVR_PLAN_LIST;

/*******************************plan control*******************************/
typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD    dwSize;
    BYTE    sDeviceID[NAME_LEN]; //device ID
    WORD    wChan;                 //channel
    BYTE    byIndex;
    BYTE    byRes1;
    DWORD    dwControlParam;
    BYTE    byMandatoryAlarm;    //1-enable  0-disable
    BYTE      byRes2;
    WORD     wZoneIndex;
    BYTE      byOperatorCode[16];
    DWORD	dwPlanNo; //4 bytes plan no., client use dwPlanNo, not use byPlanNo
    BYTE	byRes3[8];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

/*******************************GET DEVICE STATUS*******************************/
typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD   dwSize;
    DWORD   dwMemoryTotal;          //Total Memory Unit: KByte
    DWORD   dwMemoryUsage;          //Memory Used Unit: KByte
    BYTE    byCPUUsage;             //CPU Used 0-100
    BYTE    byMainFrameTemp;        //Main frame temperature, unit: Celcius
    BYTE    byBackPanelTemp;        //Back panel temperature, unit: Celcius
    BYTE    byRes1[1];
    BYTE    byLeftDecResource[32];  //left resource of each decode board, oxff-invalid
    float   fNetworkFlow;           //network flow,KB/s,eg:1200.00KB/s
    BYTE    byRes2[88];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

/*******************************Picture Preview*******************************/

/******************************GET INPUT SIGNAL LIST*******************************/
typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD        dwSize;
    DWORD        dwInputSignalNums;    //input signal numbers
    BYTE          *pBuffer;            //buffer
    BYTE        byRes1[3];
    DWORD         dwBufLen;            //buffer size
    BYTE        byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST, *LPNET_DVR_INPUT_SIGNAL_LIST;
/********************************Screen Controller end****************************/

/********************************ATM Safety Cabin begin *********************************/
typedef  struct tagNET_DVR_ALARMHOST_SAFETYCABINSTATE
{
    DWORD    dwSize;
    BYTE    byEnterButton;    //enter button state 0-the button is not pushed down;  1-the button is pushed down
    BYTE    byExitButton;    //exit button state 0-the button is not pushed down;  1-the button is pushed down
    BYTE    byDoorState;    //door state    0-close  1-open
    BYTE    byLockState;    //locker state 0-locked    1-unlocked
    BYTE    byUrgencyButton;//Urgency Button state    0-the button is not pushed down;  1-the button is pushed down
    BYTE    byManState;     //man state     0-there is no one in the cabin; 1-there is someone in the cabin
    BYTE    byAbnormal;     //abnormal state  0-normal 1-abnormal
    BYTE    byLightState;   //light state,0-close,1-open
    BYTE    byFanState;     //fan state 0-close,1-open
    BYTE    byFollow;       //follow 0-no,1-yes
    BYTE    byFighting;     //fight 0-no,1-yes
    BYTE    byFaint;        //faint 0-no,1-yes
    BYTE    byManyPerson;   //ManyPerson 0-single,1-many
    BYTE    byRes[59];      //reserve
}NET_DVR_ALARMHOST_SAFETYCABINSTATE, *LPNET_DVR_ALARMHOST_SAFETYCABINSTATE;

typedef  struct tagNET_DVR_ALARMHOST_ALARMOUTSTATUS
{
    DWORD    dwSize;
    BYTE    byName[32];        //the name of Alarm output or siren
    BYTE    byAlarmType;    //1-Alarm output status, 2-SirenStatus
    WORD    wChan;            //if the byAlarmType is alarm output status, this value is 0-511;else if the byAlarmType is siren status, this value is 1-8 (there is only one siren in SAFETYCABIN)
    BYTE    byAlarmStatus; //Alarm status,   0-no alarm 1-alarm
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_ALARMOUTSTATUS, *LPNET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////audio upload and download/////////////
typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD        dwSize;
    BYTE        byAudioFormat;      //audio format,1-G711,2-G722 
    BYTE        byRes1;
    WORD        wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD        dwSamplesPerSec;    //samples per second
    BYTE        byRes2[20];
    DWORD        dwAudioSize;        //length of audio file
}NET_DVR_AUDIO_PARAM, *LPNET_DVR_AUDIO_PARAM;
/********************************DS_19SXX begin *********************************/

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD    dwSize;
    DWORD    dwOverallEventTriggerAlarmoutOn;    //overall event cause alarmout on ,bit0-AC outage,bit1-low voltage of battery,bit2-telephone off_line,bit3-network abnormal,bit4-Wireless network abnormal,bit5-HD error,bit6-3G/4G signal abnormal,bit7-third host offline ,bit8- WIFIfault,bit9-RFsignal fault
    DWORD    dwOverallEventTriggerAlarmoutOff;    //overall event cause alarmout off,bit0-AC outage,bit1-low voltage of battery,bit2-telephone off_line,bit3-network abnormal,bit4-Wireless network abnormal,bit5-HD error    ,bit11- WIFIfault,bit12-RFsignal fault
    DWORD    dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //subsystem event cause alarmout on,dwSubSystemEvent[0] is subsystem 1,dwSubSystemEvent[2] is subsystem 1,every bit is a subsystem event,bit0-enter delay time,bit1-exit delay time,bit2-arm,bit3-disarm,bit4-alarm, bit5-clear alarm, bit6-alarm restore
    DWORD    dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //subsystem event cause alarmout off,wSubSystemEvent[0] is subsystem 1,dwSubSystemEvent[2] is subsystem 2,every bit is a subsystem event,bit0-enter delay time,bit1-exit delay time,bit2-arm,bit3-disarm,bit4-alarm, bit5-clear alarm, bit6-alarm restore
    BYTE    byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD     dwSize;
    DWORD    dwCheckFault;    //Check fault,bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormal,bit9-FPGA abnornmal,bit10-analog quantity abnornmal,bit11-Zone expand Board Abnormal,bit12-Wifi abnornmal,bit13-RF signal abnornmal
    DWORD    dwOverallFaultJointLED;        //fault cause overall keyboard led turn on, bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormalCID_MODULE_FAIL = 913
    DWORD    dwOverallFaultJointSound;    //fault cause overall keyboard sound turn on, bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormal
    DWORD    dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*fault cause subsystem keyboard led turn on,dwSubSystemFaultJointLED[0] associate to first subsystem.every bit means one fault of subsystem in dwSubSystemFaultJointLED[0],bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormal*/
    DWORD    dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*fault cause subsystem keyboard sound turn on, dwSubSystemFaultJointLED[0]associate to first subsystem.every bit means one fault of subsystem in dwSubSystemFaultJointSound,bit0-AC outage,bit1-low voltage of battery,bit2-device prevent disassemble,bit3-telephone off_line,bit4-485 device abnormal,bit5-network abnormal,bit6-wireless abnormal,bit7-expand bus abnormal,bit8-hard disk abnormal*/
    DWORD    dwFaultJointFaultLight;//fault joint LED
    BYTE    byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD    dwSize;
    BYTE    byIndex;
    BYTE       byRes[63];
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;

#define CID_CODE_LEN 4
#define DEV_SERIAL_LEN 9
typedef enum tagNET_DVR_ALARMHOST_REPORT_TYPE
{
    NET_DVR_DEFENCE_ALARM = 1,            //Zone alarm
    NET_DVR_VIDEO_ALARM,            //video alarm
    NET_DVR_VIRTUAL_DEFENCE_ALARM,    //virtual Zone alarm
    NET_DVR_HOSTAGE_ALARM,            //hostage alarm
    NET_DVR_KNOCK_DOWN_ALARM,        //knock down alarm
    NET_DVR_OPERATE_ALARM,            //operate alarm
    NET_DVR_OHTER_ABNORMAL_ALARM    //abnormal alarm
}NET_DVR_ALARMHOST_REPORT_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MAIN_TYPE
{
    CID_ENTER = 1000,
    CID_EXIT = 3000
}NET_DVR_ALARMHOST_CID_MAIN_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MINOR_TYPE
{
    CID_MEDICAL_ALARM = 100,
    CID_ALARM = 103,
    CID_FIRE_ALARM = 110,
    CID_ABDUCT_REPORT = 121,
    CID_SILENT_24 = 122,
    CID_AUDIO_24 = 123,
    CID_AUXILIARY_24 = 124,
    CID_SHOCK_24 = 125,
    CID_OVERTIME_ALARM = 126,
    CID_EMERGENCE_CALL_HELP = 129,
    CID_BURGLARY_ALARM = 130,
    CID_PERIMETER_ALARM = 131,
    CID_INNET_ALARM = 132,
    CID_ENTER_EXIT = 134,
    CID_DEVICE_OPEN = 137,
    CID_ZONE_BUS_BREAK = 141,
    CID_ZONE_BUS_SHORT = 142,
    CID_MOTION_ALARM = 148,
    CID_GAS_LEAKAGE = 151,
    CID_ZONE_EARLY_WARNING = 207,
    CID_AC_LOSS = 301,
    CID_LOW_BATT_VOL = 302,
    CID_DEV_RESET = 305,
    CID_MBUS_MODEL_FAULT = 333,
    CID_PRINTER_FAIL = 336,
    CID_LOW_EXPANDER_VOL = 338,
    CID_EXPANDER_OPEN = 341,
    CID_EXPANDER_AC_POWER_DOWN = 342,
    CID_WIRELESS_REPEATER_TAMPERED = 343,
    CID_WIRELESS_SIREN_TAMPERED = 344,
    CID_WIRELESS_SIREN_DISCONNECTED = 345,
    CID_LINE_LOSS = 354,
    CID_BUS_LOSS = 382,
    CID_DETECTOR_OPEN = 383,
    CID_ZONE_OPEN_CIRCUIT = 386,
    CID_ZONE_SHORT_CIRCUIT = 387,
    CID_GUARD = 401,
    CID_GUARD_AUTO = 403,
    CID_CANCEL_ARM = 406,
    CID_GUARD_IMME = 408,
    CID_KEY_ZONE_GUARD = 409,
    CID_GUARD_STAY = 441,
    CID_FORCED_ARM = 442,
    CID_AUTOCTRL_TRIG = 443,
    CID_ONETOUCH_AWAY_ARMING = 444,
    CID_ONETOUCH_STAY_ARMING = 445,
    CID_CARD_ARMING_OR_DISARMING = 446,
    CID_LATE_TO_DISARM = 452,
    CID_AUTOGUARD_FAIL = 455,
    CID_AOPEN_TRIG_FAIL = 460,
    CID_ACLOSE_TRIG_FAIL = 461,
    CID_AUTOUNGUARD_FAIL = 462,
    CID_BYPASS = 570,
    CID_GROUP_BYPASS = 574,
    CID_MANUAL_TEST_RPT = 601,
    CID_AUTO_TEST_RPT = 602,
    CID_PHONE_CONNET_TEST = 617,
    CID_ENTER_PROG = 627,
    CID_EXIT_PROG = 628,
    CID_FIELD_DETECTION = 759,
    CID_LINE_DETECTION = 773,
    CID_PIR_ALARM = 774,
    CID_SOUND_INTENSITY_RISE = 775,
    CID_SOUND_INTENSITY_DROP = 776,
    CID_AUDIO_INPUT_EXCEPTION = 777,
    CID_SOFT_INSTAND = 810,
    CID_SOFT_FIRE = 811,
    CID_SOFT_MOBS = 812,
    CID_KEYPAD_LOCKED = 862,
    CID_ABSENCE_ALARM = 863,
    CID_KEY_FAIL = 910,
    CID_TRIGGER_FAIL = 911,
    CID_GPK_FAIL = 912,
    CID_MODULE_FAIL = 913,
    CID_WIRELESS_DETECTOR_FAIL = 914,
    CID_WIRELESS_DETECTOR_BATTERY_LOW = 915,
    CID_EXPANDER_DISCONNECT = 916,
    CID_WIRELESS_REPEATER_DISCONNECT = 917,
    CID_RADAR_TRANS_FAULT = 918,
    CID_WIRELESS_SIREN_LOW_BATTERY = 919,
    CID_WRIE_LESS_NET = 920,
    CID_SIM_FAULT = 921,
    CID_WIFI_ABNORMAL = 922,
    CID_RF_ABNORMAL = 923,
    CID_DATE_TRAFFIC_OVERFLOW = 924,
    CID_IPADDR_CONFLICT = 930,
    CID_ETHERNET_BROKEN = 931,
    CID_GROUP_OUT_RP = 932,
    CID_GROUP_IN_RP = 933,
    CID_MOTION_DECTECT = 940,
    CID_MASK_ALARM = 941,
    CID_VI_LOST = 942,
    CID_VS_MISMATCH = 943,
    CID_VI_EXCEPTION = 944,
    CID_HD_FULL = 945,
    CID_HD_ERROR = 946,
    CID_PIC_SEND_FAILED = 947,
    CID_KEY_LOCKED = 948,
    CID_NETWORK_CAMERA_DISCONNECT = 949,
    CID_DUTY_CHECKING = 960,
    CID_POST_RESPONSE = 961,
    CID_ZONE_BUS_SEARCH = 970,
    CID_ZONE_BUS_REGIST = 971,
    CID_GUARD_DELAY_OP = 972,
    CID_GUARD_SINGLE = 973,
    CID_SINGLE_ZONE_CLEARED = 974,
    CID_ZONE_ASSOCIATED_DETECTOR = 975,
    CID_ZONE_CONSULTING = 976,
    CID_EXPANDER_DELETED = 977,
    CID_WIRELESS_REPEATER_DELETED = 978,
    CID_WIRELESS_SIREN_DELETED = 979,
}NET_DVR_ALARMHOST_CID_MINOR_TYPE;

typedef enum tagNET_DVR_ALARMHOST_CID_ALL_MINOR_TYPE
{
    CID_TYPE_MEDICAL_ALARM = 1100,
    CID_TYPE_MEDICAL_ALARM_RESET = 3100,
    CID_TYPE_ALARM = 1103,
    CID_TYPE_ALARM_RESET = 3103,
    CID_TYPE_FIRE_ALARM = 1110,
    CID_TYPE_FIRE_ALARM_RESET = 3110,
    CID_TYPE_ABDUCT_REPORT = 1121,
    CID_TYPE_SILENT_24 = 1122,
    CID_TYPE_SILENT_24_RESET = 3122,
    CID_TYPE_AUDIO_24 = 1123,
    CID_TYPE_AUDIO_24_RESET = 3123,
    CID_TYPE_AUXILIARY_24 = 1124,
    CID_TYPE_AUXILIARY_24_RESET = 3124,
    CID_TYPE_SHOCK_24 = 1125,
    CID_TYPE_SHOCK_24_RESET = 3125,
    CID_TYPE_TIMEOUT = 1126,
    CID_TYPE_TIMEOUT_RESET = 3126,
    CID_TYPE_EMERGENCE_CALL_HELP = 1129,
    CID_TYPE_EMERGENCE_CALL_HELP_RESET = 3129,
    CID_TYPE_BURGLARY_ALARM = 1130,
    CID_TYPE_BURGLARY_ALARM_RESET = 3130,
    CID_TYPE_PERIMETER_ALARM = 1131,
    CID_TYPE_PERIMETER_ALARM_RESET = 3131,
    CID_TYPE_INNET_ALARM = 1132,
    CID_TYPE_INNET_ALARM_RESET = 3132,
    CID_TYPE_ENTER_EXIT = 1134,
    CID_TYPE_ENTER_EXIT_RESET = 3134,
    CID_TYPE_DEVICE_OPEN = 1137,
    CID_TYPE_DEVICE_OPEN_RESET = 3137,
    CID_TYPE_ZONE_BUS_BREAK = 1141,
    CID_TYPE_ZONE_BUS_BREAK_RESET = 3141,
    CID_TYPE_ZONE_BUS_SHORT = 1142,
    CID_TYPE_ZONE_BUS_SHORT_RESET = 3142,
    CID_TYPE_MOTION_ALARM = 1148,
    CID_TYPE_MOTION_ALARM_RESET = 3148,
    CID_TYPE_GAS_LEAKAGE_ALARM = 1151,
    CID_TYPE_GAS_LEAKAGE_ALARM_RESET = 3151,
    CID_TYPE_ZONE_EARLY_WARNING = 1207,
    CID_TYPE_ZONE_EARLY_WARNING_RESET = 3207,
    CID_TYPE_AC_LOSS = 1301,
    CID_TYPE_AC_LOSS_RESET = 3301,
    CID_TYPE_LOW_BATT_VOL = 1302,
    CID_TYPE_LOW_BATT_VOL_NORMAL = 3302,
    CID_TYPE_DEV_RESET = 1305,
    CID_TYPE_MBUS_MODEL_FAULT = 1333,
    CID_TYPE_MBUS_MODEL_RESET = 3333,
    CID_TYPE_PRINTER_OFF = 1336,
    CID_TYPE_PRINTER_ON = 3336,
    CID_TYPE_EXTEND_MODULE_VOL_LOW = 1338,
    CID_TYPE_EXTEND_MODULE_VOL_NORMAL = 3338,
    CID_TYPE_EXTEND_MODULE_REMOVE = 1341,
    CID_TYPE_EXTEND_MODULE_RECOVER = 3341,
    CID_TYPE_EXTEND_MODULE_AC_LOSS = 1342,
    CID_TYPE_EXTEND_MODULE_AC_LOSS_RESET = 3342,
    CID_TYPE_WIRELESS_REPEATER_TAMPER = 1343,
    CID_TYPE_WIRELESS_REPEATER_RESTORE = 3343,
    CID_TYPE_WIRELESS_SIREN_TAMPER = 1344,
    CID_TYPE_WIRELESS_SIREN_RESTORE = 3344,
    CID_TYPE_WIRELESS_SIREN_DISCONNECT = 1345,
    CID_TYPE_WIRELESS_SIREN_CONNECT = 3345,
    CID_TYPE_LINE_LOSS = 1354,
    CID_TYPE_LINE_LOSS_RESET = 3354,
    CID_TYPE_BUS_LOSS = 1382,
    CID_TYPE_BUS_LOSS_RESET = 3382,
    CID_TYPE_SENSOR_TAMPER = 1383,
    CID_TYPE_SENSOR_TAMPER_RESET = 3383,
    CID_TYPE_ZONE_OPEN_CIRCUIT_ALARM = 1386,
    CID_TYPE_ZONE_SHORT_CIRCUIT_ALARM = 1387,
    CID_TYPE_DISARM = 1401,
    CID_TYPE_ARM = 3401,
    CID_TYPE_DISARM_AUTO = 1403,
    CID_TYPE_ARM_AUTO = 3403,
    CID_TYPE_CANCEL_ARM = 1406,
    CID_TYPE_ARM_IMME = 3408,
    CID_TYPE_KEY_ZONE_ARM = 1409,
    CID_TYPE_KEY_ZONE_DISARM = 3409,
    CID_TYPE_GUARD_STAY = 3441,
    CID_TYPE_FORCED_ARM = 3442,
    CID_TYPE_AUTOCTRL_TRIG_ON = 1443,
    CID_TYPE_AUTOCTRL_TRIG_OFF = 3443,
    CID_TYPE_LATE_TO_DISARM = 1452,
    CID_TYPE_AUTOGUARD_FAIL = 1455,
    CID_TYPE_AOPEN_TRIG_FAIL = 1460,
    CID_TYPE_ACLOSE_TRIG_FAIL = 1461,
    CID_TYPE_AUTOUNGUARD_FAIL = 1462,
    CID_TYPE_BYPASS = 1570,
    CID_TYPE_BYPASS_RESET = 3570,
    CID_TYPE_GROUP_BYPASS = 1574,
    CID_TYPE_GROUP_BYPASS_RESET = 3574,
    CID_TYPE_MANUAL_TEST_RPT = 1601,
    CID_TYPE_AUTO_TEST_RPT = 1602,
    CID_TYPE_LINE_TEST = 1617,
    CID_TYPE_ENTER_PROG = 1627,
    CID_TYPE_EXIT_PROG = 1628,
    CID_TYPE_FIELD_DETECTION = 1759,
    CID_TYPE_FIELD_DETECTION_RESET = 3759,
    CID_TYPE_LINE_DETECTION = 1773,
    CID_TYPE_LINE_DETECTION_RESET = 3773,
    CID_TYPE_PIR_ALARM = 1774,
    CID_TYPE_PIR_ALARM_RESET = 3774,
    CID_TYPE_SOUND_INTENSITY_RISE = 1775,
    CID_TYPE_SOUND_INTENSITY_RISE_RESET = 3775,
    CID_TYPE_SOUND_INTENSITY_DROP = 1776,
    CID_TYPE_SOUND_INTENSITY_DROP_RESET = 3776,
    CID_TYPE_AUDIO_INPUT_EXCEPTION = 1777,
    CID_TYPE_AUDIO_INPUT_EXCEPTION_RESET = 3777,
    CID_TYPE_SOFT_INSTAND = 1810,
    CID_TYPE_SOFT_FIRE = 1811,
    CID_TYPE_SOFT_MOBS = 1812,
    CID_TYPE_KEYPAD_LOCK = 1862,
    CID_TYPE_KEYPAD_UNLOCK = 3862,
    CID_TYPE_ABSENCE_ALARM = 1863,
    CID_TYPE_KEY_FAIL = 1910,
    CID_TYPE_KEY_RESET = 3910,
    CID_TYPE_TRIGGER_FAIL = 1911,
    CID_TYPE_TRIGGER_RESET = 3911,
    CID_TYPE_GPK_FAIL = 1912,
    CID_TYPE_GPK_RESET = 3912,
    CID_TYPE_MODULE_FAIL = 1913,
    CID_TYPE_MODULE_RESET = 3913,
    CID_TYPE_WIRELESS_DETECTOR_FAIL = 1914,
    CID_TYPE_WIRELESS_DETECTOR_RESET = 3914,
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_LOW = 1915,
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_NORMAL = 3915,
    CID_TYPE_EXTEND_MODULE_LOSS = 1916,
    CID_TYPE_EXTEND_MODULE_LOSS_RESET = 3916,
    CID_TYPE_WIRELESS_REPEATER_DISCONNECT = 1917,
    CID_TYPE_WIRELESS_REPEATER_CONNECT = 3917,
    CID_TYPE_RADAR_TRANS_FAULT = 1918,
    CID_TYPE_RADAR_TRANS_RESET = 3918,
    CID_TYPE_WRIELESS_SIREN_LOW_BATTERY = 1919,
    CID_TYPE_NORMAL_WRIELESS_SIREN_BATTERY = 3919,
    CID_TYPE_WRIELESS_NET_FAULT = 1920,
    CID_TYPE_WRIELESS_NET_RESET = 3920,
    CID_TYPE_SIM_FAULT = 1921,
    CID_TYPE_SIM_RESET = 3921,
    CID_TYPE_WIFI_ABNORMAL = 1922,
    CID_TYPE_WIFI_NORMAL = 3922,
    CID_TYPE_RF_ABNORMAL = 1923,
    CID_TYPE_RF_NORMAL = 3923,
    CID_TYPE_DATE_TRAFFIC_OVERFLOW = 1924,
    CID_TYPE_IPADDR_CONFLICT = 1930,
    CID_TYPE_IPADDR_NORMAL = 3930,
    CID_TYPE_ETHERNET_BROKEN = 1931,
    CID_TYPE_ETHERNET_NORMAL = 3931,
    CID_TYPE_MOTION_DECTECT_START = 1940,
    CID_TYPE_MOTION_DECTECT_STOP = 3940,
    CID_TYPE_MASK_ALARM_START = 1941,
    CID_TYPE_MASK_ALARM_STOP = 3941,
    CID_TYPE_VI_LOST_START = 1942,
    CID_TYPE_VI_LOST_STOP = 3942,
    CID_TYPE_VS_MISMATCH = 1943,
    CID_TYPE_VS_MATCH = 3943,
    CID_TYPE_VI_EXCEPTION = 1944,
    CID_TYPE_VI_NORMAL = 3944,
    CID_TYPE_HD_FULL = 1945,
    CID_TYPE_HD_FREE = 3945,
    CID_TYPE_HD_ERROR = 1946,
    CID_TYPE_HD_RESET = 3946,
    CID_TYPE_PIC_SEND_FAILED = 1947,
    CID_TYPE_SENDING_EMAIL_FAILED = 1948,
    CID_TYPE_NETWORK_CAMERA_DISCONNECT = 1949,
    CID_TYPE_NETWORK_CAMERA_CONNECT = 3949,
    CID_TYPE_DUTY_CHECKING = 1960,
    CID_TYPE_POST_RESPONSE = 1961,
    CID_TYPE_ZONE_BUS_SEARCH = 1970,
    CID_TYPE_ZONE_BUS_REGIST = 1971,
    CID_TYPE_GUARD_SINGLE_ARM = 1973,
    CID_TYPE_GUARD_SINGLE_DISARM = 3973,
    CID_TYPE_SINGLE_ZONE_ALARM_CLEARED = 1974,
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_DEL = 1975,
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_ADD = 3975,
    CID_TYPE_ZONE_CONSULT = 1976,
    CID_TYPE_ZONE_CONSULT_STOP = 3976,
    CID_TYPE_EXTEND_MODULE_DEL = 1977,
    CID_TYPE_EXTEND_MODULE_ADD = 3977,
    CID_TYPE_WIRELESS_REPEATER_DEL = 1978,
    CID_TYPE_WIRELESS_REPEATER_ADD = 3978,
    CID_TYPE_WIRELESS_SIREN_DEL = 1979,
    CID_TYPE_WIRELESS_SIREN_ADD = 3979
}NET_DVR_ALARMHOST_CID_ALL_MINOR_TYPE;

typedef struct tagNET_DVR_CID_ALARM
{
    DWORD    dwSize;
    BYTE    sCIDCode[CID_CODE_LEN/*4*/];    //CID CODE
    BYTE    sCIDDescribe[NAME_LEN/*32*/];    //CID name
    NET_DVR_TIME_EX struTriggerTime;            // time of trigger alarm
    NET_DVR_TIME_EX struUploadTime;                // time of uploading alarm
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //center account
    BYTE    byReportType;                    // see NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE    byUserType;                        //User type,0-net user 1-keyboard user 2-cellphone user,3-system user
    BYTE    sUserName[NAME_LEN/*32*/];        //user name of net user
    WORD    wKeyUserNo;                        //keyboard user no.    0xFFFF means Invalid
    BYTE    byKeypadNo;                        //keyboard no.        0xFF means Invalid
    BYTE    bySubSysNo;                        //subsystem no.        0xFF means Invalid
    WORD    wDefenceNo;                        //Zone no.        0xFFFF means Invalid
    BYTE    byVideoChanNo;                    //video channel no.    0xFF means Invalid
    BYTE    byDiskNo;                        //disk no.        0xFF means Invalid
    WORD    wModuleAddr;                    //module address    0xFFFF means Invalid
    BYTE    byCenterType;                    //0-invalid, 1-old center account(length is 6),2-new center account(length is 9)
    BYTE    byRelativeChannel;
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //center account V40
    BYTE   byDevSerialNo[DEV_SERIAL_LEN];   /*Device serial*/
    BYTE    byRepeaterNo;    //repeater No,0-invalid
    WORD    wRemoteCtrllerUserNo;    //remote ctrller user No,0-invalid
    DWORD dwIOTChannelNo;    //IOT Channel NO
    BYTE    standardCIDcode;  //standard CID code
    BYTE    byRes2[11];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;  

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD    dwSize;
    BYTE    byModuleType;    //1-zone,2-trigger      
    BYTE    byZoneType;        //zone type,1-local zone,2-single zone,3-double zone,4-8 zone,5-8 sensor zone 0xff-invalid
    BYTE    byTriggerType;    //trigger type,1-local trigger, 1-local trigger, 2-4-way trigger ,3 8-way trigger ,0xff-invalid
    BYTE    byRes1[1];
    char    sModelInfo[MODULE_INFO_LEN];                //module info
    char    sDeviceVersionInfo[VERSION_INFO_LEN];                /* version info*/
    BYTE    byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;
#define MAX_DECODE_CARD_SUPPORTDISPNUMS 8
#define MAX_SUPPORT_RES 32
typedef struct tagNET_DVR_DECCARD_ABILITY_V41
{
    BYTE byCardType;     
    BYTE byDecNums;       
    BYTE byDispNums;      
    BYTE byDecStartIdx;     
    BYTE byDispStartIdx;    
    BYTE byRes1[3];
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];
    BYTE byDispFormat[MAX_DECODE_CARD_SUPPORTDISPNUMS];   
    BYTE byWindowMode[MAX_DECODE_CARD_SUPPORTDISPNUMS][12]; 
    BYTE byRes2[36];
} NET_DVR_DECCARD_ABILITY_V41, *LPNET_DVR_DECCARD_ABILITY_V41;

#define        MAX_DECODE_CARD_NUM            6  
typedef struct tagNET_DVR_DECODESVR_ABILITY_V41
{
    DWORD dwSize;  
    BYTE byCardNums; 
    BYTE byStartChan; 
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY_V41 struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY_V41, *LPNET_DVR_DECODESVR_ABILITY_V41;
/********************************DS_19SXX end *********************************/


/********************************ATM Safety Cabin begin *********************************/


typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD        dwSize;
    BYTE         byCabacEnable;           //0 enable 1 disable
    BYTE          byRes1[31];
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

//2012-1-12
/********************************Intelligent HD IPC V3.1*********************************/
#define  MAX_IOSPEED_GROUP_NUM      4  //The total number of IO speed measuring groups
#define  MAX_IOOUT_NUM              4  //The total number of IO output ports
#define  MAX_IOIN_NUM               8  //The total number of IO input ports
#define  MAX_RELAY_NUM              12 //Maximum number of relay control equipment 2013-11-04
#define  MAX_VEHICLE_TYPE_NUM        8  //Vehicle Type Num 2013-11-04
#define  MAX_IOIN_NUMEX             10 //The total number of IO input ports(ex)
#define  MAX_ITC_LANE_NUM           6  //The total number of lanes
#define  MAX_LANEAREA_NUM           2  //The total number of single lane areas
#define  ITC_MAX_POLYGON_POINT_NUM    20 //The max number of polygon points supported by detection area
#define  MAX_ITC_SERIALCHECK_NUM    8  //The max number of serial verification types
#define  MAX_LIGHT_NUM              6  //Max light number
#define  MAX_VIDEO_INTERVAL_NUM     2  //Max video interval number
#define  MAX_VIDEO_DETECT_LIGHT_NUM  12 //maximum 12 region detection 
#define  MAX_RS485_NUM  12 //rs485 max Number
#define  MAX_CALIB_RECOG_NUM        2  //Calib Recog Num
#define  MAX_MOBILE_POLYGON_NUM     3  //Mobile Recog Num
#define  MAX_MOBILE_DETECTLINE_NUM  3  //Mobile Detect Line Num
#define  MAX_IOOUT_K_NUM            8  //K The total number of IO output ports

//IO output parameter (v3.1 or later version)
typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IO default status: 0- low level, 1- high level 
    BYTE     byIOOutStatus;//The status when IO takes effect: 0- low level, 1- high level, 2- puls
    BYTE     byMode; //The flash works, bitwise 0 - work - not work the bit0-video, bit1-mount, bit2-illegal
    BYTE     byIOWorkMode;//The IO output port mode: 0- flashlight, 1- polarizer,  2-BrightLight
    DWORD    dwTimeDelay;//IO valid duration, unit: us
    WORD     wAheadTime;//Ahead time of output IO, unit: us
    BYTE     byFreqMulti;        //Multi-frequency, range [1,15]
    BYTE     byDutyRate;        //Duty rate, [0,40%]
    BYTE     byDetectBrightness;//Whether auto detect brightness enable flash light or not: 0- not detect, 1- detect
    BYTE     byBrightnessThreld;//Brightness threshold of enable flash light, value range: [0,100], flash when the value higher than the threshold
    BYTE     byFlashLightEnable;    //Enable flash light or not: 0- close, 1- open
    BYTE     byStartHour;        //Starting time, hour, value range: 0-23
    BYTE     byStartMinute;        //Starting time, minute, value range: 0-59
    BYTE     byEndHour;            //End time, hour, value range: 0-23
    BYTE     byEndMinute;        //End time, minute, value range: 0-59
    BYTE     byAutoPlateBrightness;//The license plate automatic brightness enable flash 0- not enable 1- enabled
    BYTE     byIncrBrightEnable;
    BYTE     byIncrBrightPercent;//Incr Bright Percent 0~100%
    WORD     wIncrBrightTime;
    BYTE     byBrightness;//Brightness;0~100
    BYTE     byEnvironBright;//Environment bright:0~100
    WORD     wDelayCaptureTime;//Delay Capture Time,1~1000ms
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;

typedef enum _ITC_TRIGGERMODE_TYPE_
{
    ITC_POST_IOSPEED_TYPE = 0x1,  //IO speed measuring (traffic gate)
    ITC_POST_SINGLEIO_TYPE = 0x2,  //Single IO triggering (traffic gate)
    ITC_POST_RS485_TYPE = 0x4,  //RS485 magnetic vehicle detector triggering (traffic gate)
    ITC_POST_RS485_RADAR_TYPE = 0x8,  //RS485 radar triggering (traffic gate)
    ITC_POST_VIRTUALCOIL_TYPE = 0x10,   //Virtual coil triggering (traffic gate)
    ITC_POST_HVT_TYPE_V50 = 0x20,    //Mixed bayonet video trigger V50
    ITC_POST_MPR_TYPE = 0x40,   //MPR Type(Ver3.7)
    ITC_POST_PRS_TYPE = 0x80,   //PRS Type
    ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE = 0x100,  //IO traffic lights (electronic police)
    ITC_EPOLICE_RS485_TYPE = 0x200,  //RS485 magnetic vehicle detector triggering (electronic police)
    ITC_POST_HVT_TYPE = 0x400,    //Mixed bayonet video trigger (bayonet)
    ITC_PE_RS485_TYPE = 0x10000,  //RS485 magnetic vehicle detector triggering(electronic police of traffic gate mode)
    ITC_VIDEO_EPOLICE_TYPE = 0x20000,  //Video triggering (electronic police of traffic gate mode)
    ITC_VIA_VIRTUALCOIL_TYPE = 0x40000,  //VIA Trigger configuration
    ITC_POST_IMT_TYPE = 0x80000,   //IMT Trigger configuration
    IPC_POST_HVT_TYPE = 0x100000,    //IPC HVT Trigger configuration
    ITC_POST_MOBILE_TYPE = 0x200000, //Mobile Trigger Configuration
    ITC_REDLIGHT_PEDESTRIAN_TYPE = 0x400000,    //Red Light Pedestrian 
    ITC_NOCOMITY_PEDESTRIAN_TYPE = 0x800000    //Nocomity Pedestrian
}ITC_TRIGGERMODE_TYPE;

//Output parameter of capability set API, corresponding to pOutBuf
typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //Triggering type, indicated by bit, defining ITC_TRIGGERMODE_ABILITY. 
    //The returned triggering type is different if input ability type is different.
    BYTE byRes[16];
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM
{
    BYTE byIntervalType;    //Interval type (default by time), 0- take effect by time, 1- take effect by distance
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//Continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit: decimeter).
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

//Plate recognition parameter
typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; //Shortening of province Chinese name
    BYTE byEnable;      //Whether enable plate recognition in this area: 0- no, 1- yes
    DWORD dwRecogMode;  /*Recognition type,
                        bit0-recognition direction: 0-from front,1-from back(back plate recognition);
                        bit1-Big plate of little plate: 0-little plate,1-Big plate;
                        bit2-Colour recognition: 0-disable colour recognition,1-Enable colour recognition;
                        bit3-Agricultural car recognition: 0-disable,1-enable;
                        bit4-Blur recognition: 0-disable,1-enable;
                        bit5-Frame location or scene location: 0-Frame location,1-Scene location;
                        bit6-Frame recognition or scene recognition: 0-Frame recognition,1-Scene recognition;
                        bit7-Day or night:0- day, 1- night
                        bit10-Small plate: 0- is not enabled, 1- enables small license plate recognition (60 ~ 80 pixels)
                        bit11-Safety belt detection: 0- disable, 1- enabled*/
    BYTE byVehicleLogoRecog;//Vehicle-logo recognition 0- is not enabled, 1- enabled 
    BYTE byProvince;//Province
    BYTE byRegion;     //Region index value, 0- reserved, 1 -Europe, 2 -Russia 3-EU&CIS,4-Middle East
    BYTE byCountry;//refer to COUNTRY_INDEX(not support COUNTRY_ALL = 0xff,//ALL)
    WORD wPlatePixelWidthMin;//Plate Pixel Width min[130,500]
    WORD wPlatePixelWidthMax;//Plate Pixel Width max[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

//Polygon structure
typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //Valid point, >=3, if three points are on a straight line, or the lines cross, it is considered to invalid area 
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //Polygon boundary point, the max number is 20 
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM
{
    BYTE byMode; //Area type: 0- rectangle, 1- polygon
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //Rectangle area
        NET_ITC_POLYGON struPolygon; //Polygon area
    }uRegion;
    BYTE  byRes[16];    //Reserved
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

//Speed measuring parameter of single group IO
typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //Whether enable or not: 0- no, 1- yes
    BYTE byTrigCoil1; //The IO related with the first coil: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byCoil1IOStatus;//The input status of IO related with the first coil: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge, 
    //3- high level, 4- low level
    BYTE byTrigCoil2; //The IO related with the second coil: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byCoil2IOStatus;//The input status of IO related with the second coil: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge, 
    //3- high level, 4- low level
    BYTE byRelatedDriveWay;//Related lane number
    BYTE byTimeOut;//Timeout(default: 10), unit: s
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    DWORD dwDistance;//Coil distance (default: 1000), unit: cm
    BYTE byCapSpeed;//Capturing speed (default: 30), unit: km/h
    BYTE bySpeedLimit;//Speed limit(default: 60), unit: km/h
    BYTE bySpeedCapEn; //Enable speed snap or not: 0- no, 1- yes
    BYTE bySnapTimes1; //Snapshot times of the first coil (default: not snap): 0- not snap, none 0- continuous times: max 5 times  
    BYTE bySnapTimes2; //Snapshot times of the second coil(default: 1): 0- not snap, none 0- continuous times: max 5 times
    BYTE byBigCarSpeedLimit; //The speed limit value
    BYTE byBigCarSignSpeed;//Signs of speed limit (CART), unit km/h(3.7Ver)
    BYTE byIntervalType;    //Interval type(default: by time): 0- take effect by time, 1- take effect by distance
    WORD wInterval1[MAX_INTERVAL_NUM];//The first coil: continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit:decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    WORD wInterval2[MAX_INTERVAL_NUM];//The second coil: continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit:decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance.
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port(can associate with multiple ports), array 0 means IO output no.1, array 1 means IO output no.2, and so forth.
    //The value: 0- not related, 1- related
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byCarSignSpeed;//speed limit sign, unit km/h(3.7Ver)
    BYTE byUseageType; //Lane Useage Type,ITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition (there is one usable area, one area is reserved)
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;
    BYTE byBigCarLowSpeedLimit;
    BYTE byLowSpeedCapEn;                 //Enable low speed snap or not: 0- no, 1- yes
    BYTE byEmergencyCapEn;                //Emergency Enable
    BYTE byRes[27];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

//IO velocimetry parameter of traffic gate
typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //License recognition parameter
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //Single IO velocimetry group parameter
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

//Single IO parameter
typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO default triggering state: 0- low level, 1- high level
    BYTE byRelatedDriveWay;//Related traffic lane
    BYTE bySnapTimes; //Snapshot times (default: 1): 0- not snap, none 0- continuous times: max 5 times
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_INTERVAL_PARAM struInterval; //Snapshot interval 
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byEnable;//Single IO enable flag 0- is not enabled, 1- enabled (Remark: in the ability to return to support bySupport&0x20, said whether to support the single IO trigger interface IO enable configuration Shi Shengxiao)
    BYTE byUseageType; //Lane Useage Type,ITC_LANE_USEAGE_TYPE
    BYTE byEmergencyCapEn;                //Emergency Enable
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

//Single IO triggering parameter
typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //Single IO triggering parameter
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //Enable the lane or not: 0- no, 1- yes
    BYTE byRelatedDriveWay;//Related lane
    WORD wDistance; //Coil distance, to calculate speed
    WORD wTrigDelayTime; //Triggering delay time (default: 200), unit: ms
    BYTE byTrigDelayDistance; //Triggering delay distance (default: 0), unit: decimeter
    BYTE bySpeedCapEn; //Whether enable speed snap:  0- no, 1- yes
    BYTE bySignSpeed;//Sign speed limit, unit: km/h
    BYTE bySpeedLimit;//Speed limit value, unit: km/h
    BYTE bySnapTimes; //The total snapshot times (default: 1), 0- not snap, none 0- continuous times: max 5 times
    BYTE byOverlayDriveWay; //OSD superimposed lane number
    NET_ITC_INTERVAL_PARAM struInterval; //Snapping interval parameter 
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byCartSignSpeed;//Signs speed limit (carts) in km / h
    BYTE byCartSpeedLimit;//Speed limit value (carts), in km / h
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Lane plate recognition parameter
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byUseageType; //Lane Useage Type,ITC_LANE_USEAGE_TYPE
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;
    BYTE byBigCarLowSpeedLimit;
    BYTE byLowSpeedCapEn;                 //Whether enable low speed snap:  0- no, 1- yes
    BYTE byEmergencyCapEn;                //Emergency Enable
    BYTE byRes[9];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

//RS485 magnetic-vehicle-detector triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byTriggerSpareMode; //Trigger standby mode, 0 - default, 1 - bayonet virtual coil mode, 2-HVT mode
    BYTE byFaultToleranceTime;//Fault tolerance time (unit: minutes) for detecting vehicle inspection is normal maximum time
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;    //Radar type: 0- no radar, 1- Andoray radar, 2- Olvia, 3- TransMicrowave, 0xff- other type
    BYTE    byLevelAngle;   //Angle to the horizontal, default: 25, value range: 0~90
    WORD    wRadarSensitivity; //Radar sensitivity 
    WORD    wRadarSpeedValidTime;//Radar speed effective time (0~2000] MS, 0 did not support
    BYTE    byRes1[2];
    float      fLineCorrectParam;//Linear correction parameters of [0.0~2.0]
    int      iConstCorrectParam;//Constant correction parameters of [-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND, *LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;
    BYTE  byAssociateLaneNo;//Association of the lane numbers 1 to 99 (this value can be repeated at different RS485 port)      
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;

typedef union tagNET_ITC_ACCESS_DEVINFO_PARAM_UNION
{
    BYTE uLen[128];
    NET_ITC_RADAR_INFO_PARAM struRadarInfoParam;
}NET_ITC_ACCESS_DEVINFO_PARAM_UNION, *LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION;

typedef struct tagNET_ITC_RS485_ACCESS_CFG
{
    DWORD dwSize;
    BYTE  byModeType;//0 to set aside, Bit1 radar, bit2 ~ bit3 ~ sensors, signal detector
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam;
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG, *LPNET_ITC_RS485_ACCESS_CFG;

typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;


//RS485 radar triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    NET_ITC_RADAR_PARAM struRadar;  //Radar parameter
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//Related lane index
    BYTE bySpeedCapEn; //Enable overspeed snapshot or not: 0-no, 1- yes
    BYTE bySignSpeed;  //Sign speed limit, unit: km/h
    BYTE bySpeedLimit; //Speed limit, unit: km/h
    BYTE bySnapTimes;  //Snapshot times (default: 1): 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byBigCarSignSpeed;///*The cart flag speed, unit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit value, unitkm/h*/
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    NET_ITC_INTERVAL_PARAM struInterval; //Snapshot interval
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLowSpeedLimit;/*Low Speed Limit,Unit km/h*/
    BYTE byBigCarLowSpeedLimit; /*Big Car Low Speed Limit,Unit km/h*/
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    NET_VCA_LINE struLine;
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  //Virtual coil region
    BYTE byTrigFlag;       //Triggering flag: : 0- triggered by vehicle head, 1- triggered by vehicle rear,2- triggered by vehicle head or rear
    BYTE byTrigSensitive;  //Triggering sensitivity, value range: 1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports), array 0 means IO output no.1, array 1 means IO output no.1, and so forth.
    //The value: 0- not related, 1- related
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byLaneType;   //Lane Type, 0- is not configured, 1- highway, 2- city expressway, 0xff- other road
    BYTE byEnableRadar; //Whether to enable the radar velocimetry: 0- no, 1- yes
    NET_ITC_VTLANE_PARAM struLane; //Related lane parameter
    //Lane uses type, see ITC_LANE_USEAGE_TYPE, 1 and 8 of two types (3.7Ver)
    BYTE byUseageType;
    //The direction of travel of the vehicle, see ITC_LANE_CAR_DRIVE_DIRECT (3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

//Virtual coil triggering parameter of traffic gate
typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes
    BYTE byIsDisplay; //Whether to display virtual coil on the video: 0- no, 1- yes
    BYTE byLoopPos;   //Triggering coil bias at night, default: 10
    BYTE byPolarLenType; //Polarizer type, 0- without polarizer, 1- add Schneider polarizer 
    BYTE byDayAuxLightMode; //Auxiliary lighting during the day mode, 0- no auxiliary lighting, 1- LED lighting, 2- flash lighting
    BYTE byVideoLaneNO; //Reference lane number of the video reference brightness
    BYTE byVideoLowTh;  //Low threshold initial value of the video reference brightness, default: 40
    BYTE byVideoHighTh; //High threshold initial value of the video reference brightness, default: 55
    BYTE byRecordMode;  //Recording flag: 0- not record, 1- record
    BYTE bySnapMode;//Capture mode:
    /*speed mode: 0- not speed, 0x1- radar, 0x2- video speed*/
    BYTE bySpeedDetector;
    BYTE byRes1;
    WORD wResolutionX;  //Width of device current definition
    WORD wResolutionY;  //Height of device current definition
    DWORD   dwDayInitExp; //The initial value of video day exposure time, default: 2000
    DWORD   dwDayMaxExp;  //The max value of video day exposure time, default: 20000
    DWORD   dwNightExp;   //The night video exposure time, default: 3000
    DWORD   dwSnapExp;    //Snapshot exposure time
    BYTE   byDayInitGain; //The initial value of video day gain, default: 200
    BYTE   byDayMaxGain;  //The max value of video day gain, default: 400
    BYTE   byNightGain;   //Night video gain
    BYTE   bySnapGain;    //Snapshot gain
    DWORD dwSceneMode;    //Scene mode, see to SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //Address location, default: Zhejiang
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //Virtual coil parameter
    NET_ITC_RADAR_PARAM struRadar;  //Radar parameter
    NET_VCA_LINE struLine; //Right lane
    //Violation detection type, said, see the ITC_VIOLATION_DETECT_TYPE bit by bit, 0- is not enabled, 1- enabled (3.7Ver)
    DWORD dwVioDetectType;
    BYTE  byDebugMode; /*Debug mode, 0- not enabled, 1- enabled*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

//IO traffic light parameter of single group
typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable;  //Whether to enable or not: 0- no, 1- yes
    BYTE byLightIO; //Traffic light IO, 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byTrafficLight; //Traffic light valid status: 0- high-level voltage corresponding to red light, low-level voltage corresponding to green light, 
    //1- high-level voltage corresponding to green light, low-level voltage corresponding to red light
    BYTE byTrigIO;  //Triggered IO number: 0- IO1, 1- IO2, 2- IO3, 3- IO4, 4- IO5, 5- IO6
    BYTE byTrigIOStatus;//The IO status: 0- falling edge(default), 1- rising edge, 2- rising edge and falling edge, 3- high level, 4- low level
    BYTE byRelatedDriveWay;//Related lane index
    BYTE byRecordEnable;//Recording flag of running red light: 0- not record, 1- record
    BYTE byRecordType;//Recording type of running red light: 0- pre-recording, 1- delay recording
    BYTE byPreRecordTime;//Pre-recording time of running red light, default: 0, unit: s
    BYTE byRecordDelayTime;//Recording delay time of running red light, default: 0, unit: s
    BYTE byRecordTimeOut;//Cycle recording timeout of running red light, unit: s
    BYTE byRedSnapTimes; //Red light snapshot times: 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byGreenSnapTimes; //Green light snapshot times: 0- not snapshot, none 0- continuous times: max 5 times
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    BYTE byRes1;
    BYTE byIntervalType;    //Interval type (default: by time): 0- take effect by time, 1- take effect by distance
    WORD wRedInterval[MAX_INTERVAL_NUM];//Red light continuous snapshot interval time (unit: ms) or continuous snapshot interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    WORD wGreenInterval[MAX_INTERVAL_NUM];//Green light continuous snapshot interval time (unit: ms) or continuous snapshot interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //The related IO output port (can associate with multiple ports)
    BYTE byFlashMode;   //Flash mode of flash light: 0- flash at the same time, 1- flash in turn
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Plate recognition parameter
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

//IO traffic light parameter of electronic police
typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //IO traffic light parameter of single group
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;

typedef enum _ITC_SERIAL_PROTOCOL_
{
    ITC_PROTOCOL_UNKNOW = 0, //Unknown
    ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1, //Single-coil magnetic vehicle detector protocol (Dynamic display: arrival, departure, departure-delay snapshot, departure plate recognition)
    ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2, //Double-coil magnetic vehicle detector protocol mode no.1
    //(Dynamic display: arrival no.1, departure no.1, snapshot of departure-delay no.2, plate recognition of departure no.1)
    ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3, //Double-coil magnetic vehicle detector protocol mode no.2
    ////(Dynamic display: arrival no.1, departure no.2, snapshot of departure-delay no.2, plate recognition of departure no.1, default delay distance is 1m)
    ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4, //Double-coil magnetic vehicle detector protocol mode no.3
    //(Dynamic display: arrival no.2, departure no.1, snapshot of departure-delay no.2, plate recognition of departure no.1, default delay distance is 1m)
    ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5, /*The dual coil vehicle inspection protocol mode (display: double / triple _ into the 2_ out the 2_ extension 2_1) to reach the 2, left 2, left 2 delay capture, leave a card identification upload three vehicles picturelicense plate results*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6, /*The dual coil vehicle inspection protocol mode (display: double / triple _ Feed out 2_ 2_ extension 2_2) to reach the 2, left 2, leaving 2 delay capture, to reach 2, left 1 are brand knowledge, uploaded 3Zhang vehicle pictures and high confidence license plate results (default)*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7, /*The dual coil vehicle inspection protocol mode (display: dual / triple _ Feed the 1_ out the 2_ extension 2_2) to reach 1, left 2, left 2 delay capture, to reach a left are brand knowledge, uploaded 3the license plate of the vehicle pictures and high confidence in Zhang*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8, /*Double coil vehicle inspection protocol mode (displayed as: the double _ Feed 1_ out 1_ extension 2_1) to reach the 1, left 1, left 2 delay capture, leaving a brand identification, upload vehicle images the (bayonet leave 1, running red lights to reach 1, left 1, left delay) and license plate results*/
    ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9, /*Dual coil vehicle inspection protocol mode (display: into 1_ out double _ 1_ extension 2_2) to reach 1, left 1, left 2 delay capture, to reach 1, left 1 are brand knowledge, upload vehicle images (a bayonet left, running red lights to reach 1, left 1, leaving the delay), and high confidence license plates results (default)*/
    ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10, /*Single coils vehicle inspection protocol mode (display: Single _ into 1_ out 1_ extension 1_2), arrived and left, leaving delay capture to reach the left are brand knowledge, upload vehicle images (bayonet left, running red lights to reach, left, leave the license plate of the delay), and high confidence results (default)*/
    ITC_OTHER_PROTOCOL = 0xff //Other protocol of magnetic vehicle detector
}ITC_SERIAL_PROTOCOL;

//Logic capture type normal a car
typedef enum _ITC_NORMAL_PASS_SERIAL_PROTOCOL_
{
    ITC_NORMAL_PASS_SERIAL_UNKNOW = 0,   //Unknown
    ITC_NORMAL_PASS_PROTOCOL_MODE1 = 1,  //Single coil, leave capture card identification upload (default)
    ITC_NORMAL_PASS_PROTOCOL_MODE2 = 2,  //Single coil, arrive, leave capture are brand knowledge, only upload to leave the license plate of the vehicle pictures and high confidence results
    ITC_NORMAL_PASS_PROTOCOL_MODE3 = 3,  //Double coils, leave a snapshot, brand identification upload (default)
    ITC_NORMAL_PASS_PROTOCOL_MODE4 = 4, //Dual coil arrival, leaving a snapshot are brand knowledge only upload to leave a picture of a vehicle license plate and high confidence results
    ITC_NORMAL_PASS_PROTOCOL_MODE5 = 5, //Double coil to reach the 2, leaving 1 capture are brand knowledge only upload to leave a picture of a vehicle license plate and high confidence results
}ITC_NORMAL_PASS_SERIAL_PROTOCOL;

//Retrograde violations logic capture type
typedef enum _ITC_INVERSE_SERIAL_PROTOCOL_
{
    ITC_INVERSE_SERIAL_UNKNOW = 0,   //Unknown
    ITC_INVERSE_PROTOCOL_MODE1 = 1,  //Does not capture
    ITC_INVERSE_PROTOCOL_MODE2 = 2,  //To reach an even caught two, leaving 2 capture, to reach a two brand consciousness, upload pictures and high confidence in three vehicle license plate results
    ITC_INVERSE_PROTOCOL_MODE3 = 3,  //Arrival, leaving 2 capture, to reach a licensing knowledge, upload two vehicle images and license plate results
}ITC_INVERSE_SERIAL_PROTOCOL;

//The speeding violation logical capture type
typedef enum _ITC_SPEED_SERIAL_PROTOCOL_
{
    ITC_SPEED_SERIAL_UNKNOW = 0,   //Unknown
    ITC_SPEED_PROTOCOL_MODE1 = 1,  //Does not capture
    ITC_SPEED_PROTOCOL_MODE2 = 2,  //Double / triple coil, left 1, left 2, left 2 delay capture, leaving a brand consciousness, upload vehicle images (bayonet left 1, speeding left 1, left 2, left delay) and license plate results
    ITC_SPEED_PROTOCOL_MODE3 = 3,  //Double / triple coil, leave, leave 2 leave 2 delay capture, leaving a brand consciousness, upload vehicle images (bayonet left 1, speeding left 1, left 2) and license plate results
}ITC_SPEED_SERIAL_PROTOCOL;

//Magnetic vehicle detector parameter
typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //Protocol type of magnetic vehicle detector, see to ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;    //Interval type (default: by time): 0- take effect by time, 1- take effect by distance
    WORD wInterval;//Continuous snapping interval time (unit: ms) or continuous snapping interval distance (unit: decimeter)
    //When byIntervalType is 0, it means interval time, when byIntervalType is 1, it means interval distance
    BYTE byNormalPassProtocol; //Normal over the car to capture the protocol type, see ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //Retrograde capture protocol type, see ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //Overspeed protocol type, see ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //Whether enable this traffic lane: 0- no, 1- yes
    BYTE byRelatedDriveWay;//The related lane number
    WORD wDistance; //Coil distance, unit: cm
    BYTE byRecordEnable;//Cycle recording sign of red light running behavior: 0- not record, 1- record
    BYTE byRecordType;//Recording type of red light running behavior: 0- pre-recording,1- delay recording
    BYTE byPreRecordTime;//Pre-recording time of red light running behavior (default: 0), unit: s
    BYTE byRecordDelayTime;//Recording delay time of red light running behavior (default: 0), unit: s
    BYTE byRecordTimeOut;//Recording timeout time of red light running behavior, unit: s
    BYTE bySignSpeed;//Sign speed(Post epolice mode),km/h
    BYTE bySpeedLimit;//Speed limit(Post epolice mode), km/h
    BYTE byOverlayDriveWay; //OSD superimposed lane number
    NET_ITC_SERIAL_INFO struSerialInfo; //Magnetic vehicle detector parameter
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //Related IO output port, can associating with multiple ports 
    BYTE byFlashMode;   //Flash flashing mode: 0- flash at the same time, 1- flash in turn
    BYTE bySerialType; //Type of vehicle inspection, 0 - private vehicle inspection, 1 - private OEM vehicle inspection - Other vehicle inspection
    BYTE byRelatedIOOutEx;//Zeroth bits IO output port 1, and so on, 0- is not correlation, 1- correlation support related to the 8 (compatible with the byRelatedIOOut field)
    BYTE bySnapPicPreRecord; //Capture images of pre recorded time points 
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //Lane license plate recognition parameters
    BYTE byBigCarSignSpeed;    ///*The signs of speed limit,unit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit,unit km/h*/
    BYTE byRedTrafficLightChan;//The red channel number: 1 ~ 16 (red light detector)
    BYTE byYellowTrafficLightChan;//The yellow light channel number: 1 ~ 16 (red light detector)
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

//RS485 magnetic vehicle detector triggering parameter of electronic police or traffic-gate electronic police 
typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//The total number of related lanes 
    BYTE byTrafficLightSignalSrc;//The traffic light signal from 0 ~ 1 to red light detector sensors
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate recognition parameter
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //Related lane parameter
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType; //Lane use types, see ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType; //Lane direction types, see ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //Drive direction,see ITC_LANE_CAR_DRIVE_DIRECT 
    BYTE byRes[33];
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //Line parameters
    BYTE byLineType; //Line type, see ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE     byVehicleCapMode;//Motor vehicle to capture mode,0-Strobe mode;1-Flash mode
    BYTE     byNoVehicleCapMode;//Non-motor vehicle snap mode,0-Strobe mode;1-Flash mode
    BYTE     byPasserCapMode;//Pedestrian snap mode,0-Strobe mode;1-Flash mode
    BYTE     byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD         dwCapShutter;            //capShutter 0~65535
    WORD         wCapGain;            //capGain 0~100
    BYTE          byRes[2];
    DWORD         dwDayTimeVideoShutter;    //The maximum exposure time of day
    WORD         wDayTimeVideoGain;        //The maximum gain of day
    WORD         wNightVideoGain;        //the maximum gain of night
    DWORD         wNightVideoShutter;        //the time maximum exposure of night    
    BYTE          byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //The associated Lane No. 1~255 (used for stacking and upload)
    BYTE bySignSpeed;    //Signs of speed limit, the unit km/h 0 ~ 255   70
    BYTE bySpeedLimit;    //Signs of speed limit, the unit km/h
    BYTE byBigCarSignSpeed;///*The signs of speed limit, the unit km/h*/
    BYTE byBigCarSpeedLimit;/*The speed limit, the unit km/h*/
    BYTE bySpeedCapEn; //SpeedCapEn,0-no enable,1-enable
    BYTE byCaptureCount;//cap number 1~5(normal)
    BYTE byRelatedIOOut;    /*The associated IO output port (can simultaneously to multiple), according to a IO output port, zeroth IO output port 1, and so on, 0- is not correlation, 1- correlation*/
    BYTE byFlashMode;        /*Flash mode, 0- flash, 1 flash in turn*/
    BYTE byEnableRadar; //Whether to enable the radar,0-no enable,1- enable
    BYTE byChangeLaneEnable;   //change lane detection enable,0-disabled,1-enabled
    BYTE byChangeLaneCapNo;    //change lane capture number,2-3
    DWORD dwCapTarget;    //Snap type bit0 said Bit1 bit2 said the non-motor vehicle pedestrian 0 ~ 1 ~ said that do not
    NET_ITC_INTERVAL_PARAM struInterval; //capture the interval parameter
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //Lane attributes, using byUseageType and byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;          //The left lane line, line type is dotted, solid yellow line, single and double yellow line
    NET_ITC_LINE struRightLaneLine;          //The right lane line, line type is dotted, solid yellow line, single and double yellow line
    NET_ITC_POLYGON struPlateRecog;         //Brand recognition of regional parameters
    NET_ITC_POLYGON struTraceArea;          //Video trigger focus area
    NET_VCA_LINE  struForwardTrigLine;      //Positive trigger line: a line segment, concerned about the endpoint position, currently only supports the level of configuration, interface is saved in two ends segment. (general configuration for the optimal trigger position forward vehicle)     
    NET_VCA_LINE  struBackwardTrigLine;     //Back to the trigger line: a line segment, concerned about the endpoint position, currently only supports the level of configuration, interface is saved in two ends segment (generally configured to back to the optimal trigger position of vehicle)
    NET_VCA_LINE  struLeftTrigLine;          //The left trigger line: a line segment, concerned about the endpoint position, currently only supports the vertical configuration, interface is saved in two ends segment (general configuration for the optimal trigger position from the left into the vehicle)
    NET_VCA_LINE  struRightTrigLine;//The right trigger line: a line segment, concerned about the endpoint position, currently only supports the vertical configuration, interface is saved in two ends segment (general configuration for the optimal trigger position from the right into the vehicle)
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//The number of lanes of identification, 1-6
    BYTE bySceneMode;//Road 0- unknown 1- city 2- District entrance;
    BYTE byRoadExpBright;//Pavement desired brightness (video exposure parameter adjustment based on. In the absence of a motor vehicle, according to the luminance expectations, adjust the video exposure parameters)
    BYTE byPlateExpBright;//The desired brightness (video license plate exposure parameter adjustment based on. In a motor vehicle by and recognition to the license plates, based on the expected value of brightness, adjust the video exposure parameters)
    NET_ITC_POLYGON struDetectArea;//Video detection area  
    NET_ITC_SNAPMODE_PARAM  struCapMode;//Capture mode  
    NET_ITC_HVT_EC_PARAM struEcParam;    //The exposure control parameters 
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //Road cycling property
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;    //Brand identification parameters
    NET_DVR_GEOGLOCATION struGeogLocation;    //Address (default location in Zhejiang)
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

/*************************MPR begin 2013-12-07****************/
typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO[1, byIoInNum+1] (NET_DVR_SNAP_ABILITY.byIoInNum)
            BYTE  byTriggerType;//0-falling,1-rising
            BYTE  byRes1[2];
        }struIO;//IO mode effect
        struct
        {
            BYTE  byRelateChan;//Correlation detectors channel number[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; // ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[254];
}NET_ITC_LANE_MPR_PARAM, *LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR,1-IO,2-RS485
    BYTE byPicUploadType;//Picture Upload Type
    BYTE byRoadType;//Mode selection 0 - the entrance, 1 - city road, 2 - custom ,3-Alarm Input,4-post, 5-security monitoring
    BYTE byRes2;
    WORD wCustomDelayTime;//Custom capture delay time (in byRoadType effect for the "custom"), in the range [0150] ms 
    BYTE byRes[56];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char  szSceneName[NAME_LEN/*32*/]; //Scene Name
    NET_VCA_LINE struSnapLine;//Snap line, on the erection way as the side of the camera installed, configure the parameters take effect (i.e., 4.5 NET_DVR_CAMERA_SETUPCFG byErectMethod field in a structure to 1) 
    BYTE byRes1[392];
}NET_ITC_POST_MPR_PARAM, *LPNET_ITC_POST_MPR_PARAM;
/*************************MPR end 2013-12-07****************/

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //Associate lane number
    BYTE byRes[63]; //Reserved
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //Lane logic param
    NET_ITC_LINE  struLaneLine;//Lane line 
    NET_ITC_POLYGON  struPlateRecog;//Plate recog region
    BYTE byRes1[300]; //Reserved
} NET_DVR_VIA_LANE_PARAM, *LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;    //0-Disable 1-Enable
    BYTE byLaneNum; //Lane Num
    BYTE byRes[62]; //Reserved   
    NET_ITC_LINE  struLaneBoundaryLine;//Lane boundary line,that is the Leftmost lane on the left boundary
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //Lane param
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//Plate recog param     
    BYTE byRes1[624];//Reserved
}NET_DVR_VIA_VTCOIL_PARAM, *LPNET_DVR_VIA_VTCOIL_PARAM;

typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //Structure size
    DWORD  dwChannel;    //Channel number
    DWORD  dwTriggerMode;//Trigger mode,refet to ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//Scene ID[1,4]
    BYTE   byRes[63];    //Reserved
}NET_DVR_TRIGGER_COND, *LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;
    //ITC_RELA_LANE_DIRECTION_TYPE
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM, *LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySnapMode;
    BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;
    NET_ITC_LINE struLaneBoundaryLine;
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM, *LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO Number[1,4]
            BYTE  byTriggerType;//0-falling edge, 1-Rising edge
            BYTE  byRes1[2];
        }struIO;//IO mode effect
        struct
        {
            BYTE  byRelateChan;//Correlation detectors channel number[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRelaLaneDirectionType;
    BYTE byRes2[3];
    NET_ITC_LINE struTrigLine;
    BYTE byRes1[228];
}NET_ITC_LANE_PRS_PARAM, *LPNET_ITC_LANE_PRS_PARAM;


typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-Video detection, 1- associated IO trigger (induction coil), trigger signal 2- Association RS485
    BYTE bySnapMode;//0- panorama, 1- panorama + close-up
    BYTE byCapMode;//Video detection mode effect,0-Strobe mode, 1- flashing mode
    BYTE byNoPlatCarCap;
    BYTE bySceneMode;
    BYTE byRes[57];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line (the left most Lane left)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM, *LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_POLYGON struPlateRecog;//Plate Recog
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM, *LPNET_IPC_LANE_HVT_PARAM;

typedef struct _NET_ITC_PARKING_DETECTION_
{
    BYTE        byEnable; //Whether enabled, 0- not enabled, 1- enabled
    BYTE        byRes;
    WORD       wDuration;//Detection interval, unit: s
    WORD       wAlarmIntervalTime;//Upload interval, unit: s
    BYTE        byRes1[58];
}NET_ITC_PARKING_DETECTION, *LPNET_ITC_PARKING_DETECTION;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;
    BYTE  byLaneNum;
    BYTE byEnhancedMode;    //Enhanced mode, 0- not enabled, 1- enabled
    BYTE byPicRecognition;  //vehicle alarm picture recognition, 0- not enabled, 1- enabled
    BYTE  byRes[60];
    NET_ITC_LINE struLaneBoundaryLine;//The lane boundary line (the left most Lane left)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//Plate Recog  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char  szSceneName[NAME_LEN/*32*/]; //Scene Name
    NET_VCA_LINE struSnapLine;//Snap line, on the erection way as the side of the camera installed, configure the parameters take effect (i.e., 4.5 NET_DVR_CAMERA_SETUPCFG byErectMethod field in a structure to 1) 
    NET_ITC_PARKING_DETECTION struParkingDetection;    //Parking detection parameter
    BYTE byRes1[328];
} NET_IPC_POST_HVT_PARAM, *LPNET_IPC_POST_HVT_PARAM;

//Snap 4.0 add
typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE byLaneNO;        //Lane No. 1~255
    BYTE byFlashMode;    //Flash Mode
    BYTE bySignSpeed;    //Sign Speed Unit:km/h
    BYTE bySpeedLimit;    //Speed Limit,Unit:km/h
    BYTE bySignLowSpeed;    //Sign Low Speed,Unit:km/h
    BYTE byLowSpeedLimit;    //Low Speed Limit,Unit:km/h
    BYTE byBigCarSignSpeed;    //Big Car Sign Speed,Unit:km/h
    BYTE byBigCarSpeedLimit;    //Big Car Speed Limit,Unit:km/h
    BYTE byBigCarSignLowSpeed;    //Big Car Sign Low Speed,Unit:km/h
    BYTE byBigCarLowSpeedLimit;    //Big Car Low Speed Limit,Unit:km/h
    BYTE bySnapTimes;    //Snap Times,1~3
    BYTE  byDriveLineSnapTime;// Drive Line Snap Times 1~3
    BYTE  byHighSpeedSnapTime;// High Speed Snap Times 1~3
    BYTE  byLowSpeedSnapTime;// Low Speed Snap Time 1~3
    BYTE  byBanSnapTime;// Ban Snap Time  1~3
    BYTE  byReverseSnapTime;//Reverse Snap Time  1~3
    BYTE  byRelatedDriveWay;//Lane No.
    BYTE  byLaneType;   //Lane Type
    //RelaLane Direction Type
    BYTE   byRelaLaneDirectionType;
    BYTE  byRes1[27];
    BYTE  byChangeLaneEnable;   //change lane detection enable,0-disabled,1-enabled
    BYTE  byChangeLaneCapNo;    //change lane capture number,2-3
    DWORD  dwVioDetectType; // ITC_VIOLATION_DETECT_TYPE
    DWORD  dwRelatedIOOut;  //Related IO Out
    NET_ITC_LINE struTrigLine; //Trigger Line
    NET_ITC_LINE struLineLeft;                //Left Line
    NET_ITC_POLYGON struPlateRecog;       //Plate Recog
    NET_ITC_LANE_LOGIC_PARAM struLane;   //Lane CFG
    NET_ITC_INTERVAL_PARAM struInterval;//Interval CFG(20byte)
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;

typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;    //Lane Num,1-6
    BYTE byCapType;        //Capture Type
    BYTE byCapMode;    //Capture Mode
    BYTE bySecneMode;    //Secne Mode
    BYTE bySpeedMode;  //Speed Mode
    BYTE byLineRuleEffect; //Line Rule Effect
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;    //Left Trigger Line
    NET_ITC_LINE struRigtTrigLine;    //Right Trigger Line
    NET_ITC_LINE struLaneBoundaryLine;        //Lane Boundary Line
    NET_ITC_POLYGON struDetectArea;    //Detect Area
    NET_DVR_GEOGLOCATION struGeogLocation; //Recognition Location
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //Lane Param
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;    //Plate Recognition
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;


typedef struct tagNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byRelatedDriveWay;//Related DriveWay
    BYTE byRelaLaneDirectionType;//RelaLane Direction Type
    BYTE byPedestriansNum;//Pedestrians Num
    BYTE byVehicleSpeed;//Vehicle Speed
    DWORD dwVehicleInterval; //Vehicle Interval
    BYTE byPedesDetRule; //Pedestrians Detction Rule
    BYTE byRes[3];
    NET_ITC_LINE struLaneLine;//Lane Line
    NET_ITC_LINE struStopLine;//Stop Line
    NET_ITC_POLYGON struPlateRecog; //Plate Recog 
    BYTE byRes1[280];
} NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;


typedef struct tagNET_ITC_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;//Lane Num
    BYTE byRes[74];
    NET_ITC_LINE struLaneBoundaryLine;//Lane Boundary Line
    NET_ITC_LINE struTriggerLine;//Trigger Line
    NET_ITC_POLYGON struPedesDetRecog;//Pedestrians Detction Recog
    NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    //Lane Param
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate Recog
    BYTE byRes1[400];
}NET_ITC_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM;

//Single IO light access parameter
typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //Light type,0-left,1-straight,2-right
    BYTE byRelatedIO; //Related IO
    BYTE byRedLightState; //Red light state,0-high level,1-low level
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO light access parameter
typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //Single IO light access parameter
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

//Single RS485 access light
typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //Light type,0-left,1-straight,2-right
    BYTE byRelatedLightChan; //Related light channel
    BYTE byInputLight;    //input light type,0-red light,1-green 
    BYTE byRelatedYLightChan; //The yellow light detector channel number Association
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

//RS485 access light
typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

//Video detection of a single set of traffic lights parameter structure
typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //Number of traffic lights
    BYTE byStraightLight; //Whether there straight flag lights 0 - No 1 -yes
    BYTE byLeftLight; //Whether there turn left marker lamps 0 - No 1 -yes
    BYTE byRightLight; //Whether there is a right turn marker lamps 0 - No 1 -yes
    BYTE byRedLight;//Whether there is a red light, 0 - No, 1 -yes
    BYTE byGreenLight; //Whether there is a green light, 0 - No, 1 -yes
    BYTE byYellowLight; //Whether yellow, 0 - No, 1 -yes
    BYTE byYellowLightTime;//Range (0 ~ 10s)(ITC3.7Ver)
    NET_POS_PARAM struLightRect; //Traffic light area
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//The video detection traffic lights parameters structure (maximum 12 region detection, 488 bytes)
typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //Single video detection lights parameters
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//Light access parameter
typedef union tagNET_ITC_LIGHT_ACCESSPARAM_UNION
{
    DWORD uLen[122];
    NET_ITC_IO_LIGHT_PARAM struIOLight; //IO access light
    NET_ITC_RS485_LIGHT_PARAM struRS485Light; //485 access light
    NET_ITC_VIDEO_DETECT_LIGHT_PARAM struVideoDelectLight; //The video detection signal lights parameters
}NET_ITC_LIGHT_ACCESSPARAM_UNION, *LPNET_ITC_LIGHT_ACCESSPARAM_UNION;

//Traffic light parameter
typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //light source,0-IO access,1-RS485 access
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//light access parameter
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

//Violation detect line
typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //Lane line
    NET_ITC_LINE  struStopLine; //Stop line
    NET_ITC_LINE  struRedLightLine; //Red light line
    NET_ITC_LINE  struCancelLine; //Cancel line
    NET_ITC_LINE  struWaitLine; //Wait line
    NET_ITC_LINE  struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

//Redlight Pedestrian Param
typedef struct tagNET_ITC_REDLIGHT_PEDESTRIAN_PARAM
{
    BYTE byEnable;
    BYTE bySnapNumTimes; //Snap Num Times
    BYTE byPedesDir; //Pedestrians Dir
    BYTE byDelayTime; //Delay Time
    BYTE byStackTargetEnble;//Stack Target Enble
    BYTE byCalibRecogCtrl;//Calib Recog Ctrl
    BYTE byRes1[2];
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //Traffic Light
    NET_ITC_LINE struStopLine;//Stop Line
    NET_ITC_POLYGON struCalibRecog[MAX_CALIB_RECOG_NUM/*2*/];//Calib Recog
    BYTE byRes[440];
}NET_ITC_REDLIGHT_PEDESTRIAN_PARAM,
*LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM;

typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;
    BYTE  bySceneMode;//Scene mode, 0- highway, 1- city expressway
    WORD  wExpressWayCapType;//highway capture type
    WORD  wUrbanRoadCapType;//city expressway
    BYTE  byCapNum;//capture number [2,3]
    BYTE  byRecordEnable;//record enable, 0-off 1-om
    DWORD dwPreRecordTime;//prerecord time(s)
    DWORD dwOverRecordTime;//overrecord time(s)
    NET_ITC_LANE_LOGIC_PARAM struLane;   //Lane Param
    NET_ITC_POLYGON struPolygon[MAX_MOBILE_POLYGON_NUM/*3*/]; //Plate Recog
    NET_ITC_VIOLATION_DETECT_LINE struLine[MAX_MOBILE_DETECTLINE_NUM/*3*/]; //Violation Detect Line
    NET_ITC_LINE struLaneBoundaryLine;        //Lane Boundary Line
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //Plate Recog Param
    NET_ITC_INTERVAL_PARAM struInterval;//Interval
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM, *LPNET_ITC_POST_MOBILE_PARAM;

typedef union tagNET_ITC_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1070];            // Parameter
    NET_ITC_POST_IOSPEED_PARAM    struIOSpeed; //(traffic gate) IO velocimetry parameter
    NET_ITC_POST_SINGLEIO_PARAM   struSingleIO; //(traffic gate) single IO parameter
    NET_ITC_POST_RS485_PARAM       struPostRs485; //(traffic gate) RS485 vehicle checker
    NET_ITC_POST_RS485_RADAR_PARAM  struPostRadar; //(traffic gate) RS485 Radar parameters
    NET_ITC_POST_VTCOIL_PARAM     struVtCoil; //(traffic gate) Virtual coil
    NET_ITC_POST_HVT_PARAM          struHvt;    /*(bayonet) mixed bayonet parameters*/
    NET_ITC_EPOLICE_IOTL_PARAM     struIOTL;        //(electronic police) IO traffic light parameters
    NET_ITC_EPOLICE_RS485_PARAM    struEpoliceRs485; //(electronic police) RS485 magnetic vehicle detector triggering parameter
    NET_ITC_EPOLICE_RS485_PARAM  struPERs485;    //(traffic-gate electronic police) RS485 magnetic vehicle detector triggering parameter
    NET_ITC_POST_MPR_PARAM       struPostMpr; //MPR Detection Trigger parameter 2013-12-07
    NET_DVR_VIA_VTCOIL_PARAM        struViaVtCoil;  //(VIA)Trigger parameter
    NET_ITC_POST_IMT_PARAM          struPostImt;//(IMT)Trigger parameter
    NET_ITC_POST_PRS_PARAM           struPostPrs;//PRS Trigger parameter
    NET_IPC_POST_HVT_PARAM          struIpcHvt;//(IPC) HVT
    NET_ITC_POST_HVT_PARAM_V50      struHvtV50;  /*(bayonet) mixed bayonet parameters V50*/
    NET_ITC_POST_MOBILE_PARAM       struPostMobile;// Mobie Trigger Parameter
    NET_ITC_NOCOMITY_PEDESTRIAN_PARAM struNoComityPed;//Nocomity Pedestrian Param
    NET_ITC_REDLIGHT_PEDESTRIAN_PARAM struRedLightPed;//RedLight Pedestrian Param
}NET_ITC_TRIGGER_PARAM_UNION, *LPNET_ITC_TRIGGER_PARAM_UNION;

//Single triggering parameter structure
typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;    //Enable the triggering mode: 1- yes, 0- no
    BYTE  byRes1[3];
    DWORD dwTriggerType; //Triggering type, see to ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //Triggering parameter
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

//Triggering parameter structure
typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;            //Structure size
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //Single triggering parameter
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;


//violation detect type
typedef enum _ITC_VIOLATION_DETECT_TYPE_
{
    ITC_VIOLATION_POST = 0x01, //post
    ITC_VIOLATION_DRIVELINE = 0x02,//drive line
    ITC_VIOLATION_REVERSE = 0x04,//reverse
    ITC_VIOLATION_REDLIGHT = 0x08,//red light
    ITC_VIOLATION_DIRECTION = 0x10,//direction
    ITC_VIOLATION_INTERSECTION_CONGEST = 0x20,//intersection congest
    ITC_VIOLATION_NONDRIVEWAY = 0x40,  //non-driveway
    ITC_VIOLATION_CHANGELANE = 0x80, //Illegal lane change
    ITC_VIOLATION_BAN = 0x100, //Illegal ban
    ITC_VIOLATION_INTERSECTION_PARK = 0x200,//intersection park
    ITC_VIOLATION_GREEN_PARK = 0x400,//green park
    ITC_VIOLATION_HIGH_SPEED = 0x800,
    ITC_VIOLATION_LOW_SPEED = 0x1000,
    ITC_VIOLATION_EMERGENCY = 0x2000,
    ITC_VIOLATION_TURN_AROUND = 0x8000,/*Illegal Turn*/
    ITC_VIOLATION_CONGESTION = 0x10000 /*congestion*/
}ITC_VIOLATION_DETECT_TYPE;

//Violation detect parameter
typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //violation detect type, bit, see ITC_VIOLATION_DETECT_TYPE ,0-disenable,1-enable
    BYTE byDriveLineSnapTimes; //Pressure lane line to capture the number of sheets,2-3
    BYTE byReverseSnapTimes; //Retrograde capture,2-3
    WORD wStayTime; //Machines accounted for non-residence time (the time after capture), the unit s
    BYTE byNonDriveSnapTimes;//Machine for non capture a number 2-3
    BYTE byChangeLaneTimes;//Illegal lane change capture a number 2-3
    BYTE bybanTimes;//Illegal ban snapshot number 2-3
    BYTE byDriveLineSnapSen;// Drive Line Snap(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //Article 2,3 to capture the position of minimum deviation (violation of signal onset) (unit: pixel)
    BYTE bySpeedTimes;//Illegal speeding capture number 2-3(3.8Ver)
    BYTE byTurnAroundEnable;//Turn Around Enable
    BYTE byThirdPlateRecogTime;//Third Plate Recognition Time 0~180s
    BYTE byPostSnapTimes;//Post Snap Times,1~2
    BYTE byRes1[18];
    WORD wStopLineDis;  //Electric police the the two breaches pictures with the shortest distance to the stop line, [0,300] units (pixels)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;

typedef enum _ITC_RELA_LANE_DIRECTION_TYPE_
{
    ITC_RELA_LANE_DIRECTION_UNKNOW = 0,
    ITC_RELA_LANE_EAST_WEST = 1,
    ITC_RELA_LANE_WEST_EAST = 2,
    ITC_RELA_LANE_SOUTH_NORTH = 3,
    ITC_RELA_LANE_NORTH_SOUTH = 4,
    ITC_RELA_LANE_EASTSOUTH_WESTNORTH = 5,
    ITC_RELA_LANE_WESTNORTH_EASTSOUTH = 6,
    ITC_RELA_LANE_EASTNORTH_WESTSOUTH = 7,
    ITC_RELA_LANE_WESTSOUTH_EASTNORTH = 8
} ITC_RELA_LANE_DIRECTION_TYPE;


//Lane useage type
typedef enum _ITC_LANE_USEAGE_TYPE_
{
    ITC_LANE_USEAGE_UNKNOW = 0,  //Unknow
    ITC_LANE_CARRIAGEWAY = 1,   //car lane
    ITC_LANE_BUS = 2,   //bus lane
    ITC_LANE_FAST = 3,   //fast lane
    ITC_LANE_SLOW = 4,   //slow lane
    ITC_LANE_MOTOR = 5,   //motor lane
    ITC_LANE_NONMOTOR = 6,    //non motor lane
    ITC_LANE_REVERSE_LANE = 7, //reverse lane
    ITC_LANE_BAN_TRUCKS = 8, // Prohibit trucks lane
    ITC_LANE_MIX = 9,
    ITC_LANE_EMERGENCY = 10,
    ITC_LANE_BAN_LEFT = 11,
    ITC_LANE_BAN_RIGHT = 12

}ITC_LANE_USEAGE_TYPE;

//Lane direction type
typedef enum _ITC_LANE_DIRECTION_TYPE_
{
    ITC_LANE_DIRECTION_UNKNOW = 0, //Unknow
    ITC_LANE_LEFT = 1, //left
    ITC_LANE_STRAIGHT = 2, //straight
    ITC_LANE_LEFT_STRAIGHT = 3, //left+straight
    ITC_LANE_RIGHT = 4, //right
    ITC_LANE_LEFT_RIGHT = 5, //left+right
    ITC_LANE_RIGHT_STRAIGHT = 6, //right+straight
    ITC_LANE_LEFT_RIGHT_STRAIGHT = 7, //left+right+straight
    ITC_LANE_LEFT_WAIT = 9, //left wait
    ITC_LANE_STRAIGHT_WAIT = 10, //straight wait
    ITC_LANE_FORWARD = 11, //Moving forward
    ITC_LANE_BACKWARD = 12, //Back to travel
    ITC_LANE_BOTHWAY = 13, //Two-way traffic
    ITC_LANE_STRAIGHT_WAIT_RIGHT = 14
}ITC_LANE_DIRECTION_TYPE;


//Drive direction
typedef enum _ITC_LANE_CAR_DRIVE_DIRECT_
{
    ITC_LANE_DRIVE_UNKNOW = 0, //Unknown
    ITC_LANE_DRIVE_UP_TO_DOWN = 1, //From up to down
    ITC_LANE_DRIVE_DOWN_TO_UP = 2  //From down to up    
}ITC_LANE_CAR_DRIVE_DIRECT;

//Line type
typedef enum _ITC_LINE_TYPE_
{
    ITC_LINT_UNKNOW = 0,  //Unknow
    ITC_LINE_WHITE = 1,  //Lane write line
    ITC_LINE_STOP = 2,  //Lane stop line
    ITC_LINE_SINGLE_YELLOW = 3,  //Lane single yellow line
    ITC_LINE_DOUBLE_YELLOW = 4,  //Lane double yellow line
    ITC_LINE_GUARD_RAIL = 5,  //Lane guard rail line
    ITC_LINE_NO_CROSS = 6,   //Lane no cross line
    ITC_LINE_DOTTED = 7 //dotted
}ITC_LINE_TYPE;



//Single video epolice param
typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //Lane NO.
    BYTE bySensitivity; //Coil sensitivity,[1,100]
    BYTE byEnableRadar;//Whether to enable the radar  0-no enable ,1- enable
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //Lane logic param
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //violation detect param
    NET_ITC_VIOLATION_DETECT_LINE struLine; //Violation detect line param
    NET_ITC_POLYGON struPlateRecog; //plate recog param
    BYTE byRecordEnable;//Running a red light cycle video flag, 0 - no video - Video
    BYTE byRecordType;//Through a red light video type, 0 - pre-recorded, 1 - Time-Lapse Recording
    BYTE byPreRecordTime;//Red light running pre-recorded video clips (default 0) unit: seconds
    BYTE byRecordDelayTime;//Red light running footage delay time (default 0) Unit: second
    BYTE byRecordTimeOut;//Running a red light cycle video timeout (in seconds)
    BYTE byCarSpeedLimit; //Car Limit Speed Unit:km/h
    BYTE byCarSignSpeed;//Sign Limit Speed Unit:km/h
    BYTE bySnapPicPreRecord; //snap Picture Record
    NET_ITC_INTERVAL_PARAM struInterval;//Interval
    BYTE byRes[36];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//Video epolice param
typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;    //enable,0-no,1-yes
    BYTE byLaneNum; //Lane number
    BYTE byLogicJudge;//Red light violations judgment logic, setting value: 0- according to the direction, 1- in the lane
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //plate recog
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //traffic light
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //single lane param
    NET_ITC_LINE  struLaneBoundaryLine; //Lane boundary line(the lane right boundary line
    NET_ITC_LINE  struLeftLine; //left line
    NET_ITC_LINE  struRightLine; //right line
    NET_ITC_LINE  struTopZebraLine; //top zebra line
    NET_ITC_LINE  struBotZebraLine; //bottom zebra line
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;

typedef union tagNET_ITC_VIDEO_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1150];
    NET_ITC_VIDEO_EPOLICE_PARAM struVideoEP; //Video epolice param
}NET_ITC_VIDEO_TRIGGER_PARAM_UNION, *LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION;

typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //trigger mode,see ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //video trigger param
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;            //Structure size
    BYTE   byEnableTrigIODetect; //Enable the status detection of triggering IO: 1- yes, 0- no
    BYTE   byEnableFlashOutDetect; //Enable the status detection of synchronous output: 1- yes, 0- no
    BYTE   byEnableRS485Detect; //Enable the detection of RS485 receiving status: 1- yes, 0- no
    BYTE   byEnableTrafficLightDetect;//Open the traffic light state detection, 1-yes, 0- no
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;

typedef enum _ITC_STATUS_DETECT_TYPE_
{
    ITC_STATUS_DETECT_NULL = 0,        //Unknown
    ITC_STATUS_DETECT_TRIGGERIO,    //Triggered IO port
    ITC_STATUS_DETECT_FLASHOUT,     //Synchronous output
    ITC_STATUS_DETECT_RS485, //RS485
    ITC_STATUS_DETECT_TRIGGERTYPE, //Triggering type(reserved)
    ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //The traffic light (color difference)
    ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //The traffic lights (distinguish steering)
}ITC_STATUS_DETECT_TYPE;

typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //Triggered IO port
    BYTE byRes[40];
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //Synchronous output number 
    BYTE byRes[40];
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //RS485 verification result: 0- invalid, 1- valid, 
    //bySerialIndex[0] means the correct head, bySerialIndex[1] means the correct rear
    BYTE byRes[40];
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //Triggering type value
    BYTE byRes[47];
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//Turn left at the lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byRightLight; //Turn right at the lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byStraightLight; //straight lights, 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 invalid, 1 to 2 red to green 3 yellow 4 lamp does not light
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;

typedef union tagNET_ITC_STATUS_UNION
{
    BYTE   uLen[48];            //Parameter
    NET_ITC_TRIGGERIO_INFO struTrigIO; //Triggered IO port
    NET_ITC_FLASHOUT_INFO struFlashOut; //Synchronous output
    NET_ITC_SERIAL_CHECKINFO struSerial;  //Serial port
    NET_ITC_TRIGGERTYPE_INFO struTrigType; //Triggering type (reserved)
    NET_ITC_TRAFFIC_LIGHT_COLOR struTrafficLightColor; //The traffic light (color difference) corresponding types ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    NET_ITC_TRAFFIC_LIGHT_TURN struTrafficLightTurn;//The traffic lights (distinguish steering) corresponding types ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
}NET_ITC_STATUS_UNION, *LPNET_ITC_STATUS_UNION;

typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//Status detection type, see to ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //Status detection result
    DWORD dwHoldTime; //Light holding time(reserved), unit: ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //Arming priority: 0-high, 1-middle, 2-low
    BYTE  byAlarmInfoType;
    BYTE  byRetAlarmTypeV40; //0- Ret NET_DVR_ALARMINFO_V30 or Older, 1- if Device Support NET_DVR_ALARMINFO_V40,  Ret NET_DVR_ALARMINFO_V40, else Ret NET_DVR_ALARMINFO_V30 Or NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR alarm 0-COMM_ALARM_DEVICE, 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //Exptected VQD alarm type,0-upload NET_DVR_VQD_DIAGNOSE_INFO,1-upload NET_DVR_VQD_ALARM
    //1-(INTER_FACE_DETECTION),0-(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0 - indicates whether the secondary protection to upload pictures: 0 - upload, 1 - do not upload 
    //Bit1 - said open data upload confirmation mechanism; 0 - don't open, 1 - to open
    //Bit6- eventType:radarDetection real-time upload:0-off,1-on
    BYTE  bySupport;
    //broken Net Http 
    //bit0-Vehicle Detection(IPC) (0 - not continuingly, 1 - continuingly)
    //bit1-PDC(IPC)  (0 - not continuingly, 1 - continuingly)
    //bit2-HeatMap(IPC)  (0 - not continuingly, 1 - continuingly)
    //bit3-Face Snap(IPC) (0 - not continuingly, 1 - continuingly)
    //bit4-Face Match(IPC) (0 - not continuingly, 1 - continuingly)
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;//Tasking number and the (field dwTaskNo corresponding data upload NET_DVR_VEHICLE_RECOG_RESULT the same time issued a task structure NET_DVR_VEHICLE_RECOG_COND corresponding fields in dwTaskNo
    BYTE  byDeployType;//deploy type:0-client deploy,1-real time deploy
    BYTE  bySubScription;
    //Bit7-MotionDetection Target Picture0-false1-true
    BYTE  byRes1[2];
    BYTE  byAlarmTypeURL;//bit0-(NET_DVR_FACESNAP_RESULT),0-binary,1-URL
    //bit1-(Picture data in EVENT_JSON),0-binary,1-URL
    BYTE  byCustomCtrl;//Bit0- Support the copilot face picture upload: 0-Upload,1-Do not upload
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_DVR_SETUPALARM_PARAM_V50
{
    DWORD dwSize;
    BYTE  byLevel; //Arming priority: 0-high, 1-middle, 2-low
    BYTE  byAlarmInfoType;
    BYTE  byRetAlarmTypeV40; //0- Ret NET_DVR_ALARMINFO_V30 or Older, 1- if Device Support NET_DVR_ALARMINFO_V40,  Ret NET_DVR_ALARMINFO_V40, else Ret NET_DVR_ALARMINFO_V30 Or NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR alarm 0-COMM_ALARM_DEVICE, 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //Exptected VQD alarm type,0-upload NET_DVR_VQD_DIAGNOSE_INFO,1-upload NET_DVR_VQD_ALARM
    //1-(INTER_FACE_DETECTION),0-(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0 - indicates whether the secondary protection to upload pictures: 0 - upload, 1 - do not upload 
    //Bit1 - said open data upload confirmation mechanism; 0 - don't open, 1 - to open
    BYTE  bySupport;
    //broken Net Http 
    //bit0-Vehicle Detection(IPC) (0 - not continuingly, 1 - continuingly)
    //bit1-PDC(IPC)  (0 - not continuingly, 1 - continuingly)
    //bit2-HeatMap(IPC)  (0 - not continuingly, 1 - continuingly)
    //bit3-Face Snap(IPC) (0 - not continuingly, 1 - continuingly)
    //bit4-Face Match(IPC) (0 - not continuingly, 1 - continuingly)
    //bit5-json(IPC) (0 - not continuingly, 1 - continuingly)
    //bit6-Heat Map Duration(IPC)(0 - not continuingly, 1 - continuingly)
    //bit7-Heat Map PDC (0 - not continuingly, 1 - continuingly)
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;//Tasking number and the (field dwTaskNo corresponding data upload NET_DVR_VEHICLE_RECOG_RESULT the same time issued a task structure NET_DVR_VEHICLE_RECOG_COND corresponding fields in dwTaskNo
    BYTE  byDeployType;//deploy type:0-client deploy,1-real time deploy
    BYTE  bySubScription; //Bit7-MotionDetection Target Picture;0-false,1-true
	//broken V60 
    //bit0-AID(COMM_ALARM_AID_V41) (0 - not continuingly, 1 - continuingly)
    //bit1-TFS(OMM_ALARM_TFS) (0 - not continuingly, 1 - continuingly)
    //bit2-TPS STATISTICS(COMM_ALARM_TPS_STATISTICS)  (0 - not continuingly, 1 - continuingly)
    BYTE  byBrokenNetHttpV60;
    BYTE  byRes1;
    BYTE  byAlarmTypeURL;//bit0-(NET_DVR_FACESNAP_RESULT),0-binary,1-URL
    //bit1-(Picture data in EVENT_JSON),0-binary,1-URL
    BYTE  byCustomCtrl;//Bit0- Support the copilot face picture upload: 0-Upload,1-Do not upload
    BYTE  byRes4[128];
}NET_DVR_SETUPALARM_PARAM_V50, *LPNET_DVR_SETUPALARM_PARAM_V50;


typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //video ep mode,see ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;
    BYTE    byWorkMode;  // 0-FTP1(main FTP),1-FTP2(sub FTP)
    BYTE    byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;


typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE                byEnable;/*Do you want to start the FTP upload function, 0- no, 1- yes*/
    BYTE                 byAddressType;   //0- IPv4 IPv6 address 1- domain name
    // Control of unionServer is to use the actual address or domain name
    WORD                wFTPPort;
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;
        } struAddrIP;
    }unionServer;
    BYTE                szUserName[NAME_LEN];
    BYTE                szPassWORD[PASSWD_LEN];
    BYTE                byRes4;  // 0-FTP1(main FTP),1-FTP2(sub FTP)
    BYTE                byDirLevel;    /*0 = do not use a directory structure, directly stored in the root directory,
                                    1 = 1 level directory, 2= uses 2 directory,
                                    3 = 3 level directory, 4= uses 4 directory*/
    BYTE                 byIsFilterCarPic;/*plate small map is uploaded, 0- upload, 1- do not upload*/
    BYTE                   byUploadDataType;//All of the 0-, 1- mount, 2- violation (single FTP default select all, support the bayonet, double FTP violation choice)
    NET_DVR_PICTURE_NAME     struPicNameRule;/* Picture naming rules */
    BYTE                byTopDirMode; /*Top Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
                                      0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
                                      0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE                bySubDirMode; /*Sub Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
                                      0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
                                      0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE                byThreeDirMode; /*Three Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
                                      0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
                                      0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    BYTE                byFourDirMode; /*Four Dir, 0x1 = use device name, 0x2 = use of equipment, equipment used,
                                      0x3 = IP address, 0x4= monitoring, 0x5= uses time (month and year), the operation time of 0x6= (Nian Yueri),
                                      0x7= type of violation, 0x8= direction, 0x9= sites, 0xa= channel, 0xb= channel, 0xc= lane, 0xff= custom*/
    //Picture naming custom, When "PICNAME_ITEM_CUSTOM" Take effect
    BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver Take effect)
    BYTE                szTopCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE                szSubCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE                szThreeCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE                szFourCustomDir[MAX_CUSTOMDIR_LEN];
    BYTE                 byRes3[900];
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//Degree[0,179]
    BYTE byMinute;//Minute[0,59]
    BYTE bySec;//Sec[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//Degree[0,179]
    BYTE byMinute;//Minute[0,59]
    BYTE bySec;//Sec[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD     dwSize;
    BYTE byGpsDataMode;//GPS Get Date Mode: 0-auto,1-manual
    BYTE byLongitudeType;//longitude  0-east,1-west
    BYTE byLatitudeType;//latitude  0-South,1-North
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM    struLatitude;     /*longitude*/
    NET_DVR_LONGITUDE_PARAM    struLongitude; /*latitude*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG, *LPNET_DVR_GPS_DATACFG;

/********************************Intelligent HD IPC V3.1 end*********************************/

typedef    struct tagNET_DVR_LEDDISPLAYINFO
{
    DWORD            dwSize;
    BYTE              byAddressType;
    BYTE             byRes1[3];
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;
        } struAddrIP;
    }unionServer;
    char        szDisplayInfo[MAX_LEDDISPLAYINFO_LEN/*1024*/];
    BYTE        byRes[128];
}NET_DVR_LEDDISPLAYINFO, *LPNET_DVR_LEDDISPLAYINFO;


/********************************Face search*********************************/
typedef enum _VCA_DATABASE_TYPE_
{
    DATABASE_NULL = 0, //unknow
    DATABASE_SNAP,    //snap database
    DATABASE_FACE    //face database
}VCA_DATABASE_TYPE;

typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //database ID
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //database name
    BYTE byAttribute[64]; //attirbute
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    BYTE byRes[12];
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //Database id, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    BYTE byRes[64];
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//channel NO.
    NET_DVR_TIME struStartTime;//start time
    NET_DVR_TIME struStopTime;//stop time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate,for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    BYTE byRes[12];
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_DVR_TIME struSnapTime;  //Snap Time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate,for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];
    BYTE *pFacePic;    //face picture data
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;

typedef union tagNET_VCA_DELETE_SNAPRECORD_COND_UNION
{
    NET_VCA_INQUIRE_SNAPDB_COND struAttribute;  //information(bulk delete)
    DWORD dwRecordID; //record ID(single delete)
}NET_VCA_DELETE_SNAPRECORD_COND_UNION, *LPNET_VCA_DELETE_SNAPRECORD_COND_UNION;

typedef enum _VCA_DELETE_RECORD_TYPE_
{
    DELETE_RECORD_SINGLE = 0, //single delete
    DELETE_RECORD_BATCH    //bulk delete
}VCA_DELETE_RECORD_TYPE;

typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //delete type
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //delete condition
    BYTE  byRes[40];
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;

typedef enum _VCA_SEARCH_DATABASE_TYPE_
{
    VCA_NORMAL_SEARCH_DATABASE = 0x00000000,   //normal search
    VCA_ADVANCE_SEARCH_DATABASE = 0x00000001    //advance search
}VCA_SEARCH_DATABASE_TYPE;

typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //database type,see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    DWORD dwFacePicID; //face picture ID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;

typedef union tagNET_VCA_SEARCH_DATABASE_COND_UNION
{
    DWORD uLen[25];
    NET_VCA_REGISTER_PIC struNormalFind; //normal search
    NET_VCA_ADVANCE_SEARCH_DATABASE_COND struAdvanceFind; //advance search
}NET_VCA_SEARCH_DATABASE_COND_UNION, *LPNET_VCA_SEARCH_DATABASE_COND_UNION;

typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //search type,see VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //search parameter
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{
    DWORD dwChannel; //channel NO.
    DWORD dwDataBaseID; //database ID
    NET_DVR_TIME struStartTime;//start time
    NET_DVR_TIME struStopTime;//stop time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate, for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //Search parameter
    DWORD dwMaxSearchNum; //max seatch number
    WORD wThreshold;  //threshold,0-100
    BYTE  byRes[78];
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_DVR_TIME struSnapTime;//snap time
    BYTE bySex; //sex:0-non,1-man,2-woman
    BYTE byRes1[3];
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //start birthdate, for:201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //end birthdate, for:201106
    BYTE byAttribute1[NAME_LEN]; //Attribute1
    BYTE byAttribute2[NAME_LEN]; //Attribute2
    float fSimilarity; //similarity,[0.001,1]
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];
    BYTE *pFacePic;    //face picture data
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{
    DWORD dwSize;
    DWORD dwRecordID; //record ID, update record valid
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribure
    NET_VCA_REGISTER_PIC struRegisterPic;  //human picture information
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    BYTE  byRes[32]; //
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{
    DWORD dwSize;
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribure
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    DWORD dwImageLen;  //image length
    BYTE  byRes[80];  //
    BYTE *pImage;    //image data
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{
    DWORD dwSize; //
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribute
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];  //
    BYTE *pFacePic;    //face picture data
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseID;  //database ID
    DWORD dwRecordID; //record ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //human attribute
    BYTE  byRemark1[NAME_LEN]; //remark1
    BYTE  byRemark2[64]; //remark2
    float fSimilarity; //similarity,[0.001,1]
    DWORD dwFacePicID; //face picture ID
    DWORD dwFacePicLen;  //face picture length
    BYTE byRes[80];  //
    BYTE *pFacePic;    //face picture data
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{
    DWORD dwDataBaseID; //database ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //human attribute
    BYTE byRes[80];  //
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;

typedef union tagNET_VCA_DELETE_RECORD_COND_UNION
{
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //human attribute(batch delete)
    DWORD dwRecordID; //record ID(single delete)
}NET_VCA_DELETE_RECORD_COND_UNION, *LPNET_VCA_DELETE_RECORD_COND_UNION;

typedef struct tagNET_VCA_DELETE_RECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //delete type
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //delete parameter
    BYTE  byRes[40]; //
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{
    DWORD dwDataBaseID; //Database ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //Human attribute
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //Search parameter
    DWORD dwMaxSearchNum; //Max search number
    WORD wThreshold;  //threshold, 0-100
    BYTE  byRes[78]; //
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //database ID, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //database ID
    DWORD dwRecordID; //record ID
    BYTE byRes[64]; //
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //database ID, see VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //databaseID
    DWORD dwRecordID; //record ID
    DWORD dwPicLen; //picture length
    BYTE byRes[64]; //
    BYTE *pPicBuffer; //picture data
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

/********************************VCA face end*********************************/

/********************************IPC*************************/
typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    WORD wDealyTime; //delay time,unit:s
    BYTE  byRes[30];
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byRes[16];
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE  byIndex;  //wireless alarm ID,1-8
    BYTE  byRes[15];
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;

#define MAX_AUX_ALARM_NUM 8 //max aux alarm number
#define MAX_WIRELESS_ALARM_NUM 8 //max wireless alarm number
typedef enum _IPC_AUX_ALARM_TYPE_
{
    IPC_AUXALARM_UNKNOW = 0, //Unknow
    IPC_AUXALARM_PIR = 1, //PIR alarm
    IPC_AUXALARM_WIRELESS = 2,   //Wireless alarm
    IPC_AUXALARM_CALLHELP = 3  //Call help alarm
}IPC_AUX_ALARM_TYPE;

typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD    dwDecibelLimit; //Decibel Limit
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //Exception handle
    BYTE    byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG, *LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //Exception handle
    BYTE    byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG, *LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* Alarm name */
    BYTE byAlarmHandle;            /* Handle alarm, 0-disanble,1-enable*/
    BYTE byID; //Wireless alarm ID,1-8
    BYTE byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* alarm handle type */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //record channel, 1-enable    
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //Single Wireless alarm
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;

typedef union tagNET_IPC_AUX_ALARMCFG_UNION
{
    DWORD uLen[472];
    NET_IPC_PIR_ALARMCFG_EX struPIRAlarm; //PIR alarm
    NET_IPC_WIRELESS_ALARMCFG struWirelessAlarm; //Wireless alarm
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //call help alarm
}NET_IPC_AUX_ALARMCFG_UNION, *LPNET_IPC_AUX_ALARMCFG_UNION;

typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;       //alarm type,see IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //alarm parameter
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //alarm
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;

typedef union tagNET_IPC_AUXALARM_UPLOAD_UNION
{
    DWORD uLen[66];
    NET_IPC_PIR_ALARMCFG struPIRAlarm; //PIR alarm
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm; //wireless alarm
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //call help alarm
}NET_IPC_AUXALARM_UPLOAD_UNION, *LPNET_IPC_AUXALARM_UPLOAD_UNION;

typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    BYTE byAlarmType;       //alarm type,see IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //alarm information
    BYTE byDeviceID[NAME_LEN];
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;
    BYTE   byCorrectMode;     //Correction mode, 0 - software calibration, 1 - chip calibration
    BYTE   byMountType;       //Type of installation - Ceiling, 1 - Desktop 2 - wall
    /*
        0- mode 1: fisheye + panoramic +3PTZ (non real time mode with the original agreement);
        1- mode: +4PTZ (2 eye with the original real-time consistent mode);
        2- mode 3: fisheye (main) + fisheye (sub) +3PTZ;
        3- mode 4: Pan (Ma Liu and Ma Liu);
        4- mode 5:4PTZ;
        5- mode 6:fisheye;
        6- mode 7:Latitude and longitude panorama expansion 
        7- mode 8:4PTZ merge
        */
    BYTE   byRealTimeOutput;  //Realtime output,0 -disable,1-enable
    BYTE   byRes[61];         //Reserved
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZCommand; //PTZ control commands
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    DWORD dwSpeed; //Control the speed, range [0,7]
    DWORD dwStop; //Action to stop or start action: 0 - start; 1 - stop
    BYTE  byRes[32];
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZPresetCmd; //Preset control commands
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    DWORD dwPresetIndex; //Preset number (1), supports up to 255 preset points
    WORD  wZoomCoordinate;
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //Channel number
    DWORD dwPTZCruiseCmd; //Cruise control command 
    NET_VCA_POINT struVcaPoint; //Preview interface point coordinates
    WORD wCruiseRoute; //Cruise path, supports up to 32 paths (serial number starting with 1)
    WORD wCruisePoint; //Cruise point supports up to 32 points (numbered from 1)
    WORD wInput; //Different cruise command value preset points (maximum 255), time (maximum 255), speed (maximum 40)
    WORD wZoomCoordinate;
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //enable WPS,0-no,1-yes
    BYTE byRes[31];
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN
    BYTE byRes[32];
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS connect type,0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN(WPS connect type,AP PIN)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS connect type,AP PIN)
    BYTE byRes[32];
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;


#define UPLOAD_CERTIFICATE  1 //upload certificate

/********************************IPC end*************************/

/**********************pic preview of push mode***************************/
typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struCuIp;    // ip of CU
    WORD    wPort;                // port of CU
    BYTE    bySourceIndex;        // channel index of signal
    BYTE    byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

#define DVCS_DEVICEID_LEN   16
//2012-03-13  picture preview message callback
typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD    dwUserID;
    BYTE   sDeviceID[DVCS_DEVICEID_LEN];
    LONG    nPicViewHandle; //picture view handle
    WORD    wSignalIndex;    //signal index
    WORD    wHeadLen;        //head len, the len of private stream is 40
    BYTE    byHeadBuf[100]; //stream head buffer
    BYTE    byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

/**********************get sub device list***************************/

typedef struct tagNET_DEVICEID_INFO
{
    DWORD        dwSize;
    DWORD        dwDeviceIndex;                    //device index
    BYTE        byWallNo;                        //wall no.,start from 1
    BYTE        byRes1[27];
    DWORD        dwChan;                            //channel index
    DWORD        dwInputSignalIndex;                //signal index,used in DVCS
    BYTE        byRes[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;

typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;                 //DHCP 0xff-INVALID 0-not used 1-used
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // ip address
    NET_DVR_IPADDR  struSubnetMask;  // mask
    NET_DVR_IPADDR  struGateway;     // gate way
    WORD    wDevPort;                 // port
    BYTE    byMACAddr[MACADDR_LEN];  // MAC address(get only)
    BYTE    byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD    dwSize;
    BYTE    byValid;                //0-invalid 1-valid
    BYTE    byRes1[3];
    BYTE    sChanName[NAME_LEN];    //channel name
    NET_DVR_COLOR struVideoColor;  //video color
    WORD    wResolutionX;        //current resolution---width 
    WORD    wResolutionY;        //current resolution---high
    BYTE   byRes2[40];;
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

//coder information
typedef struct tagNET_DVR_CODEDEV_INFO
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];//channel information 
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

//decoder information
typedef struct tagNET_DVR_DECODEDEV_INFO
{
    BYTE    byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

//net signal information
typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD    dwSize;
    BYTE    byDevName[NAME_LEN/*32*/];        // net signal name
    NET_DVR_PU_STREAM_CFG struPuStream;
    BYTE    byValid;                        // 0-invalid,set 0 when delete signal, 1-valid,set 1 when add or mod signal/
    BYTE     byRes1[3];                        // res
    BYTE    sGroupName[NAME_LEN/*32*/];        // group name of net signal
    WORD    wResolutionX;        //current resolution---width 
    WORD    wResolutionY;        //current resolution---high
    BYTE    byRes2[24];
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE    byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;

typedef union tagNET_DVR_DIFFDEV_INFO
{
    NET_DVR_CODEDEV_INFO struCodeDevInfo;            //coder information
    NET_DVR_DECODEDEV_INFO struDecodeDevInfo;        //decoder information
    NET_DVR_NETSIGNALDEV_INFO struNetSignalInfo;    //net signal information
} NET_DVR_DIFFDEV_INFO, *LPNET_DVR_DIFFDEV_INFO;

typedef enum tagNET_DVCS_DEVICE_TYPE
{
    NET_DVR_BNC_PROC = 1,                   // BNC processor
    NET_DVR_RGB_PROC,                       // RGB processor
    NET_DVR_STP_PROC,                       // stream processor
    NET_DVR_DISP_PROC,                      // display processor
    NET_DVR_NETSIGNAL,                      // net signal
    NET_DVR_SDI_PROC,                       // SDI processor
    NET_DVR_BIW_PROC,                       // 8 channels BNC processor
    NET_DVR_DON_PROC,                       // display processor
    NET_DVR_TVI_PROC,                       // TVI processor
    NET_DVR_DI2_PROC,                       // 2 channels DVI processor
    NET_DVR_DO2_PROC,                       // 2 channels DVI output
    NET_DVR_UHDI_PROC,                      // 1 channels DP/HDMI 4K input
    NET_DVR_YI2_PROC,                        // 2 channels YPbPr input
	NET_DVR_HI2_PROC,                        //2 channels HDMI input
	NET_DVR_VI2_PROC,                        //2 channels VGA  input
	NET_DVR_SI2_PROC,                        //2 channels SDI  input 
	NET_DVR_HO2_PROC,                        //2 channels HDMI output 
	NET_DVR_S24G_PROC,                        //24 channels C20N proper thousand switch 
	NET_DVR_S24X_PROC                        //24 channels C20N proper ten thousand switch
}NET_DVCS_DEVICE_TYPE;

typedef struct  tagNET_DVR_SINGLE_DEV_INFO
{
    DWORD    dwSize;
    DWORD    dwSoftVersion;            // soft version, the highest 8 bits is main version, other 8bits is sub version. the last 16 bits is repair version
    DWORD    dwSoftwareBuildDate;     // version Build data, 0xYYYYMMDD
    BYTE    byUseInSys;                // 0-not used in system 1-used in the system
    BYTE    byDevStatus;            // device status,0-offline,1-online 
    BYTE    byDeviceType;            // device type  describe in struct DEVICE_TYPE 
    BYTE    byRes1[17];
    BYTE    sDevName[NAME_LEN];                            //device name
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; //net param of device
    BYTE    sSerialNumber[SERIALNO_LEN];                //device serial
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;                //device information
    DWORD   dwDeviceIndex;
    DWORD   dwSubBoardNo;
    BYTE    bySubSysNo;
    BYTE    byRes3[3];
    WORD    wStartAudioTalkChanNo;
    WORD    wAudioTalkChanNum;
    BYTE    byRes2[36];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD        dwSize;
    DWORD        dwDevNums;//sub device numbers
    BYTE          *pBuffer;
    BYTE        byRes1[3];
    DWORD         dwBufLen;//buffer len
    BYTE        byRes2[64];
} NET_DVR_DEVLIST, *LPNET_DVR_DEVLIST;

/********************************base information of sub device****************************/
typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;            // 0-not used in system 1-used in the system
    BYTE   byDeviceType;        // device type 
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN];    // device name 
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO, *LPNET_DVR_DEV_BASE_INFO;

/********************************net information of sub device****************************/
typedef  struct tagNET_DVR_NETPARAM
{
    DWORD dwSize;
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET];
    BYTE   byRes[64];
} NET_DVR_NETPARAM, *LPNET_DVR_NETPARAM;

/********************************config display unit****************************/
// Binding screen and device(16 bytes)
typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD    dwSize;
    WORD    wScreenID;    // screen ID, start from 1
    BYTE    byWallNo;    // wall no.
    BYTE    byRes1;
    DWORD    dwDeviceIndex;// id of output device
    BYTE    byRes2[16];
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

// screen control
typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//1-display text,0-do not display text
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD        dwSize;
    BYTE        byWallNo;
    BYTE        byRes[11];
    DWORD        dwScreenNums;//screen numbers
    BYTE          *pBuffer;
    DWORD         dwBufLen;//buffer length
} NET_DVR_SCREENLIST, *LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD    dwSize;
    DWORD    dwSubCommand;//1-start upgrade,2-stop upgrade
    DWORD    dwDeviceIndex;//device index
    BYTE    byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

//upgrade
typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD    dwProgress; // 0-100
    BYTE     byState;  //1-upgrade finished 2-upgrading 3-upgrade failed
    BYTE    byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;

//data type of picture preview, the data type is bmp picture in cvcs, the picture data is ps stream in dvcs
typedef enum
{
    NET_DVR_DATA_BMP = 0,
    NET_DVR_START_CALLBACK,
    NET_DVR_STREAM_SYSHEAD,
    NET_DVR_STREAM_DATA
}PIC_PREVIEW_DATATYPE;

typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD    dwSize;
    DWORD    dwSignalIndex;                    // signal index,used in cvcs
    DWORD    dwDeviceIndex;//device index
    BYTE    byRes1[12];
    BYTE    byChanIndex;                    // channel index
    BYTE    byRes2[3];

    DWORD   dwScreenNum; //big screen index,start from zero
    DWORD   dwLayer;     //layer No : start from zero
    DWORD   dwResolution;//resolution, 1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//frame, unit: frame/second
    BYTE    bySupportStreamView; //client support stream view, 0-not support, 1-support
    BYTE    byRes3[14];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD    dwSize;
    BYTE    byAlarmType;         //alarm type 1-device online,2-device offline 3-server online 4-server offline, 5-manager logon,6-plan begin,7-plan end 8-resolution change,9-cut picture failed,10-not enough resource,11-temperature abnormal
    BYTE    byDeviceType;        //device type ,see struct NET_DVCS_DEVICE_TYPE
    BYTE    byWallNo;            // wall no,start from 1
    BYTE    byDeviceChanIndex;     // device channle index,0 means invalid,the other data means the channel index
    DWORD    dwDeviceIndex;        // device index
    WORD    wResolutionX;        //resolution-width
    WORD    wResolutionY;        //resolution-high
    WORD    wTemperature;       // device temperature 
    BYTE    byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

#define    DECODEPIC_LEFTADJUST            1        /*shift left*/
#define    DECODEPIC_RIGHTADJUST            2        /*shift right*/
#define    DECODEPIC_UPADJUST                3        /*shift upper*/
#define    DECODEPIC_DOWNADJUST            4        /*shift down*/
#define    DECODEPIC_REDUCEADJUST            5        /*zoom in*/   
#define    DECODEPIC_FULL_SCREEN_ADJUST    6        /*full screen*/
#define    DECODEPIC_CANCEL_FULL_SCREEN_ADJUST    7        /*cancel full screen*/
#define DECODEPIC_AUTOADJUST            8       /* auto adjust */
#define DECODEPIC_HEIGHTADJUST         9       /* height adjust */
#define DECODEPIC_WIDTHADJUST             10       /* width adjust */

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD        dwSize;
    BYTE        bySubCommand;        //see struct DECODEPIC_LEFTADJUST
    BYTE        byScale;            //scale
    BYTE        byPictureProportion;    //picture proportion 1-4:3, 2-16:9
    BYTE        byRes[29];
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD    dwSize;
    BYTE    byControlCommand;    //control command,1-show,2-hide,3-delete all(use when GIF)
    BYTE    byUseType;            //pictrue type,1-OSD 2-basemap,3-GIF
    BYTE    byWallNo;            //wall no.start from 1
    BYTE    byPictureNo;        //picture no.
    BYTE    byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;
/********************************dvcs end****************************/

// 76SP device config POE channel add mode
typedef struct tagNET_DVR_POE_ADAPTER_TYPE
{
    DWORD        dwSize;
    BYTE         byAdapterType;             //Aapter type 0: inter adpter 1: LAN1    
    BYTE          byRes1[127];
}NET_DVR_POE_ADAPTER_TYPE, *LPNET_DVR_POE_ADAPTER_TYPE;

// 76SP device config POE channel add mode
typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD        dwSize;
    BYTE         byAddMode;                 //0: UPNP 1: add by manual    
    BYTE          byRes1[127];
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

#define MAX_ESATA_NUM 16
#define MAX_MINISAS_NUM 96

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD        dwSize;
    BYTE        byESATAUsage[MAX_ESATA_NUM];        // 0:backup 1:record      
    BYTE        byMiniSASUsage[MAX_MINISAS_NUM];    // 0:backup 1:record
    BYTE         byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

#define MAX_DISK_NUM 128

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD        dwSize;
    BYTE        byDiskDesc[DESC_LEN_32];
    BYTE        byHardDisk[MAX_DISK_NUM];
    BYTE        byBackupHardDiskNum;
    BYTE        byContinue;
    BYTE        byAllLogBackUp;
    BYTE         byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD    dwSize;
    BYTE    byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //Digital audio talk state 0-not use,1-using, 0xff, not valid
    BYTE    byDigitalChanState[MAX_CHANNUM_V30];
    BYTE    byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30 * 3];
    BYTE    byDigitalChanStateEx[MAX_CHANNUM_V30 * 3];
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];
    BYTE    byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;

typedef enum
{
    NET_SDK_DC_STATUS_CONNECTED = 1,
    NET_SDK_DC_STATUS_CONNECTING,
    NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,
    NET_SDK_DC_STATUS_DOMAIN_ERROR,
    NET_SDK_DC_STATUS_CHANNEL_ERROR,
    NET_SDK_DC_STATUS_ACCOUNT_ERROR,
    NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,
    NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,
    NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,
    NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,
    NET_SDK_DC_STATUS_IPC_NOT_EXIST,
    NET_SDK_DC_STATUS_IPC_EXCEPTION,
    NET_SDK_DC_STATUS_OTHER_ERROR,
    NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,
    NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,
    NET_SDK_DC_STATUS_USER_LOCKED = 16,
    NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,
    NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,
    NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,
    NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20,
    NET_SDK_DC_STATUS_RESOURCE_EXCEED = 21,
    NET_SDK_DC_STATUS_NEED_TO_REPAIR = 22,
    NET_SDK_DC_STATUS_ACTIVATING = 23,
    NET_SDK_DC_STATUS_TOKEN_AUTHENTCATE_FAILED = 24
}NET_SDK_DIGITAL_CHANNEL_STATUS;


/*************************************ITS****************************/
#define VERSION_LEN                 32 //Version length
#define    MAX_OVERLAP_ITEM_NUM        50 //Max character overlap number
#define    ITS_MAX_DEVICE_NUM            32 //Max device number

//Terminal basic information
typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;
    BYTE    byMainVer[VERSION_LEN];    // Terminal Basic information
    BYTE    byMprVer[VERSION_LEN];    // Multiple frame recognize data version
    BYTE    byBvtVer[VERSION_LEN];    // Backward video library version
    BYTE    byLptVer[VERSION_LEN];    // Video tracking data version
    BYTE    byTvdVer[VERSION_LEN];    // Rule-break detection data version
    BYTE    byTldVer[VERSION_LEN];    // Signal light detection data version
    BYTE    byRes[252];        // Reserved
}NET_ITS_BASEINFO, *LPNET_ITS_BASEINFO;

//Photomontage parameters
typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE  byIsMerge;        //Merged needed or not (0:No 1:YES)
    BYTE   byCloseupProportion;   //Figure 1- the original resolution feature size, 2- width and height as the original resolution two times, and so on (1 ~ 8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;    //Single captured picture merged method (close-up view might be cut out )
    DWORD  dwTwoMergeType;    //Two captured picture merged method
    DWORD  dwThreeMergeType;    //Three captured picture merged method
    DWORD  dwJpegQuality;      //Compression quality(0~100)
    DWORD  dwCloseupIndex;     //The number of close-up picture
    DWORD  dwMerageMaxSize;   //Top limit size of the merged pictures (300~10240KB)
    WORD   wCloseupDeviation; //Closeup deviation(50~picture height),unit:pixel
    BYTE   byRes[30];
    /************************************************************************/
    /* 201 merge the upper and the lower pictures, the width of the merged picture is one times, the height is doubled         */
    /* 202 merge the left and the right pictures, the width of the merged picture is doubled, the height is one times.         */
    /* 301 merge the top, the middle and the bottom pictures, the width of the merged picture is one times, the height is tripled */
    /* 302 merge the left, the middle and the right pictures, the width of the merged picture is tripled, the height is one times */
    /* 303 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower right. The width of the merged picture is doubled and the height is doubled.*/
    /* 304 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower right. The width of the merged picture is one times and the height is one times.*/
    /* 305 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top left. The width of the merged picture is doubled and the height is doubled.*/
    /* 306 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top left. Compress the resolution. The width of the merged picture is one times, and the height is one times.*/
    /* 307 merge the three pictures into a 1*2 layout */
    /* 308 merge the three pictures into a 2*1 layout */
    /* 309 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower left. The width of the merged picture is doubled and the height is doubled.*/
    /* 310 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the lower left. The width of the merged picture is one times and the height is one times.*/
    /* 311 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top right. The width of the merged picture is doubled and the height is doubled.*/
    /* 312 take a license plate from the three pictures as a close-up, and merge with the other three pictures into a 2*2 layout, make the license plate on the top right. Compress the resolution. The width of the merged picture is one times, and the height is one times.*/
    /************************************************************************/
}NET_ITS_IMGMERGE_CFG, *LPNET_ITS_IMGMERGE_CFG;

//Transportation data host
typedef    struct    tagNET_ITS_TRAFFIC_DATA_HOST
{
    NET_DVR_IPADDR    struHostAddr;    // Remote host IP
    WORD            wHostPort;    // Remote host port
    BYTE            byRes1[2];
    DWORD            dwDataType;    // Upload the data type of the remote mainframe (see below definition), indicated by bit
    BYTE            bySuspendUpload;    //Suspend the data uploading or not: 0- upload, 1- suspend
    BYTE            byUploadStrategy;    //Upload strategy: 0- upload the latest data first, 1- upload the data in sequence
    WORD            wUploadInterval;    //The interval of the upload(ms, 1~2000), this parameter only works for historical data
    DWORD            dwUploadTimeOut; //Upload timed-out
    BYTE            byRes[24];
}NET_ITS_TRAFFIC_DATA_HOST, *LPNET_ITS_TRAFFIC_DATA_HOST;

//Data upload parameter
typedef  struct    tagNET_ITS_UPLOAD_CFG
{
    DWORD                  dwSize;
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost1;       //Host 1 to receive transportation dat
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost2;    //Host 2 to receive transportation data 
}NET_ITS_UPLOAD_CFG, *LPNET_ITS_UPLOAD_CFG;

typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;           //Year
    WORD  wMonth;          //Month
    WORD  wDay;            //Day
    WORD  wHour;           //Hour
    WORD  wMinute;      //Minute
    WORD  wSecond;      //Second
    WORD  wMilliSec;    //Millisecond
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;

//The status of the transportation data host
typedef    struct tagNET_ITS_TRAFFIC_DATA_INFO
{
    DWORD    dwDataQuantity;      //Data amount
    DWORD    dwDataRsendQuantity;     //Undelivered data quantity (needs to be uploaded to the transportation data host)
    NET_DVR_SYSTEM_TIME      struStartTime;      //The earliest time of the undelivered data
    NET_DVR_SYSTEM_TIME      struEndTime;        //The most recent time of the undelivered data
    NET_DVR_IPADDR   struDataHost;    //Host of receiving transportation data
}NET_ITS_TRAFFIC_DATA_INFO, *LPNET_ITS_TRAFFIC_DATA_INFO;

//The terminal work status
typedef  struct tagNET_ITS_WORKSTATE
{
    DWORD      dwSize;
    BYTE     byDevName[32];    // Device name
    DWORD  dwRunTime;        // System running time, Unit: second
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //Tow hosts are supported(The data upload to the configuration hosts)
    DWORD  dwMemoryUsage;    // Memory usage (If the usage is 30%, enter 30 in this field)
    DWORD  dwCpuUsage;        // CPU usage (If the usage is 30%, enter 30 in this field)
    DWORD  dwDevTemperature;    // Temperature
    DWORD  dwDeviceStatic;     // Device status: 0-normal, 1-CPU usage is more than 85, 2-hardware error, e.g. serial port broken
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Hardware status
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //Channel status
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //Alarm input status, 0- no alarm, 1- alarm
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //Alarm output status, 0- no alarm, 1- alarm
    DWORD dwLocalDisplay;            //Local view status, 0- normal, 1-abnormal
    BYTE  byAudioInChanStatus[8];      //Audio channel status, 0-not in use, 1- in use, array 0 means the no.1 voice channel
    BYTE  byRes[36];             //Reserved
}NET_ITS_WORKSTATE, *LPNET_ITS_WORKSTATE;

//Import and export traffic configuration to obtain parameters
typedef  struct tagNET_ITS_ECT_WORKSTATE_COMMAND
{
    DWORD    dwSize;
    DWORD  dwChannel;
    BYTE   byRes[256];
}NET_ITS_ECT_WORKSTATE_COMMAND, *LPNET_ITS_ECT_WORKSTATE_COMMAND;

typedef struct tagNET_ITS_ECTWORKSTATE
{
    DWORD      dwSize;
    BYTE      byDevName[NAME_LEN];    // device name
    DWORD    dwRunTime;        // System uptime, unitss
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //Support two hosts (data upload configuration host)
    DWORD    dwMemoryUsage;    // Memory usage (memory occupancy rate of 30%, where the fill 30)
    DWORD    dwCpuUsage;        // cpu usage (cpu occupancy rate of 30%, where the fill 30)
    DWORD    dwDevTemperature;    // The temperature of the machine
    DWORD    dwDeviceStatic;     // The status of the device, 0 - normal, 1-CPU occupancy rate is too high, more than 85%, 2 - hardware error, such as serial dead
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Hard disk status
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //The status of the alarm input port, 0 - no alarm - alarm
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //The status of the alarm output port, 0 - no output, 1 - alarm output
    DWORD    dwLocalDisplay;//Local display state 0 - normal, 1 - normal
    BYTE     byRes[256];
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

// Picture info
typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;            //Media data length
    //0: license picture, 1: Scene picture, 2: Composite map, 3: stream 12: pilot room picture 13: copilot room picture;14-face picture
    //15 - custom pictureNET_DVR_TFS_ALARM, *LPNET_DVR_TFS_ALARM;
    BYTE    byType;                
    BYTE    byDataType; // 0-Data Upload; 1-Cloud Storage Server
    BYTE    byCloseUpType;//Close Up Type
    BYTE    byPicRecogMode;  //Picture Recog Mode; 
    DWORD   dwRedLightTime;        //Time for passing the red traffic light (s)
    BYTE    byAbsTime[32];        //Absolute time, yyyymmddhhmmssxxx,e.g.20090810235959999, The last three numbers mean millisecond
    NET_VCA_RECT   struPlateRect;    //License plate location,human location when byType is 8,9
    NET_VCA_RECT  struPlateRecgRect;   //License plate region coordinate ,when the image type is 12/13, the coordinates of the pilot coordinates
    BYTE        *pBuffer;    //Data pointer
    DWORD   dwUTCTime;//UTC Time
    BYTE    byCompatibleAblity; //Compatible Ablity
    BYTE    byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char    cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char    cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE    byRes2[4];           //Reserved
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;


typedef struct tagNET_ITS_ILLEGAL_INFO
{
    BYTE  byIllegalInfo[MAX_ILLEGAL_LEN/*64*/];// Illegal Info
    BYTE  byRes[256];
}NET_ITS_ILLEGAL_INFO, *LPNET_ITS_ILLEGAL_INFO;


//Detection result
typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;        //Structure size
    DWORD   dwMatchNo;  //Matched Serial Number. (consisting of the vehicle serial number, data type and lane number)
    BYTE    byGroupNum;    //Amount of the picture groups (the amount of pictures captured when one vehicle passing by. The data can be used for the Time Delay Matching.)
    BYTE    byPicNo;    //Continuous captured pictures serial number. (indicating the complete of the receiving.)
    BYTE    bySecondCam;    //Whether set the second camera to snapshot (e.g. prospect camera of far and near scene capture, rear camera of front and rear capture)
    BYTE    byFeaturePicNo; //electric alarm of running red light, which picture taken to be close-up, 0xff- not take
    BYTE    byDriveChan;    //Triggering lane No.
    BYTE    byVehicleType;     //Vehicle type,refer to VTR_RESULT
    BYTE    byDetSceneID;//Detecting Scene ID[1,4], 
    // 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    //this Attribute is useless, use byYellowLabelCar and byDangerousVehicles
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //Rules broken type adopts the international standard definition
    BYTE    byIllegalSubType[8];   //Rules broken sub-type
    BYTE    byPostPicNo;    //The captured picture number to be traffic mount picture when the rule is broken,0xff- not take
    BYTE    byChanIndex;        //Camera No. (reserved)
    WORD    wSpeedLimit;        //Speed upper limit(valid when overspeed)
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex
    /* vehicle position control flag,0~No,1~With,
    (PUT /ISAPI/Traffic/channels//vehiclePositionControl? Format = json)
    2~(GPS or preset,PUT /ISAPI/Traffic/channels/<ID>/vehicleMonitor/<taskID>/startTask, with no 'unarmedVehicleDetectionAlarm' or unarmedVehicleDetectionAlarm is false)
    3~(manualVehicleMonitor, /ISAPI/Traffic/channels/<ID>/manualVehicleMonitor?format=json)
    4~DailyVehicleMonitor  /ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities:isSupportDailyVehicleMonitor*/
    BYTE    byVehiclePositionControl;  
    NET_DVR_PLATE_INFO  struPlateInfo;     //Plate info. structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //Vehicle info
    BYTE    byMonitoringSiteID[48];        //Camera No.
    BYTE    byDeviceID[48];                //Device No.
    BYTE    byDir;            //Monitoring direction; 1- Up, 2- Down, 3- Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other directio
    BYTE    byDetectType;    //Detecting methods: 1- Triggered by induction coil, 2- Triggered by video, 3- Triggered by multi-frame detection, 4-Triggered by radar.
    BYTE    byRelaLaneDirectionType;//ITC_RELA_LANE_DIRECTION_TYPE
    BYTE    byCarDirectionType; //Car Direction Type
    DWORD   dwCustomIllegalType; //Custom Illegal Type
    BYTE*   pIllegalInfoBuf;    //Illegal Info Buf
    BYTE    byIllegalFromatType; //Illegal Fromat Type
    BYTE    byPendant;//  Pendant,0-Unknow, 1-No,2-Yes
    BYTE    byDataAnalysis;            //0-Data Not Analysis, 1-Data Analysis
    BYTE    byYellowLabelCar;        //Yellow Label Car; 0-Unknow, 1-No,2-Yes
    BYTE    byDangerousVehicles;    //Dangerous Vehicles; 0-Unknow, 1-No,2-Yes
    //The following field contains Pilot characters are main driving, contains Copilot characters are sub driving
    BYTE    byPilotSafebelt;//Pilot Safe belt
    BYTE    byCopilotSafebelt;//Copilot Safe belt
    BYTE    byPilotSunVisor;//Pilot Sun Visor
    BYTE    byCopilotSunVisor;//Copilot Sun Visor
    BYTE    byPilotCall;// Pilot Call
    //The 0-open, 1-close(dedicated to the historical data based on block and allow list matching, whether to open a sign of success)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-RealTime Data,1-Historical Data
    NET_DVR_TIME_V30  struSnapFirstPicTime;//End time (MS) (captured the first picture time.)
    DWORD   dwIllegalTime;//Illegal duration (MS) = captured the last picture time - to capture the first picture of the time
    DWORD   dwPicNum;        //The picture count (different with picGroupNum, represent the picture count attached by this information, picture info defined by struVehicleInfoEx    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //Picture info, check picture, at most 6 pictures at one time
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

//Import and export vehicles to capture data upload
typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwMatchNo;    //Match the serial number, by default match code (vehicle ID, data type, lane number) 0
    BYTE    byGroupNum;    //Image data control the picture group number (a number of car camera several times to capture the total number of on behalf of a group of pictures for delay matching data) default capture type subsequently received delay operations
    BYTE    byPicNo;        //Continuous group of pictures upload pictures serial number (the number of received a group of pictures, which means that the reception is complete.
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    bySecondCam;    //Rear camera to capture whether the second camera to capture (such as distance views to capture the vision camera, or about special projects will be used) marked the front and rear camera to capture pictures
    BYTE    byRes;
    WORD    wLaneid;            //Lane number 1 to 32 (index lane number, you can jump)
    BYTE    byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE    byRes1;
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //Custom alarm type defaults to Chinese
    WORD    wBackList;    //Marked as to whether the alarm data of 0 indicates normal-car data expressed blocklist
    WORD    wSpeedLimit;        //Speed limit upper limit (speeding) km / h
    DWORD   dwChanIndex;
    NET_DVR_PLATE_INFO    struPlateInfo;
    NET_DVR_VEHICLE_INFO  struVehicleInfo;
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //Monitoring points
    BYTE    byDeviceID[MAX_ID_LEN];                //Device number 
    BYTE    byDir;            //Monitoring direction, 0 - 1 admission, 2 appearances
    BYTE    byDetectType;    //Detection, 0 - Other 1 - to feel fat, 2 - video trigger, 3 - Multi-frame identification, 4 - radar trigger
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN];
    DWORD   dwPicNum;        //Pictures (unlike picGroupNum, on behalf of this section with the number of pictures, image information defined by the struVehicleInfoEx    
    NET_ITS_PICTURE_INFO struPicInfo[4];         //Picture message, a single callback, up to 4, by serial number distinguish
    //2013-11-19 add Parameters
    BYTE    bySwipeTime[MAX_TIME_LEN];//Swipe Time  Time Format:yyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;

typedef  struct  tagNET_ITS_GATE_FACE
{
    DWORD   dwSize;
    BYTE    byGroupNum;    //Image group number of (a pedestrian cameras capture many times the number of the total number of on behalf of a group of pictures for the delay matching data)
    BYTE    byPicNo;        //Continuous picture serial number (the number of received a group of pictures, which means that the reception is complete.
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    byFeaturePicNo; //Take a few pictures and even caught as a close-up view, 0xff-said they did not take
    BYTE    byRes;
    WORD    wLaneid;            //Lane number 1 to 32 (index lane number, you can jump)
    BYTE    byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE    byDir;        //Monitoring direction, 0 - 1 admission, 2 appearances
    DWORD   dwChanIndex;
    BYTE    byMonitoringSiteID[MAX_ID_LEN];
    BYTE    byDeviceID[MAX_ID_LEN];
    NET_VCA_FACESNAP_RESULT     struFaceInfo;
    BYTE    byRes2[256];
}NET_ITS_GATE_FACE, *LPNET_ITS_GATE_FACE;

typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize;
    BYTE    byGroupNum; //The number of group of pictures (single polling snapshot pictures)
    BYTE    byPicNo; //Receive complete burst picture group upload pictures serial number (the number of received a group of pictures
    //Receive time-out is less than the number of the group of pictures, according to the need to retain or delete)
    BYTE    byLocationNum; //The number of parking spaces managed by a single picture
    BYTE    byParkError; //Parking abnormalities, 0 - Normal 1 exception
    BYTE    byParkingNo[MAX_PARKNO_LEN];
    BYTE    byLocationStatus; //Parking the vehicle state, 0 - no cars, car
    BYTE    bylogicalLaneNum;//Logical number of parking spaces, 0-3, a camera largest pipe 4 parking spaces (0 represents the left-most, 3 represents the far right)
    WORD    wUpLoadType;//Zero bit: 0 ~ rotational training upload, 1 to change to upload
    BYTE    byRes1[4];
    DWORD   dwChanIndex; //Channel number digital channels
    NET_DVR_PLATE_INFO   struPlateInfo;
    NET_DVR_VEHICLE_INFO struVehicleInfo;
    BYTE   byMonitoringSiteID[MAX_ID_LEN];
    BYTE   byDeviceID[MAX_ID_LEN];
    DWORD  dwPicNum; //Pictures (picGroupNum, on behalf of this information incidental to the number of pictures
    //,The picture by struVehicleInfoEx defined 
    NET_ITS_PICTURE_INFO struPicInfo[2];  //Picture message, a single callback, up to 2 No. distinguish
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

typedef enum _VTR_RESULT
{
    VTR_RESULT_OTHER = 0,  //other
    VTR_RESULT_BUS = 1,  //Bus
    VTR_RESULT_TRUCK = 2,  //Truck
    VTR_RESULT_CAR = 3,   //Car
    VTR_RESULT_MINIBUS = 4,   //MiniBus
    VTR_RESULT_SMALLTRUCK = 5,    //SmallTruck
    VTR_RESULT_HUMAN = 6,   //human
    VTR_RESULT_TUMBREL = 7,   //Tumbrel
    VTR_RESULT_TRIKE = 8,     //Trike
    VTR_RESULT_SUV_MPV = 9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS = 10,  //Medium Bus
    VTR_RESULT_MOTOR_VEHICLE = 11, //Motor Vehicle
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //Non-Motor Vehicle
    VTR_RESULT_SMALLCAR = 13,   //Small Car
    VTR_RESULT_MICROCAR = 14,   //Micro Car
    VTR_RESULT_PICKUP = 15,    //Pick Up
    VTR_RESULT_CONTAINER_TRUCK = 16, //Container truck
    VTR_RESULT_MINI_TRUCK = 17, //Mini truck
    VTR_RESULT_SLAG_CAR = 18, //Slag car
    VTR_RESULT_CRANE = 19, //Crane
    VTR_RESULT_OIL_TANK_TRUCK = 20, //Oil tank truck
    VTR_RESULT_CONCRETE_MIXER = 21, //Concrete mixer
    VTR_RESULT_PLATFORM_TRAILER = 22, //Platform Trailer
    VTR_RESULT_HATCHBACK = 23, //Hatchback
    VTR_RESULT_SALOON = 24, //Saloon
    VTR_RESULT_SPORT_SEDAN = 25,  //Sport sedan
    VTR_RESULT_SMALL_BUS = 26      //small bus
}VTR_RESULT;

typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //Structure size
    DWORD                   dwRelativeTime;        //Relative time 
    DWORD                   dwAbsTime;               //Absolute time 
    DWORD                   dwIllegalType;         //Lawless types, using national standard definition, using byIllegalCode when dwIllegalType value of 0 XFFFFFFFF 
    DWORD                   dwIllegalDuration;     //Illegal duration(second)
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//ID of monitoring point 
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //ID of the device 
    NET_VCA_DEV_INFO        struDevInfo;           //Device info
    NET_DVR_SCENE_INFO      struSceneInfo;         //Scene info
    NET_DVR_TIME_EX         struBeginRecTime;      //Record begin time
    NET_DVR_TIME_EX         struEndRecTime;        //Record end time
    NET_DVR_AID_INFO        struAIDInfo;           //Traffic event info
    NET_DVR_PLATE_INFO      struPlateInfo;         //License plate information 
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //Vehicle info
    DWORD                   dwPicNum;              //The number of pictures
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //Picture information, up to 8 pitures 
    BYTE                    bySpecificVehicleType;     //The specific vehicle type recognition result types reference  VTR_RESULT
    BYTE                    byLaneNo;  //Relate Lane No
	WORD                    wDevInfoIvmsChannelEx; //NET_VCA_DEV_INFO->byIvmsChannel
    NET_DVR_TIME_V30        struTime;//Time
    DWORD                   dwSerialNo;//Serial No.
    BYTE                    byVehicleAttribute;// 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    BYTE                    byPilotSafebelt;//Pilot Safe belt
    BYTE                    byCopilotSafebelt;//Copilot Safe belt
    BYTE                    byPilotSunVisor;//Pilot Sun Visor
    BYTE                    byCopilotSunVisor;//Copilot Sun Visor
    BYTE                    byPilotCall;// Pilot Call
    BYTE                    byRes2[2]; //Res
    BYTE                    byIllegalCode[ILLEGAL_LEN/*32*/];//Illegal code extension, when dwIllegalType value is 0 XFFFFFFFF; Use this value 
    WORD                    wCountry; //Country,COUNTRY_INDEX
    BYTE                    byRegion; //Region, 0-res,1-(Europe Region),2-(Russian Region),3-(EU&CIS) ,4-(Middle East),0xff-all
    BYTE                    byCrossLine;//cross line 0-res 1-not cross 2-cross
    BYTE                    byParkingSerialNO[SERIAL_NO_LEN/*16*/];//parking serial NO
    BYTE                    byCrossSpaces;//cross spaces 0-res,1-no,2-yes
    BYTE                    byAngledParking;//angled parking 0-res,1-no,2-yes
    BYTE                    byAlarmValidity;//alarm validity 0-100
    BYTE                    byDoorsStatus;//door staus 0-door close 1-door open
	DWORD                  dwXmlLen;//XML Alarm data length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*  pXmlBuf; // XML Alarm pointer XML EventNotificationAlert XML Block
#else
    char*   pXmlBuf; // XML Alarm pointer XML EventNotificationAlert XML Block
    BYTE  byRes3[4];
#endif  
    BYTE                    byVehicleHeadTailStatus; //the status  of  vehicle head or vehicle tail  0-res 1-vehicle head 2-vehicle tail
    BYTE                    byBrokenNetHttp;         //Broken net HTTP(0 - not continuingly, 1 - continuingly)
    BYTE                    byRes[30];               //Res
}NET_DVR_TFS_ALARM, *LPNET_DVR_TFS_ALARM;

typedef struct tagNET_DVR_SOFTWARE_SERVICE_CFG
{
    DWORD       dwSize;
    BYTE        byThirdStreamEnabled;  //Whether open three yards flow configuration:0 - no, 1 - is 
    BYTE        bySubStreamEnabled;  //Whether to open the child code flow configuration:0 - no, 1 - is 
    BYTE        byRes[254];
}NET_DVR_SOFTWARE_SERVICE_CFG, *LPNET_DVR_SOFTWARE_SERVICE_CFG;

typedef struct tagNET_ITS_ECT_BLOCKLIST
{
    DWORD dwSize;
    DWORD dwChannel;
    BYTE  bylogicalLaneNo;
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];
    NET_DVR_PLATE_INFO  struPlateInfo;
    BYTE  byRes2[256];
}NET_ITS_ECT_BLOCKLIST, *LPNET_ITS_ECT_BLOCKLIST;

//IPC channel configuration
typedef    struct     tagNET_ITS_IPC_CHAN_CFG
{
    DWORD        dwSize;
    BYTE        byCameraType;        //Camera type, 0- surveillance camera, 1- coil triggering camera, 2- camera for video analysis, 3- zoom camera
    BYTE        byRes1[3];           //Reserved
    BYTE        byMonitoringSiteID[48];        //Camera No.
    BYTE        byDeviceID[48];                //Device No.
    BYTE        byDirectionNo;         //Monitoring direction; 1-Up, 2-Down, 3-Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other direction 
    BYTE        byMonitorInfo[48];      //Camera information description
    BYTE        byRes2[15];        //Reserved
}NET_ITS_IPC_CHAN_CFG, *LPNET_ITS_IPC_CHAN_CFG;

//Single device info
typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;          //Device Type, 0- end, 1- camera, 2- compensation light, 3- car checking machine
    DWORD  dwDirID;               //Direction No.
    DWORD  dwLaneID;             //Lane No.
    DWORD  dwDeviceState;         //Device status; 0:normal, others: abnormal
    BYTE     byDeviceName[32];     //Device name
    BYTE       byDeviceID[48];    //Device No., normally it should be the serial number and for the car checking machine, address should be used.
    NET_DVR_TIME_V30  struTriggerTime;//triggering time ; 
    BYTE   byRelateChan; //Relate Channel
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO, *LPNET_ITS_SINGLE_DEVICE_INFO;

//Road junction information
typedef struct tagNET_ITS_ROADINFO
{
    DWORD     dwSize;
    DWORD     dwChannel;          //Channel No., 0xffffffff means terminal, other value mean the corresponding camera
    BYTE     byTriggerMode;    //0: Triggered  by loop; 1: Triggered by video
    BYTE     byRes1[3];
    DWORD   dwDeviceNum;       //Actual device count 
    BYTE      byMonitoringSiteID[48];    //Camera No.
    BYTE       byRoadInfo[48];       //Camera info
    NET_ITS_SINGLE_DEVICE_INFO        struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE byRes[16];
}NET_ITS_ROADINFO, *LPNET_ITS_ROADINFO;

typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;        //Drive channel
    BYTE   byRes1[3];            // 
    WORD   wCarFlux;            //Car flux
    WORD   wPasserbyFlux;        //Passerby flux
    WORD   wShayFlux;        //Shay flux
    float  fAverOccpancy;       //Average occpancy
    WORD   wAverSpeed;         //Average speed(km/h)
    WORD   wAverCarDis;        //Average car distance()
    BYTE   byRes2[16];            // 
}NET_ITS_TRAFFIC_DRIVE_CHAN, *LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;        //
    BYTE   byMonitoringSiteID[48];        //Monitor ID
    BYTE   byDeviceID[48];                //Device ID
    BYTE   byLaneNum;    //Lane number
    BYTE   byDir;        //Direction
    BYTE   byDetectType;    //Detect type 1-coil 2-video trigger 3-Multi frame identification 4-radar trigger
    BYTE   byRes1;           //
    DWORD  dwChannel; //channel number
    NET_DVR_SYSTEM_TIME     struStartTime;        //Starttime
    DWORD  dwSamplePeriod;    //Sample period,second
    NET_ITS_TRAFFIC_DRIVE_CHAN    struDriveChan[6];         //Drive channel data
    BYTE   byRes2[24];     //
}NET_ITS_TRAFFIC_COLLECT, *LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //Configuration mode, 0- terminal, 1-front end(Directly connect to front-end or terminal connect to the front end)
    BYTE  byPicModeType;//0-Said Small map,1-Said Big map
    /*
    0 MPR Mode
    1 Hvt Mode
    */
    BYTE  byRelateType;
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;

typedef enum ITS_OVERLAP_ITEM_TYPE
{
    OVERLAP_ITEM_NULL = 0,              //0-Unknown
    OVERLAP_ITEM_SITE,                //1-Location
    OVERLAP_ITEM_ROADNUM,             //2-Road Cross No.
    OVERLAP_ITEM_INSTRUMENTNUM,       //3-Device No.
    OVERLAP_ITEM_DIRECTION,           //4-Direction No.
    OVERLAP_ITEM_DIRECTIONDESC,       //5-Direction
    OVERLAP_ITEM_LANENUM,             //6-Lane No.
    OVERLAP_ITEM_LANEDES,             //7-Lane
    OVERLAP_ITEM_CAPTIME,             //8-Captured time(without ms)
    OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-Captured time(with ms)
    OVERLAP_ITEM_PLATENUM,            //10-License plate number
    OVERLAP_ITEM_CARCOLOR,            //11-Vehicle color
    OVERLAP_ITEM_CARTYPE,             //12-Vehicle type
    OVERLAP_ITEM_CARBRAND,            //13-Car brand
    OVERLAP_ITEM_CARSPEED,            //14-Speed
    OVERLAP_ITEM_SPEEDLIMIT,          //15-Speed limit sign
    OVERLAP_ITEM_CARLENGTH,           //16-Vehicle length: 1~99m
    OVERLAP_ITEM_ILLEGALNUM,          //17-Illegal code(generally it will be not used, it should overlay illegal information, such as normal, low speed, overspeed, retrograde, running red lights, lane and pressure the yellow line)
    OVERLAP_ITEM_MONITOR_INFO,        //18-Vehicle length
    OVERLAP_ITEM_ILLEGALDES,          //19-Illegal action
    OVERLAP_ITEM_OVERSPEED_PERCENT,      //20-Over-speed ratio
    OVERLAP_ITEM_RED_STARTTIME,       //21-Red light start time
    OVERLAP_ITEM_RED_STOPTIME,          //22-Red light stop time
    OVERLAP_ITEM_RED_DURATION,        //23-Red light on time
    OVERLAP_ITEM_SECUNITY_CODE,          //24-Anti-counterfeiting code
    OVERLAP_ITEM_CAP_CODE,              //25-Capture No.  
    OVERLAP_ITEM_SEATBELT,              //26-SeatBelt  
    OVERLAP_ITEM_MONITOR_ID,          //27-Monitor Id
    OVERLAP_ITEM_SUN_VISOR,           //28-Sun Visor 
    OVERLAP_ITEM_LANE_DIRECTION,       //29-Lane Direction
    OVERLAP_ITEM_LICENSE_PLATE_COLOR,  //30-Plate Color
    OVERLAP_ITEM_SCENE_NUMBER,  //31-Scene Number
    OVERLAP_ITEM_SCENE_NAME,   //32-Scene Name
    OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-yellow Sign Car
    OVERLAP_ITEM_DANGEROUS_CAR,    //34-dangerous Car
    OVERLAP_ITEM_CAR_SUBBRAND,  //35-Car Sub Brand
    OVERLAP_ITEM_CAR_DIRECTION,  //36-Car Direction
    OVERLAP_ITEM_PENDANT,  //37-Pendant
    OVERLAP_ITEM_CALL,  //38-Call
    OVERLAP_ITEM_CAR_VALIDITY,  //39-validity
    OVERLAP_ITEM_CAR_COUNTRY,       //40-Country
    OVERLAP_ITEM_CAR_PLATE_TYPE,    //41-Plate Type
    OVERLAP_ITEM_CAR_PLATE_SIZE,		//42-Plate Size
    OVERLAP_ITEM_CAR_PLATE_COLOR,		//43-Plate Color
    OVERLAP_ITEM_CAR_PLATE_CATEGORY,		//44-Plate Category
    OVERLAP_ITEM_ACCIDENT,  //45-accident
    OVERLAP_ITEM_SMOKING,  //46-smoking
    OVERLAP_ITEM_HELMET, //47-wear helmet
    OVERLAP_ITEM_MANNED, //48-manned
    OVERLAP_ITEM_HUMAN, //49-human attr
    OVERLAP_ITEM_PLAYMOBILEPHONE, //50-play mobile phone
    OVERLAP_ITEM_ADR //51- ADR
}ITS_OVERLAP_ITEM_TYPE;

//Single item of character overlay
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                 // String length for text overlaying
    BYTE byItemType;               //Item type, see to OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //Line numbers after overlay item[0-10](default: 0)
    BYTE bySpaceNum;                   //Line numbers after overlay item[0-255](default: 0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //Enable Pos
    WORD wStartPosTop;    //Start Top Pos [0~2448]
    WORD wStartPosLeft;    //Start Left Pos [0~2448]
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //Single string parameter
    DWORD dwLinePercent;  //Overlay percentage(0~100),(default: 100)
    DWORD dwItemsStlye;   //Overlay style: 0- horizontal,1- vertical, (default: horizontal)
    WORD wStartPosTop;    //The starting top coordinate, only effective for the internal overlay of picture[0~2448](default:0)
    WORD wStartPosLeft;   //The starting left coordinate,only effective for the internal overlay of picture[0~2448](default:0)
    WORD wCharStyle;    //Font type: 0- Times New Roman,1- (default)
    WORD wCharSize;     //Font size: 0--16x16,1--32x32,2-48x48,3--64x64 (default)
    WORD wCharInterval;    //Character spacing: [0~16],unit: pixel(default)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB; //foreground color RGB value: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00FFFFFF- white)
    DWORD dwBackClorRGB; //Background color RGB value, only effective for the extra overlay of picture: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00000000- black)
    BYTE  byColorAdapt;     //Color self-adaption: 0- no, 1- yes
    //(Ver3.7 )
    // Param Fill Zero Enble 0-Fill Zero , 1-Not Fill Zero 
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// Plate small overlay the upper left corner of the 0- don't stack, 1- stack
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //Picture Start Top Pos [0~2448]
    WORD  wStartSPicPosLeft; //Picture Start Left Pos [0~2448]
    //OSD stack location 0- picture, 1- picture on the edge, 2- image edge (synthetic map of the special is the edge)(V3.7)
    BYTE       byOsdLocate;
    BYTE         byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

//Overlay specified info
typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //Location description
    BYTE byRoadNum[32];  //Road Cross No.
    BYTE byInstrumentNum[32];                //Device No.
    BYTE byDirection[32];        //Direction No.
    BYTE byDirectionDesc[32];    //Direction
    BYTE byLaneDes[32];        //Lane description
    BYTE byRes1[32];     //
    BYTE byMonitoringSite1[44];        //Camera 1 info
    BYTE byMonitoringSite2[32];        //Camera 2 info
    BYTE byRes[64];        //Reserved
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //Enable or not: 0- no, 1- yes
    BYTE byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM        struOverLapItem; //String parameters
    NET_ITS_OVERLAP_INFO_PARAM     struOverLapInfo;  //String content info
    BYTE byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

//Single item of character overlay
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                 // String length for text overlaying
    BYTE byItemType;               //Item type, see to OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //Line numbers after overlay item[0-10](default: 0)
    BYTE bySpaceNum;                   //Line numbers after overlay item[0-255](default: 0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //Enable Pos
    WORD wStartPosTop;    //Start Top Pos [0~2448]
    WORD wStartPosLeft;    //Start Left Pos [0~2448]
    BYTE byItemTypeCustom[32];   //Custom Item Type
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //Single string parameter
    DWORD dwLinePercent;  //Overlay percentage(0~100),(default: 100)
    DWORD dwItemsStlye;   //Overlay style: 0- horizontal,1- vertical, (default: horizontal)
    WORD wStartPosTop;    //The starting top coordinate, only effective for the internal overlay of picture[0~2448](default:0)
    WORD wStartPosLeft;   //The starting left coordinate,only effective for the internal overlay of picture[0~2448](default:0)
    WORD wCharStyle;    //Font type: 0- Times New Roman,1- (default)
    WORD wCharSize;     //Font size: 0--16x16,1--32x32,2-48x48,3--64x64 (default)
    WORD wCharInterval;    //Character spacing: [0~16],unit: pixel(default)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB; //foreground color RGB value: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00FFFFFF- white)
    DWORD dwBackClorRGB; //Background color RGB value, only effective for the extra overlay of picture: bit0-1:(B) bit2-3:(G) bit4-5:(G) (default: x00000000- black)
    BYTE  byColorAdapt;     //Color self-adaption: 0- no, 1- yes
    //(Ver3.7 )
    // Param Fill Zero Enble 0-Fill Zero , 1-Not Fill Zero 
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// Plate small overlay the upper left corner of the 0- don't stack, 1- stack
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //Picture Start Top Pos [0~2448]
    WORD  wStartSPicPosLeft; //Picture Start Left Pos [0~2448]
    //OSD stack location 0- picture, 1- picture on the edge, 2- image edge (synthetic map of the special is the edge)(V3.7)
    BYTE       byOsdLocate;
    BYTE         byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //Enable or not: 0- no, 1- yes
    BYTE byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM_V50        struOverLapItemV50; //String parameters
    NET_ITS_OVERLAP_INFO_PARAM             struOverLapInfo;  //String content info
    BYTE byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;


#define  MAX_PTZCRUISE_POINT_NUM   32   //Maximum support of 32 cruise points


typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum;
    DWORD dwGroupNum;
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;


typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO;
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;


typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex;
    NET_VCA_POINT struVcaPoint;
    WORD wZoomCoordinate;
    BYTE  byRes[30];
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum;
    DWORD dwGroupNum;
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO;
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;


typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex;
    NET_VCA_POINT struVcaPoint;
    BYTE    byDwell;
    BYTE    bySpeed;
    WORD  wZoomCoordinate;
    BYTE   byRes[28];
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute;
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM];
    BYTE  byRes[32];
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;


typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize;
    BYTE byEnableTrack;
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;


typedef struct tagNET_DVR_DAY_SCHEDULE
{
    BYTE byWorkMode;            //0-open all day,1-close all day,2-time
    BYTE byRes1[3];
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];
    BYTE byRes2[8];
}NET_DVR_DAY_SCHEDULE, *LPNET_DVR_DAY_SCHEDULE;

typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD    dwSize;
    BYTE     byEnableTrack;            //0-disable,1-enable
    BYTE    byRes1[3];
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];
    BYTE    byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG, *LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD    dwSize;
    BYTE    sStreamID[STREAM_ID_LEN/*32*/]; //stream ID
    DWORD    dwChan;                     //channel no
    BYTE    byStreamType;             //0-main stream,1-sub stream,2-stream 3,3-stream 4,4-stream5     
    BYTE    byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;


/*************************************ITS end****************************/

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //date,1 to 7 represent Monday to Sunday
    BYTE byHour;   //hour
    BYTE byMinute; //minute
    BYTE byRes1;
    BYTE byRebootMode; //reboot mode, 0-by week,1-by month(only for getting, cannot be set)
    BYTE byDisabled; // 0-enable 1-disable
    BYTE byRes[10];
}NET_DVR_REBOOT_TIME, *LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG, *LPNET_DVR_AUTO_REBOOT_CFG;

/*************************************MVA 2.1 begin****************************/
#define NET_DVR_GPS_FINDING       0   //finding
#define NET_DVR_GPS_RECV          1   //receive data
#define NET_DVR_GPS_OVER          2   //finding finish
#define NET_DVR_GPS_EXCEPTION     3   //receive exception
typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD        dwSize;
    BYTE        byMenuOutputMode; //menu output mode. not homologous device:0-Auto 1-main CVBS 2-HDMI 3-VGA homologous device:0-Auto 1-main CVBS 2-HDMI/VGA
    BYTE        byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP address
    WORD        wPort;   //port
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR, *LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //pu id
    BYTE byPassword[PASSWD_LEN];  //password
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //pu id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{
    DWORD dwSize;
    BYTE byNetEnvironment;/*network,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*current platform,0 - WVS, 1 - E home, 2 - CMS */
    BYTE byRes1[2];
    NET_DVR_MB_WVSPARA  struWVSPara; /*WVS platform parameter*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E home platform parameter */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE        byGPSModule;      /*gps module, 0: not exist, 1: normal*/
    BYTE        byPositionStatus;      /*gps position status, 0: fail, 1: success*/
    BYTE        bySignalStrength;    /*signal strength, 0: weak, 1: normal, 2: good*/
    BYTE        byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE        byGsensorModule;    /*g-sensor module, 0: not exist, 1 build-in: , 2: external*/
    BYTE        byCurAccX[10];     /*current acceleration of X*/
    BYTE        byCurAccY[10];    /*current acceleration of Y*/
    BYTE        byCurAccZ[10];    /*current acceleration of Z*/
    BYTE        byRefAccX[10];    /* reference acceleration of X*/
    BYTE        byRefAccY[10];    /* reference acceleration of Y*/
    BYTE        byRefAccZ[10];    /* reference acceleration of Z*/
    BYTE        byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

#define IP_ADDR_LEN         16
#define IW_ESSID_MAX_SIZE    32

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE        byEnableWiFi; /* WIFI, 0 off, 1 on */
    BYTE         byWiFiConnectStatus;  /* WIFI status, 0: fail to connect, 1: connect success 2: no module*/
    BYTE        bySignalStrength;             /* signal strength, 0 weak, 1 normal, 2 good */
    BYTE        byIPaddress[IP_ADDR_LEN];   /*WIFI device ip*/
    BYTE        byEssid[IW_ESSID_MAX_SIZE];  /*AP essid*/
    BYTE        byres[5];
}NET_DVR_MB_WIFI_STATUS, *LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE        byCurPlat;      /*current platform, 0: wvs, 1: ivms, 2: CMS*/
    BYTE        byLoginStatus;     /*login status, 0: login failed, 1: login success*/
    BYTE        byExceptionInfo;      /*exception*/
    /*
    WVS :exception info:
    0: fail to connect server
    1: logining
    2: user name or password error
    3: time out
    4: no heartbeat
    5: success
    iVMS :exception info:
    0: not login
    1: logining
    2: fail to connect
    3: heart beat timeout
    4: connection break
    5: New registration
    6: max device number in CMS
    7: max channel number in CMS
    8: no configuration in web management center
    9: communication to CMS and WEB management center error
    10:login unknown error
    11:login success
    CMS  :exception info:
    0: not login
    1: logining
    2: Duplicate registration
    3: connect fail
    4: server IP change
    5: login success
    6: logput
    7: heart beat timeout
    */
    BYTE        byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;


typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD        dwSize;
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

#define NET_DVR_GPS_STATUS       0
#define NET_DVR_GSENSOR_STATUS   1
#define NET_DVR_WIFI_STATUS      2
#define NET_DVR_PLATFORM_STATUS  3


typedef struct tagNET_DVR_GPS_INFO
{
    BYTE    byDirection[2];        /*direction[0]0or1(east longitude/west longitude), direction[1]:0or1(North latitude/south latitude)  */
    BYTE    bySvs;         /* satellite vehicles:Effective Satellite number */
    BYTE    byLocateMode;  /* location mode:only NMEA0183 3.00 version,0=auto,1=Differential,2=Estimate,3= Invalid data*/
    WORD    wHDOP;  /* horizontal accuracy,0.5-99.9,below 6 represent high accuracy,above 20 need to be abandoned,this value is multipled by 10 */
    WORD    wHeight;             /* height */
    DWORD   dwLatitude;     /*latitude = degree*3600*100+branch*60*100+second*100 */
    DWORD   dwLongitude; /*longitude =degree*3600*100+branch*60*100+second*100 */
    DWORD   dwVehicleSpeed;        /* mobile speed =speed*100000 kph*/
    DWORD    dwVehicleDirection;    /* mobile direction= actual direction*100,colockwise from North, uint:degree */
    BYTE    byRes[8];
}NET_DVR_GPS_INFO, *LPNET_DVR_GPS_INFO;

//GPS status upload
typedef  struct _NET_DVR_GPS_STATUS_ALARM_
{
    DWORD       dwSize;
    NET_DVR_TIME_V30   struGPSTime;      //GPS sampling time, use the local time 
    NET_DVR_GPS_INFO   struGPSInfo;      //GPS coordinate point
    BYTE         byRetransFlag; //0 - this GPS real-time package; 1 - this GPS as heavy package 
    BYTE         byNeedsResponse; //Response to tag, 0: does not need to respond to pack, 1: need to response to the package 
    BYTE         byType;//Report type 0 - unmanned aerial vehicle (uav) 
    BYTE         byBatteryRemaining;//Battery:-1 ~ 100; -1 said wrong
    int        iRollAngle;//Roll Angle, range - PI - + PI, the actual value * 100 
    int        iPitchAngle;//Pitch Angle, range - PI - + PI, the actual value * 100 
    WORD        wRelativeHeight;//Relative height, unit: cm  
    WORD        wVerticalSpeed;//Vertical speed, unit: cm/h 
    BYTE         byRes2[160];
}NET_DVR_GPS_STATUS_ALARM, *LPNET_DVR_GPS_STATUS_ALARM;

typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS point
    NET_DVR_TIME      struTime;            //GPS point time
    BYTE        byRes[12];
}NET_DVR_GPS_DATA, *LPNET_DVR_GPS_DATA;


typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{
    DWORD dwCmdType;              //0-find by time segment,1-find by time point    
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //start time       
            NET_DVR_TIME struEndTime;                 //end time
            DWORD dwInterval;                  //interval,unit: second
            BYTE  byRes[76];
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //time point
            BYTE  byRes[104];
        }TimePoint;
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM, *LPNET_DVR_GET_GPS_DATA_PARAM;

#define NET_SDK_MAX_CARD_LEN 32 //Maximum length of card number

//Tag Information Upload
typedef  struct _NET_DVR_TAG_INFO_ALARM_
{
    DWORD        dwSize;
    BYTE         byCardNo[NET_SDK_MAX_CARD_LEN/*32*/]; //card No.
    int          iRssi;//The received signal strength, range -100 - +100 
    BYTE         byIndexCode[64];//index code, just like device id
    NET_DVR_TIME_V30  struAcquisitionTime;//acquistion time
    BYTE         byRFIDInfo[32]; //RFID infomation
    BYTE         byRFIDInfoLen;  //RFID infomation length
    BYTE         byVoltageLow; //1-low power, 0-normal power
    BYTE         byAlarmFlag; //1-need, 0-do not need
    BYTE         byRes[49];         //res
}NET_DVR_TAG_INFO_ALARM, *LPNET_DVR_TAG_INFO_ALARM;

/*************************************MVA 2.1 end****************************/
typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE    byEnableAbilityParse;    //use ability parse,0-not use,1-use,default 0
    BYTE    byVoiceComMode;          //Voice Intercom Mode ,1-Use Windows Api( linux ,mac not support),0-Use VoiceIntercom library(default);
    BYTE    byLoginWithSimXml;  //use simulate ability in login,0-not use,1-use,default 0
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE    byProtectKey[128];    //default 0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;


typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE    byEnableAbilityParse;
    BYTE    byRes[127];
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE    byTalkMode;
    BYTE    byRes[127];
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;


typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE    byProtectKey[128];
    BYTE    byRes[128];
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //use simulate in login,0-no,1-yes
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;

//Alarm callback configuration parameters.
typedef struct
{   /* control the JSON format of the JSON transparent call (i.e., COMM_VCA_ALARM).
    0~ new JSON format;
    1~ old JSON format.
    */
    BYTE byVcaAlarmJsonType;
    BYTE byRes[63];
}NET_DVR_MESSAGE_CALLBACK_PARAM_V51,
*LPNET_DVR_MESSAGE_CALLBACK_PARAM_V51;

typedef enum tagNET_SDK_LOCAL_CFG_TYPE
{
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,        //NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,            //NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,                //NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,        //NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,            //NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,                //NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,                //NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,              //configuration version. test device.
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,                //Rtsp params config, NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            //NET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                //NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  //local security config,
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            //EZVIZLIB path config
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               //13.char encode type config
    NET_SDK_LOCAL_CFG_TYPE_PROXYS,                     //get the proxy server info
    NET_DVR_LOCAL_CFG_TYPE_LOG,                       //SDK Log Configuration
    NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK,           //Stream CallBack Configuration NET_DVR_LOCAL_STREAM_CALLBACK_CFG
    NET_DVR_LOCAL_CFG_TYPE_GENERAL,                   //NET_DVR_LOCAL_GENERAL_CFG
    NET_DVR_LOCAL_CFG_TYPE_PTZ,
    NET_DVR_LOCAL_CFG_MESSAGE_CALLBACK_V51,           /*The alarm V51 callback is related to the local configuration,
                                                      and the corresponding structure is NET_DVR_MESSAGE_CALLBACK_PARAM_V51.
                                                      (only valid for the version NET_DVR_SetDVRMessageCallBack_V51 and above)*/
    NET_SDK_LOCAL_CFG_CERTIFICATION,                  //NET_DVR_LOCAL_CERTIFICATION
    NET_SDK_LOCAL_CFG_PORT_MULTIPLEX,                 //Port multiplexing,struct:NET_DVR_LOCAL_PORT_MULTI_CFG
    NET_SDK_LOCAL_CFG_ASYNC,                 //asynchronous configuration,struct:NET_DVR_LOCAL_ASYNC_CFG
    NET_SDK_P2P_LOGIN_2C,
    NET_SDK_P2P_LOGIN_2B,
    NET_SDK_P2P_LOGOUT
}NET_SDK_LOCAL_CFG_TYPE;

typedef enum tagNET_SDK_EXCEPTION_CALLBACK_TYPE
{
    NET_SDK_EXCEPTION_CALLBACK_BY_POOL = 0,         //callback by pool
    NET_SDK_EXCEPTION_CALLBACK_DIRECTLY = 1,        //callback directly
}NET_SDK_EXCEPTION_CALLBACK_TYPE;

typedef struct tagNET_DVR_LOCAL_GENERAL_CFG
{
    BYTE     byExceptionCbDirectly;    //0-callback by pool,1-callback directly
    BYTE     byNotSplitRecordFile;     //0-split record,1-not split
    BYTE     byResumeUpgradeEnable;    //resume upgrade enable,0-disable(default),1-enable
    BYTE     byAlarmJsonPictureSeparate;   //Control whether the JSON transmitted alarm data and images are separated, 0-not separated, 1-separated (COMM_ISAPI_ALARM callback is returned after separation)
    BYTE     byRes[4];
    UINT64   i64FileSize;              //file size:Byte
    DWORD    dwResumeUpgradeTimeout;   //resume upgrade reconnect timeout,ms
    BYTE     byAlarmReconnectMode;          
    BYTE     byStdXmlBufferSize;       //Receive buffer size of ISAPI transparent transparent  1-1M other-default 
    BYTE     byMultiplexing;           //0-general link(not TLS)not using byMultiplexing1-general link(not TLS)using byMultiplexing
    BYTE     byFastUpgrade;           //0-normal upgrade, 1-fast upgrade
    BYTE     byRes1[232];
}NET_DVR_LOCAL_GENERAL_CFG, *LPNET_DVR_LOCAL_GENERAL_CFG;

typedef struct tagNET_SDK_P2P_SERVER_2C
{
    BYTE   byPlatformType;
    BYTE   byRes1[3];
    char   *pAppID;
    char   *pAuthAddr;
    char   *pPlatformAddr;
    char   *pUserName;
    char   *pPassword;
    BYTE byRes[40];
} NET_SDK_P2P_SERVER_2C, *LPNET_DVR_P2P_SERVER_2C;

typedef struct tagNET_SDK_P2P_SERVER_2B
{
    BYTE   byPlatformType;
    BYTE   byRes1[3];
    char   *pAppID;
    char   *pAuthAddr;
    char   *pPlatformAddr;
    char   *pToken;
    BYTE byRes[44];
} NET_SDK_P2P_SERVER_2B, *LPNET_DVR_P2P_SERVER_2B;

typedef struct tagNET_DVR_LOCAL_STREAM_CALLBACK_CFG
{
    BYTE     byPlayBackEndFlag;                         //0- Not CallBack PlayBack EndFlag,1-CallBack PlayBack EndFlag
    BYTE     byRes[255];
}NET_DVR_LOCAL_STREAM_CALLBACK_CFG, *LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG;

typedef void(CALLBACK *LOGCALLBACK)(char *pContent, unsigned int dwInputLen, int wLogLevel, void *pData);

typedef struct tagNET_DVR_LOCAL_LOG_CFG
{
    WORD    wSDKLogNum;      //Default number 0 (meaning 10 logs) in SDK override mode
    LOGCALLBACK    fnCB;        //Log callback function
    void    *pUserData;        //User's pointer
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))      //win64 or linux64 pointers are 8 bytes
    BYTE    byRes[238];      //Reserve
#else
    BYTE    byRes[246];      //Reserve
#endif  
}NET_DVR_LOCAL_LOG_CFG, *LPNET_DVR_LOCAL_LOG_CFG;

typedef int(CALLBACK * CHAR_ENCODE_CONVERT)(char * pInput, DWORD dwInputLen, DWORD dwInEncodeType, char *pOutput, DWORD dwOutputLen, DWORD dwOutEncodeType);

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;       //communication mode, //0-compatibility mode,1-security mode (MD5)2-security mode(RSA)
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD    wLocalBindTcpMinPort;
    WORD    wLocalBindTcpMaxPort;
    BYTE    byRes[60];
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD    wLocalBindUdpMinPort;
    WORD    wLocalBindUdpMaxPort;
    BYTE    byRes[60];
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD    dwAlarmMaxBlockNum;
    DWORD    dwAlarmReleaseInterval;
    DWORD   dwObjectReleaseInterval;
    BYTE    byRes[508];
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef  struct  tagNET_DVR_OPTICAL_CHANNEL_BIND
{
    WORD wChannelIndex;    //optical port num(0-7)
    WORD wSubChannel;      //sub optical channel,get value range from ability set
    BYTE  byBind;      //0-not bind,1-bind
    BYTE  byRes[3];
}NET_DVR_OPTICAL_CHANNEL_BIND, *LPNET_DVR_OPTICAL_CHANNEL_BIND;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD        dwPreviewTime;        //Preview module timeout
    DWORD        dwAlarmTime;            //alarm module timeout
    DWORD        dwVodTime;            //playback timeout
    DWORD        dwElse;                    //other module timeout
    BYTE        byRes[512];                            //res
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

#define MAX_CERTIFICATE_ISSUER_LEN      64     
#define MAX_CERTIFICATE_VALIDITY_LEN    128    
#define MAX_CERTIFICATE_SUBJECT_LEN     64     
typedef struct  tagNET_DVR_CETTIFICATE_INFO
{
    DWORD dwSize;
    char szIssuer[MAX_CERTIFICATE_ISSUER_LEN];                       
    char szSubject[MAX_CERTIFICATE_SUBJECT_LEN]; 
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byRes1[1024];
}NET_DVR_CETTIFICATE_INFO, *LPNET_DVR_CETTIFICATE_INFO;

typedef BOOL(CALLBACK *fnCertVerifyResultCallBack) (DWORD uiResult, LPNET_DVR_CETTIFICATE_INFO lpCertificateInfo, char *pUserData);

#define MAX_FILE_PATH_LEN       256     //length of file name
typedef struct tagNET_DVR_LOCAL_CERTIFICATION
{
    char szLoadPath[MAX_FILE_PATH_LEN];
    fnCertVerifyResultCallBack fnCB;
    void* pUserData;
    BYTE byRes[64];
}NET_DVR_LOCAL_CERTIFICATION, *LPNET_DVR_LOCAL_CERTIFICATION;

typedef struct tagNET_DVR_LOCAL_PORT_MULTI_CFG
{
    BOOL    bEnable;                //enabled,true-open
    BYTE    byRes[60];
}NET_DVR_LOCAL_PORT_MULTI_CFG, *LPNET_DVR_LOCAL_PORT_MULTI_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD    dwMaxBuffRoomNum;    //max buffer num
    BYTE    byUseSort;    //rtp over udp sort, 0-disable  1-enable
    BYTE    byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;

typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//video binding configuration
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//audio binding configuration
    BYTE  byRes[16];
}NET_DVR_OPTICAL_CHANNEL_CFG, *LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//code subsystem slot num
    BYTE  byChannel; //code channel num
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO, *LPNET_DVR_OPTICAL_INFO;

//audio switch
typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //audio status,1-on,0-off
    BYTE  byRes1[3];
    //byStatus == 1 valid
    DWORD dwSubWinNum; //related sub window number
    DWORD dwSurChanNum;             /*device channel number */
    NET_DVR_IPADDR struIpaddr;            /*device ip address */
    WORD   wPort;                          /*device port */
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

//ethernet channel
#define MAX_ETHERNET_PORT_NUM       8//max port number in one link
typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j represents add port i to link j,j's value range is 1-8,j = 0 means delete port i from the link
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO, *LPNET_DVR_ETHERNET_CHANNEL_INFO;
//spartan
typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-off,1-on
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO, *LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //enable,0-no,1-yes
    BYTE byFilterType; //filter type,0-forbit,1-permit
    BYTE byRes1[2];
    BYTE byRes[16];
    BYTE byIPAddr[1024];    //IP address,for 192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable,0-no,1-yes
    BYTE  byRes1[3];
    DWORD dwCoordinateX;    //X coordinate
    DWORD dwCoordinateY;    //Y coordinate
    WORD  wPicWidth; //width
    WORD  wPicHeight; //height
    BYTE  byLogoName[16];//Logo name
}NET_DVR_LOGO_OVERLAYCFG, *LPNET_DVR_LOGO_OVERLAYCFG;


typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // Disk number
    BYTE                byDelAll;            // 0-Delete dwDiskNo  1-Delete all
    BYTE                 byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;


typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // Disk number
    BYTE                 byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;

typedef void (CALLBACK *fLoginResultCallBack) (LONG lUserID, DWORD dwResult, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo, void* pUser);

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64

typedef struct
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byUseTransport;
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType;
    BYTE byUseUTCTime;
    BYTE byLoginMode; //0-Private 1-ISAPI 2-adapt
    BYTE byHttps;     //0-tcp,1-tls 2-adapt
    LONG iProxyID;
    BYTE byVerifyMode;  
    BYTE byRes3[119];
}NET_DVR_USER_LOGIN_INFO, *LPNET_DVR_USER_LOGIN_INFO;

// Long config callback type
typedef enum
{
    NET_SDK_CALLBACK_TYPE_STATUS = 0,        // Status
    NET_SDK_CALLBACK_TYPE_PROGRESS,            // Progress
    NET_SDK_CALLBACK_TYPE_DATA                // Data
}NET_SDK_CALLBACK_TYPE;


// Long config status value
typedef enum
{
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,        // Success
    NET_SDK_CALLBACK_STATUS_PROCESSING,            // Processing
    NET_SDK_CALLBACK_STATUS_FAILED,                // Failed
    NET_SDK_CALLBACK_STATUS_EXCEPTION,            // Exception
    NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,    // Language mismatch
    NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,    // Device type mismatch
    NET_DVR_CALLBACK_STATUS_SEND_WAIT,           // send wait
}NET_SDK_CALLBACK_STATUS_NORMAL;

//The following is a key configuration failure status code ---part1 
#define NET_SDK_OKC_STATUS_SUCCESS                1000  
#define NET_SDK_OKC_STATUS_FAILED                1002  
#define NET_SDK_OKC_STATUS_START_CONFIG            1003  
#define NET_SDK_OKC_CHECK_HD                    1004 
#define NET_SDK_OKC_INIT_HD                        1005  
#define NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK    1006 
#define NET_SDK_OKC_INIT_CVR_SERVICE            1007  
#define NET_SDK_OKC_CREATE_RECORD_VOLUME        1008
#define NET_SDK_OKC_ERR_LOAD_CONF_FAILED              1009 
#define NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE        1010  
#define NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT          1011 
#define NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED          1012 
#define NET_SDK_OKC_ERR_CHECK_DISK_FAILED             1013 
#define NET_SDK_OKC_ERR_INIT_DISK_FAILED              1014 
#define NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL           1015 
#define NET_SDK_OKC_ERR_BOTH_SV_NS                    1016 
#define NET_SDK_OKC_ERR_CREATE_RAID_FAILED            1017 
#define NET_SDK_OKC_ERR_GET_RAID_FAILED               1018 
#define NET_SDK_OKC_ERR_CREATE_SPARE_FAILED           1019 
#define NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED    1020
#define NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED          1021 
#define NET_SDK_OKC_ERR_CREATE_LUN_FAILED             1022 
#define NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED           1023 
#define NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED          1024 
#define NET_SDK_OKC_ERR_GET_BACKUP_FAILED                1025 
#define NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED        1026 
#define NET_SDK_OKC_ERR_CREATE_RV_FAILED              1027 
#define NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED         1028 
#define NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED      1029 

//One key configuration state of SAN 
#define NET_SDK_OKC_CREATING_ARRAY                    1030  
#define NET_SDK_OKC_CREATING_STORAGE_POOL            1031  
#define NET_SDK_OKC_CREATING_LUN_VOL                1032 
#define NET_SDK_OKC_CREATING_ISCSI                    1033 
#define NET_SDK_OKC_ERR_HOT_SPARE_CONFICT            1034 
#define NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT        1035  
#define NET_SDK_OKC_ERR_RAID_CONFLICT               1036 //System already exists array  
#define NET_SDK_OKC_ERR_OPEN_ISCSI_FAILED           1037 //Open the ISCSI failure 
#define NET_SDK_OKC_ERR_DEVICE_NOSUPPORT_SAN        1038 //The device does not support the SAN 

//The following is a key configuration failure status code ---part2
#define NET_SDK_OKC_ERR_SAPRE_NUM_EXCEED            1101    //Hot plate number too much 
#define NET_SDK_OKC_ERR_CREATE_PIC_VOLUME_FAILED    1102    //Failed to create image volumes 

typedef enum
{
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,    // Get data successfully, Call API NET_DVR_RemoteConfigGetNext after processing this data.
    NET_SDK_GET_NETX_STATUS_NEED_WAIT,        // Need wait, keep calling NET_DVR_RemoteConfigGetNext
    NET_SDK_GET_NEXT_STATUS_FINISH,            // Get data finish, call API NET_DVR_StopRemoteConfig
    NET_SDK_GET_NEXT_STATUS_FAILED,            // Get data failed, call API NET_DVR_StopRemoteConfig
}NET_SDK_GET_NEXT_STATUS;

typedef enum
{
    NET_SDK_CONFIG_STATUS_SUCCESS = 1000,    // Get data successfully, Call API NET_DVR_SendWithRecvRemoteConfig after processing this data.
    NET_SDK_CONFIG_STATUS_NEEDWAIT,          // Need wait, keep calling NET_DVR_SendWithRecvRemoteConfig
    NET_SDK_CONFIG_STATUS_FINISH,            // Get data finish, call API NET_DVR_StopRemoteConfig
    NET_SDK_CONFIG_STATUS_FAILED,            // Get data failed, Call API NET_DVR_SendWithRecvRemoteConfig process nexts
    NET_SDK_CONFIG_STATUS_EXCEPTION,         // Get data exception, call API NET_DVR_StopRemoteConfig
}NET_SDK_SENDWITHRECV_STATUS;


typedef enum tagNET_SDK_IPC_CFG_FILE_ERR_CODE
{
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,
    NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID
}NET_SDK_IPC_CFG_FILE_ERR_CODE;

typedef enum
{
    NET_SDK_UPGRADE_IPC_INVALID = 0,
    NET_SDK_UPGRADE_IPC_SUCCESS,
    NET_SDK_UPGRADE_IPC_OFFLINE,
    NET_SDK_UPGRADE_IPC_NOT_SUPPORT,
    NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,
    NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,
    NET_SDK_UPGRADE_IPC_OTHER_ERROR
}NET_SDK_UPGRADE_IPC_ERR_CODE;

typedef enum
{
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,
    NET_SDK_REMOTE_CONFIG_STATUS_FAILED,
    NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING
}NET_SDK_REMOTE_CONFIG_STATUS;

/*************************************coder server start****************************/
#define MAX_CODE_CARD_SUPPORTDISPNUMS 8//max support display channel for one card
#define MAX_SUPPORT_RES 32

typedef enum _BOARD_TYPE
{
    DS4004HC_BOARD = 2,  //4004HC
    DS4008HC_BOARD = 3,  //4008HC
    DS4016HC_BOARD = 4,  //4016HC
    DS4001HF_BOARD = 5,  //4001HF
    DS4004HF_BOARD = 6,  //4004HF
    DS4002MD_BOARD = 7,  //4002MD
    DS4004MD_BOARD = 8,  //4004MD
    DS4016HCS_BOARD = 9,  //4016HCS
    DS4004HC_PLUS_BOARD = 13, //4004HC+
    DS4008HC_PLUS_BOARD = 14, //4008HC+
    DS4016HC_PLUS_BOARD = 15, //4016HC+
    DS4008HF_BOARD = 16, //4008HF
    DS4008MD_BOARD = 17, //4008MD
    DS4008HS_BOARD = 18, //4008HS
    DS4016HS_BOARD = 19, //4016HS

    DS4108HCV_BOARD = 20, //4108HCV
    DS4116HCV_BOARD = 21, //4116HCV
    DS5016HC_BOARD = 22, //5016HC

    DS4208HFV_BOARD = 23, //4208HFV
    DS4216HC_BOARD = 24, //4216HC
    DS4216HFV_BOARD = 25, //4216HFV

    DS5008HF_BOARD = 26, //5008HF
    DS5116HF_BOARD = 27, //5116HF

    DS5216HC_BOARD = 28, //5216HC
    DS5208HF_BOARD = 29, //5208HF
    DS5216HF_BOARD = 30, //5216HF

    DS4101HD_BOARD = 31, //4101HD
    DS4102HD_BOARD = 32, //4102HD
    DS4104HD_BOARD = 33, //4104HD

    DS4002MD_PLUS_BOARD = 34, //4002MD+  
    DS4004MD_PLUS_BOARD = 35, //4004MD+

    DS4204HFV_BOARD = 36, //4204HFV
    DS4308HCV_BOARD = 37, //4308HCV
    DS4308HFV_BOARD = 38, //4308HFV
    DS4316HCV_BOARD = 39, //4316HCV
    DS4316HFV_BOARD = 40, //4316HFV
    DS4304HD_BOARD = 41, //4304HD
    DS4304HFH_BOARD = 42, //4304HFH
    DS4304HFV_BOARD = 43, //4304HFV
    DS4302HFH_BOARD = 44, //4302HFH
    DS5316HF_BOARD = 45, //5316HF
    DS4308HW_BOARD = 46, //4308HW
    DS4316HW_BOARD = 47, //4316HW
    DS4308MD_BOARD = 48, //4308MD
    UNKNOWN_BOARD_TYPE = 0xffffffff,
}BOARD_TYPE;

typedef struct tagNET_DVR_CODECARD_ABILITY
{
    BYTE byCardType;      //code card type(enum BOARD_TYPE)
    BYTE byCodeNums;      //code channel nummber 
    BYTE byDispNums;      //display channel number 
    BYTE byCodeStartIdx;     //fisrt code channel index in all code channels 
    BYTE byDispStartIdx;     //first display channel index in all display channels
    BYTE byRes1[3];
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of VGA
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of HDMI
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of DVI
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//supported resolution of Ypbpr
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //supported display format(enum HD_DISPLAY_FORMAT) 
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //supported window mode(eg. 1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY, *LPNET_DVR_CODECARD_ABILITY;

#define        MAX_CODE_CARD_NUM            8   //max code card number
typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;
    BYTE byCardNums;      /* code card number */
    BYTE byStartChan;     /* start channel number */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;        /*display channel type:0-BNC,1-VGA,2-HDMI,3-DVI*/
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL,0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //resolution
    DWORD  dwWindowMode;        /*window mode*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG, *LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //display channel number
    DWORD  dwCodeChan; //code channel number
    DWORD  dwWinNum;   //window number
    BYTE   byEnableAudio; //enable video,0-disable,1-enable
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO, *LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//display channel number
    DWORD dwWinNum;     //window number
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO, *LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;
    DWORD  dwCodeChan;      /*code channel number*/
    BYTE   byDisplay;        /*enable output,0-disable,1-enable*/
    BYTE   byAudio;            /*enable video,0-disable,1-enable*/
    BYTE   byRes[30];
}NET_DVR_WINDOW_STATUS, *LPNET_DVR_WINDOW_STATUS;

/*************************************coder server end****************************/

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD     dwSize;
    BYTE     byPercentage;        //range [0,100]
    BYTE      byRes[31];          //
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD             dwSize;
    NET_DVR_STREAM_INFO struStreasmInfo;     //Stream ID
    DWORD              dwBeginTime;    //record begin time
    DWORD             dwEndTime;        //record end time
    BYTE              byRes[32];
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwCmdType;                         //Command type
    DWORD                    dwRecordTimeLen;                //Record time,second
    BYTE                    byEventID[MAX_EVENTID_LEN];        //Event ID
    DWORD                    dwLockDuration;                //Lock duration, unit: second, 0xffffffff- permanently locked, 0- unlocked
    BYTE                    byBackUp;                       //Whether archived, 0- not archived, 1- archive
    BYTE                    byPreRecord;                    //Whether pre-recorded, 0- not prerecorded, 1- pre-recorded
    BYTE                    byRes[122];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE                byFileName[NAME_LEN];     // record file name
    DWORD                dwLockDuration;            // duration time 
    BYTE                byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;



typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD                    dwSize;
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwStreamType; //Stream type,0-main stream,1-sub stream,2-event,3-stream 3,-
    BYTE                    byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD                            dwSize;
    DWORD                            dwStreamType;        //Stream type,0-main stream,1-sub stream,2-event,3-stream 3,-
    NET_DVR_COMPRESSION_INFO_V30     struStreamPara;      //copress info
    DWORD                            dwResolution;        //when value less then 255,this value equal with byResolution,when more then 255 this value is the index
    BYTE                             byRes[76];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0- sensor alarm; 1- hard disk full; 2- video lost; 3- motion detection; 4- hard disk unformatted; 5- hard disk error; 6- tampering detection; 7- unmatched video output standard; 8- illegal operation; 9- video exception; 0xa- record exception
                        11- Vca scene change 12-Array exception 13 resolution dismatch*/
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;   /*Alarm input Port*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*State of Alarm output channel, 1- - Triggered*/
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*channels triggered to record, 1- recording,  dwAlarmRelateChannel[0] is the first channel*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; //Stream id
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*If the dwAlarmType is 2, 3 or 6, it stands for channel, dwChannel[0] is the first channel*/
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*When dwAlarmType is 1, 4 or 5,  it stands for Hard Disk,  dwDiskNumber[0] is the first disk*/
            BYTE byDeviceID[NAME_LEN]; /*Device ID*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;
typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    DWORD           dwPackageInterval;    // Packaged interval time     units: min
    BYTE              byRes[32];            // preserve
}NET_DVR_RECORD_PACK, *LPNET_DVR_RECORD_PACK;

/*****************************Netra 2.3***********************************/
//Netra 2.3 2012-10-9 
#define NET_DVR_FIND_NAS_DIRECTORY          6161        //find NAS directory
#define NET_DVR_NAS_FINDING       0   //is finding 
#define NET_DVR_NAS_RECV          1   // recv data
#define NET_DVR_NAS_OVER          2   // find over
#define NET_DVR_NAS_EXCEPTION     3   //Exception 
typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR              struIP;         // IP address
    WORD              wPort;      // IP port
    BYTE                byRes[10];  // preserve
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;


typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // file directory
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD    dwSize;
    WORD    wHttpsPort;  // HTTPS ports
    BYTE    byEnable;    // enable 0:close 1:open
    BYTE    byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE              byWD1Enable;         //WD1 enable   0 close  1 open    
    BYTE                 byRes[31];      //preserve
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;



/*****************************Netra 2.3***********************************/
//Netra 2.3 2012-10-9 







typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE                byEnableFTP;        /* enable ftp , 0-No 1-yes */
    BYTE                byProtocolType;        /*Protocol type 0-FTP,1-SFTP*/
    WORD                wFTPPort;            /*Port*/
    union
    {
        struct
        {
            BYTE            szDomain[64];      //domain name
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;          /*IP Address*/
        }struAddrIP;
    }unionServer;  //IPv4 IPv6 server address or domain name

    BYTE                szUserName[32];        /*User name */
    BYTE                szPassWORD[16];        /*password*/
    BYTE                szTopCustomDir[64];    /*Custom top directory*/
    BYTE                szSubCustomDir[64];    /*Custom sub directory*/
    BYTE                byDirLevel;            /*0 = Do not use the directory structure directly stored in the root directory,
                                              1 = stored in the top directory,2=stored in the sub directory */
    BYTE                 byTopDirMode;        /* Top directory,0x1 = use device name, 0x2 = use device No,0x3 = use device ip,
                                               0x4=use Monitoring points ,0x5=Time (Date)  0x6-Using a custom , 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    BYTE                 bySubDirMode;       /*Sub directory,0x1=use channel name,0x2=use channel number
                                               0x3=use time (Date),0x4=use Lane number 0x5-Using a custom , 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE                byType;                /* 0-Main server,1-reserved server*/
    BYTE                byEnableAnony;      /*use anony 0-no 1-yes*/
    BYTE                byAddresType;        /*0 use IPV4,IPV6  1- use Domain name*/
    /*******************2013-09-27 New parameters begin********************************/
    BYTE                byFTPPicType;        //0-preserve,1-Parking lot to capture the picture naming rules
    BYTE                 byPicArchivingInterval; //Picture Archiving Interval[1~30]
    NET_DVR_PICTURE_NAME_EX     struPicNameRule;/* picture naming rules:
                                                byFTPPicType ==1,Parking lot to capture the picture naming rules*/
    BYTE                byPicNameRuleType;      //Picture Name Rule Type
    BYTE                 byRes[203];          /*preserve*/
    /*******************2013-09-27 New parameters end ********************************/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE    byType;  // 0-main server,1-Spare server
    BYTE    byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

typedef struct
{
    DWORD     dwSize;
    BYTE                byEnableFTP;        /*enable ftp , 0-No 1-yes */
    BYTE                byProtocolType;        /*Protocol type 0-FTP,1-SFTP*/
    WORD                wFTPPort;            /*Port*/
    union
    {
        BYTE byRes[144];
        struct
        {
            BYTE    szDomain[MAX_DOMAIN_NAME];      /*domain name*/
            BYTE    byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;          /*IP Address*/
        }struAddrIP;
    }unionServer;  //IPv4 IPv6 server address or domain name

    BYTE    szUserName[NAME_LEN];        /*User name */
    BYTE    szPassWORD[PASSWD_LEN];        /*password*/
    BYTE    szTopCustomDir[MAX_CUSTOM_DIR];    /*Custom top directory*/
    BYTE    szSubCustomDir[MAX_CUSTOM_DIR];    /*Custom sub directory*/
    BYTE                byDirLevel;            /*0 = Do not use the directory structure directly stored in the root directory,
                                              1 = stored in the top directory,2=stored in the sub directory */
    BYTE                 byTopDirMode;        /* Top directory,0x1 = use device name, 0x2 = use device No,0x3 = use device ip,
                                               0x4=use Monitoring points ,0x5=Time (Date)  0x6-Using a custom , 0x7= type of violation, the direction of 0x8=, 0x9= location*/
    BYTE                 bySubDirMode;       /*Sub directory,0x1=use channel name,0x2=use channel number
                                               0x3=use time (Date),0x4=use Lane number 0x5-Using a custom , 0x6= type of violation, the direction of 0x7=, 0x8= location*/
    BYTE                byType;                /* 0-Main server,1-reserved server*/
    BYTE                byEnableAnony;      /*use anony 0-no 1-yes*/
    BYTE                byAddresType;        /*0 use IPV4,IPV6  1- use Domain name*/

    BYTE    byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

#define NET_SDK_ACCESS_KEY_LEN 64   //Access key length
#define NET_SDK_SECRET_KEY_LEN 64  //Secret key length

typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD    dwSize;
    union
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA    struNtpPara;                    /*NTP server test param 80 bytes*/
            BYTE    byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40    struNasPara;   /*NAS server test param 480 bytes*/
            BYTE    byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA    struFtpPara;   /*FTP server test param 528 bytes*/
            BYTE    byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30    struEmailPara;            /*Email server test param 660 bytes*/
            BYTE    byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR    struIp;                            /*IP conflict test param 24 bytes*/
            BYTE    byRes1[716];
        }struIpPara;
        struct
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //Port
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //User
            char  szPassword[CLOUD_PASSWD_LEN/*48*/];     // Passwor
            NET_DVR_POOLPARAM  struPoolInfo[16];//Array 0 bayonet video pool, an array of 1 said illegal video pool,  2 Vehicle detection(IPC/D)
            BYTE   byProtocolType;//Protocol type,0- 1.0,1- 2.0
            BYTE   byRes3[3];
            char  szAccessKey[NET_SDK_ACCESS_KEY_LEN/*64*/]; //access key
            char  szSecretKey[NET_SDK_SECRET_KEY_LEN/*64*/]; //secret kry
            BYTE byRes1[354];
        }struCloudStoragePara;
        struct
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/]; //Phone Num
            BYTE byRes1[708];
        }struPhoneNumPara;//Phone Num Test
    }unionServerPara;
    BYTE byRes2[800];
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO
{
    DWORD      dwSize;          //struct size
    LONG      lChannel;
    NET_DVR_TIME_EX   struStartTime;
    NET_DVR_TIME_EX   struEndTime;
    BYTE                 byRes[256];
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;
    DWORD         dwDuration;
    DWORD         dwDataSize;
    BYTE          byRes[128];
    char* pBuf;
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK
{
    DWORD       dwSize;
    NET_DVR_TIME_V30  struTime;
    DWORD       dwDuration;
    DWORD       dwMetaDataSize;
    DWORD       dwPicDataSize;
    char*        pMetaDataBuffer;
    char*       pPicDataBuf;
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;
/****************************Netra 2.3 end ***************************************/

#define MAX_LOCAL_ADDR_LEN            96        
#define    MAX_COUNTRY_NAME_LEN        4    

typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD    dwSize;
    BYTE    byEnableBonjour;
    BYTE     byRes1[3];
    BYTE     byFriendlyName[MAX_DOMAIN_NAME];
    BYTE     byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD            dwSize;
    BYTE            byEnableSocks;
    BYTE             byVersion;
    WORD            wProxyPort;
    BYTE            byProxyaddr[MAX_DOMAIN_NAME];
    BYTE             byUserName[MAX_DOMAIN_NAME];
    BYTE             byPassword[NAME_LEN];
    BYTE             byLocalAddr[MAX_LOCAL_ADDR_LEN];
    BYTE             byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;

typedef struct tagNET_DVR_QOS_CFG
{
    DWORD        dwSize;
    BYTE        byManageDscp;
    BYTE        byAlarmDscp;
    BYTE        byVideoDscp;
    BYTE        byAudioDscp;
    BYTE        byFlag;
    BYTE        byEnable;
    BYTE         byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;


//Cert Info
typedef struct tagNET_DVR_CERT_NAME
{
    BYTE    byCountry[MAX_COUNTRY_NAME_LEN];
    BYTE     byState[MAX_DOMAIN_NAME];
    BYTE     byLocality[MAX_DOMAIN_NAME];
    BYTE     byOrganization[MAX_DOMAIN_NAME];
    BYTE     byUnit[MAX_DOMAIN_NAME];
    BYTE     byCommonName[MAX_DOMAIN_NAME];
    BYTE     byEmail[MAX_DOMAIN_NAME];
    BYTE     byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME;

typedef struct tagNET_DVR_CERT_ADDITION_PARAM
{
    DWORD dwSize;
    char  csCustomID[64];
    BYTE  byRes1[2];
    BYTE  byCertificateMode;
    BYTE  byPrivateKeyMode;
    BYTE  byPassword[64];
    BYTE  byRes[128];
}NET_DVR_CERT_ADDITION_PARAM, *LPNET_DVR_CERT_ADDITION_PARAM;

typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //certificate type,0-802.1x,1-HTTPS,3-ieee802.1x
    WORD wCertType; //certificate type,0-CA,1-Certificate,2-private 
    BYTE byFileType; //certificate type,0-PEM,1-PFX
    BYTE byRes1[2];//res1
    BYTE byAddition;//using Addition ,0-no;1-yes
    NET_DVR_CERT_ADDITION_PARAM* pStruAdditionParam;//point to struct NET_DVR_CERT_ADDITION_PARAM
    BYTE byRes[28];//res
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

typedef struct tagNET_DVR_CERT_INFO
{
    DWORD                 dwSize;
    NET_DVR_CERT_PARAM     struCertParam;
    DWORD                dwValidDays;
    BYTE                 byPasswd[NAME_LEN];
    NET_DVR_CERT_NAME     struCertName;
    NET_DVR_CERT_NAME     struIssuerName;
    NET_DVR_TIME_EX         struBeginTime;
    NET_DVR_TIME_EX         struEndTime;
    BYTE                 serialNumber[NAME_LEN];
    BYTE                 byVersion;
    BYTE                 byKeyAlgorithm;
    BYTE                  byKeyLen;
    BYTE                 bySignatureAlgorithm;
    BYTE                 byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;



typedef enum
{
    UPGRADE_CERT_FILE = 0,
    UPLOAD_CERT_FILE = 1,
    TRIAL_CERT_FILE = 2,
    CONFIGURATION_FILE = 3,
    UPLOAD_RECORD_FILE = 4,  //upload record file
    SCENE_CONFIGURATION_FILE = 5, //upload sence configure file 
    UPLOAD_PICTURE_FILE = 6,  //upload pocture file
    UPLOAD_VIOLATION_FILE = 7,  //Upload Violation File
    UPLOAD_TG_FILE = 8,  //Upload TG File
    UPLOAD_DATA_TO_DB = 9,        //upload data to DB
    UPLOAD_BACKGROUND_PIC = 10, //Upload Background Picture
    UPLOAD_CALIBRATION_FILE = 11, //Upload Calibration file
    UPLOAD_TME_FILE = 12, //Tme File
    UPLOAD_VEHICLE_BLOCKALLOWLIST_FILE = 13,
    UPLOAD_PICTURE_TO_CLOUD = 15, //upload picture to cloud storage
    UPLOAD_VIDEO_FILE = 16,  //upload video file
    UPLOAD_SCREEN_FILE = 17,    //upload screen server file
    UPLOAD_PUBLISH_MATERIAL = 18,    //upload info publish material file
    UPLOAD_PUBLISH_UPGRADE_FILE = 19,    //upload info upgrade file
    UPLOAD_RING_FILE = 20,   //upload ring file
    UPLOAD_ENCRYPT_CERT = 21,    //upload encrypt cert
    UPLOAD_THERMOMETRIC_FILE = 22,  //Upload Thermometric File
    UPLOAD_SUBBRAND_FILE = 23,  //Upload Sub Brand File
    UPLOAD_LED_CHECK_FILE = 24,    //upload LED check file
    BATCH_UPLOAD_PICTURE_FILE = 25,  //batch upload pictrue
    UPLOAD_EDID_CFG_FILE = 26, //upload EDID file
    UPLOAD_PANORAMIC_STITCH = 27,//Upload a panoramic stitching configuration file automatically 
    UPLOAD_BINOCULAR_COUNTING = 28,//Upload the vertical flow correction table 
    UPLOAD_AUDIO_FILE = 29,   //Upload Audio File
    UPLOAD_PUBLISH_THIRD_PARTY_FILE = 30,  //upload third part file
    UPLOAD_DEEPEYES_BINOCULAR = 31,//Upload eye binocular correction table
    UPLOAD_CERTIFICATE_BLOCKLIST = 32,  //upload certificate block list 
    UPLOAD_HD_CAMERA_CORRECT_TABLE = 33,//upload certificate for 2400/3200
    UPLOAD_FD_DATA = 35,//Export the specified face database
    UPLOAD_FACE_DATA = 36, //upload face data
    UPLOAD_FACE_ANALYSIS_DATA = 37,//upload face analysis data
    UPLOAD_FILEVOLUME_DATA = 38,//Upload file volume data file (currently only CVR device support) 
    IMPORT_DATA_TO_FACELIB = 39,//Import data to face lib
    UPLOAD_LEFTEYE_4K_CALIBFILE = 40,//Left Eye and 4K Camera Calibration file
    UPLOAD_SECURITY_CFG_FILE = 41,//upload config file use secret key
    UPLOAD_RIGHT_CONTROLLER_AUDIO = 42, //upload right controller audio
    UPLOAD_MODBUS_CFG_FILE = 43, //import Modbus protocol configuration file
    UPLOAD_NOTICE_VIDEO_DATA = 44, //Upload Notice Video Data
    UPLOAD_RS485_PROTOCOL_DLL_FILE = 45, //Upload RS485 dll file
    UPLOAD_PIC_BY_BUF = 46,//Upload picture by buffer
    UPLOAD_CLIENT_CALIBFILE = 47,//Upload client calibration file(.pto format)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W = 48,//3200W camera correct table(.cal format)
    UPLOAD_DOOR_CONTENT = 49, //upload door content
	UPLOAD_ASR_CONTROL_FILE = 50, //upload ASR file for device control
    UPLOAD_APP_FILE = 51,//upload HEOP APP file
    UPLOAD_AI_ALGORITHM_MODEL = 52, //AI open platform, upload algorithm model to device
    UPLOAD_PUBLISH_PROGRAM_THUMBNAIL = 53,    //upload Program Thumbnail
    UPLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 54,   //upload template Thumbnail
    UPLOAD_AI_PICTURE = 55,//AI Open Platform, Picture Task, Download Pictures in Binary Format
    UPLOAD_OFFLINE_CAPTURE_INFO = 56,       //user info import
	UPLOAD_FONT_TYPE_DLL_FILE = 57,            //Font library import
    UPLOAD_CLIENT_CALIBFILE_FILE = 58,   //Upload client calibration file(.pto format,add channel)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W_FILE = 59,  //3200W camera correct table(.cal format,add channel)
    IMPORT_DATA_TO_HBDLIB = 60,      /*Import data to human lib*/
    UPLOAD_SCENE_FILE = 61,   //import scene file
    UPLOAD_RATIOSTITCHING_FILE = 62,   //import ratioStitching file
    UPLOAD_LENS_PARAM_FILE = 63,   // import lens parameter file 
    UPLOAD_CUSTOMAUDIO_FILE=64,      //Import custom audio material file
    UPLOAD_VIDEOWALL_MATERIAL_FILE = 65  //Import videowall material file
}NET_SDK_UPLOAD_TYPE;

typedef enum
{
    NET_SDK_DOWNLOAD_CERT = 0,               //Download certificate file
    NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,         //Download ipc config file
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2, //Download baseline scene picture
    NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3, //Download the lastest alarm picture of certain VQD event    
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE = 4,   //Download configuration file
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5, //Download scene configure file
    NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,                //Download from DB
    NET_SDK_DOWNLOAD_TME_FILE = 7,  //TME File
    NET_SDK_DOWNLOAD_VEHICLE_BLOCKALLOWLIST_FILE = 8, //Download block and allow configure file
    NET_SDK_DOWNLOAD_GUID_FILE = 9, //Download GUID file 
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,   //download picture from cloud storage
    NET_SDK_DOWNLOAD_PICTURE = 11, //download picture file
    NET_SDK_DOWNLOAD_VIDEO = 12, //download video file
    NET_DVR_DOWNLOAD_SCREEN_FILE = 13, //download screen server file
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL = 14,    //download info publish material
    NET_SDK_DOWNLOAD_THERMOMETRIC_FILE = 15,  //Download Thermometric File
    NET_SDK_DOWNLOAD_LED_CHECK_FILE = 16,        //download LED check file
    NET_SDK_DOWNLOAD_CERTIFICATE_BLOCKLIST_TEMPLET = 18, //download certificate block list template
    NET_SDK_DOWNLOAD_LOG_FILE = 19, //Log export 
    NET_SDK_DOWNLOAD_FILEVOLUME_DATA = 20,//Download file data files (currently only CVR device support)
    NET_SDK_DOWNLOAD_FD_DATA = 21,//    Export the specified face database
    NET_SDK_DOWNLOAD_SECURITY_CFG_FILE = 22,//config file download 
    NET_SDK_DOWNLOAD_PUBLISH_SCHEDULE = 23, //schedule export
    NET_SDK_DOWNLOAD_RIGHT_CONTROLLER_AUDIO = 24, //download right controller audio
    NET_SDK_DOWNLOAD_MODBUS_CFG_FILE = 25, //export Modbus protocol configuration file
    NET_SDK_DOWNLOAD_RS485_PROTOCOL_DLL_FILE = 26, //export RS485 dll file
    NET_SDK_DOWNLOAD_CLUSTER_MAINTENANCE_LOG = 27, //Cluster maintenance log export
    NET_SDK_DOWNLOAD_SQL_ARCHIVE_FILE = 28, //Archive database record export
	NET_SDK_DOWNLOAD_SUBWIND_STREAM = 29,//sub window stream export
    NET_SDK_DOWNLOAD_DEVTYPE_CALIBFILE = 30,//device type calibration file export(.cal format)
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE = 31,// camera correct table for 2400/3200 export(.cal format)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE = 32,//client calibration file(.pto format)
    NET_SDK_DOWNLOAD_FOUE_CAMERAS_PICTURES = 33,//four cameras pictures(.tar format)
    NET_SDK_DOWNLOAD_DOOR_CONTENT = 34, //download door content
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL_THUMBNAIL = 35,    //download Material Thumbnail
    NET_SDK_DOWNLOAD_PUBLISH_PROGRAM_THUMBNAIL = 36,   //download Program Thumbnail
    NET_SDK_DOWNLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 37,   //download template Thumbnail
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_MAIN = 38, //darkFighterX correct table(main  partition)
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_BACKUP = 39,//darkFighterX correct table(backup partition)
    NET_SDK_DOWNLOAD_OFFLINE_CAPTURE_INFO_TEMPLATE = 40,  //download user template file
    NET_SDK_DOWNLOAD_CAPTURE_DATA = 41, //download capture data
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE_FILE = 42, // camera correct table for 2400/3200 export(.cal format,add channel)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE_FILE = 43, //client calibration file(.pto format,add channel)
    NET_SDK_DOWNLOAD_FOUR_CAMERAS_PICTURES_FILE = 44, //four cameras pictures(.tar format,add channel)
    NET_SDK_DOWNLOAD_SCENE_FILE = 45,   //export scene file
    NET_SDK_DOWNLOAD_OPEN_SOURCE_CERT = 46,   //export open source cert
    NET_SDK_DOWNLOAD_RATIOSTITCHING_FILE = 47,   //export ratioStitching file
    NET_SDK_DOWNLOAD_LENS_PARAM_FILE = 48,   // export len parameter file
    NET_SDK_DOWNLOAD_SELECT_DEVTYPE_CALIBFILE = 49,  //export calibration file(.cal format)
    NET_SDK_DOWNLOAD_VIDEOWALL_MATERIAL_FILE = 50,  //export videowall material file
}NET_SDK_DOWNLOAD_TYPE;

typedef struct tagNET_DVR_CAPTURE_DATA_COND
{
    DWORD  dwSize;
    char   szPassword[128];   //string
    BYTE   byRes[128];
}NET_DVR_CAPTURE_DATA_COND, *LPNET_DVR_CAPTURE_DATA_COND;

typedef enum
{
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,
    NET_SDK_DOWNLOAD_STATUS_PROCESSING,
    NET_SDK_DOWNLOAD_STATUS_FAILED,
    NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR,
    NET_SDK_DOWNLOAD_STATUS_RESOURCE,
    NET_SDK_DOWNLOAD_STATUS_GUIDFILE_EXPORT_FAIL
}NET_SDK_DOWNLOAD_STATUS;

typedef enum tagNET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM
{
    ENUM_DOWNLOAD_CONTROL_ERR = -1,
    ENUM_DOWNLOAD_CONTROL_QOS = 1
}NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM;


/********************************video wall begin*********************************/
typedef struct tagNET_DVR_PANORAMIC_STITCH_UPLOAD
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE    byRes[128];
}NET_DVR_PANORAMIC_STITCH_UPLOAD, *LPNET_DVR_PANORAMIC_STITCH_UPLOAD;

typedef struct NET_DVR_UPLOAD_FACE_DATA
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];   //FDID
    BYTE        byFDLibType; //FDLibType0-res;1-blocklist;2-allowlist
    BYTE        byRes1[3];
    char        szCustomInfo[NET_SDK_FDPIC_CUSTOM_INFO_LEN/*96*/];   //CustomInfo
    BYTE        byRes[512];
}NET_DVR_UPLOAD_FACE_DATA, *LPNET_DVR_UPLOAD_FACE_DATA;

typedef struct NET_DVR_UPLOAD_FACE_DATA_OUT
{
    char        szPicID[NET_SDK_MAX_PICID_LEN/*256*/];   //fdID
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_DATA_OUT;

typedef struct NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT
{
    DWORD       dwSize;
    DWORD       dwPID;//picture ID
    DWORD       dwFaceAnalysisNum;// face analysis num
    NET_VCA_RECT       struVcaRect[NET_DVR_MAX_FACE_ANALYSIS_NUM];  //face rect
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT;

typedef struct NET_DVR_SECURITY_CFG_FILE_COND
{
    DWORD       dwSize;
    char        szSecretKey[NET_SDK_SECRETKEY_LEN/*128*/];// check secret key
    BYTE        byRes[128];
}NET_DVR_SECURITY_CFG_FILE_COND, *LPNET_DVR_SECURITY_CFG_FILE_COND;

typedef struct tagNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM_
{
    DWORD     dwSize;
    BYTE      byType;   //Log type, 0- all, 1- simple, 2- default
    BYTE      byRes[255];
}NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM, *LPNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;
    BYTE   byRes1[3];
    DWORD  dwWallNum;//output No.    
    NET_DVR_RECTCFG struRectCfg;//screen position
    BYTE    byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

/*windows information*/
typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//window No.
    DWORD dwLayerIndex;//layer No.
    NET_DVR_RECTCFG struWinPosition;//window position
    DWORD dwDeviceIndex;//device index
    WORD  wInputIndex;//input index
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD    dwSize;
    BYTE    byWallNo;    //wall no. start from 1
    BYTE    bySceneNo;    //scene no.
    BYTE    byRes1[2];
    DWORD    dwDeviceID;    //sub device index
    DWORD    dwWindowNo;    //window no./signal no.
    BYTE    byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //enable transparency,0-disable, not 0-enable
    BYTE  byWinMode;//window mode
    BYTE  byEnableSpartan;//enable motion fluency,0-disable,1-enable
    BYTE  byDecResource;//decode resource alloc,1-D1,2-720P,3-1080P
    BYTE  byWndShowMode;
    BYTE    byEnabledFeature;
    BYTE    byFeatureMode;
    BYTE  byRes1;
    DWORD dwAmplifyingSubWndNo;
    BYTE  byWndTopKeep;
    BYTE  byWndOpenKeep;
    BYTE  byRes[22];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//scene name
    BYTE    byEnable;        //0-invalid,1-valid
    BYTE    bySceneIndex;     //scene index,get only.use this parameter when get all scene
    BYTE  byRes[78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //window No.
    DWORD dwSubWinNum;//sub window No.
    DWORD dwWallNo;  //video wall No
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO, *LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize;
    BYTE  byDecodeStatus; /*corrent decode status:0:off,1 :on*/
    BYTE  byStreamType;    /*stream type*/
    BYTE  byPacketType;    /*packet type*/
    BYTE  byFpsDecV; /*video decode frame rate*/
    BYTE  byFpsDecA; /*audio decode frame rate*/
    BYTE  byRes1[7];
    DWORD dwDecodedV; /*decoded video frame number*/
    DWORD dwDecodedA; /*decoded video frame number*/
    WORD  wImgW; /*image size*/
    WORD  wImgH;
    BYTE  byStreamMode; //stream source(valid for video platform): 1-Network, 2-Video platform inter coder, 3-screen server, 0xff-invalid
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //window No.
    DWORD dwSubWinIndex;//sub window No.
    BYTE  byType;//resource type,1-decode,2-pic preview
    BYTE  byWallNo; //Wall No
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize;
    BYTE   sAddress[MAX_DOMAIN_NAME];//address,ip or domain
    WORD   wDVRPort;                 /* port */
    WORD   wChannel;                /* channel */
    BYTE   sUserName[NAME_LEN];    /* username */
    BYTE   sPassword[PASSWD_LEN];    /* password */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO, *LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //Resolution    
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat;  //video format,0-invalid,1-NTSC,2-PAL
    BYTE  byDisplayMode;/*display mode,1-BNC,2-VGA,3-HDMI,4-DVI,5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI self adapt,0xff-invalid*/
    BYTE  byBackgroundColor; //backgroundcolor,0-invalid,1-red,2-green,3-blue,4-yellow,5-purple,6-cyan,7-black,8-white,0xff-selfdefine
    BYTE  byUseEDIDResolution; //use EDID resolution, 0-not use, 1-use
    WORD  wLEDWidth;     //LED output width resolution 
    WORD  wLEDHeight;    //LED output height resolution
    NET_DVR_RGB_COLOR struBackColor;//back color,byBackgroundColor is 0xff valid
    BYTE    byLinkStatus;//output link status:0-res,1-Connected ,2-Not connected 
    BYTE    byRes2[51];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

#define     MAX_UNITEDMATRIX_NUM        8  //max united video platform number

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    DWORD        dwSequence;//video platform number
    BYTE        sAddress[MAX_DOMAIN_NAME];//address,ip or domain
    WORD        wSubMatrixPort;        /*sub system port*/
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /*username*/
    BYTE        sPassword[PASSWD_LEN];    /*password */
    BYTE        byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO, *LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //united video platform information
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO, *LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_SUBSTREAM_SWITCH_CFG
{
    BYTE  byAutoSwitchEnable;
    BYTE     byRes1[3];
    WORD  wSubWndWidth;
    WORD  wSubWndHeight;
}NET_DVR_SUBSTREAM_SWITCH_CFG, *LPNET_DVR_SUBSTREAM_SWITCH_CFG;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD dwSize;
    BYTE  byTransparency;//transparency,0-100,0 represents not transparent
    BYTE  byWinStaticMode; //the display model after decode stop, 1-clear screen ,2-show last frame, 
    BYTE  byStreamFailedMode; //1-no video signal 2 - show last frame, 3 - link exception, 4 - clear screen
    BYTE    byEnabledOverlayLogo;
    NET_DVR_SUBSTREAM_SWITCH_CFG  struSubStreamSwitch;
    BYTE  byLEDShowMode;
    BYTE  byLowLatencyMode;
    BYTE  byRes[50];
}NET_DVR_WALL_CFG, *LPNET_DVR_WALL_CFG;
/********************************video wall end*********************************/

/************************************200 million pixels high definition infrared ball(V5.0.2)  begin*******************************/
typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD  dwSize;
    BYTE  byLowLightLimt;
    BYTE  byLowLightLimtLevel;
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD  dwSize;
    BYTE  byFocusMode;
    BYTE  byAutoFocusMode;
    WORD  wMinFocusDistance;
    BYTE  byZoomSpeedLevel;
    BYTE  byFocusSpeedLevel;
    BYTE  byOpticalZoom;
    BYTE  byDigtitalZoom;
    float fOpticalZoomLevel;
    DWORD dwFocusPos;
    BYTE   byFocusDefinitionDisplay;
    BYTE   byFocusSensitivity;
    BYTE   byRes1[2];
    DWORD  dwRelativeFocusPos;
    BYTE   byRes[48];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;
    BYTE  byIrBrightness;
    BYTE  byIrSensitivity;
    BYTE  byIrTrigMode; /* TriggerMode 0-camera,1-photosensitive (work in Auto Mode)*/
    BYTE  byIrBrightnessLimit;/* Brightness Limit (work in Auto Mode)*/
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int  iIrisSet;
    int  iGainSet;
    int  iGainLimit;
    int  iExposureCompensate;
    BYTE  byExposureModeSet;
    BYTE  byShutterSet;
    BYTE  byImageStabilizeLevel;
    BYTE  byCameraIrCorrect;
    BYTE  byHighSensitivity;
    BYTE  byInitializeLens;
    BYTE  byChromaSuppress;
    BYTE  byMaxShutterSet;     //Max Shutter Set
    BYTE  byMinShutterSet;     //Min Shutter Set
    BYTE  byMaxIrisSet; //Max Iris Set
    BYTE  byMinIrisSet;    //Min Iris Set
    BYTE  byExposureLevel;//Exposure levels (model for automatic exposure, aperture priority, shutter priority is effective), the default 4 level 1-5, compatible with the old version of the SDK configuration of new equipment, keep byte 0, so the byte 0, is also the default for exposure level is 1 
    BYTE  byRes[60];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;
typedef struct tagNET_DVR_FLASH_CFG
{
    DWORD      dwSize;
    DWORD    dwChan;
    DWORD    dwInNumbers;
    DWORD    dwOutNumbers;
    DWORD    dwStartTime;
    DWORD    dwEndTime;
    DWORD    dwEhomeFlag;
    DWORD    dwAlarmFlag;
    BYTE       byRes[1024];
}NET_DVR_FLASH_CFG, *LPNET_DVR_FLASH_CFG;
/************************************200 million pixels high definition infrared ball(V5.0.2)  end*******************************/

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD    dwSize;
    BYTE    byJointed;        //  0-not jointed  1-jointed
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;    // IP of jointed decoder
    WORD    wPort;            // Port of jointed decoder
    WORD    wChannel;        // channel of jointed decoder
    BYTE    sDeviceName[NAME_LEN];    //device name of jointed decoder
    BYTE    sChanName[NAME_LEN];    //channel name of jointed decoder
    BYTE    byRes2[32];
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

/***************************************CVCS V2.1 begin**************************************/

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress;
    WORD    wPort;
    BYTE    byNicNum; //0 - eth0, 1 - eth1
    BYTE    byRes[69];
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;
typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE    bySerPortNum;   // Serial port , 0xff - loop through access*/
    BYTE    byMatrixSerPortType;//0 --- Matirx protocol 1 --- keyboard protocol
    BYTE    byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;    //232 serial port parameter, it is invaild when loop through access 
    BYTE    byRes2[200];
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;

typedef union tagNET_MATRIX_UNION
{
    NET_MATRIX_DIGITALMATRIX struDigitalMatrix;
    NET_MATRIX_ANALOGMATRIX struAnalogMatrix;
}NET_MATRIX_UNION, *LPNET_MATRIX_UNION;

typedef struct tagNET_MATRIX_MATRIXINFO
{
    DWORD   dwSize;
    DWORD    dwMatrixId; 
    BYTE    sDevName[NAME_LEN];
    BYTE    byCtrlType;
    BYTE    byProtocolType;
    BYTE    byRes1[6];  
    NET_MATRIX_UNION struMatrixUnion;
    DWORD    dwMaxPortsIn; 
    DWORD    dwMaxPortsOut;
    BYTE    sUserName[NAME_LEN];   
    BYTE    sPassword[PASSWD_LEN];
    NET_DVR_TIME struInstallTime;
    BYTE    sPurpose[NAME_LEN];
    BYTE    byRes2[20];  
}NET_MATRIX_MATRIXINFO, *LPNET_MATRIX_MATRIXINFO;

typedef struct tagNET_DVR_MATRIXLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwMatrixNum;
    BYTE    *pBuffer;
    DWORD   dwBufLen;
}NET_DVR_MATRIXLIST, *LPNET_DVR_MATRIXLIST;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD        dwSize;
    BYTE        byValid;            // set matrix config when byValid is 1 and delete matrix when byValid is 0
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // matrix name
    DWORD          dwMatrixID;        // matrix id, only can be geted
    WORD        wMatrixInputChanNum;            // input channel number of matrix
    WORD        wMatrixOutputChanNum;            // output channel number of matrix 
    WORD           wMatrixOutputChanRef[MAX_CAM_COUNT];   // the relation between output channel of matrix and input channel of cvcs 
    //when > 0, it means bind output channel to input channel, when = 0, it means delete the binding. screen server use screen index and  matrix output channel to bind  
    BYTE        byMatrixChanType;// matrix type 1-BNC,2-VGA,3-RGB,4-DVI
    BYTE        byMatrixProtocol;    // matrix protocol 1.ZT1.0;2.ZT2.0;3.Extron;4.Creator
    BYTE        byMatrixType;        //1-analog matrix,2-digital matrix
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE        byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG_V50
{
    DWORD       dwSize;
    BYTE        byValid;            // set matrix config when byValid is 1 and delete matrix when byValid is 0
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // matrix name
    DWORD       dwMatrixID;        // matrix id, only can be geted
    WORD        wMatrixInputChanNum;            // input channel number of matrix
    WORD        wMatrixOutputChanNum;            // output channel number of matrix 
    WORD        wMatrixOutputChanRef[MAX_CAM_COUNT_V50];   // the relation between output channel of matrix and input channel of cvcs 
    //when > 0, it means bind output channel to input channel, when = 0, it means delete the binding. screen server use screen index and  matrix output channel to bind  
    BYTE        byMatrixChanType;// matrix type 1-BNC,2-VGA,3-RGB,4-DVI
    BYTE        byMatrixProtocol;    // matrix protocol 1.ZT1.0;2.ZT2.0;3.Extron;4.Creator
    BYTE        byMatrixType;        //1-analog matrix,2-digital matrix
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE        byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG_V50, *LPNET_DVR_EXTERNAL_MATRIX_CFG_V50;

typedef struct tagNET_MATRIX_UARTPARAM
{
    DWORD dwSize;
    BYTE  byPortName[NAME_LEN];
    WORD  wUserId;
    BYTE  byPortType;   
    BYTE  byFuncType;
    BYTE  byProtocolType; 
    BYTE  byBaudRate;
    BYTE  byDataBits;
    BYTE  byStopBits;   
    BYTE  byParity;      
    BYTE  byFlowCtrl;   
    BYTE  byRes[22];    
}NET_MATRIX_UARTPARAM, *LPNET_MATRIX_UARTPARAM;

typedef struct tagNET_MATRIX_USERPARAM
{
    DWORD dwSize;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN/*16*/];
    BYTE    byRole;
    BYTE    byLevel;  
    BYTE    byRes[18];
}NET_MATRIX_USERPARAM, *LPNET_MATRIX_USERPARAM;

typedef struct tagNET_MATRIX_RESOURSEGROUPPARAM
{
    DWORD dwSize;
    BYTE  byGroupName[NAME_LEN];
    BYTE  byGroupType;
    BYTE  byRes1;
    WORD  wMemNum;
    DWORD dwGlobalId[512];
    BYTE  byRes2[20];
}NET_MATRIX_RESOURCEGROUPPARAM, *LPNET_MATRIX_RESOURSEGROUPPARAM;

typedef struct tagNET_MATRIX_USERGROUPPARAM
{
    DWORD dwSize;
    BYTE  sGroupName[NAME_LEN];
    WORD  wUserMember[255];  
    WORD  wResorceGroupMember[255];
    BYTE  byPermission[32];
    BYTE  byRes[20];
} NET_MATRIX_USERGROUPPARAM, *LPNET_MATRIX_USERGROUPPARAM;


#define MAX_INPUTNUMS 1024
#define MAX_OUTPUTNUMS 256
typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD    dwDeviceIndex;    //device index of dvcs
    WORD    wInputIndex;    //input signal index
    BYTE    byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byWallNo;        //wall no. start from 1
    BYTE    byRes1[2];
    DWORD    dwOutputIndex;    //screen index
    BYTE    byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM, *LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD    dwSize;
    BYTE    sUserName[NAME_LEN];        // username,max length is 16
    BYTE    sPassWord[PASSWD_LEN];        // password
    NET_DVR_IPADDR    struUserIP;            // ip address, 0 means every ip
    BYTE    byMacAddr[MACADDR_LEN];        // mac address
    BYTE    byPriority;                    // priority 1-administrator,2-operater
    BYTE    byRes1;
    DWORD    dwRight;/*remote right,every bit is a right,0-not support,1-support*/
    //bit0-get/set base parameter    
    //bit1-manage screen
    //bit2-manage window 
    //bit3-manage signal source
    //bit4-manage layout
    //bit5-manage plan
    //bit6-manage picture
    //bit7-manage OSD
    //bit8-picture view
    //bit9-arm
    //bit10-upgrade
    //bit11-resume
    //bit12-input and output config file
    //bit13-search log
    //bit14-restart
    //bit15-Screen area manage
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //screen manage region 
    BYTE   byWallNo;    //wall No. of screen area manage
	BYTE   byRes2[3];
	BYTE   sLoginPassword[PASSWD_LEN/*16*/];		//login password
	BYTE   byRes[88];
} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;
/***************************************CSCS V2.1 end**************************************/

/*************************************63T 64T 65D V2.0.0 start****************************/
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{
    BYTE    byValid; //enable media server,0-disable,1-enable
    BYTE    byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP or domain   
    WORD    wDevPort;            /*media server port*/
    BYTE    byTransmitType;        /*transmit type 0-TCP,1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41, *LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];    //domain of device
    WORD     wDVRPort;                 //device port
    BYTE     byChannel;                //channel num
    BYTE    byTransProtocol;        //transmit type 0-TCP,1-UDP
    BYTE    byTransMode;            //stream mode 0-main stream 1-sub stream
    BYTE    byFactoryType;            /*device factory type*/
    BYTE    byDeviceType; //Device type(Used by videoplatfom VCA card),1-decoder(use decode channel No. or display channel depends on byVcaSupportChanMode in videoplatform ability struct),2-coder
    BYTE    byDispChan;//Display channel No. used by VCA configuration
    BYTE    bySubDispChan;//Display sub channel No. used by VCA configuration
    BYTE    byResolution;    //Resolution: 1-CIF 2-4CIF 3-720P 4-1080P 5-500w used by big screen controler
    BYTE    byRes[2];
    BYTE    sUserName[NAME_LEN];    //Remote device user name
    BYTE    sPassword[PASSWD_LEN];    //Remote device password
}NET_DVR_DEV_CHAN_INFO_V41, *LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{
    BYTE   byValid;
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP or Domain 
    WORD   wDevPort;            /*Stream Media Server Port*/
    BYTE   byTransmitType;        /*Stream Trans Protocol 0-TCP,1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER, *LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_LOCAL_ASYNC_CFG
{
    BOOL    bEnable;
    BYTE    byRes[60];
}NET_DVR_LOCAL_ASYNC_CFG, *LPNET_DVR_LOCAL_ASYNC_CFG;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE    byChanType;              //Channal Type,0-Normal Channal,1-Zero Channal,2-Stream ID,3-Local input,4-virtual screen server channel,5-Joint channel,6-screen server,7-distributed IP,8-multi camera compose,9-internet resource
    BYTE    byStreamId[STREAM_ID_LEN];//Stream ID,when byChanType is 2 or 9,this byStreamId is valid
    BYTE    byRes1[3];
    DWORD   dwChannel;   //Channel No. 
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];    //Device Domain
    WORD     wDVRPort;                 //Port
    BYTE     byChannel;                //Channel No. if dwChannel is not equal to 0,this value is invalid
    BYTE    byTransProtocol;        //Stream Trans Protocol 0-TCP,1-UDP
    BYTE    byTransMode;            //Stream Trans Mode 0-Main Stream  1-Sub stream 
    BYTE    byFactoryType;            /*Factory Type*/
    BYTE    byDeviceType; //Device Type,1-Decoder,2-Encoder
    BYTE    byDispChan;//Display Channel Number
    BYTE    bySubDispChan;//Display Sub Channel Number
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w big Stream use
    BYTE    byRes[2];
    BYTE    sUserName[NAME_LEN];    //Remote user
    BYTE    sPassword[PASSWD_LEN];    //Remote Password
}NET_DVR_DEV_CHAN_INFO_EX, *LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX, *LPNET_DVR_DEC_STREAM_DEV_EX;

typedef struct tagNET_DVR_DEC_STREAM_DEV
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_V41    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_V41                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV, *LPNET_DVR_DEC_STREAM_DEV;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];    //Domain
    BYTE   byTransProtocol;        //Trans protocol 0-TCP,1-UDP, 2-MCAST
    BYTE   byTransMode;            //Stream Trams Mode 0-Main Stream 1-Sub Stream
    BYTE   byDdnsType;         //Server TYPE,0-IPServer 1-Dyndns 2-PeanutHull,3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS Server Address
    WORD   wDdnsPort;                 //DDNS Server Port
    BYTE   byChanType;              //0-Normal Channal,1-Zero Channal,2-Stream ID
    BYTE   byFactoryType;            //Factory Type
    DWORD  dwChannel; //Channal Number
    BYTE   byStreamId[STREAM_ID_LEN]; //Stream ID
    BYTE   sUserName[NAME_LEN];    //Remote User
    BYTE   sPassword[PASSWD_LEN];    //Remote Password
    WORD   wDevPort;                //Remote Port
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO, *LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV, *LPNET_DVR_DEC_DDNS_DEV;

typedef union tagNET_DVR_DEC_STREAM_MODE
{
    NET_DVR_DEC_STREAM_DEV_EX struDecStreamDev;
    NET_DVR_PU_STREAM_URL struUrlInfo;
    NET_DVR_DEC_DDNS_DEV struDdnsDecInfo;
    BYTE byRes[300];
}NET_DVR_DEC_STREAM_MODE, *LPNET_DVR_DEC_STREAM_MODE;

typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD                                dwSize;
    BYTE                                byStreamMode;//stream mode,0-invalid,1-get stream by IP or Domain,2-get stream by URL
    BYTE                                byStreamEncrypt;//stream encrypt enabled, 0-not support,1-support
	BYTE                                byRes1[2];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//stream info
    DWORD                        dwDecDelayTime;//decode time delay,unit:ms
    BYTE                         sStreamPassword[STREAM_PASSWD_LEN];  //stream password
	BYTE                         byRes2[48];
}NET_DVR_PU_STREAM_CFG_V41, *LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE                                byEnable; //enable the node,0-disable,1-enable
    BYTE                                byStreamMode;//stream mode,0-invalid,1-get stream by IP or Domain,2-get stream by URL
    BYTE                                byRes[2];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//stream info
}NET_DVR_MATRIX_CHAN_INFO_V41, *LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*loop interval*/
    NET_DVR_MATRIX_CHAN_INFO_V41    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                            byStreamEncrypt;  
    BYTE	                        byRes[3];
    BYTE                            sStreamPassword[STREAM_PASSWD_LEN]; 
}NET_DVR_MATRIX_LOOP_DECINFO_V41, *LPNET_DVR_MATRIX_LOOP_DECINFO_V41;



typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD    dwSize;
    BYTE                                byStreamMode;//stream mode,0-invalid,1-get stream by IP or Domain,2-get stream by URL
    BYTE                                byRes1[3];
    NET_DVR_DEC_STREAM_MODE             uDecStreamMode;//decode stream info
    DWORD    dwPlayMode;        /* 0-dynamic decode 1-loop decode 2-paly back by time 3-paly back by name */
    NET_DVR_TIME StartTime;         /* start time for playback by time mode,  */
    NET_DVR_TIME StopTime;         /* stop time for playback by time mode */
    char    sFileName[128];         /* file name for playback by file mode */
    DWORD   dwGetStreamMode;    //Fetch Stream Mode: 1- Positive, 2- Passive
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE    byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41, *LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

/*************************************63T 64T 65D V2.0.0 end******************************/
typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD        dwSize;
    DWORD        dwTrunkID;    //trunk ID
    WORD        wReserveUserID;    //reserve user ID: 1~256 ,0 means release trunk
    BYTE        byStatus;  //1-free,2-used,3-reuse */
    BYTE        byRes1;
    BYTE          byUserId[256];  //Array subscript is user id,the user 1 is using it when byUserID[0] is 1.
    BYTE           byRes2[64];
}NET_DVR_TRUNK_USE_STATE, *LPNET_DVR_TRUNK_USE_STATE;


typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD    dwSize;
    DWORD    dwCtrlDelayTime;        //PTZ control time, the user of low lever can not use it in this time, unit: s
    BYTE    byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

#define        MAX_MATRIX_CASCADE        32
typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD        dwSize;
    DWORD           dwCamNo;
    DWORD       dwMonNo;
    DWORD        dwSubWin;
    DWORD        dwUserId;
    DWORD       dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId[0] is the first cascade,trunkId[1] is the second cascade, there is no trunk when trunkId[i] is 0  
    BYTE        byRes[64];
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;

typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD        dwSize;
    DWORD        dwUserID;    //1~256,0 means no user
    DWORD       dwStatus;      // PTZ control state 0-stop,1-run
    DWORD        dwRestTime;  //rest time
    BYTE        byRes[64];
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;


typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //work mode,0-always open if no person,1-always locked if no person
    BYTE  byFaintToUnlock; //Did person faint some time to external could unlock: 0-no,1-yes
    BYTE  byOvertimeToUnlock;  //Did Overtime to external button could unlock: 0-no,1-yes
    BYTE  byRes[13];
}NET_DVR_SAFETYCABIN_WORK_MODE, *LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //sensor type,0-Infrared,1-curtain
    BYTE  bySensitivity; //sensor sensitivity,range:0-100
    BYTE  byDevUseTimeout; //cabin use timeout,unit:min,range:5-30,default:15min,upload alarm when timeout
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //curtain sensor delay time,unit:second,range:0-10
    WORD  wCurtainResponseTime; //curtain sensor response time,unit:second, range:0-300    
    WORD  wFaintToEmergencyTime; //person faint to emergency time, uint:second, range:10-300
    BYTE  byFollowDetectorSensitivity;  //sensitivity about check person followed, rang:0-100%
    BYTE  byManyPersonSensitivity;    //sensitivity about check many person in, rang:0-100%
    BYTE  byRes2[28];  //reserve
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG, *LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;

/********************************IPC 5.0 SDK BEG***************************************/

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD        dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //The physical address of the network card
    BYTE  byRes[64];
}NET_DVR_ETHERNET_IPV6_COND, *LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD        dwSize;
    BYTE  byState;              //IPv6 status, 0 - routing allocation 1 - automatically set
    BYTE  byRes1[3];
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6 address
    BYTE  byRes[64];
}NET_DVR_ETHERNET_IPV6_CFG, *LPNET_DVR_ETHERNET_IPV6_CFG;
/********************************IPC 5.0 SDK END***************************************/

/*********************************IPC 5.1.0 begin**************************************/
typedef struct  //8
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME, *LPNET_DVR_DAYTIME;

typedef struct
{
    NET_DVR_DAYTIME  struStartTime;
    NET_DVR_DAYTIME  struStopTime;
}NET_DVR_SCHEDULE_DAYTIME, *LPNET_DVR_SCHEDULE_DAYTIME;

typedef struct
{
    BYTE byObjectSize;//ObjectSize[0,100]
    BYTE byMotionSensitive; /*MotionSensitive, [1,100],0xff close*/
    BYTE byRes[6];
}NET_DVR_DNMODE, *LPNET_DVR_DNMODE;

typedef struct //60
{
    BYTE byAreaNo;//Area No(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;
    NET_DVR_DNMODE  struDayNightDisable;
    NET_DVR_DNMODE  struDayModeParam;
    NET_DVR_DNMODE  struNightModeParam;
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;

typedef struct
{
    BYTE byDayNightCtrl;//DayNightCtrl 0~close,1~Auto,2~Schedule
    BYTE byAllMotionSensitive;
    BYTE byRes[2];
    NET_DVR_SCHEDULE_DAYTIME struScheduleTime;
    NET_DVR_MOTION_MULTI_AREAPARAM struMotionMultiAreaParam[MAX_MULTI_AREA_NUM];
    BYTE byRes1[60];
}NET_DVR_MOTION_MULTI_AREA, *LPNET_DVR_MOTION_MULTI_AREA;

typedef struct
{
    BYTE byMotionScope[64][96];        /*Motion detection area, 0- 96 bits stand for 64 lines and there are 96*64 small areas,  1- - it is motion detection area, 0- - not*/
    BYTE byMotionSensitive;            /*sensitive grade of motion detection,  0 -  5 (5 is most sensitive) ,  oxff turn off*/
    BYTE byRes[3];
}NET_DVR_MOTION_SINGLE_AREA, *LPNET_DVR_MOTION_SINGLE_AREA;

typedef struct
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //Normal mode
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //Expert mode    
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct
{
    NET_DVR_MOTION_MODE_PARAM  struMotionMode;
    BYTE byEnableHandleMotion;/* Process motion alarm  0- No 1- Yes*/
    BYTE byEnableDisplay;    /*Display motion detect,0- No 1- Yes*/
    BYTE byConfigurationMode; //0~Nomrmal,1~Expert
    BYTE byKeyingEnable; //Keying motion detecting, 0 - No 1 - Yes 
    DWORD   dwHandleType;////Way to handle,  result of operation OR   
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum; //the max of dvr support can trigger the alarm output channel number (read-only)
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //The actual trigger alarm output, according to the values, the compact arrangement, the subscript 0 - dwRelAlarmOut -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD     dwMaxRecordChanNum;   //The maximum number of channels - video equipment support read-only
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];     /* The actual trigger video channel, according to the values, the compact arrangement, the subscript 0 - dwRelRecordChan -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid*/
    BYTE  byDiscardFalseAlarm; //Enable false alarm 0 - invalid, 1 - not enabled, 2 - enabled
    BYTE  byRes[127];
}NET_DVR_MOTION_V40, *LPNET_DVR_MOTION_V40;

typedef struct
{
    DWORD dwEnableVILostAlarm;                /* Enable Video Lost Alarm 0-no,1-yes*/
    DWORD   dwHandleType;        //Way to handle,  result of operation OR  
    /*0x00:  No response*/
    /*0x01:  Alarm on monitor*/
    /*0x02:  Audio Alarm*/
    /*0x04:  Upload to center*/
    /*0x08:  Trigger alarm output*/
    /*0x10:  Grab JPEG image and EMail it*/
    /*0x20:  wireless voice and light alarm*/
    /*0x40:  Trigger electric map(only PCNVR supports)*/
    /*0x200: capture jpeg and update to FTP*/
    /*0x1000:capture jpeg and update to cloud*/
    DWORD   dwMaxRelAlarmOutChanNum; //Alarm output channel trigger (read-only) maximum support number
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*Trigger the alarm output, according to the values, the compact arrangement, the subscript 0 - dwRelAlarmOut -1 effectively, if encountered in the middle 0xFFFFFFFF, subsequent invalid*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE    byVILostAlarmThreshold;    /*0-99*/
    BYTE    byRes[63];
}NET_DVR_VILOST_V40, *LPNET_DVR_VILOST_V40;

typedef struct
{
    NET_DVR_COLOR      struColor[MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME  struHandleTime[MAX_TIMESEGMENT_V30];
}NET_DVR_VICOLOR, *LPNET_DVR_VICOLOR;


typedef struct
{
    DWORD  dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD  dwVideoFormat;        /* Read only,  Video Standard 1- NTSC 2- PAL*/
    NET_DVR_VICOLOR struViColor;
    DWORD  dwShowChanName; // Display channel name or not, 0- no, 1- display size = 704*576
    WORD    wShowNameTopLeftX;/* X- coordinate of display position */
    WORD    wShowNameTopLeftY;/* Y- coordinate of display position  */
    DWORD  dwEnableHide;        /* Enable Tamper Alarm , 0- disable, 1- enable*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD  dwShowOsd;    // Display OSD or not, 0- No OSD, 1- Display Area for display:  704*576
    WORD   wOSDTopLeftX;/* X- coordinate of OSD */
    WORD   wOSDTopLeftY;/* Y- coordinate of OSD*/
    BYTE    byOSDType;/* OSD Type  (format of Year/Month/Day)  */
    /* 0: XXXX- XX- XX Year Month Day */
    /* 1: XX- XX- XXXX Month Day Year */
    /* 2: XXXXYearXXNonthXXDay */
    /* 3: XXMonthXXDayXXXXYear */
    /* 4: XX- XX- XXXX Day Month Year*/
    /* 5: XXDayXXMonthXXXXYear */
    /* 6: xx/xx/xxxx(Month/Day/Year) */
    /* 7: xxxx/xx/xx(Year/Month/Day) */
    /* 8: xx/xx/xxxx(Day/Month/Year)*/
    BYTE    byDispWeek;    /* display Week */
    BYTE    byOSDAttrib;/* OSD attribute:  Transparent, Flash */
    /* 1:  Transparent, Flash */
    /* 2:  Transparent, not Flash */
    /* 3:  Flash, not Transparent */
    /* 4:  not Transparent,  not Flash */
    BYTE    byHourOSDType;/* : 24- Hour system, 12- Hour system */
    BYTE    byFontSize;
    BYTE    byOSDColorType;    //0-auto;1-custom;2-outline
    BYTE    byAlignment;//Alignment 0 - adaptive,1 - right aligned, 2 - left aligned, 3 - gb model, 4-all right aligned, 5-all left aligned
    BYTE    byOSDMilliSecondEnable;//OSD MilliSecond Enable
    NET_DVR_VILOST_V40 struVILost;
    NET_DVR_VILOST_V40 struAULost;
    NET_DVR_MOTION_V40 struMotion;
    NET_DVR_HIDEALARM_V40 struHideAlarm;
    NET_DVR_RGB_COLOR    struOsdColor;//OSD color
    DWORD dwBoundary; //boundary value
    NET_DVR_RGB_COLOR struOsdBkColor; //self-define OSD background color
    BYTE    byOSDBkColorMode; //OSD backgroud color mode, 0-default, 1-self-define OSD backgroud color
    BYTE    byUpDownBoundary;//minimum characters of up-down boundary,character range[0,1,2],unused in global(byAlignment) mode
    BYTE    byLeftRightBoundary;//minimum characters of left-right boundary,character range[0,1,2],unused in global(byAlignment) mode
    BYTE    byAngleEnabled;//Angle information of OSD is superimposed,0~ not superimposed, 1- superimposed
    WORD    wTiltAngleTopLeftX;    /* Angle information displays the x coordinate of the position */
    WORD    wTiltAngleTopLeftY;  /* Angle information displays the y coordinate of the position */
    BYTE    byRes[108];
}NET_DVR_PICCFG_V40, *LPNET_DVR_PICCFG_V40;

typedef struct  //
{
    DWORD                   dwSize;
    BYTE   byWorkType;// 0-SelfAdaptive mode, 1-Schedule mode
    BYTE   byRes[3];
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam;
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG, *LPNET_DVR_ISP_CAMERAPARAMCFG;

typedef struct
{
    DWORD       dwSize;
    BYTE         byIrLampServer;//IR lamp Server Cfg 0~close,1~open
    BYTE         bytelnetServer;//telnet  Server Cfg 0~close,1~open
    BYTE         byABFServer;//ABF cfg 0~open,1~close
    BYTE         byEnableLEDStatus;//State indicating lamp control 0~close,1~open
    BYTE         byEnableAutoDefog;//Automatic defrosting control 0~open, 1~close
    BYTE         byEnableSupplementLight;//Supplement Light;0-open,1-close
    BYTE         byEnableDeicing;//Deicing 0-close,1-open
    BYTE         byEnableVisibleMovementPower;// Visible Movement Power 0-close 1-open
    BYTE         byEnableThermalMovementPower;// Thermal Movement Power 0-close 1-open
    BYTE         byEnablePtzPower;// Ptz Power 0-close 1-open
    BYTE         byPowerSavingControl;//0-resd 1-sleep 2-low
    BYTE        byCaptureWithSupplimentLightEnabled;//Enable snapshot light compensation enabled 0-close 1-open
    BYTE         byRes[244];
}NET_DVR_DEVSERVER_CFG, *LPNET_DVR_DEVSERVER_CFG;

typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD         dwSize;
    BYTE         byEnable;//28181 protcol enable ; 0-close 1-open 
    BYTE         byTransProtocol;//TransProtocol:0-UDP,1-TCP,default 0-UDP
    WORD         wLocalSipPort;//1024-65535(IPC)
    char         szServerID[MAX_SERVERID_LEN];
    char         szServerDomain[MAX_SIPSERVER_ADDRESS_LEN];
    char         szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN];
    WORD         wServerSipPort;
    BYTE         byProtocolVersion;//Protocol Version 0-GB/T28181-2011,1-GB/T28181-2015,2-GB/T28181-2016
    BYTE        byTCPConnectMod;
    char         szSipUserName[MAX_SERVERNAME_LEN];
    char         szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];
    char         szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];
    DWORD        dwRegisterValid;
    BYTE         byHeartbeatInterval;
    BYTE         byMaxHeartbeatTimeOut;
    BYTE         byStreamType;
    BYTE            byDeviceStatus; //Whether the equipment online, 0- reserve, 1- online, 2- offline 
    DWORD        dwRegisterInterval;//Registration: registration failure interval register again time interval, the range of 60-600s, the default 60s
    DWORD        dwAutoAllocChannelID; // whether to auto distribute channel ID , every bit has meaning, 0 - manual set, 1 - auto distribute, bit1-auto distribute code channel, bit2-auto distribute alarm in channel, bit3-auto distribute code channel ID
    char         szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN];//Device domain
    BYTE         byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG, *LPNET_DVR_GBT28181_ACCESS_CFG;


typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD                   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG, *LPNET_DVR_GBT28181_CHANINFO_CFG;


typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;
    BYTE  byRes[32];
}NET_DVR_ALARMIN_INFO, *LPNET_DVR_ALARMIN_INFO;


typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD                   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//dev Alarm input ID
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG, *LPNET_DVR_GBT28181_ALARMINCFG;
/*********************************IPC 5.1.0 end**************************************/

/*********************************Capture machineV2V3 begin**************************************/
typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD wSetupHeight; //Erecting height [0,20] units: meters
    BYTE byLensType; //The focal length of the lens type,0-unknow,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE bySetupHeightUnit;// Height 0 ~ M, 1~CM
    DWORD dwSceneDis; //Between the edge position and camera image under the horizontal distance, unit: cm
    float fPitchAngle; //Camera pitch angle [-180 , 180 ], float * 1000
    float fInclineAngle; //Camera tilt angle [-180 , 180 ], float * 1000
    float fRotateAngle;  //Camera rotation angle [-180 , 180 ], float * 1000
    WORD  wVideoDetCoefficient; //Video test coefficient [0300] (3.6 new)
    BYTE  byErectMethod; //Erection of 0- dress, 1- side mounted (3.6 new)
    BYTE  byCameraViewAngle;//The camera view (0- vertical, 1- inclined, (Default) 0- vertical)
    DWORD dwHorizontalDistance;//Camera Horizontal distance: 1-1000, (Default) 30, unit:cm, pay attention to the camera angle to tilt the effective
    BYTE  byDetailLensType;//Range: 1-100, Default: 28, unit: 0.1mm
    BYTE  byRes[3];
    float fHorFieldAngle; //[0, 360]
    float fVerFieldAngle; //[0, 360]
    float fLableSetupHeight; //[0-100]
    float fMaxViewRadius;//MaxViewRadius,0-10000.00m,default:5000.
    BYTE  byRes1[16];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

typedef struct tagNET_DVR_SCHEDDATE
{
    BYTE   byStartMonth;   //Start month
    BYTE   byStartDay;     //Start day
    BYTE   byStopMonth;    //Stop month
    BYTE   byStopDay;      //Stop day
}NET_DVR_SCHEDDATE, *LPNET_DVR_SCHEDDATE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{
    NET_DVR_SCHEDTIME struTime;  //Time when take effect
    BYTE byState;                //0-Off, 1-On
    BYTE byRes[11];              //Reserved
} NET_DVR_OUTPUT_SCHEDULE, *LPNET_DVR_OUTPUT_SCHEDULE;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{
    BYTE                     byEnable;    //0-Disable,1-Enable
    BYTE                     byRes1[3];   //Reserved
    NET_DVR_SCHEDDATE        struDate;    //Date in which this rule takes effect
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //Support max 8 time segments one day
    BYTE                     byRes2[16];  //Reserved
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE, *LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{
    DWORD  dwSize; //Structure size
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //Support max 8 date segments on year
    BYTE   byRes[64];  //Reserved
}NET_DVR_OUTPUT_SCHEDULE_RULECFG, *LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

//Traffic statistics alarm parameters
typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //Whether to enable traffic statistics alarm upload
    BYTE byRes1[3];    //
    DWORD dwInterval;//The Statistics interval (unit: minutes)
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;    //The alarm recording ID (used to query video only when byResultType 2)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;
/*********************************Capture machineV2V3 end**************************************/

/*********************************Capture machineV5 begin**************************************/
typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//wherein 1-4 represents a IO channel, specific, 0xff is not enabled
    BYTE  byCabinetState;//The 0- low level, the 1- high level
    BYTE  byAlarmIntervalTime;//The range of 1-60, unit: s
    BYTE  byRes1[25];
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0 not enabled, 1 enabled
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;
/*********************************Capture machineV5 end**************************************/

/*************************************TS-5XXX-L begin*******************************/
typedef  struct  tagNET_ITS_GATE_LANE_CFG
{
    BYTE      byGateSiteID[MAX_ID_LEN];    //Gate Numbers
    BYTE      byGateInfo[MAX_ID_LEN];      //Gate Info
    BYTE      byLaneName[NAME_LEN];
    BYTE      byValid;              //0 indicates whether to enable is not enabled, 1 to enable
    BYTE      byCamLaneId;     //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    WORD      wLaneid;            //Lane number 1 to 32 (index lane number, you can jump logic lane)
    BYTE      byRelativeIoNum;         //Logical lane number associated output port number      
    BYTE      byDirection;          //The direction number; 0 - 1 admission 2 3 appearances bidirectional
    BYTE      byLprMode; //Brand identification release all configuration 0 into 1 in addition to the blocklist into the allow list into
    BYTE       byCardMode; //The card release configuration 0 all into an addition to the blocklist into the allow list into
    BYTE       byGateLaneMode;//Release of entrances and exits configuration mode - all into 1 - only the brand identify matching release only credit card matching put / / line 3 - brand identification card has a matching release - brand identification card at the same time match release - all into
    //2013-11-19 Add Parameter
    BYTE      byCharge;//Charge 0- No Charge,1-Charge
    BYTE      byChargeMode;//Charge Mode 0-Plate Charge,1-Card Charge
    BYTE      byRes1;
    BYTE      byLedRelativeIndex[MAX_INDEX_LED];//LED Relative Index (1~255) 
    BYTE      byGateRelativeIndex;//Gate Relative Index
    BYTE      byFarRrRelativeIndex;// Far reader Relative Index
    BYTE      byRes[82];
}NET_ITS_GATE_LANE_CFG, *LPNET_ITS_GATE_LANE_CFG;

typedef    struct  tagNET_ITS_IPC_CHAN_LANE_CFG
{
    DWORD     dwSize;
    BYTE      byIpcType;  //0 - no, 1 - license plate capture, 2 - face capture, 3 - surveillance camera
    BYTE      byRes[135];
    NET_ITS_GATE_LANE_CFG  struGateLane[4];
}NET_ITS_IPC_CHAN_LANE_CFG, *LPNET_ITS_IPC_CHAN_LANE_CFG;

typedef    struct    tagNET_ITS_REMOTE_COMMAND
{
    WORD            wLaneid; //Lane number 1 to 32 (index lane number, you can jump)
    BYTE             byCamLaneId;    //The corresponding camera lane number from 1 to 16 (camera configuration lane number, you can jump, can be the same)
    BYTE            byRes;
    DWORD           dwCode;       //Command code 0x0 gate 0x1 closing, to be extended
    BYTE            byRes1[128];
}NET_ITS_REMOTE_COMMAND, *LPNET_ITS_REMOTE_COMMAND;

typedef  struct    tagNET_ITS_REMOTE_CONTROL_
{
    DWORD          dwSize;
    NET_ITS_REMOTE_COMMAND    struRemoteCommand;
}NET_ITS_REMOTE_CONTROL, *LPNET_ITS_REMOTE_CONTROL;

typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //Channel in the video - 0 no Record - 1 Record
    BYTE  bySignalStatic; //The connected signal state, 0 -normal, 1 - Loss of Signal
    BYTE  byHardwareStatic;//Channel hardware status, 0 - normal, 1 - exceptions, such as the DSP die
    BYTE  byChannelArmState; //Access IPC armed state
    DWORD dwChannel;
    DWORD dwBitRate;//The actual bit rate
    DWORD dwLinkNum;//The number of client connections
    NET_DVR_IPADDR struClientIP[MAX_LINK];//The client's IP address
    DWORD dwIPLinkNum;//If the channel is IP access, which means that the IP access this number of connections
    BYTE  byExceedMaxLink;    // Than 128 connections 0 - does not exceed 1 - beyond    
    BYTE  byRes[139];
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

/*************************************TS-5XXX-L end*******************************/

/*************************************PJ03C2013060554 park DS-TP5016-P begin*****************************/
typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 ~ close 1 ~ open
    BYTE   byFlicker;//0 ~ no flashing 1 ~ flashing 
    BYTE   byIOState;//0 ~ Low level  1 ~ Hight level (external light work)
    BYTE   byLampColor;
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0 ~ close 1 ~ open
    BYTE   byFlicker;//0 ~ no flashing 1 ~flashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work) 
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//car IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//no car IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//spacial car park IO level status
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//special no car park IO level status
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*External light off a message, a channel 4 largest parking Spaces (from left to right an array of 0 ~ 3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0 ~ close 1 ~ open
    BYTE   byFlicker;//0 ~ no flashing 1 ~flashing
    BYTE   byLampColor;//0-close 1-red 2-green 3-yellow 4-blue 5-magenta  6-cyan 7-white (lamp work) 
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //State 0 represents no car parking spaces, 1 representatives of car, 2 representative line (highest priority), 3 special parking spaces
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //Association parking lamp (0- built-in lamp, 1- external lamp 1, 2- external lamp 2, 3- external lamp 3)
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable;
    BYTE   byFlicker;
    BYTE   byLampColor;
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP;

typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;
    BYTE   byFlicker;
    BYTE   byLampColor;
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];
    BYTE byLampType;
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;

typedef union tagNET_DVR_LAMP_CTRL_MODE_UNION
{
    BYTE uLen[288];
    NET_DVR_INLAY_LAMP_CTRL_MODE struInlayLampCtrlMode;
    NET_DVR_EXTERNAL_LAMP_CTRL_MODE struExternalLampCtrlMode;
    NET_DVR_PARKLAMP_CTRL_MODE struParkLampCtrlMode[MAX_PARKING_NUM/*4*/];
    NET_DVR_MIXLAMP_CTRL_MODE  struMixLampCtrlMode;
    NET_DVR_SINGLELAMP_CTRL_MODE struSingleExternalLampCtrlMode;
}NET_DVR_LAMP_CTRL_MODE_UNION, *LPNET_DVR_LAMP_CTRL_MODE_UNION;

typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*Mode: 1-Lamp,2-external Lamp,3 - lamp && external lamp*/
    BYTE      byCtrlChannelIndex;/*Alternate control channel number*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

//Parking configuration properties (the default is normal) 
typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~normal Park 1~special Park
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//A channel 4 largest parking Spaces (from left to right an array of 0 ~ 3) 
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0~no flashing 1 ~ flashing
    BYTE      byParkingIndex;//ParkingNo 1~3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //ExterNal 0~no enable 1~enable
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

// the parking enforcement at most a channel 4 parking Spaces 
typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE       byParkIndex;/*Parking space number from left to right(0- said the current several parking spaces, will upload some pictures)1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD      dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;
    NET_DVR_TIME      struExternalBeginTime;
    BYTE      byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;
/*************************************PJ03C2013060554 park DS-TP5016-P end*******************************/

/*****************PJ03D2013112505 Entrance controller*********************/

/* Devices Type */
typedef enum tagEXTERNAL_DEVICES_TYPE
{
    DEVICES_TYPE_RES1 = 0,
    DEVICES_TYPE_FAR_SCR = 1,
    DEVICES_TYPE_ENTRANCE_CONTROL = 2,
    DEVICES_TYPE_WJ_LED_DEV = 3,
    DEVICES_TYPE_NJ_LED_DEV = 4,
    DEVICES_TYPE_VEH_DETECT_DEV = 5,
    DEVICES_TYPE_DZ_DEV = 6,
    DEVICES_TYPE_PX_SCR_DEV = 7,
    DEVICES_TYPE_KJ_SCR_DEV = 8,
    DEVICES_TYPE_FKJ_DEV = 9,
    DEVICES_TYPE_SKJ_DEV = 10,
    DEVICES_TYPE_HDD_DEV = 11,
    DEVICES_TYPE_DZ_LOCK = 12,
    DEVICES_TYPE_PAPER_PRINTER = 13,
    DEVICES_TYPE_PAPER_SCANNERS = 14,
    DEVICES_TYPE_IPC_ALARM = 15
}EXTERNAL_DEVICES_TYPE;

/* Devices Status */
typedef enum tagEXTERNAL_DEVICES_STATUS
{

    DEVICES_STATUS_NORMAL = 0,
    DEVICES_STATUS_ABNORMAL = 1,


    DEVICES_STATUS_TOO_LESS_CARD = 20,
    DEVICES_STATUS_NO_CARD = 21,
    DEVICES_STATUS_SENDCARD_ERROR = 22,
    DEVICES_STATUS_CARD_BLOCKED = 23,
    DEVICES_STATUS_CARD_FULL = 24,

    DEVICES_STATUS_OPENING = 40,
    DEVICES_STATUS_CLOSING = 41,
    DEVICES_STATUS_OPENED = 42,
    DEVICES_STATUS_CLOSED = 43,
    DEVICES_STATUS_NOSIGNAL = 44,
    DEVICES_STATUS_LOCK = 45,

    PP_STATUS_OFFLINE = 61,
    PP_STATUS_PRINT_HEADER_UP,
    PP_STATUS_FEED_BUTTON_FEEDING,
    PP_STATUS_ONLINE_WAITING,
    PP_STATUS_FEED_BUTTON_ENABLE,
    PP_STATUS_JAMR_PAPER_ERROR,
    PP_STATUS_CUT_PAPER_ERROR,
    PP_STATUS_AUTO_FEED_ERROR,
    PP_STATUS_EXIT_RECOVERY_ERROR,
    PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,
    PP_STATUS_PULL_PAPER_ERROR,
    PP_STATUS_LESS_PAPER,
    PP_STATUS_NO_PAPER,
    PP_STATUS_PRINT_FAIL,
    PP_STATUS_PRINTING,
}EXTERNAL_DEVICES_STATUS;

/* Devices Control Status */
typedef enum tagEXTERNAL_DEVICESCTRL_TYPE
{
    DEVICES_CTRL_RES = 0,        //Res
    DEVICES_CTRL_REMOTE = 1,     //Remote control
}EXTERNAL_DEVICESCTRL_TYPE;


typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1 vehicle illegal intrusion alarm
    //0x2 gateway timeout is not closed alarm
    //0x3 vehicle coil timeout
    //0x4 card alarm (no card)
    //0x5 card alarm (Defect card)
    //0x6 card (card abnormal alarm)
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//EXTERNAL_DEVICES_TYPE
    BYTE  byExternalDevStatus;//EXTERNAL_DEVICES_STATUS
    BYTE  byExternalDevCtrlType;//EXTERNAL_DEVICESCTRL_TYPE
    NET_DVR_TIME_V30  struAlarmTime;
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//Car License
            /*vehicle type 0- retains 1- fixed car, temporary 2- car, 3- car car booking, 4- levels, 5- authorized vehicles*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//(struAlarmType == 0x1)
    }uAlarmInfo;
    BYTE  byRes2[64];
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;

typedef struct tagNET_DVR_ALARMWIRELESSINFO
{
    BYTE     byDeviceID[NAME_LEN];   //device id
    float       fDataTraffic;    /* data traffic,unit:MB,retain two decimal places */
    BYTE      bySignalIntensity;  /* singnal intensity,0-100*/
    BYTE      byRes[127];
} NET_DVR_ALARMWIRELESSINFO, *LPNET_DVR_ALARMWIRELESSINFO;

/*****************PJ03D2013112505 Entrance controller*********************/

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;            //Phase A voltage
    int iPhaseBVol;            //Phase B voltage
    int iPhaseCVol;            //Phase C voltage
    int iAveragePhaseVol;    //Average of phase voltage
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;            //AB line voltage
    int iLineVolBC;            //BC line voltage
    int iLineVolCA;            //CA line voltage
    int iAverageLineVol;    //Average of line voltage
} NET_DVR_LINE_VOLTAGE, *LPNET_DVR_LINE_VOLTAGE;

typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;            //Phase A Current
    int iPhaseBCurrent;            //Phase B Current
    int iPhaseCCurrent;            //Phase C Current
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;            //Phase A Power
    int iPhaseBPower;            //Phase B Power
    int iPhaseCPower;            //Phase C Power
    int iSysTotalPower;            //System Total Power
}NET_DVR_POWER, *LPNET_DVR_POWER;

typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;        //Phase A Power Factor
    int iPhaseBPowerFactor;        //Phase B Power Factor
    int iPhaseCPowerFactor;        //Phase C Power Factor
    int iTotalPowerFactor;        //Total Power Factor
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;        //Phase A Frequency
    int iPhaseBFrequency;        //Phase B Frequency
    int iPhaseCFrequency;        //Phase C Frequency
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;        //Phase A Load Factor
    int iPhaseBLoadFactor;        //Phase B Load Factor
    int iPhaseCLoadFactor;        //Phase C Load Factor
    BYTE    byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE        struInputVoltage;    //input voltage
    NET_DVR_VOLTAGE        struBypassVoltage;    //bypass voltage
    NET_DVR_VOLTAGE        struOutputVoltage;    //output voltage
    int iRectifierVol;            //rectifier voltage
    int iInverterVol;            //inverter voltage

    NET_DVR_CURRENT    struInputCurrent;    //input current
    NET_DVR_CURRENT    struBypassCurrent;    //bypass current
    NET_DVR_CURRENT    struOutputCurrent;    //output current
    int iInverterCurrent;        //inverter current

    NET_DVR_FREQUENCY    struInputFrequency;        //input frequency
    NET_DVR_FREQUENCY    struBypassFrequency;    //bypass frequency
    NET_DVR_FREQUENCY    struOutputFrequency;    //output frequency
    int iInverterFre;            //inverter frequency

    NET_DVR_POWER         struInputPower;    //input power
    NET_DVR_POWER        struBypassPower;//bypass power
    NET_DVR_POWER        struOutputPower;//output power
    NET_DVR_POWER        struComplexPower;//complex power

    int iNormalPower;            //normal power
    int iPowerFacter;            //power factor

    NET_DVR_LOAD_FACTOR    struBatteryLoadFactor;    //battery load factor
    int iBatteryEstimated;        //battery estimated time
    int iBatteryTemperature;    //battery temperature
    int iBatteryVoltage;            //Battery Voltage


    BYTE    byRectifierState;        //Rectifier State 1-normal 2-abnormal 
    BYTE    byInverterState;        //Inverter State 1-normal 2-abnormal
    BYTE    byChargeState;        //Charge State 1-normal 2-abnormal
    BYTE    byBatteryState;        //Battery State 1-normal 2-abnormal
    BYTE    byAutoBypassState;    //Auto Bypass State 1-normal 2-abnormal
    BYTE    byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE;

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE        struACVoltage;    //AC Voltage
    int     iDCConvertVoltage;    //DC Convert Voltage    
    NET_DVR_CURRENT        struACCurrent;    //AC Current
    int     iTotalCurrent;            //Total Current
    int     iBattery1Temperature;    //Temperature of Battery 1
    int     iBattery2Temperature;    //Temperature of Battery 2
    int     iBattery1Current;        //Current of Battery 1
    int     iBattery2Current;        //Current of Battery 2
    int     iBattery3Current;        //Current of Battery 3
    int     iBattery4Current;        //Current of Battery 4
    int     iBatteryTestVoltage;    //test voltage of battery
    int     iRectifierOutputVoltage;    //Rectifier Output Voltage
    int     iRectifierOutputCurrent;    //Rectifier Output Current
    int     iDCOutputVoltage;        //DC Output Voltage
    BYTE    byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE,
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int        iSF6;            //unit:ppm
    int      iFlow;           //unit:ml/min       
    int        iTemperature;
    int        iO2;            //unit:%
    int        iHumidity;        //unit:%
    BYTE    byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,
*LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int        iTemperature;    //unit: 'c
    int        iHumidity;        //unit: %
    BYTE    byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int        iTemperature;    //unit: 'c
    int        iHumidity;        //unit: %
    BYTE   byRunState;        //1-running,2-stop
    BYTE    byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;


typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int        iDCVoltage;        //DC Voltage
    int        iDCCurrent;        //DC Current
    NET_DVR_VOLTAGE        struPhaseVoltage;    //Phase Voltage
    NET_DVR_LINE_VOLTAGE struLineVoltage;    //Line Voltage
    NET_DVR_CURRENT    struCurrent[4];        //current,struCurrent[0] means the current of first load 
    int iAverageCurrent;        //Average Current
    int iNeutralCurrent;        //Neutral Current
    NET_DVR_POWER    struActivePower[4];    //Active Power struActivePower[0]means the active power of first load
    NET_DVR_POWER    struReactivePower[4];    //Reactive Power struReactivePower[0] means the reactive power of first load
    NET_DVR_POWER    struApparentPower[4];    //Apparent Power struApprentPower[0]means the apparent power of first load
    NET_DVR_POWER_FACTOR    struPowerFactor[4];    //Power Factor,struPowerFactor[0]means the power factor of first load
    NET_DVR_FREQUENCY        struFrequency;            //Frequency
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int        iPhaseATemperature;        //phase A temperature
    int        iPhaseBTemperature;        //phase B temperature
    int        iPhaseCTemperature;        //phase C temperature
    int        iPhaseDTemperature;        //phase D temperature
    BYTE     byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;


//water level sensor
typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG    iWaterLevel;        //water level
    BYTE    byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//dust and noise sensor
typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG    iDust;        //dust
    LONG    iNoise;       //noise
    LONG    iPM25;        //PM2.5
    BYTE    byRes[500];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//environment logger
typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG    iAmmoniaNitrogen;    //Ammonia and Nitrogen
    LONG    iCOD;                //COD
    LONG    iPH;                //PH
    LONG    iOxygen;            //Oxygen
    LONG    iSulfurDioxide;    //Sulfur Dioxide
    LONG    iSoot;            //Soot
    LONG    iFluoride;        //Fluoride
    LONG    iPollutedWater;    //Polluted Water
    LONG    iTotalPhosphorus;    //Total Phosphorus
    LONG    iExhaust;            //Exhaust
    LONG    iNitrogenOxides;    //Nitrogen Oxides
    LONG    iFlueGasTemperature;//Flue Gas Temperature
    LONG    iFlueGasPressure;    //Flue Gas Pressure
    LONG 	iDustThickness;
    LONG 	iAirCleanLevel;
    LONG 	iPm10Thickness;
    BYTE	byRes[448];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

typedef struct
{
    int  iWindSpeed;
    BYTE   byRes[508];
}NET_DVR_WIND_SPEED_STATE, *LPNET_DVR_WIND_SPEED_STATE;

typedef struct
{
    BYTE byOutPutState1;
    BYTE byOutPutState2;
    BYTE byOutPutState3;
    BYTE byOutPutState4;
    BYTE byOutPutState5;
    BYTE byOutPutState6;
    BYTE Res[506];
}NET_DVR_GENERATE_OUTPUT_STATE, *LPNET_DVR_GENERATE_OUTPUT_STATE;

typedef struct
{
    int  iWaterLogVal;
    int  iLeakResist1;
    int  iTotolResist1;
    int  iLeakResist2;
    int  iTotolResist2;
    BYTE   byWaterLogAlarm;
    BYTE   byLeakAlarm1;
    BYTE   byFaultAlarm1;
    BYTE   byLeakAlarm2;
    BYTE   byFaultAlarm2;
    BYTE   byRes[487];
}NET_DVR_SOAK_STATE, *LPNET_DVR_SOAK_STATE;

typedef struct
{
    int  iChangerVolInput;
    int  iChangerCurInput;
    int  iChangerPwInput;
    int  iChangerVolOutput;
    int  iChangerCurOutput;
    int  iChangerPwOutput;
    int  iDischangerVolOutput;
    int  iDischangerCurOutput;
    int  iDischangerPwOutput;
    int  iDevTemperatrue;
    BYTE   byBatteryVolState;
    BYTE   byBatteryTmpState;
    BYTE   byChangerVolInputState;
    BYTE   byChangerRunState;
    BYTE   byChangerChgState;
    BYTE   byBatteryVolFlt;
    BYTE   byBatteryTmpFlt;
    BYTE   byBatteryResistanceFlt;
    BYTE   byVolRcgFlt;
    BYTE   byChangerVolInputFlt;
    BYTE   byChangerMosShort;
    BYTE   byChangerAntiOrMosShort;
    BYTE   byChangerAntiShort;
    BYTE   byInputOverCur;
    BYTE   byLoadOverCur;
    BYTE   byLoadShort;
    BYTE   byLoadMosShort;
    BYTE   byChangerFlt;
    BYTE   byRes[454];
}NET_DVR_SOLAR_POWER_STATE, *LPNET_DVR_SOLAR_POWER_STATE;

typedef struct
{
    int  iSf6Thick1;
    int  iO2Thick1;
    int  iTemprature1;
    int  iHumidity1;
    int  iSf6Thick2;
    int  iO2Thick2;
    int  iTemprature2;
    int  iHumidity2;
    int  iSf6Thick3;
    int  iO2Thick3;
    int  iTemprature3;
    int  iHumidity3;
    int  iSf6Thick4;
    int  iO2Thick4;
    int  iTemprature4;
    int  iHumidity4;
    int  iSf6Thick5;
    int  iO2Thick5;
    int  iTemprature5;
    int  iHumidity5;
    int  iSf6Thick6;
    int  iO2Thick6;
    int  iTemprature6;
    int  iHumidity6;
    int  iSf6Thick7;
    int  iO2Thick7;
    int  iTemprature7;
    int  iHumidity7;
    int  iSf6Thick8;
    int  iO2Thick8;
    int  iTemprature8;
    int  iHumidity8;
    int  iSf6Thick9;
    int  iO2Thick9;
    int  iTemprature9;
    int  iHumidity9;
    int  iSf6Thick10;
    int  iO2Thick10;
    int  iTemprature10;
    int  iHumidity10;
    int  iSf6Thick11;
    int  iO2Thick11;
    int  iTemprature11;
    int  iHumidity11;
    int  iSf6Thick12;
    int  iO2Thick12;
    int  iTemprature12;
    int  iHumidity12;
    BYTE   byFanState1;
    BYTE   byFanState2;
    BYTE   byFanState3;
    BYTE   byFanState4;
    BYTE   byFanState5;
    BYTE   byFanState6;
    BYTE   byFanState7;
    BYTE   byFanState8;
    BYTE   byFanState9;
    BYTE   byFanState10;
    BYTE   byFanState11;
    BYTE   byFanState12;
    BYTE   byRes[308];
}NET_DVR_SF6_ALARMHOST_STATE, *LPNET_DVR_SF6_ALARMHOST_STATE;


typedef struct
{
    int  iWeight;
    BYTE   byRes[508];
}NET_DVR_WEIGHT_STATE, *LPNET_DVR_WEIGHT_STATE;

typedef struct
{
    int  iAirTemperature;
    DWORD  dwAirHumidity;
    DWORD  dwWindSpeed;
    DWORD  dwWindDirection;
    DWORD  dwIlluminationIntensity;
    DWORD  dwCO2;
    DWORD  dwPM25;
    DWORD  dwAirPressure;
    int  iSoilTemperature;
    DWORD  dwSoilHumidity;
    DWORD  dwIsRainSnow;
    BYTE   byRes[468];
}NET_DVR_WEATHER_STATION_STATE, *LPNET_DVR_WEATHER_STATION_STATE;

typedef struct
{
    DWORD  dwTurbidity;
    DWORD  dwChlorine;
    DWORD  dwPH;
    BYTE   byRes[500];
}NET_DVR_WATER_QLT_STATE, *LPNET_DVR_WATER_QLT_STATE;

typedef struct
{
    int  iNatrualGasThick;
    BYTE   byRes[508];
}NET_DVR_FUEL_GAS_DETE_STATE, *LPNET_DVR_FUEL_GAS_DETE_STATE;

//fire alarm host state information
typedef struct tagNET_DVR_FIRE_ALARM_STATUS
{
    BYTE  byFireAlarm[MAX_FIRE_ALARM_ZONE][MAX_FIRE_ALARM_POINT_ZONE];         //fire status, 1-normal, 2-alarm
    BYTE  byRes[128];   //reserve
}NET_DVR_FIRE_ALARM_STATUS, *LPNET_DVR_FIRE_ALARM_STATUS;


typedef union tagNET_DVR_EXTERNAL_DEVICE_STATE_UNION
{
    NET_DVR_ALARMHOST_UPS_STATE struUpsState;        //UPS state
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE struSwitchPowerState;//switch power state
    NET_DVR_ALARMHOST_GAS_DETECTOR_STATE struGasDetectorState;//gas detector state
    NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE struTempHumiSensorState;//TH Sensor state
    NET_DVR_ALARMHOST_AIRCONDITION_STATE struAirConditionState;//air condition state
    NET_DVR_ALARMHOST_ELECTRICITY_STATE struElectricityState;//electricity state
    NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE struTransformerTempState;    //transformer state
    NET_DVR_ALARMHOST_WATERLEVEL_SENSOR struWaterLevelSensor;//water level sensor
    NET_DVR_ALARMHOST_DUSTNOISE_SENSOR struDustNoiseSensor;//dust and noise sensor
    NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER struEnvironmentLogger;//environmental logger
    NET_DVR_WIND_SPEED_STATE struWindSpeedState; //wind speed sensor status
    NET_DVR_GENERATE_OUTPUT_STATE struGenerateOutputState; //generate output control
    NET_DVR_SOAK_STATE struSoakState; //flooding sensor status
    NET_DVR_SOLAR_POWER_STATE struSolarPowerState; //solar power controller status
    NET_DVR_SF6_ALARMHOST_STATE struSF6AlarmHostState; //SF6 alarm host status
    NET_DVR_WEIGHT_STATE struWeightState; //weighing apparatus condition
    NET_DVR_WEATHER_STATION_STATE struWeatherStationState; //the state of meteorological acquisition system
    NET_DVR_WATER_QLT_STATE struWaterQltState; //status of water quality monitor
    NET_DVR_FUEL_GAS_DETE_STATE struFuelGasDeteState; //gas monitoring system status 
    NET_DVR_FIRE_ALARM_STATUS struFireAlarmStatus; //fire alarm host status
    BYTE    byRes[512];
} NET_DVR_EXTERNAL_DEVICE_STATE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS state,2-switch power state 3-gas detector state,4-TH Sensor state,5-air condition state,6-electricity state,7-transformer state, 
    //8-water level sensor,9-dust and noise sensor,10-environment logger,11-wind speed sensor status,12-generate output control,13-flooding sensor status,14-solar power controller status,15-SF6 alarm host status,
    //16-weighing apparatus condition,17-the state of meteorological acquisition system,18-status of water quality monitor,19-gas monitoring system status,20-fire alarm host status
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE    byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;

typedef struct
{
    DWORD dwSize;
    BYTE byOutPutState1;
    BYTE byOutPutState2;
    BYTE byOutPutState3;
    BYTE byOutPutState4;
    BYTE byOutPutState5;
    BYTE byOutPutState6;
    BYTE byOperateType;
    BYTE Res[65];
}NET_DVR_GENERATE_OUTPUT_CTRL, *LPNET_DVR_GENERATE_OUTPUT_CTRL;

typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;        //input voltage of high limit
    int iInputVolLow;        //input voltage of low limit
    int iInputFreHigh;        //input frequency of high limit
    int iInputFreLow;        //input frequency of low limit
    int iOutputVolHigh;        //output voltage of high limit
    int iOutputVolLow;        //output voltage of low limit
    int iBatteryVoltageLow;    //battery voltage low
    int iBatterySurplus;        //battery surplus low
    int iBatteryTemperatureHigh;//Battery temperature High
    BYTE    byRes[64];            //res
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;    //high limit value of temperature
    int iTemperatureLowLimit;    //low limit value of temperature
    int iHumidityHighLimit;        //high limit value of humidity
    int iHumidityLowLimit;        //low limit value of humidity
    BYTE    byRes[84];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

typedef union tagNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION
{
    NET_DVR_ALARMHOST_UPS_LIMIT_VALUE struUpsLimitValue;
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE struTempHumidityLimitValue;
}NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS,2-TH Sensor
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE    byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

#define    ALARMHOST_ALARMOUT_NUM    64  //max trigger number
#define  MAX_OSD_UNIT_LEN   8    //OSD unit lenght
typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD         dwSize;
    BYTE        bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];
    BYTE        bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];
    BYTE        bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//sensor joint alarmout by alarm type,it is expend from bySensorJointAlarmOut.array index if trigger no.,every bit is a alarm type,1-limit1;2-limit2;3-limit3;4-limit4;5-fault
    BYTE        bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //siren joint alarmout by alarm type,it is expend from bySensorJointAlarmOut.array index if trigger no.,every bit is a alarm type,1-limit1;2-limit2;3-limit3;4-limit4;5-fault
    BYTE        byChan;        //chan number
    BYTE        byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE    byAlarmType;/*alarm type:1.phase A input voltage out of limit value 2.phase B input voltage out of limit value 3.phase C input voltage out of limit value
    4.phase A output voltage out of limit value 5.phase B output voltage out of limit value 6.phase C output voltage out of limit value 7.phase A input frequency out of limit value 8.phase B input frequency out of limit value9.phase C input frequency out of limit value
    10.Rectifier voltage out of limit value 11.overoad alarm 12.battery voltage low 13.battery supplus low 14.battery tempetature high 15.inverter close
    16.auto bypass open 17.Rectifier fault 18.inverter fault 19.charger fault    20.battery fault     21.auto bypass fault */
    BYTE    byChanNo;    //485 channel no
    BYTE   bySlotNo;    //485 slot no
    BYTE    byRes1;
    int         iAlarmValue;    //alarm value
    BYTE    byRes2[64];        //res
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE    byAlarmType;    /*alarm type:1-battery test fail  2-AC-DC fault,3-AB/A out of limit,4-BC/B out of limit,5-CA/C out of limit,6-output current A out of limit,
    7-output current B out of limit,8-output current C out of limit,9-rectifier module fault,10-fan fault,11-DC voltage out of limit*/
    BYTE    byChanNo;        //485 Channel No
    BYTE    bySlotNo;        //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;    //alarm value
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO,
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE    byAlarmType;    /*alarm type:1- SF6 content abnormal,2-O2 content abnormal,3-temperature abnormal 4-humidity abnormal 5-Flow abnormal*/
    BYTE    byChanNo;    //485 Channel No, start from 1
    BYTE    bySlotNo;    //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;        //alarm value
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO,
*LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE    byAlarmType;    //1-temperature abnormal,2-humidity abnormal
    BYTE    byChanNo;        //485 Channel No
    BYTE    bySlotNo;        //485 Slot No
    BYTE    byRes1;
    int     iAlarmValue;    //alarm value
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

typedef union  tagNET_DVR_485_DEVICE_ALARM_UNION
{
    NET_DVR_ALARMHOST_UPS_ALARMINFO struUPSAlarm; //UPS alarm
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO struSwitchPowerAlarm; //Switch power alarm
    NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO struGasDetectSystemAlarm; //gas detector alarm
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO struTempHumiditySensorAlarm; //TH Sensor alarm
    BYTE    byRes[72];
} NET_DVR_485_DEVICE_ALARM_UNION, *LPNET_DVR_485_DEVICE_ALARM_UNION;

typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE    byAlarmType;    //1-UPS Alarm,2-Switch power alarm,3-gas detector alarm,4-TH Sensor alarm
    BYTE    byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE    byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD       dwSize;
    BYTE        sDeviceName[NAME_LEN];     // device name
    WORD        wDeviceType;            // ALARM_FRONT_DEVICE_TYPE
    WORD        wDeviceProtocol;        // device protocol
    WORD        wAddress;                // device address    
    BYTE        byChannel;          //485 channel
    BYTE        bySlotChan;         //slot chan
    BYTE        byRes[60];                // res
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    WORD                 wYear;
    BYTE                 byMonth;
    BYTE                byDrawFrame;    // 0-Do not draw frame 1-draw frame
    BYTE                byStreamType;   //0-main 1-stream
    BYTE				byLocalOrUTC;  	//0-local  1-UTC
    BYTE                byRes[30];            
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{
    DWORD            dwSize;
    BYTE            byRecordDistribution[LEN_32];
    BYTE            byHasEventRecode[LEN_31];
    BYTE            byRes;
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;


//Corridor Mode
typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD        dwSize;
    BYTE        byEnableCorridorMode; // Modes 0 to enable or disable the corridor is not enabled, 1 to enable
    BYTE        byMirrorMode;            //Mirror Mode 0-Cosed; 1-Left and right; 2The upper and lower; 3 intermediate
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

//Face Detect
typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD     dwSize;
    BYTE     byEnableDetectFace; //Whether to enable 0 to enable, 1 to enable
    BYTE     byDetectSensitive; //Sensitivity 10 Level 1 to 10
    BYTE     byEnableDisplay;    /*Enable motion detection to highlight, 0 - no, 1 - yes*/
    BYTE     byRes;
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*Treatment*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*Arming Time */
    DWORD    dwMaxRelRecordChanNum;     //Alarm triggered video channel (read-only) the maximum number of support
    DWORD    dwRelRecordChanNum;     //Number of alarm-triggered video channel support
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];    /* Alarm triggered video channel*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday time
    WORD     wDuration;  //duration
    BYTE     byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD        dwSize;
    DWORD       dwGroup;
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg;
    BYTE         byRes[64];
}NET_DVR_MUL_STREAM_CHANNEL_GROUP, *LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD        dwSize;
    DWORD       dwChannel;
    DWORD       dwGroup;
    BYTE        byID;//Dev Region Setint ID 
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //Position No.
    BYTE        byRes[56];
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;

typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //Sched Time
    BYTE   byDetSceneID;//Scence ID [1,4],IPC: 0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION, *LPNET_DVR_TIME_DETECTION;

//Conditions
typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    /*
    0 Invalid,
    1 VIA Mode;
    2 HVT Mode
    */
    BYTE   byRelateType;
    BYTE   byGroupNo;
    BYTE   byRes[62];
}NET_DVR_GUARD_COND, *LPNET_DVR_GUARD_COND;

//Capture trigger mode support association Alarm time and Upload Center
typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //Alarm Time
    NET_DVR_TIME_DETECTION    struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode
    DWORD  dwMaxRelRecordChanNum;
    DWORD  dwRelRecordChanNum;
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30];
    BYTE   byDirection;//direction: 0-res,1-both,2-forward,3-reverse
    BYTE   byRes[87];
}NET_DVR_GUARD_CFG, *LPNET_DVR_GUARD_CFG;

typedef    struct  tagNET_DVR_SNAPINFO_COND_
{
    DWORD    dwSize;
    DWORD    dwChan;
    /*
    0 MPR Mode
    1 HVT Mode
    ...
    */
    BYTE     byRelateType;
    BYTE     byRes[63];
}NET_DVR_SNAPINFO_COND, *LPNET_DVR_SNAPINFO_COND;

//Snap Picture Info
typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0- picture Quality, 1- Picture size
    BYTE  byPicQuality;//picture Quality[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//Picture size[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG, *LPNET_DVR_SNAPINFOCFG;

//ptz Track Mode
typedef enum _PTZ_TRACK_MODE_
{
    PTZ_TRACK_MODE_ALWAYS = 1,   //Track always
    PTZ_TRACK_MODE_BYTIME = 2,   //Track for a specified time
    PTZ_TRACK_MODE_NEXT = 3,   //Track next targets when it appears
}PTZ_TRACK_MODE;

//ptz track parameters
typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //Structure size
    BYTE  byTrackMode; //Track mode,refer to PTZ_TRACK_MODE
    BYTE byLinkageTarget; //Linkage Target 0-default,1-IPD1
    BYTE byAutoTrackEnable;//Auto Track enable 0-open,1-close
    BYTE byRes1; //Res
    DWORD dwTrackTime; //Track time
    //When PTZ_TRACK_MODE_ALWAYS,this filed is not used
    //When PTZ_TRACK MODE_BYTIME,range[1,60],default 10 seconds
    //When PTZ_TRACK MODE_NEXT,range[1,10],default 2 seconds
    BYTE  byRes2[256]; //Reserved
}NET_DVR_PTZ_TRACK_PARAM, *LPNET_DVR_PTZ_TRACK_PARAM;

#define MAX_ALERTLINE_NUM    8 //Max alter line number
typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byEnableDualVca;// enable dual vca 0-disable,1-enable
    BYTE    byEnableHumanMisinfoFilter;//0-false 1-true
    BYTE    byEnableVehicleMisinfoFilter;//0-false 1-true
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception
    DWORD  dwMaxRelRecordChanNum;
    DWORD  dwRelRecordChanNum;
    DWORD byRelRecordChan[MAX_CHANNUM_V30]; //Channel triggered to record
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday time 
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;

#define MAX_INTRUSIONREGION_NUM    8 //Max field number
typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE byEnableDualVca;// enable dual vca 0-disable,1-enable
    BYTE byEnableHumanMisinfoFilter;//0-false 1-true
    BYTE byEnableVehicleMisinfoFilter;//0-false 1-true
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception
    DWORD  dwMaxRelRecordChanNum;
    DWORD  dwRelRecordChanNum;
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//Channel triggered to record
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //holiday Schedule time
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;    //Stream type, 0 - the main stream, 1 - sub-stream, 2 - the type of event, 3 - stream 3, ...
    DWORD   dwRoiFixNum; //The total number of fixed area to determine the follow-up once again to obtain the group number
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC now supports four ball machine now supports 24
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//The fixed ROI region name
    DWORD   dwRoiTrackNum; //The total number of automatic tracking area, to determine the follow-up once again to get the group number
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC now supports four ball machine now supports 24
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;

typedef  enum  _DETECT_ROI_TYPE_
{
    DETECT_FIX_ROI = 0, //Detection ROI fixed area
    DETECT_TRACK_ROI = 1 //Automatic detection ROI tracking area
}DETECT_ROI_TYPE;

typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //The area detection number one PTZ support 4
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg;
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE 
    BYTE    byRoiDetectTrackType;//When a fixed region, this field is invalid; tracking area 1 to the face detection (IPC), 2 to the moving object tracking,3-Plate tracking
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND, *LPNET_DVR_ROI_DETECT_COND;


typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI fixed area mode is enabled 0 to enable, 1 to enable
    BYTE  byImageQualityLevel; //Image quality to enhance the level 1 to 6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;


typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI automatic tracking mode is enabled 0 to enable, 1 to enable
    BYTE  byImageQualityLevel; //Image quality to enhance the level 1 to 6
    BYTE  byModeType;//0 to 1 to face mode (mobile and stationary objects), 2 to moving object tracking (moving objects),3-Plate tracking
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;

typedef union tagNET_DVR_ROI_DETECT_UNION
{
    DWORD      uLen[128];
    NET_DVR_ROI_FIX_RECT_CFG   strRoiFixRectCfg;
    NET_DVR_ROI_TRACK_RECT_CFG   strRoiTrackRectCfg;
}NET_DVR_ROI_DETECT_UNION, *LPNET_DVR_ROI_DETECT_UNION;

typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;
    DWORD       dwStreamType;    //Stream type - the main stream, 1 - sub-stream, 2 - the type of event, 3 - stream 3, ...
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE 
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo;
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

//defouce detection
typedef struct tagNET_VCA_DEFOCUSPARAM
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE  bySensitiveLevel;// 1-100,default 50,The higher sensitivity to alarm easier
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM, *LPNET_VCA_DEFOCUSPARAM;

/************************VQD iVMS-6200(D) V2.1.0 begin***********/
typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad;    ///< CPU :0-100
    BYTE       byMemLoad;    ///< Memory :0-100
    WORD       wAbility;    ///< DEV Ablity
    WORD       wRemainAbility;    ///<last Ablity
    WORD       wTotalPlanNum;      ///<max plan 64>
    WORD       wCurPlanNum;  ///<current plan num>
    BYTE       byRes[62];
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;       ///     
    BYTE   byDevType;         //:0-no PTZ dev,1-PTZ dev
    BYTE   bySignalPoint;   ///< 0-100
    BYTE   byBlurPoint;    ///< 0-100
    BYTE   byLumaPoint;    ///< 0-100
    BYTE   byChromaPoint;    ///< 0-100
    BYTE   bySnowPoint;    ///< 0-100
    BYTE   byStreakPoint;    ///< 0-100
    BYTE   byFreezePoint;    ///< 0-100
    BYTE   byPTZPoint;    ///< 0-100
    BYTE   byMonitorDel;  //< 0-no del, 1-del
    BYTE   byContrastThreshold; //Contrast Threshold, 0-100
    BYTE   byMonoThreshold;     //Mono Threshold, 0-100
    BYTE   byShakeThreshold;    //Shake Threshold, 0-100
    BYTE   byFlashThreshold;    //Flash Threshold, 0-100
    BYTE   byCoverThreshold;    //Cover Threshold, 0-100
    BYTE   bySceneThreshold;    //Scene Threshold, 0-100
    BYTE   byDarkThreshold;     //Dark Threshold, 0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];    ///< streamId,
    char  sMonitorIP[64];  ///< 
    DWORD  dwChanIndex;  ///<  
    DWORD  dwWidth;  ///< 
    DWORD  dwHeight;  ///< 
    NET_DVR_TIME  struCheckTime;  ///<:2012-08-06 13:00:00
    BYTE  byResult;  ///0-no check 1-norm 2 - abnormal 3 - Login failed - to take flow anomaly
    BYTE  bySignalResult; ///< video loss detection results 0 - 1 - normal - not detected abnormal
    BYTE  byBlurResult;  ///< image blur detection results 0 - not detected 1 - normal - abnormal
    BYTE  byLumaResult;  ///< brightness anomaly detection results 0 - 1 - normal 2 not detected - abnormal
    BYTE  byChromaResult;  ///< the cast test results, 0 - 1 - normal - not detected abnormal
    BYTE  bySnowResult;  ///< the snow point interference detection results 0 - not detected 1 - normal - abnormal
    BYTE  byStreakResult;  ///< the fringe interference detection results 0 - not detected 1 - normal - abnormal
    BYTE  byFreezeResult;  ///< screen freeze test results 0 - 1 - normal - not detected abnormal
    BYTE  byPTZResult;  ///< the PTZ test results, 0 - 1 - normal - not detected abnormal
    BYTE  byContrastResult;     //Contrast result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byMonoResult;         //Mono result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byShakeResult;        //Shake result, 0-not detected, 1-normal, 2-abnormal
    char  sSNapShotURL[256];    ///<pic URL address
    BYTE  byFlashResult;        //Flash result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byCoverResult;        //Cover result, 0-not detected, 1-normal, 2-abnormal
    BYTE  bySceneResult;        //Scene change result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byDarkResult;         //Dark result, 0-not detected, 1-normal, 2-abnormal
    BYTE  byStreamType;            //stream type, 0-invalid, 1-unknown, 2-national standard type, 3-not national standard type
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST
{
    NET_DVR_STREAM_INFO  struStreamInfo;
    char   sSnapShotURL[256];
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO
{
    DWORD  dwSize;
    char   sStreamID[32];
    DWORD  dwPicLength;
    BYTE   byStatus;
    BYTE   byRes[31];
    char   *pSnapShot;      ///< (700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];    ///
    NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];    ///<  
    BYTE    byPlanMode;  ///0: immediate plans: cycle plan
    BYTE    byRes1;//     
    BYTE    byCheckFlag;  ///< detected, 0 - not detected, 1 - detection
    BYTE    bySignal;  ///<video loss is detected, 0 - do not detect, 1 - detection
    BYTE    byBlur;  ///< image blurring is detected, 0 - does not detect, 1 - detection
    BYTE    byLuma;  ///< brightness whether the abnormality is detected, 0 - does not detect 1 - detection
    BYTE    byChroma;  ///< whether the color cast detection detection, 0 - not detected, 1 - detection
    BYTE    bySnow;  ///<snowflake points interference is detected, 0 - does not detect, 1 - detection
    BYTE    byStreak;  ///<whether the stripes interference is detected, 0 - not detected, 1 - detection
    BYTE    byFreeze;  ///<whether the screen freezes detection, 0 - not detected, 1 - detection
    BYTE    byPTZ;  ///<the PTZ whether detection, 0 - does not detect 1 - detection
    BYTE    byEnablePlanRound;  ///plan cycle is on
    BYTE    byContrast;  //Contrast detection, 0 - does not detect 1 - detection
    BYTE    byMono;      //Mono detection, 0 - does not detect 1 - detection
    BYTE    byShake;     //Shake detection, 0 - does not detect 1 - detection
    BYTE    byFlash;     //Flash detection, 0 - does not detect 1 - detection
    BYTE    byCover;     //Cover detection, 0 - does not detect 1 - detection
    BYTE    byScene;     //Scene detection, 0 - does not detect 1 - detection
    BYTE    byDark;      //Dark detection, 0 - does not detect 1 - detection
    BYTE    byRes[13];
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;

typedef struct tagNET_PTZ_INFO_EX
{
    float fPan;//P[0,360.000]
    float fTilt; //Z[-90.000,90.000]
    float fVisibleZoom;//Vzoom [0,10000.0]
    DWORD dwVisibleFocus;//Vfocus[0,65535]
    float fThermalZoom;//Tzoom[0,10000.0]
    DWORD dwThermalFocus;//Tfocus[0,65535]
}NET_PTZ_INFO_EX, *LPNET_PTZ_INFO_EX;

//IPC5.1.0
typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD  wPresetNum; //the number of preset 
    BYTE  byRes1[2];
    char  byName[NAME_LEN]; //the name of name
    WORD wPanPos;//The level of parameter If access to the data of more than 360 minus 360 by default 
    WORD wTiltPos;//The vertical parameters If access to the data of more than 360 minus 360 by default 
    WORD wZoomPos;//Variable times parameters if access to the data of more than 360 minus 360 by default 
    BYTE byRes2;
    BYTE byPTZPosExEnable; //0-NO 1-YES
    NET_PTZ_INFO_EX struPtzPosEx;// ptz EX
    BYTE byRes[32];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;

typedef struct
{
    NET_DVR_SCHEDTIME struSchedTime; //time
    WORD  wAction;  ///< action for schdule
    WORD  wActionNum; ///< the child number of action
    BYTE byres[12];
}NET_DVR_SCHEDTASK, *LPNET_DVR_SCHEDTASK;

typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///1-open,0-close
    BYTE byRes[3];    ///
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];
    DWORD dwParkTime;   ///< park time 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK, *LPNET_DVR_TIME_TASK;

typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;
    DWORD dwChannel;           //channelNo
    DWORD dwIndex;             //Index
    BYTE  byRes[64];
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;
    char  cName[NAME_LEN];          //name
    BYTE  byRes[64];
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

//Logon device param
typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{
    DWORD  dwSize;       //Structure size
    BYTE   byMobileDev;  //Device type, 0- Not mobile device, 1 - Mobile device
    BYTE   byRes[63];    //Reserved            
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;

typedef enum RECV_DATA_TYPE
{
    ENUM_RECV_ERRCODE = 0x0, //return ErrCode
} RECV_DATA_TYPE;

//Stream output mode
typedef enum tagFISHEYE_STREAM_OUTPUT_MODE_
{
    FISHEYE_STREAM_MODE_FISHEYE = 1,   //Fisheye
    FISHEYE_STREAM_MODE_PTZ = 2,   //PTZ
    FISHEYE_STREAM_MODE_PANORAMA = 3    //Panorama
}FISHEYE_STREAM_OUTPUT_MODE;

//Callback data type
typedef enum _CALLBACK_TYPE_DATA_ENUM_
{
    ENUM_FISHEYE_STREAM_STATUS = 1,  //Stream output status
    ENUM_FISHEYE_PTZPOS = 2,  //ptz position of current channel under the picture of fishieye
    ENUM_FISHEYE_REALTIME_OUTPUT = 3   //Realtime output mode
}CALLBACK_TYPE_DATA_ENUM;

//Fisheye stream status
typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{
    DWORD  dwSize;        //Structure size
    BYTE   byStreamMode;  //Stream output mode,refer to FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //Reserved
}NET_DVR_FISHEYE_STREAM_STATUS, *LPNET_DVR_FISHEYE_STREAM_STATUS;

//Callback data of long link
typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{
    DWORD  dwChannel;      //Channel number
    DWORD  dwDataType;     //Data type,refer to CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //Data length
    BYTE*  pData;          //Data pointer,if dwTypeData is ENUM_FISHEYE_STREAM_STATUS,pData is a pointer to NET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //Reserved
}NET_DVR_CALLBACK_TYPE_DATA, *LPNET_DVR_CALLBACK_TYPE_DATA;

//Drag ptz param of fisheye
typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD           dwChannel;     //Channel number
    DWORD           dwPtzChannel;  //Linkage drag ptz channel.if dwChannel's stream output mode is FISHEYE_STREAM_MODE_FISHEYE,this is the linkage drag ptz channel. When a non-fisheye channel mode,set this to 0
    NET_VCA_POINT   struToPoint;   //Target point,relative to the upper left corner of preview window
    NET_VCA_POINT   struOriPoint;  //Original point,this is the positon that relative to the upper left corner of preview window when beigin dragging
    BYTE            byRes[56];     //Reserved
}NET_DVR_DRAG_POS_PARAM, *LPNET_DVR_DRAG_POS_PARAM;

/************************VQD iVMS-6200(D) V2.1.0 end***********/

typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;
    BYTE  byStepIndex;
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;

typedef enum tagNET_DVR_IPC_ENUM
{
    ENUM_BUSINESS_INVALID = -1,

    ENUM_BUSINESS_HIKVISION = 0,
    ENUM_BUSINESS_PANASONIC,
    ENUM_BUSINESS_SONY,
    ENUM_BUSINESS_AXIS,
    ENUM_BUSINESS_SANYO,
    ENUM_BUSINESS_BOSCH,
    ENUM_BUSINESS_ZAVIO,
    ENUM_BUSINESS_GRANDEYE,
    ENUM_BUSINESS_PROVIDEO,
    ENUM_BUSINESS_ARECONT, // 9 
    ENUM_BUSINESS_ACTI,
    ENUM_BUSINESS_PELCO,
    ENUM_BUSINESS_VIVOTEK,
    ENUM_BUSINESS_INFINOVA,
    ENUM_BUSINESS_DAHUA,    //14

    ENUM_BUSINESS_HIK_STD_H264 = 0x20,
    ENUM_BUSINESS_HIK_STD_MPEG4,
    ENUM_BUSINESS_SUNELL,  
    ENUM_BUSINESS_ATEME,
    ENUM_BUSINESS_LAUNCH,    
    ENUM_BUSINESS_YAAN,   
    ENUM_BUSINESS_BLUESKY,   
    ENUM_BUSINESS_BLUESKYLIMIT,
    ENUM_BUSINESS_TDWY,       
    ENUM_BUSINESS_HBGK,    
    ENUM_BUSINESS_SANTACHI,    
    ENUM_BUSINESS_HIGHEASY,     
    ENUM_BUSINESS_SAMSUNG,

    ENUM_BUSINESS_URL_RTSP = 0x40,   
    ENUM_BUSINESS_ONVIF,

    ENUM_MAX_BUSINESS_TYPE,    
} NET_DVR_IPC_ENUM, *LPNET_DVR_IPC_ENUM;

typedef enum tagNET_DVR_IPC_ENUM_UNIFY
{
    ENUM_IPC_PROTOCOL_INVALID = -1,
    ENUM_IPC_PROTOCOL_HIKVISION = 0,  
    ENUM_IPC_PROTOCOL_PANASONIC,   
    ENUM_IPC_PROTOCOL_SONY,          

    ENUM_IPC_PROTOCOL_AXIS = 4,      
    ENUM_IPC_PROTOCOL_SANYO,        
    ENUM_IPC_PROTOCOL_BOSCH,         
    ENUM_IPC_PROTOCOL_ZAVIO,        
    ENUM_IPC_PROTOCOL_GRANDEYE,     
    ENUM_IPC_PROTOCOL_PROVIDEO,    
    ENUM_IPC_PROTOCOL_ARECONT,     
    ENUM_IPC_PROTOCOL_ACTI,         
    ENUM_IPC_PROTOCOL_PELCO,     
    ENUM_IPC_PROTOCOL_VIVOTEK,     
    ENUM_IPC_PROTOCOL_DAHUA,        
    ENUM_IPC_PROTOCOL_SAMSUNG,       

    ENUM_IPC_PROTOCOL_PSIA = 17,     
    ENUM_IPC_PROTOCOL_ONVIF,         
    ENUM_IPC_PROTOCOL_BRICKCOM,      
    ENUM_IPC_PROTOCOL_GB28181,    

    ENUM_IPC_PROTOCOL_CANON = 23,    

    ENUM_IPC_PROTOCOL_HUINT = 32,     
    ENUM_IPC_PROTOCOL_INFINOVA,      
    ENUM_IPC_PROTOCOL_HIK_STD_H264,    
    ENUM_IPC_PROTOCOL_HIK_STD_MPEG4,  
    ENUM_IPC_PROTOCOL_SUNELL,       
    ENUM_IPC_PROTOCOL_ATEME,        
    ENUM_IPC_PROTOCOL_LAUNCH,     
    ENUM_IPC_PROTOCOL_YAAN,              
    ENUM_IPC_PROTOCOL_BLUESKY,          
    ENUM_IPC_PROTOCOL_BLUESKYLIMIT,    
    ENUM_IPC_PROTOCOL_TDWY,         
    ENUM_IPC_PROTOCOL_HBGK,           
    ENUM_IPC_PROTOCOL_SANTACHI,          
    ENUM_IPC_PROTOCOL_HIGHEASY,          
    ENUM_IPC_PROTOCOL_HANBANG,       
    ENUM_IPC_PROTOCOL_SAMSUNG_3120,    
    ENUM_IPC_PROTOCOL_SAMSUNG_3080,    
    ENUM_IPC_PROTOCOL_SAMSUNG_2000,     
    ENUM_IPC_PROTOCOL_SAMSUNG_5200,    
    ENUM_IPC_PROTOCOL_JINGYUAN,       
    ENUM_IPC_PROTOCOL_VIDEOTREC,     
    ENUM_IPC_PROTOCOL_CHENOVA,           
    ENUM_IPC_PROTOCOL_FENGHUO,     
    ENUM_IPC_PROTOCOL_ZB_5301,      
    ENUM_IPC_PROTOCOL_ZB_5401,        
    ENUM_IPC_PROTOCOL_HAIXIN,          
    ENUM_IPC_PROTOCOL_ZHONGYINGXIN,    
    ENUM_IPC_PROTOCOL_AVUN,       
    ENUM_IPC_PROTOCOL_GOVTY,       
    ENUM_IPC_PROTOCOL_SAE,             
    ENUM_IPC_PROTOCOL_DONGFANGWANGLI,  
    ENUM_IPC_PROTOCOL_CHANGHONG,     
    ENUM_IPC_PROTOCOL_H3C,          
    ENUM_IPC_PROTOCOL_BAIAN,         
    ENUM_IPC_PROTOCOL_HAT,               
    ENUM_IPC_PROTOCOL_YUANYE,         
    ENUM_IPC_PROTOCOL_HIKCARD,           
    ENUM_IPC_PROTOCOL_HAIXINCAP,       
    ENUM_IPC_PROTOCOL_WENANCAP,       
    ENUM_IPC_PROTOCOL_XUNMEI,           
    ENUM_IPC_PROTOCOL_BAIWO,          
    ENUM_IPC_PROTOCOL_APD,                
    ENUM_IPC_PROTOCOL_REACHDEV,      
    ENUM_IPC_PROTOCOL_XUNMEI_DAHUA,  
    ENUM_IPC_PROTOCOL_HUANGHE,           
    ENUM_IPC_PROTOCOL_LIANCHEN,       
    ENUM_IPC_PROTOCOL_CHENGYE,            
    ENUM_IPC_PROTOCOL_VISIONDIGI,      
    ENUM_IPC_PROTOCOL_HENGHE,        
    ENUM_IPC_PROTOCOL_KODAK,           
    ENUM_IPC_PROTOCOL_AIRONIX,      
    ENUM_IPC_PROTOCOL_LG,            
    ENUM_IPC_PROTOCOL_HASEE,          
    ENUM_IPC_PROTOCOL_8000ME,  
    ENUM_IPC_PROTOCOL_POVITEL,       
    ENUM_IPC_PROTOCOL_YIVIEW,       
    ENUM_IPC_PROTOCOL_TIANYUE,        
    ENUM_IPC_PROTOCOL_HOWELL,  
    ENUM_IPC_PROTOCOL_WAPA,           
    ENUM_IPC_PROTOCOL_SANLE,           
    ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION,     
    ENUM_IPC_PROTOCOL_JUNSDA,      
    ENUM_IPC_PROTOCOL_LIYUAN,         
    ENUM_IPC_PROTOCOL_XINCHAN,      
    ENUM_IPC_PROTOCOL_BITE,         
    ENUM_IPC_PROTOCOL_MEIAN,            
    ENUM_IPC_PROTOCOL_ROSEEK,       
    ENUM_IPC_PROTOCOL_AEBELL,     
    ENUM_IPC_PROTOCOL_JSL_ST,   
    ENUM_IPC_PROTOCOL_VIMICRO,
    ENUM_IPC_PROTOCOL_UNIVIEW, 

    ENUM_IPC_PROTOCOL_TYPE, 
}NET_DVR_IPC_ENUM_UNIFY, *LPNET_DVR_IPC_ENUM_UNIFY;

typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD    dwSize;
    BYTE     byGroup;
    BYTE    byProType;
    BYTE    byAccessMode;
    BYTE    byRes1;
    char    szUserName[NAME_LEN];
    char    szPassword[PASSWD_LEN];
    char    szDomain[MAX_DOMAIN_NAME];
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181 protocol access device server ID
    BYTE    byRes2[2];
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD    dwSize;
    DWORD    dwTotalChannelNum;
    BYTE     byChannel[MAX_CHANNUM_V30];
    BYTE    byRes[32];
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD    dwSize;
    BYTE    byGroup;
    BYTE    byVideoOutType;
    BYTE    byGetDefaultPreviewSet;//get the default
    BYTE    byPreviewNumber;//preview number
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD    dwSize;
    WORD    wSwitchSeq[MAX_WINDOW_V40];
    BYTE    byPreviewNumber;
    BYTE    byEnableAudio;
    BYTE    bySwitchTime;
    BYTE    bySameSource;
    BYTE    byRes[32];
}NET_DVR_PREVIEW_SWITCH_CFG, *LPNET_DVR_PREVIEW_SWITCH_CFG;

// CVR 2.0.X
typedef struct tagNET_DVR_USER_COND
{
    char        szUserName[NAME_LEN];
    BYTE        byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{
    DWORD            dwSize;
    BYTE            byAddMonitoringPointRight;
    BYTE            byModMonitoringPointRight;
    BYTE            byDelMonitoringPointRight;
    BYTE            bySetRecordPlanRight;
    BYTE            byDelRecordPlanRight;
    BYTE            byEnableOrDisableRecordPlanRight;
    BYTE            byManualRecordRight;
    BYTE            bySetAlarmRecordRight;
    BYTE            byRecordBackupRight;
    BYTE            byRecordDownloadRight;
    BYTE            byRecordDeleteRight;
    BYTE            byDelBackupRecordRight;
    BYTE            bySetBackupVolumeRight;
    BYTE            byRecordPlayBackRight;
    BYTE            byLogDeleteRight;
    BYTE            byLogDownloadRight;
    BYTE            byAddUserRight;
    BYTE            byDelUserRight;
    BYTE            byModUserRight;
    BYTE            byAllocUserRight;
    BYTE            byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD                dwSize;
    DWORD               dwMaxNum;
    BYTE                   byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;


typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD    dwSize;
    BYTE    byWorkMode;        //0-working device 1-redundant device
    BYTE    byRes[127];
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR    struIP;
    char            szPassword[PASSWD_LEN];
    BYTE             byAddType;
    BYTE             byDisableBackup;
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR    struIP;
    BYTE             byDelType;
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;

typedef union tagNET_DVR_NPO_PARAM_UNION
{
    NET_DVR_ADD_PARAM    struAddParam;
    NET_DVR_DEL_PARAM     struDelParam;
}NET_DVR_NPO_PARAM_UNION, *LPNET_DVR_NPO_PARAM_UNION;

typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD                    dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam; //0 - corresponding to struAddParam 1 - corresponding to struDelParam
    BYTE                     byType;
    BYTE                      byRes[3];
    char                        szUserName[NAME_LEN];    //User name
    BYTE                      byRes2[220];
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD     dwSize;
    BYTE     bySleepStatus;/*0-Not sleep 1-sleep*/
    BYTE      byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD     dwSize;
    BYTE     bySpeed;    /*0-Low 1-Mid 2-High*/
    BYTE      byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD                dwSize;
    BYTE                   byEnable;
    BYTE                   byDelData;
    BYTE                   byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD                dwSize;
    DWORD                dwSrcLunID;
    DWORD               dwDstLunID;
    BYTE                   byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD                dwSize;
    DWORD                dwLunID;
    DWORD                dwHSize;
    DWORD                dwLSize;
    char                szArrayIDGroup[NAME_LEN];
    char                   szNewLunName[MAX_NAMELEN];
    BYTE                   byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;

typedef struct tagNET_DVR_DVR_NET_DISK_CREATE
{
    DWORD                dwSize;
    char                   szRaidName[MAX_NAMELEN];
    char                   szDvrNetDiskName[MAX_NAMELEN];
    DWORD                dwBlockSize;
    DWORD               dwHCapacity;
    DWORD               dwLCapacity;
    NET_DVR_IPADDR        struWarrantIP;
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_CREATE, *LPNET_DVR_DVR_NET_DISK_CREATE;

typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD                dwSize;
    char                szOldDvrNetDiskName[MAX_NAMELEN];
    char                   szNewDvrNetDiskName[MAX_NAMELEN];
    NET_DVR_IPADDR        struWarrantIP;
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;

typedef struct tagNET_DVR_DVR_NET_DISK_DEL_
{
    DWORD                dwSize;
    char                szDvrNetDiskName[MAX_NAMELEN];
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_DEL, *LPNET_DVR_DVR_NET_DISK_DEL;

typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD                dwSize;
    DWORD                dwLunID;
    BYTE                   byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD                dwSize;
    DWORD                dwTargetID;
    DWORD                dwLunID;
    DWORD                dwAccessMode;
    NET_DVR_IPADDR        struClientIP;
    BYTE                   byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD                dwSize;
    DWORD                dwStoreLunID;
    DWORD                dwLogicLunID;
    DWORD                dwHbaID;
    DWORD                dwAccessMode;
    char                szClientWWWPN[NAME_LEN];
    BYTE                   byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;

typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD        dwHCapacity;
    DWORD        dwLCapacity;
    char        szName[MAX_NAMELEN];
    DWORD        dwBlockSize;
    char        szArrayIDGroup[NAME_LEN];
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;


typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD        dwHCapacity;
    DWORD        dwLCapacity;
    char            szName[MAX_NAMELEN];
    DWORD        dwBlockSize;
    NET_DVR_IPADDR    struWarrantIP;
    char            szArrayIDGroup[NAME_LEN];
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;

typedef union tagNET_DVR_VD_UNION
{
    BYTE                        byUnionLen[256];
    NET_DVR_OPERATE_VD_PARAM    struHikVDParam;
    NET_DVR_LUN_PARAM            struLunParam;
    NET_DVR_DVR_PARAM            struDvrParam;
}NET_DVR_VD_UNION, *LPNET_DVR_VD_UNION;

typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE                byVDType;
    BYTE                byRes1[3];
    NET_DVR_VD_UNION     uVDParam;
    BYTE                byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;


typedef struct tagNET_DVR_CVR_ALARM
{
    char            szFirstType[NAME_LEN];
    char            szFirstIndex[NAME_LEN];
    char            szSecondType[NAME_LEN];
    NET_DVR_TIME    struTime;
    BYTE             byStatus;
    BYTE            byAlarmLevel;
    BYTE            byRes1[2];
    char               szSecondIndex[NAME_LEN];
    char            szThirdType[NAME_LEN];
    char            szThirdIndex[NAME_LEN];
    char            szFourthType[NAME_LEN];
    char            szFourthIndex[NAME_LEN];
    BYTE              byRes2[92];
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;
    BYTE             byLinkStatus;
    BYTE             byWorkStatus;
    BYTE             byBacupStatus;
    BYTE             bySyncProgress;
    NET_DVR_TIME_EX    struSyncBeginTime;
    NET_DVR_TIME_EX    struSyncEndTime;
    char            szSerialNumber[SERIALNO_LEN];
    DWORD            dwSoftwareVersion;
    BYTE              byWorkingDeviceGUID[GUID_LEN];
    char            szDevTypeName[DEV_TYPE_NAME_LEN];
    WORD            wDevType;
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;
    BYTE     byWorkStatus;
    BYTE     byBackupStatus;
    WORD    wBackupPort;
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO_V50
{
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;        //Work machine information
    char            szUserName[NAME_LEN];    //user name
    BYTE           byRes[32];
}NET_DVR_WORKING_DEVICE_INFO_V50, *LPNET_DVR_WORKING_DEVICE_INFO_V50;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO_V50
{
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;     //Standby information
    char            szUserName[NAME_LEN];    //user name
    BYTE           byRes[32];
}NET_DVR_REDUNDANT_DEVICE_INFO_V50, *LPNET_DVR_REDUNDANT_DEVICE_INFO_V50;

typedef union tagNET_DVR_NPO_DEV_INFO_UNION
{
    BYTE                             byUnionLen[512];
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;
    NET_DVR_WORKING_DEVICE_INFO_V50        struWorkingDeviceInfoV50;        //Work machine information V50 
    NET_DVR_REDUNDANT_DEVICE_INFO_V50    struRedundantDeviceInfoV50;     //Standby information V50 
}NET_DVR_NPO_DEV_INFO_UNION, *LPNET_DVR_NPO_DEV_INFO_UNION;

typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD                        dwSize;
    NET_DVR_NPO_DEV_INFO_UNION    unionDevInfo;
    /*type 0 - work machine, corresponding to the struWorkingDeviceInfo in unionDevInfo
           1 - the standby, corresponding to the struRedundantDeviceInfo in unionDevInfo
           2 - work machine V50, corresponding to the struWorkingDeviceInfoV50 in unionDevInfo
           3 - the standby V50, corresponding to the struRedundantDeviceInfoV50 in unionDevInfo */
    BYTE                        byType;
    BYTE                           byRes[127];
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;


typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO    struStreamInfo[MAX_CHANNUM_V30];
    char                  szFileName[260];
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO    struStreamInfo;
    WORD                wErrCode;
    BYTE                byRes[30];
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char          szFileName[260];
    BYTE        byRes[32];
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD     wRow;
    WORD    wErrCode;
    BYTE    byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE     struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_TRANSFER_SWITCH
{
    DWORD dwEnable;
    BYTE  byRes[64];
}NET_DVR_TRANSFER_SWITCH, *LPNET_DVR_TRANSFER_SWITCH;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize;
    DWORD dwChannel; //channel
    DWORD dwPatternCmd; //pattern command
    DWORD dwPatternID; //pattern ID
    BYTE  byRes[64];
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable,0-no,1-yes
    BYTE  byOneTouchSwitch;//One Key Switch, 0-no,1-yes 2014-03-15
    BYTE  byRes1[2];
    DWORD dwParkTime; //park time, second 
    WORD  wActionType; //action type,0-atuoScan,1-frameScan,2-randomScan,3-patrol,4-pattern,5-preset,,6-panoramaScan,7-verticalScan,8-8-regionScan
    WORD  wID; //ID
    BYTE  byRes[128];
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD dwSize;
    DWORD dwChannel;
    NET_VCA_POINT struPoint;
    BYTE  byTrackType;
    BYTE  byLinkageType;
    BYTE  byRes[2];
    NET_VCA_POINT struPointEnd;
    NET_DVR_TIME_V30 struTime;//Time.
    DWORD dwSerialNo;//Serial No.;
    BYTE  byRes1[36];
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;

/************************************VQD start ******************************************/

typedef enum tagVQD_TYPE
{
    VQD_BLUR_FLAG = 0x00000001, //Blurred Image
    VQD_LUMA_FLAG = 0x00000002, //Abnormal Brightness 
    VQD_CHROMA_FLAG = 0x00000004,  //Color Cast
    VQD_SNOW_FLAG = 0x00000008,  //Snow Noise
    VQD_STREAK_FLAG = 0x00000010,  //Stripe Noise
    VQD_FREEZE_FLAG = 0x00000020,  //Freeze Frame
    VQD_SIGLOSE_FLAG = 0x00000040,  //Signal Loss
    VQD_PTZ_FLAG = 0x00000080   //PTZ Control Failed
}VQD_TYPE;


typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD   dwSize;        //struct size 
    BYTE    byEnable;        //enbale  0 :close, 1:open
    BYTE     byRes1[3];
    BYTE    byVQDTypeEnable[32]; /*The diagnosis mode   result of operation OR such as */
    /*0- Blur, 1-Luma, 2-Chroma,    3-Snow,   4-Streak,  5-Freeze,  6-Siglose,  7-PTZ*/
    BYTE    byThresholdValue[32];       //Threshold value 0~100,The different diagnostic mode has its own Threshold
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //alarm 
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];
    BYTE    byRes[324];
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;


typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;  //channel No.
    DWORD  dwVQDType;     // The diagnosis mode    
    NET_DVR_TIME struDiagnoseTime;    //diagnose Time
    BYTE    byScoreValue;       //score value, centesimal system
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO, *LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize;
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo; //Diagnose info
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;
/************************************VQD End******************************************/

/********************************DS_19DXX 104 protocol begin****************************/
typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD        dwSize;
    BYTE        byChanType;        //input type,1-local sensor,2-local switch,3-485,4-net
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //channel no
    DWORD        dwSubChanNo;    //sub channel no.
    DWORD        dwVariableNo;    //variable no.
    BYTE        byRemoteType;    //obtain variable type 0-all type, 1-remote signalling, 2-telesignalisation
    BYTE        byLinkageIPCType;   //The config type of linkage IPC: 0-default, 1-by variable, 2-by channel
    BYTE        byLinkageTriggerType;  //The config type of linkage trigger: 0-default, 1-by variable, 2-by channel
	BYTE        byRes2[57];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD        dwSize;
    WORD        wVariableIndex;        //variable no. (only can be getted)
    WORD        wVariableType;        //variable type 1-sensor 2-switch(only can be getted)
    BYTE        sDescribe[NAME_LEN];//variable name
    BYTE        byLimitLineType;    //limit line type,0-no limit line,1-two limit lines,2-four limit lines
    BYTE        byRemoteType;     //variable remote electric system type
    BYTE        byOsdEnabled;       //how about OSD? 0-default 1-support 2-not support
    BYTE        byRes[29];            //reserve
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;

typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int           nMeasureHigh;   // measure high
    int           nMeasureLow;    //  measure low
    BYTE        byAlarmMode;    //alarm mode -HHHH(1111),-HHHL(1110),-HHLL(1100),HLLL(1000),-LLLL(0000)
    BYTE         byRes1[3];
    int            nAlarmValue[4];       //alarm value
    DWORD          dwOsdCfg;        //osd, bit0 means channel 1, bit1 means channel2 .....
    DWORD        dwSensitive;
    DWORD        dwIPChanOsd;    // ip channel osd,bit0 means channel 1, bit1 means channel2 .....
    char         szOSDUnit[MAX_OSD_UNIT_LEN];   //OSD unit overlay
    BYTE        byRes[16];
}NET_DVR_ALARM_SENSOR_POINT_CFG, *LPNET_DVR_ALARM_SENSOR_POINT_CFG;

typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
	DWORD     dwIPCChanOsd;// ip channel osd,bit0 means channel 1, bit1 means channel2 .....
    BYTE        byRes[60];
}NET_DVR_ALARM_SWITCH_POINT_CFG, *LPNET_DVR_ALARM_SWITCH_POINT_CFG;

typedef union tagNET_DVR_ALARM_POINT_PARAM_UNION
{
    BYTE    byLength[64];
    NET_DVR_ALARM_SENSOR_POINT_CFG struSensor;    //sensor parameter
    NET_DVR_ALARM_SWITCH_POINT_CFG struSwitch;    //switch parameter
}NET_DVR_ALARM_POINT_PARAM_UNION, *LPNET_DVR_ALARM_POINT_PARAM_UNION;

typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD        dwSize;
    DWORD        dwPointNo;            //point no.
    BYTE        sPointDescribe[NAME_LEN];        //point describe
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam;
    BYTE        byPointType;        //point type,1-sensor,2-switch
    BYTE        byChanType;
    BYTE        byRes1[2];
    DWORD        dwChanNo;
    DWORD        dwSubChanNo;
    DWORD        dwVariableNo;
    BYTE        byRes[16];
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD        dwSize;
    BYTE        byMajorType;    //major type,1-aa,2-time, 3-type,4-time && type
    BYTE        byMinorType;    //1-point,2-channel && subchannel && variable
    BYTE        byRes1[2];
    NET_DVR_TIME        struStartTime;    //start time
    NET_DVR_TIME        struStopTime;    //stop time
    BYTE        byChanType;        //channel type;,1-sensor,2-485,3-net
    BYTE        byRes2[3];
    DWORD        dwChanNo;        //channel no. start from 1,0xffffffff means invalid
    DWORD        dwSubChanNo;    //slot no,start from 1,0xffffffff means invalid
    DWORD        dwVariableNo;    //variable no,start from 1,0xffffffff means invalid
    DWORD        dwPointNo;        //point no,0xffffffff means invalid
    BYTE        byDataType;        //0-normal data,1-up data,2-down data
    BYTE          byRes3[31];
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD        dwSize;
    NET_DVR_TIME        struTime;    //time
    BYTE        byChanType;        //channel type,1-sensor,2-485,3-net,0xff means invalid
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //channel no. start from 1,0xffffffff means invalid
    DWORD        dwSubChanNo;    //slot no,start from 1,0xffffffff means invalid
    DWORD        dwVariableNo;    //variable no,start from 1,0xffffffff means invalid
    DWORD        dwPointNo;        //point no,0xffffffff means invalid
    int            iData;            //history data
    BYTE        byDataType;
    BYTE        byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD        dwSize;
    BYTE    byDataUploadMode;    //1-upload by channel,2-upload by point
    BYTE    byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG, *LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;


typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE    byChanType;        //channel type,1-sensor,2-switch,3-485,4-net channel 0xff means invalid
    BYTE    byPointType;    //point type,1-sensor,2-switch
    BYTE    byRes1[2];
    DWORD     dwChanNo;        //channel no. start from 1,0xffffffff means invalid
    DWORD    dwSubChanNo;    //slot no,start from 1,0xffffffff means invalid
    DWORD    dwVariableNo;    //variable no,start from 1,0xffffffff means invalid
    DWORD     dwPointNo;        //point no,0xffffffff means invalid
	int        iValue;            //The value of the monitoring point, indicating the lower 32 bits
	int        iValueEx;          //The value of the monitoring point, which indicates the upper 32 bits
	BYTE    byRes[12];
}NET_DVR_ALARMHOST_POINT_VALUE, *LPNET_DVR_ALARMHOST_POINT_VALUE;

typedef union tagNET_DVR_ALARMHOST_DATA_UNION
{
    BYTE    byLength[40];
    NET_DVR_ALARMHOST_POINT_VALUE struPointValue;
}NET_DVR_ALARMHOST_DATA_UNION, *LPNET_DVR_ALARMHOST_DATA_UNION;

typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD        dwSize;
    BYTE        byDataType;        //data type,1-point value upload
    BYTE        byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE        byRes2[32];
} NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;
/********************************DS_19DXX 104 protocol end****************************/

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;
    BYTE   byAudioInputChan;
    BYTE   byRes[63];
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

//IPC5.0.5
typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE   byAudioOutVolume;// LEVEL:0-100
    BYTE   byRes[63];
}NET_DVR_AUDIOOUT_VOLUME, *LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE, *LPNET_DVR_FUZZY_UPGRADE;

/************************************code splitter Start******************************************/

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //work mode,0-console,1-private transparent channel,2-transparent channel
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //enable transparent channel,0-disable,1-enable
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //remote device ip
    WORD wPort; //remote device port
    BYTE byRes2[18];
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //enable transparent channel,0-disable,1-enable
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //allowed access remote device ip    
    BYTE byRes2[16];
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //local listen port
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;

typedef union tagNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION
{
    BYTE byRes[512];
    NET_DVR_TRANSPARENT_CLIENT_MODE struClientMode;  //cilent mode config
    NET_DVR_TRANSPARENT_SERVER_MODE struServerMode; //server mode config
}NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION, *LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;
    BYTE  byWorkMode; //transparent channel work mode,1-client mode,2-server mode
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

/************************************code splitter End******************************************/


/********************************POS start*******************************************/

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;

typedef enum tagNAKED_DATA_TYPE
{
    NAKED_DATA_TYPE_NOT_DEFINED = 0, //Undefined
    NAKED_DATA_TYPE_POS_INFO    //Pos Info
}NAKED_DATA_TYPE;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP Port 7050
    BYTE byRes[130];
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

#define UPLOAD_POS_INFO     1001  //Upload Pos Info

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD     struVerHead;  //Ver head
    DWORD dwChannelNum;          // channel numbers
    BYTE  byRes[60];
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;


#define MAX_IGNORE_STRING_NUM        4
#define FILTERRULE_NUM              4
#define MAX_POS_FILTER_DATA_LEN     128

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //Start Point
    NET_VCA_POINT   struEnd;    //End Point
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;

typedef struct
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];
    BYTE byExclusive;    //if or not include tag itself 0-include 1-not include
    BYTE byFlagType;    //flag type:0-string;1-hex
    BYTE byRes[2];                    /*Reserve*/
}NET_DVR_GENERIC_START, *LPNET_DVR_GENERIC_START;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*end of Transaction*/
    BYTE  byExclusive;    //if or not include tag itself 0-include 1-not include
    BYTE  byFlagType;    //flag type:0-string;1-hex
    BYTE  byRes[6];
} NET_DVR_GENERIC_END, *LPNET_DVR_GENERIC_END;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];
    BYTE  byFlagType;    //flag type:0-string;1-hex
    BYTE  byRes[3];
}NET_DVR_GENERIC_DATA_CFG, *LPNET_DVR_GENERIC_DATA_CFG;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*Ignore char*/
}NET_DVR_IGNORE_STRING, *LPNET_DVR_IGNORE_STRING;

typedef struct
{
    BYTE  byCaseSensitive;/*Case Sensitive ,0->no,1->yes*/
    BYTE  byRes1[7];
    NET_DVR_GENERIC_START struTransactionStart;/*start of transcation*/
    NET_DVR_GENERIC_END struTransactionEnd;/*end of transcation*/
    NET_DVR_GENERIC_DATA_CFG struLineDeli;/*New Line char*/
    NET_DVR_IGNORE_STRING struIgnoreString[MAX_IGNORE_STRING_NUM];/*Ingnore Char*/
    BYTE byRes[40];    // Reserve
}NET_DVR_POS_GENERIC, *LPNET_DVR_GENERIC;

typedef struct
{
    DWORD  dwPosAddr;/*Pos Address*/
    BYTE   byRes[948];
}NET_DVR_POS_AVE, *LPNET_DVR_AVE;

#define SERIAL_NUM_LEN 8
typedef struct tagNET_DVR_POS_NUCLEUS/*size 952byte*/
{
    char   szEmployeeNo[SERIAL_NUM_LEN];
    char   szTerminalNo[SERIAL_NUM_LEN];
    char   szShiftNo[SERIAL_NUM_LEN];
    BYTE      byRes[928];
}NET_DVR_POS_NUCLEUS, *LPNET_DVR_POS_NUCLEUS;

typedef  union _NET_DVR_POS_PROTOCOL_UNION
{
    BYTE byLenth[952];   //the union lenth
    NET_DVR_POS_GENERIC struGeneric;
    NET_DVR_POS_AVE struAve;
    NET_DVR_POS_NUCLEUS struNUCLEUS;
}NET_DVR_POS_PROTOCOL_UNION, *LPNET_DVR_POS_PROTOCOL_UNION;

typedef enum tagNET_DVR_CHARSET_ENUM
{
    ENUM_UTF8 = 0,
    ENUM_GB2312,
    ENUM_LATIN1,
    ENUM_LATIN2,
    ENUM_LATIN3,
    ENUM_LATIN4,
    ENUM_CYRILLIC,
    ENUM_ARABIC,
    ENUM_GREEK,
    ENUM_HEBREW,
    ENUM_TURKISH,
    ENUM_NORDIC,
    ENUM_THAI,
    ENUM_LATIN7,
    ENUM_LATIN8,
    ENUM_LATIN9,
    ENUM_LATIN10,
    ENUM_CENTRAL_EUROPEAN,
    ENUM_CYRILLIC_SCRIPT,
    ENUM_HEBREW_DOS862
}NET_DVR_CHARSET_ENUM, *LPNET_DVR_CHARSET_ENUM;

typedef struct
{
    BYTE byEnable;    //
    BYTE byRes1[3];   //reserve
    BYTE  sPosName[NAME_LEN];/*POS Name */
    DWORD dwProtocolType;/*Protocal Type,1->generic text, 2->AVE VSI-ADD    3->AVE Vnet  */
    NET_DVR_POS_PROTOCOL_UNION struPosProtocol;   //POS Protocal
    NET_DVR_POS_ACTION struAction;/*Action*/
    BYTE byRes[64];
}NET_DVR_FILTER_CONFIG, *LPNET_DVR_FILTER_CONFIG;

typedef struct
{
    DWORD   dwSize;
    BYTE     byEnable;            //Filter Enable
    BYTE     byCharSetType;      //NET_DVR_CHARSET_ENUM
    BYTE    byRes1;
    BYTE    byProtocolType;//Protocol Type, 1->generic text (universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON, 5 - NUCLEUS 6- Gilbarco 7- NCR
    NET_DVR_POS_PROTOCOL_UNION uPosProtocol;   //POS  
    BYTE    byRes[32];
}NET_DVR_POS_FILTER_CFG, *LPNET_DVR_POS_FILTER_CFG;

typedef struct  tagNET_DVR_NET_SNIFF
{
    BYTE       byEnableSourcePort;
    BYTE       byEnableDestAddr;
    BYTE       byEnableDestPort;
    BYTE       byRes1;
    BYTE       bySourceIpAddr[MAX_DOMAIN_NAME];
    BYTE       byDestinationIpAddr[MAX_DOMAIN_NAME];
    WORD          wSourcePort;
    WORD          wDestinationPort;
    BYTE       byRes[16];
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;


typedef struct
{
    WORD  wNetPort;  /*device net port*/
    BYTE  byRes[2];
}NET_DVR_NET_RECEIVE, *LPNET_DVR_NET_RECEIVE;

typedef struct tagNET_DVR_MONITOR_INFO
{
    WORD  wPort;
    BYTE   byRes1[2];
    NET_DVR_IPADDR  struRestrictRemoteIP;
    BYTE   byRes[164];
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;

typedef union tagNET_DVR_POS_CONNECTMODE_UNION
{
    BYTE                       byLen[312];      //union Len
    NET_DVR_NET_RECEIVE     struNetRecv;     //Net recv mode
    NET_DVR_MONITOR_INFO     struTcpMonitor;    //tcp monitor mode
    NET_DVR_SINGLE_RS232     struRS232;        //RS232 
    NET_DVR_MONITOR_INFO     struUdpMonitor;     //udp monitor mode
    NET_DVR_NET_SNIFF          struSniff;          //Sniff mode
    NET_DVR_ADDRESS            struMcast;          //multii-cast mode 
    NET_DVR_USB_RS232         struUSBRS232;    //USB To Rs232 Mode
}NET_DVR_POS_CONNECTMODE_UNION, *LPNET_DVR_POS_CONNECTMODE_UNION;

//DVR and POS connect Mode
typedef struct
{
    DWORD   dwSize;
    BYTE     byConnectMode;    //Connect Mode 0->TCP Monitor,1->Net Recv,2->Serial ,3-UDP Monitor,4-sniff,5-Multicast,6-USB To Serial
    BYTE     byRes1[3];
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;    //Connect Mode
    BYTE  byRes[64];
} NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD                  dwSize;
    BYTE                  byFilterID;           //POS filter ID
    BYTE                 byFontSize;         //font size, 0-- 8*16  1--16*32  2--32*64 
    BYTE                  byShowPosInfo;
    BYTE                byOverlayMode;
    DWORD                 dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR        struOsdColor;           //OSD color
    NET_DVR_SCHEDTIME        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD                  dwMaxRelRecordChanNum;
    DWORD                  dwRelRecordChanNum;
    DWORD                  dwRelRecordChan[MAX_CHANNUM_V30];
    DWORD                 dwTimeOut;        /*time Out(5-3600s)*/ //You can't get a POS data timeout refers to the long time data at the end of the determining a packet. 
    BYTE              byRes[60];
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG;



/********************************POS start*******************************************/

#define        MAX_LAN_ENCODE_LEN        32    //max language encode length
typedef struct    tagNET_DVR_DEVICE_LAN_ENCODE
{
    DWORD        dwSize;
    BYTE        byLanEncode[MAX_LAN_ENCODE_LEN];    //device language encode 
    BYTE        byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byEnable; //Enable,0~Enable,1~Disable
    BYTE    bySensitiveLevel;// 1-100,default:50,The higher the sensitivity, the more easily the alarm .
    BYTE    byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode 
    DWORD    dwMaxRelRecordChanNum;  //Alarm video channel trigger number (read-only) maximum support number 
    DWORD    dwRelRecordChanNum;     //Alarm number video channel number to trigger the practical support 
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];//Trigger Video Channel 
    //Alarm video channel trigger (Four bytes of channel number, initial value 0xffffffff)
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION, *LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD           dwSize;
    NET_VCA_DEV_INFO     struDevInfo;    //DevInfo
    WORD    wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE            byRes[126];
}NET_DVR_SCENECHANGE_DETECTION_RESULT, *LPNET_DVR_SCENECHANGE_DETECTION_RESULT;


typedef enum
{
    PREVIEW_MOD = 0,
    ALARM_MOD,
    PLAYBACK_MOD,
    MAX_TYPE
}MODULE_TYPE;

//Parking Information
typedef struct tagNET_DVR_PARK_INFO
{
    char          sPlateNo[MAX_PlATE_NO_LEN];             //License plate number 
    char          sParkIndex[MAX_PlATE_NO_LEN];        //Number of parking spaces
    BYTE          byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;


typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD                 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*Trigger Time*/
    NET_DVR_PARK_INFO    struParkInfo; //Parking Information
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //Stream id information
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //Stream id source information
}NET_DVR_STREAM_SRC_CFG, *LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //Video format type,1-original,2-RTP,3-PS,4-TS,5-private,6-FLV,7-ASF,8-3GP, 9-RTP+PS(GB28181),0xff-invalid
    BYTE  byVideoEncType;//Video encode type,0-private 264,1-standard h264,2-standard mpeg4,7-M-JPEG,0xff-invalid
    WORD  wWidth; //Image width
    WORD  wHeight; //Image height
    BYTE  byRes1[2];
    DWORD dwVideoBitrate;     //Video bit rate,unit:Kbps
    DWORD dwVideoFrameRate;    //Video frame rate,larger than 200 represents below 1 frame/s,else represents reality frame rate,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//Audio encode type,0-G722,1-G711_U,2-G711_A,5-MPEG2,6-G726,7-AAC,0xff-invalid
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;

typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//Stream ID and channel information    
    BYTE  byMode;//Transcode type,1-Active,2-Passive
    BYTE  byLinkNums;//Link number
    BYTE  byPassiveTransMode; //Passive transcode mode,0-invalid,1-Real time stream,2-File stream
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//Target ip address
    BYTE  byTransResource;//Number of used resource,unit:D1 transcode resource
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//Stream source encode information
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//target encode information
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;
/**********************************Ehome Platform begin 2013-10-9*********************************/
typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD            dwSize;
    NET_DVR_IPADDR    struAddr;
    WORD            wServerPort;
    BYTE            bySeverProtocolType;
    BYTE               byStatus;
    BYTE            sDeviceId[NAME_LEN/*32*/];
    char            sPassWord[PASSWD_LEN];
    /********* IPC5.1.7 new parameters Begin 2014-03-21***********/
    BYTE            sPlatformEhomeVersion[NAME_LEN];//Platform EHOME protocol version                   
    /********* IPC5.1.7 new parameters end 2014-03-21***********/
    BYTE            byNetWork;
    BYTE            byAddressType;            //0 - invalid, 1 - ipv4/ipv6 address,2 - domain name
    BYTE            byProtocolVersion;            //Protocol version 0 - invalid,  1 - v2.0, 2 - v4.0 ,3-v2.6
    BYTE            byRes1;
    BYTE            sDomainName[MAX_DOMAIN_NAME/*64*/];
    BYTE        byEnable;      //0-close,1-open
    BYTE            byRes[139];          // reserve
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;
/**********************************Ehome Platform end*********************************************/

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//Total transcode resource
    DWORD dwIdleResource;//Left transcode resource
    BYTE  byCpuLoad;//CPU load
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_PASSIVETRANSINFO
{
    DWORD dwSize;
    BYTE byStreamType;// Stream type,0-main stream,1-sub stream
    BYTE byLinkMode;//Passive transcode link mode 0:TCP mode,1:UDP mode
    BYTE byPassiveTransMode; //Passive transcode mode,1-real stream,2-file stream
    BYTE byRes1[5];
    BYTE byDataType;//Data type,1-SDP,2-media head
    BYTE byRes2;
    WORD wDataLength;//Data length
    char *pBuffer;//Data buffer
    BYTE byRes3[32]; // RES
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-Channel mode,2-Stream ID mode
    BYTE  byDisplayMode; //0-NORMAL,1-Fluency
    BYTE  byEnableVcaDec; // wheter to start  vca decode, 0-not !0-start
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE, *LPNET_DVR_DEV_WORK_MODE;

typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //Window No.,start from 1,0 represents basemap
    BYTE  byEnable; //Enable audio,1-enable,0-disable
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //electronic enlargement status:0-normal,1-enlarge
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //enlarge area
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS, NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD       dwSize;
    BYTE  byPreviewFpsAdjMode;   /* preview Audio Framerate adjust mode:0-no adjust ,standard Audio Framerate preview,1-standard low Audio Framerate preview,2-adjust Audio Framerate by GPS speed */
    BYTE  bySelPeccType;           /* choose illegal type 0-not choose; 1-choose */
    BYTE  byOptHabit;  /* Forensics operating habits, 0:Long press Forensics;1:Short press two time for forensics */
    BYTE  byEnablePeccRec;      /* 1: enable Illegal record grab, 0: disable Illegal record grab */
    BYTE  byPicSize;                /*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA,7-XVGA,8-HD900p,9-HD1080,10-2560*1920,11-1600*304,12-2048*1536,13-2448*2048,14-2448*1200,15-2448*800,16-XGA(1024*768),17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;            /* Picture quality 0-best 1-good 2-ok */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG, *LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

/*******************************IPC5.1.4 resume initial tracking position  begin********************/
//2013-10-28
typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;
    DWORD           dwChannel;;     // Channel number 
    BYTE            byRes[16];      // 
}NET_DVR_RESUME_INITRACKPOS_CFG, *LPNET_DVR_RESUME_INITRACKPOS_CFG;
/*******************************IPC5.1.4  end *********************************/

typedef  struct tagNet_DVR_TEST_SELFCHECK_RESULT
{
    DWORD   dwSize;
    DWORD   dwChannel;      //Channel number            
    BYTE    bySelfCheckStatus;   //self check status  0-not start,1-success,2-fail,3-self checking
    BYTE    byRes[23];   //
}NET_DVR_TEST_SELFCHECK_RESULT, *LPNET_DVR_TEST_SELECHECK_RESULT;

#define  MAX_TEST_COMMAND_NUM 32 
typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number  
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM];
    //0 -not to test  1 - to test
    //the subscript 0 of the array means whether enable the olding  test                       
    //the subscript 1 of the array means whether enable the red light come in test
    //the subscript 2 ICR aging test, 0 means closed, 1 is open, can be combined with bit0, such as 0000 _0001 (open only cruise aging), 0000 _0101 aging (at the same time open cruise and ICR), 0000 _0100 (ICR) aging only open 
    //the subscript 3 - ball machine status since the correction function, 0 means the ball machine since the correction function is not cleared, 1 ball machine since the correction function has been removed 
    //the subscript 4 synchronized scanning test program, 0 means closed, 1 is open 
    //the subscript 5 electronic compass calibration program, 0 means closed, 1 is open WORD wICRIntervalTime;
    // icr time interval (byTestCommand in table 2 in the array value is 1, icr switch time interval, the unit of a second)
    WORD    wICRIntervalTime;
    BYTE    byElectronicCompassState;//Compass state return, 0 - normal, 1 - not normal 
    BYTE    byRes1[1];
    float   fDeviceTem; //Precision equipment machine core temperature 0.001
    BYTE    byTemp[9];  //Multiple temperature equipment
    BYTE    byRes[3];
}NET_DVR_TEST_COMMAND, *LPNET_DVR_TEST_COMMAND;

typedef struct  tagNET_DVR_AGING_TRICK_SCAN
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number 
    BYTE     byAging; // Said set of parameters for aging before or after aging tools,0 - before aging ,1 - after aging
    BYTE     byWriteReadEnalbe; //Literacy instruction enabled, 0 - set read instructions, 1 - set up writing instruction 
    BYTE     byRes[126];
}NET_DVR_AGING_TRICK_SCAN, *LPNET_DVR_AGING_TRICK_SCAN;

#define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //Clear pattern scanning parameter Settings 
typedef struct tagNET_DVR_IPC_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //Parameter types, according to the who said     
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //Clear pattern scanning parameter Settings 
    BYTE byRes[32];
}NET_DVR_IPC_PARAM_TYPE, *LPNET_DVR_IPC_PARAM_TYPE;

typedef struct  tagNET_DVR_ECCENTRIC_CORRECT_STATE
{
    DWORD   dwSize;
    DWORD   dwChannel;       //Channel number 
    BYTE     byEccentricCorrectState; // Eccentric correction status, 0 - calibration failure,1 - calibration success,2 - in the correction
    BYTE     byRes[127];
}NET_DVR_ECCENTRIC_CORRECT_STATE, *LPNET_DVR_ECCENTRIC_CORRECT_STATE;


#define MAX_DEVMODULE_NUM 8
typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //Channel number  
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //the type of the testing device
    // 0 - unable  1 - enable 
    // bit0 - to test the number 1 fan 
    // bit1 - to test the number 2 fan 
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //the type of the testing device
    // 0 - unable  1 - enable 
    // bit0 - to test the number 1 heater
    // bit1 - to test the number 2 heater
    BYTE    byRes[22];      //
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;


/****************2013-11-04 PJ01R2013091201 entrance capture begin***************/
////////////////////////////entrance capture CFG begin///////////////////////////////
typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE   byLaneNo;//Lane No.(0-Invalid,1-Lane 1)
    BYTE   byRes[3];
}NET_DVR_BARRIERGATE_COND, *LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-No operation,1-Open Gateway
    BYTE   byRes1;
    WORD   wAlarmOperateType;//0-No operation,bit0-Relay output alarm, bit1-A output arm bit3-Alarm host upload(Can check)(0-Close,1-Open)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL, *LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-Not access equipment,1-Open Gate,2-Close Gate,3-Stop Gate,4-alarm,5-Often bright lamp
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM, *LPNET_DVR_RELAY_PARAM;

//Entrance CFG
typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    /*0x00: Do not match.*/
    /*0x01: license plate matching (with license plate color).*/
    /*0x02: license plate matching (without the license plate color).*/
    /*0x04: card matching.*/
    BYTE    byEnable;// Enable;0-Close,1-Open
    BYTE    byBarrierGateCtrlMode;//0-automatic Camera Ctrl,1-platform Ctrl
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//Trigger Mode,ITC_TRIGGERMODE_TYPE
    DWORD   dwMatchContent; //Match Content
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//Relay Relate Info(A relay can control an access device) Array of 0 represents a relay 1 array of 1 represents a relay 2 turn 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //A single IO trigger parameters, a single IO trigger parameters, an array of 0 IO1, 1 IO2 array, and so on; the array values meaning (0- no, 1- gate open place, 2- gate is closed in place, 3- fire alarm)
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//Vehicle information management 
    BYTE    byNotCloseCarFollow;//Not Close Car Follow,0-Close,1-Open
    BYTE  byParkingDetectEnabled;//0-no 1-yes
    BYTE  byParkingDetectJudgeTime;//unit:second
    BYTE    byRes2[61];
}NET_DVR_ENTRANCE_CFG, *LPNET_DVR_ENTRANCE_CFG;

// Barrier Gate Ctrl
typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //Channel
    BYTE  byLaneNo;  //Gate No(0-Invalid,1-Gate 1)
    BYTE  byBarrierGateCtrl;//0-Close Gate,1-Open Gate,2-Stop Gate 3-Lock Gate,4-Unlock Gate
    BYTE  byEntranceNo;//Entrance No [1,8]
    BYTE  byUnlock;//Unlock Enable
    BYTE  byRes[12];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;
////////////////////////////entrance capture CFG end///////////////////////////////

//Vehicle Control List Info
typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//channel
    DWORD  dwDataIndex;//Data Index
    char   sLicense[MAX_LICENSE_LEN]; //License
    BYTE   byListType;//List Type
    BYTE   byPlateType;    //Plate Type
    BYTE   byPlateColor;    //Plate Color
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // Card No.
    NET_DVR_TIME_V30  struStartTime;//Start Time
    NET_DVR_TIME_V30  struStopTime;//Stop Time
    char   sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE   byRes1[224];
} NET_DVR_VEHICLE_CONTROL_LIST_INFO, *LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;


typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//Channel
    DWORD  dwOperateType;//Operate Type,VCA_OPERATE_TYPE.
    char   sLicense[MAX_LICENSE_LEN];//License
    char   sCardNo[MAX_CARDNO_LEN]; // Card No.
    BYTE   byListType;//List Type;0-allow list,1-block list,0xff-all
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//Data Index     
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND, *LPNET_DVR_VEHICLE_CONTROL_COND;


typedef struct
{
    DWORD    dwSize;
    DWORD    dwDataIndex;//Data Index
    char     sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE     byRes[32];
}NET_DVR_VEHICLE_CONTROL_LIST_DSALARM, *LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM;


typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //List Type;0-allow list,1-block list,2-Provisional List
    BYTE  byPlateType;  //Plate Type
    BYTE  byPlateColor;    //Plate Color
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//License
    char  sCardNo[MAX_CARDNO_LEN];  //Card No.
    NET_DVR_TIME_V30 struAlarmTime; //Alarm Time
    DWORD dwChannel;
    DWORD dwPicDataLen;   //
    BYTE  byPicType;    //picture type,0-JPEG
    BYTE  byPicTransType;  //Image data transmission: 0-binary; 1-url
    BYTE  byRes3[2];
    char    *pPicData;
    BYTE  byRes2[48];
}NET_DVR_VEHICLE_CONTROL_ALARM, *LPNET_DVR_VEHICLE_CONTROL_ALARM;


typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//Alarm Time
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM, *LPNET_DVR_FIRE_ALARM;


typedef struct
{
    DWORD       dwSize;
    DWORD dwDelType;//Delete Type VCA_OPERATE_TYPE
    char  sLicense[16]; //License
    char  sCardNo[48];  //Card No 
    BYTE  byPlateType;    //Plate Type
    BYTE  byPlateColor;    //Plate Color
    BYTE  byOperateType;//Operate Type(0-Delete a,0xff-Delete All)
    //2014-02-25
    BYTE  byListType;//List Type;0-Allow List,1-Block List 2014-03-03
    DWORD dwDataIndex;//Data Index     
    char  sOperateIndex[MAX_OPERATE_INDEX_LEN]; //Operate Index 2014-03-03
    BYTE  byRes[24];
} NET_DVR_VEHICLE_CONTROL_DELINFO, *LPNET_DVR_VEHICLE_CONTROL_DELINFO;


typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //Channel
    BYTE  byLaneNo; //LaneNo(0-invalid,1-Lane 1)
    BYTE  byBrightlampCtrl;//0-Close Brightlamp,1-Open Brightlamp
    BYTE  byRes[14];
}NET_DVR_GATELAMP_INFO, *LPNET_DVR_GATELAMP_INFO;


//SDI matrix 1.0
#define  MATRIX_MAX_OUTPUT_NUM      256              //SDI matix max output num 
typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize;
    DWORD dwValidInputNum;     //vaild input num 
    DWORD dwValidOutputNum;    //vaild output num 
    BYTE  byRes[64];
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize;
    DWORD   dwInputChan;        //input channel, 0 mean delete the relation of the output channel
    DWORD   dwOutputChan;       //output channel to relate ,(screen server use screen index(1byte device No + 1byte Res + 2byte screen index))0xffffffff mean relate all the all ouput 
    DWORD   dwMatrixID; //Matrix ID
    BYTE    byRes[28];
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize;
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //output channel relate the input channel,  dwIORelation[i] = j mean output channel (i + 1) and input channel (j) has a relation, 
    //dwIORelation[i] = 0 mean output channel (i +1) didn't relate any input channel                                                        
    BYTE    byRes[256];
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;

typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //TriggerType,ITC_TRIGGERMODE_TYPE 
    BYTE   byRes[24];
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;


typedef struct tagNET_DVR_TEMP_HUMI
{
    DWORD    dwSize;
    DWORD       dwChannel;         // Channel
    int      iHumidity;         // Humidity
    int      iTemp;             // Temp
    BYTE     byRes[8];
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;

typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;
    DWORD    dwChannel;     // Channel Number, Default 1
    DWORD    dwSoundMode;   // Alarm Sound Mode: 0~Hint Mode;1~Alarm Mode;2~Mute Mode
    BYTE     byRes[12];
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{
    DWORD    dwSize;
    DWORD    dwChannel;
    DWORD    dwMode;
    char     szRandCode[6];
    BYTE     byRes[6];
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;        //show enable,1-show ,0-hide    
    BYTE  byBaseMapType;    //basemap type,1-picture,2-virtual screen,3-basemap circle
    BYTE  byBaseMapCircleNo; //basemap circle number, byBaseMapType is basemap circle
    BYTE  byRes1;
    DWORD dwBaseMapNo;     /*base map No. ,Base map type 1:picture No;Basemap type 2:virtual screen input No.(1byte:video platform No.
    +1byte:sub board No.+1byte:input No.+1byte:0)*/
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG, *LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //resolution
    BYTE  byRes2[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byWndOperateMode;
    BYTE  byRes1[6];
    NET_DVR_RECTCFG_EX struWinPosition;//base map window position,window length and hight must be integer multiple of the base unit
    NET_DVR_RECTCFG_EX struResolution;
    DWORD dwXCoordinate;
    DWORD dwYCoordinate;
    BYTE  byRes2[36];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//base map picture name
    BYTE   byUsed; //picture exist,0-not exist,1-exist
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO, *LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO size,include BMP head, should be smaller than 100Kb,length and hight should be integer multiple of 32 
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO, *LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo exist,0-not exist,1-exist(read only)
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO size, include BMP head(read only)
    BYTE   byLogoName[NAME_LEN];  //logo name
    DWORD  dwLogoNo;    //logo No.(valid for getting all logos' configuration)
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG, *LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo No.
    BYTE   byEnable; //logo show or hide,1-show,0-hide
    BYTE   byRes1[3];
    DWORD  dwCoordinateX;    //picture x coordinate
    DWORD  dwCoordinateY;    //picture y coordinate    
    BYTE   byFlash;  //flash or not,1-flash,0-not flash
    BYTE   byTranslucent; //translucent or not,1-translucent,0-not translucent
    BYTE   byRes2[34];
}NET_DVR_WIN_LOGO_CFG, *LPNET_DVR_WIN_LOGO_CFG;


typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    BYTE    byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE    byRes[63];
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//Target tracking: 0- Close, 1- open, Default 0- Close
    BYTE bySensitivity;  // Sensitivity ;Range:1-100,Default:50
    BYTE byBackgroundUpdateRate;//Background updating speed: Range:1-100,Default:50
    BYTE bySceneChangeLevel;//Scene change level: Range:1-100, Default:50
    BYTE byMinTargetSize;//minimum target : Range: 1-100, Default: 50
    BYTE byUploadHeatMapResultType;//upload heat map result type 0-COMM_UPLOAD_HEATMAP_RESULT 1-COMM_UPLOAD_HEATMAP_RESULT_PDC and COMM_UPLOAD_HEATMAP_RESULT_DURATION
    BYTE byDayReport;
    BYTE byWeekReport;
    float fConfidence;//Confidence 0.00-100.00
    BYTE byMonthReport;
    BYTE byYearReport;
    BYTE byRes[6];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

#define MAX_HEATMAPREGION_NUM 8

//Heat map
typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD   dwSize;
    BYTE    byEnable; //Enable
    BYTE    byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//Region 
    NET_DVR_HEATMAP_PARAM  struHeatMap;
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //Exception processing mode
    //Alarm Time
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*Device Info*/
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    DWORD  dwMaxHeatMapValue;
    DWORD  dwMinHeatMapValue;
    DWORD  dwTimeHeatMapValue;
    WORD   wArrayLine;//Array Line 
    WORD   wArrayColumn;//Array Column
    BYTE*  pBuffer;  //Heat Map Picture
    BYTE   byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE   byBrokenNetHttp;     //Offline continuingly flags, 0 - not the retransmission data, 1 - retransmission data 
    WORD   wDevInfoIvmsChannelEx;     //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE   byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char   cStartTimeDifferenceH;      /*Time difference(HOUR) from UTC*/
    char   cStartTimeDifferenceM;      /*Time difference(MINUTE) from UTC*/
    char   cStopTimeDifferenceH;       
    char   cStopTimeDifferenceM;     
    BYTE   byArrayUnitType; //1-byte,2-short,4-int
    BYTE   byRes1[2];
    DWORD  dwTotalTime;//total stay time
    BYTE   byRes[112];
}NET_DVR_HEATMAP_RESULT, *LPNET_DVR_HEATMAP_RESULT;

typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel No.
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    BYTE    byReportType;//0-Invalid,1-Day list,2-Week list,3-Month list,4-Year list
    BYTE    byDetSceneID;//Detecetion Scene ID[1],Dome: 1, IPC:0
    BYTE    byHeatMapInfoType;//Info type
    BYTE    byStatisticalModel;//Statistical Model  0-def ,1-duration, 2-PDC
    BYTE    byRes[124];
}NET_DVR_HEATMAP_QUERY_COND, *LPNET_DVR_HEATMAP_QUERY_COND;

typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;  /*End Time*/
    DWORD  dwHeatMapPicLen;         /*Heat Map Picture Length*/
    BYTE*  pBuffer;                 //Heat Map Picture
    DWORD  dwTimeHeatMapValue;     //Time Heat Map Value
    DWORD  dwHeatMapMaxValue;
    DWORD  dwHeatMapMinValue;
    WORD   wArrayLine;//Array Line
    WORD   wArrayColumn;//Array Column
    BYTE*  pArrayBuffer; //Array Buffer
    BYTE   byArrayUnitType;//Array info Unit type,0~byte,1~int
    BYTE   byRes[107];
}NET_DVR_HEATMAP_INFO, *LPNET_DVR_HEATMAP_INFO;

typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    BYTE   byReportType;//0-Invalid,1-Day list,2-Week list,3-Month list,4-Year list
    BYTE    byEnableProgramStatistics; //According to the statistics show, 0 - no, 1 - is
    BYTE    byTriggerPeopleCountingData;//Enable the statistics of the passenger flow, 0- no, 1- is 
    BYTE    byMultiChannelSearch;//Multi-channel queries enabling
    DWORD   dwPlayScheduleNo; //According to the statistics show the related schedule number
    BYTE    byISO8601;  //Whether the 8601 time format
    char cStartTimeDifferenceH;
    char cStartTimeDifferenceM;
    char cStopTimeDifferenceH;
    char cStopTimeDifferenceM;
    BYTE    byRes1[3];
    DWORD dwSearchChannelNum; //Query the channel number
    char*    pSearchChannel;     //Query channel number buffer
    BYTE    byChild;//Only children, 0-no, 1-yes
    BYTE    byMinTimeInterva;// Minimum time interval, 0-invalid, 1-15 minutes, 2-30 minutes, 3 hours, 4-days, 5-weeks, 6-months
    BYTE    byStatisticType;//Statistical type, 0-invalid value, 1-entry number, 2-exit number, 3-all,,4-entryExitDuplicate,5-faceExpression
    BYTE    byFaceExpression;
    BYTE    byGender;
    BYTE    byMask;
    BYTE    byAgeGroup;
    BYTE    byGlasses;
    BYTE    byRes[96];
}NET_DVR_PDC_QUERY_COND, *LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PROGRAM_INFO
{
    DWORD   dwProgramNo; //program num
    BYTE    sProgramName[NAME_LEN]; //gropram name
    BYTE    byRes[16];
}NET_DVR_PROGRAM_INFO, *LPNET_DVR_PROGRAM_INFO;

typedef struct tagNET_DVR_POSINFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byEnable;//Pos information stack,0 - stack,1 - stac
    BYTE    byBackpackEnanble;//Whether the superimposed backpack information is superimposed, 0 - does not stack,1 - stack
    BYTE    bySexEnanble;//Is the superposition of gender information superimposed,0 - does not stack, 1 - stack
    BYTE    byCarryEnanble;//Whether stacking things to carry information superimposed,0 - does not stack, 1 - stack
    BYTE    byRideEnanble;// Whether the superposition of whether or not the superposition of bike information,0 - does not stack,1 - stack
    BYTE    byMaskEnanble;//Whether or not superimposed mask information is superimposed,0 - does not stack, 1 - stack
    BYTE    byHatEnanble;//Whether or not superimposed hat wearing information is superimposed,0 - does not stack, 1 - stack
    BYTE    bySleeveEnanble;//If the stack extended short sleeved case,0 - does not stack, 1 - stack
    BYTE    byPantsTypeEnanble;//Whether the superposition of pants property information is superimposed,0 - does not stack, 1 - stack
    BYTE    byHairEnanble;//Whether the superposition of short hair information superimposed,0 - does not stack, 1 - stack
    BYTE    byGlassesEnanble;//Whether superimposed wearing glasses information is superimposed,0 - does not stack, 1 - stack
    BYTE    byAgeEnanble;//Do you stack age information,0 - does not stack, 1 - stack
    BYTE    byHeightEnanble;//Stack height information is superimposed,0 - does not stack, 1 - stack
    BYTE    byRes[511];
}NET_DVR_POSINFO_OVERLAY, *LPNET_DVR_POSINFO_OVERLAY;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*Start Time*/
    NET_DVR_TIME_EX   struEndTime;/*End Time*/
    DWORD   dwEnterNum;   //Enter Num
    DWORD   dwLeaveNum;  //Leave Num
    NET_DVR_PROGRAM_INFO struProgramInfo;        //program info
    DWORD  dwPeoplePassing;        //People Passing
    BYTE    byRes1[8];
    BYTE    byISO8601;
    char cStartTimeDifferenceH;
    char cStartTimeDifferenceM;
    char cStopTimeDifferenceH;
    char cStopTimeDifferenceM;
    BYTE     byRes3[3];
    DWORD    dwDuplicatePeople;
    DWORD    dwExpressionUnknown;
    DWORD    dwPokerFace;
    DWORD    dwHappy;
    DWORD    dwSurprised;
    DWORD    dwDisgusted;
    DWORD    dwSad;
    DWORD    dwAngry;
    DWORD    dwContemptuous;
    DWORD    dwPanic;
    DWORD    dwGenderUnknown;
    DWORD    dwFemale;
    DWORD    dwMale;
    DWORD    dwMaskUnknown;
    DWORD    dwMaskYes;
    DWORD    dwMaskNo;
    DWORD    dwGlassUnknown;
    DWORD    dwGlassYes;
    DWORD    dwGlassNo;
    DWORD    dwSunglasses;
    DWORD    dwAgeGroupUnknown;
    DWORD    dwChild;
    DWORD    dwYoung;
    DWORD    dwMiddle;
    DWORD    dwOld;
    DWORD    dwInfant;
    DWORD    dwKid;
    DWORD    dwTeenager;
    DWORD    dwPrime;
    DWORD    dwMiddleAged;
    BYTE     byRes[64];
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;

typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*Province of shorthand  3 */
    BYTE  byTimeOsd;// the time information superposition 0 - no Superposition,1- Superposition
    BYTE  byRecogResultOsd;//recognize result superposition  0 - no Superposition,1- Superposition
    BYTE  byRecogHint;//recognize success with prompt. 0 - no prompt, 1- prompt
    BYTE  byRecogDir;//recoginze order 0: forward, 1: reverse
    BYTE  byRecogEnv;//recognize environment 0: daytime, 1: night
    BYTE  byRecogPlateType;//0-small licence plate recongnize,1-big licence plate recongnize
    BYTE  byUploadPlate;//0 -not upload licence plate, 1-upload licence plate
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG, *LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:not start radar  1:start radar */
    BYTE   byEnableAlarm;   /* 0:start alarm  1:not start alarm */
    WORD   wOverSpeed;    /* 20~250 */
    BYTE   bySpeedUnits;  /* 0:kph   1:mph */
    BYTE   bydirection;     /* 0:reverse(the same order of radar and car) 1:forward(not the same order of rader and car) */
    BYTE   byMeasureMode;   /* 0:static state (radar state)       1:dynamic state (radar state)*/
    BYTE   byTargetType;    /* 0:the fast  1:the last*/
    BYTE   bySensitivity;  /* sensitivity[0,100] */
    BYTE   byCaptureNum;   /* capture number[0,255] */
    BYTE   byUploadPlate;  /*upload or not the over speed capture picture 0-not upload,1-upload*/
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG, *LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* 0-block list check,1-no block list check*/
    BYTE  byCheckAlarm;/* check success with alarm 0-not alarm,1-alarm*/
    BYTE  byCheckHint; /* check success with promte (software promte) 0-no promte,1-promte*/
    BYTE  byUploadUnlicensedCar; /*0-not upload block car info,1-upload block car info*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG, *LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//channel number 0xff - all channel(default 1,represent one channel)
    NET_DVR_PLATE_INFO  struPlateInfo; //lpate info
    WORD  wIllegalType; //illegal type
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// illegal type info
    NET_DVR_TIME_V30  struIllegalTime;//illegal time
    BYTE  byIllegalVehicleNum;//illegal times
    BYTE  byRes1[3];
    char sCustomInfo[64];//custom info
    BYTE  byRes2[128]; // res
}NET_DVR_VEHICLE_CHECK, *LPNET_DVR_VEHICLE_CHECK;

typedef enum _LONG_CFG_SEND_DATA_TYPE_ENUM_
{
    ENUM_DVR_VEHICLE_CHECK = 1, //vehicle block list check
    ENUM_MSC_SEND_DATA = 2,  //screen control data type
    ENUM_ACS_SEND_DATA = 3, //access card data type
    ENUM_TME_CARD_SEND_DATA = 4, //Parking Card data type
    ENUM_TME_VEHICLE_SEND_DATA = 5, //TME Vehicle Info data type
    ENUM_DVR_DEBUG_CMD = 6, //Debug Cmd
    ENUM_DVR_SCREEN_CTRL_CMD = 7, //Screen interactive
    ENUM_CVR_PASSBACK_SEND_DATA = 8, //CVR get passback task executable data type
    ENUM_ACS_INTELLIGENT_IDENTITY_DATA = 9,  //intelligent identity data type
    ENUM_VIDEO_INTERCOM_SEND_DATA = 10,  //video intercom send data
    ENUM_SEND_JSON_DATA = 11    //send json data
}LONG_CFG_SEND_DATA_TYPE_ENUM;

typedef enum _LONG_CFG_RECV_DATA_TYPE_ENUM_
{
    ENUM_DVR_ERROR_CODE = 1, //Error code
    ENUM_MSC_RECV_DATA = 2, //screen control data type
    ENUM_ACS_RECV_DATA = 3 //ACS control data type
}LONG_CFG_RECV_DATA_TYPE_ENUM;
//2013-11-25
typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//WorkTime Interval(Unit:Sec)[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//Continue WorkTime(Unit:Sec)[2min~24h]Interface display by the minute units
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM, *LPNET_DVR_WIPER_CONTINUEWORK_PARAM;

typedef union tagNET_DVR_WIPERMODE_PARAM_UNION
{
    BYTE uLen[16];
    //if byWiperWorkMode = 1,valid.
    NET_DVR_WIPER_CONTINUEWORK_PARAM struWiperContinueWorkParam;
}NET_DVR_WIPERMODE_PARAM_UNION, *LPNET_DVR_WIPERMODE_PARAM_UNION;

typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //Wiper Work Mode
    //0- single mode, 1- Continue mode (according to the configuration of NET_DVR_ROTATE_OPERATE_PARAM), 2-auto mode, 0xff-close
    BYTE  byWiperWorkMode;
    BYTE  byRes1;
    WORD  wSensitivity;//rainfall sensitivity
    BYTE  byRes[20];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG, *LPNET_DVR_WIPERINFO_CFG;

//Set Autofocus Test 2013-10-26
typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{
    DWORD     dwSize;
    DWORD     dwChannel;            //Channel
    BYTE      byRes[24];
}NET_DVR_AUTOFOCUS_TESTCFG, *LPNET_DVR_AUTOFOCUS_TESTCFG;

/*******************************LCD begin******************************************/
//////////////////////////LCD Screen Display begin 2013-08-28////////////////////////////////
typedef struct tagNET_DVR_VIDEO_OUT_CFG
{
    BYTE    byDisplayMode;        //Display Mode,1-Standard,2-Cool Colour,3-Warm Colour,0xff-User Defined
    BYTE     byBrightnessLevel;     // Brightness 0-100
    BYTE    byContrastLevel;     // Contrast 0-100
    BYTE     bySharpnessLevel;     // Sharpness 0-100
    BYTE     bySaturationLevel;     // Saturation 0-100
    BYTE     byHueLevel;         // Hue0-100
    BYTE    byImageMode;        // Image mode, 0-normal, 1-night model 1, 2 - night model 2, 3 - night model 3, 4 - day model 1, 5 - day model 2, 6 - day model 3 
    BYTE    byRes[5];            //             
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;
//Color Temperature
typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{
    BYTE    byRed;                //Red, 0-100
    BYTE    byGreen;            //Green, 0-100
    BYTE    byBlue;                //Blue,0-100
    BYTE    byRedOffset;        //Red Offset,0-100
    BYTE    byGreenOffset;        //Green Offset,0-100
    BYTE    byBlueOffset;        //Blue Offset,0-100
    BYTE    byRes[6];
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{
    BYTE    byGainR;            //Gain R, 0-100
    BYTE    byGainG;            //Gain G,0-100
    BYTE    byGainB;            //Gain B,0-100
    BYTE    byOffsetR;            //Offset R,0-100
    BYTE    byOffsetG;            //Offset G,0-100
    BYTE    byOffsetB;            //Offset B,0-100
    BYTE    byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{
    BYTE    byEnable;           //Whether to enable the screen edge  0-Disable 1-Enable
    BYTE    byLeftEdge;           //Left Edge,0-100
    BYTE    byRightEdge;       //Right Edge,0-100
    BYTE    byTopEdge;           //Top Edge,0-100
    BYTE    byLowerEdge;       //Lower Edge,0-100
    BYTE    byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;
    BYTE    byCfgType;       /*Set Parameter type ,Get Parameter Invalid,
                               0-Invalid,1-Back Light,2-Video Out Cfg,3-Color Temperature Cfg,4-ADC,5-Screen Edge Cfg*/
    BYTE    byBackLight;        //Back Light 0~100
    BYTE    byRes1[2];
    NET_DVR_VIDEO_OUT_CFG           struVideoOutCfg;     //Video Out Cfg(Picture mode)
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //Color Temperature Cfg
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //Screen Edge Cfg
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;
//////////////////////////LCD Screen Display end/////////////////////////////////////////////

//Control Type
typedef enum tagNET_DVR_SCREEN_REMOTE_CTRL_TYPE
{
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,//1-power supply Open
    REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,//2-power supply Close
    REMOTE_CTRL_SIGNALSOURCE,//3-signal source
    REMOTE_CTRL_MENU,//4-menu
    REMOTE_CTRL_DETERMINATION,//5-determination
    REMOTE_CTRL_ON,//6-On
    REMOTE_CTRL_UNDER,//7-Under
    REMOTE_CTRL_LEFT,//8-Left
    REMOTE_CTRL_RIGHT,//9-Right
    REMOTE_CTRL_INFO,//10-INFO
    REMOTE_CTRL_RETURN,// 11-returns a layer
    REMOTE_CTRL_NUM, //12-number key
}SCREEN_REMOTE_CTRL_TYPE;

//Simulate Screen Remote Ctrl 2013-09-05
typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;
    BYTE        byControlType;    /*1- power supply, 2- power supply, 3- signal source, the 4- menu,
    5- determination,6-On,7-Under,8-Left,9-Right,  10-INFO, 11- returns a layer 12-digital key,13-power on/off*/
    BYTE        byControlParam; //operate parameter, when operate type is 12, it means key value(0-9), other invaild.   
    BYTE        byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL, *LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//Screen Signal CFG
typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;
    BYTE     bySignalSourceType;    //Signal Source Type,Refer to NET_DVR_CAM_MODE
    BYTE     byNoSignalPic;            //No Signal Pic,1- Blue screen, 2- Black screen, 3-LOGO screen
    BYTE     byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

//Screen Splice Cfg
typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;
    BYTE    bySpliceIndex;            //Splice Screen Index,0 - No splicing,Other values - Splice Screen Index.
    BYTE    bySpliceX;                //Splice X
    BYTE    bySpliceY;                //Splice Y
    BYTE    byWidth;                //Weight
    BYTE    byHeight;               //Height
    BYTE    byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

//Fan Work Mode
typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;
    BYTE        byWorkMode;                 //1- normally open, 2- automatically
    BYTE        byTemperatureLimitValue; //Temperature Limit Value,working mode is automatically,Parameters effective.
    BYTE        byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA
typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;
    BYTE        byEnableAutoAdjust;     //Enable Auto Adjust,0-No,1-Yes,Enable Auto Adjust,The following parameters effective.
    BYTE        byHorizontalPosition;   //Horizontal Position 0-100
    BYTE        byVerticalPosition;      //Vertical Position 0-100
    BYTE        byClock;                //Clock ,0-100
    BYTE        byPhase;                //Phase,0-100
    BYTE        byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

//Screen Menu
typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;
    BYTE        byMenuLanguage; //Language,1-Chinese,2-English
    BYTE        byTransparency; //Transparency 0-opacitas,1-Low,2-Middle,3-High
    BYTE        byDuration;        //Duration,0-normally open,1-5 sec,2-15 sec,3-30 sec
    BYTE        byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

//Pip
typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;                 //Enable 0~Disable,1~Enable
    BYTE    bySubWindowSource;         //Sub Window Source,Refer to NET_DVR_CAM_MODE
    BYTE    bySubWindowBorderColor;     //Sub Window Border Color, 1-Blue,2-Black
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;   //Sub Window Position,The total size of the 100*100 screen
    BYTE    byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

//Defog
typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;
    BYTE    byDefogEnable;    //Defog Enable,0~Disable,1~Enable
    BYTE    byDefogModel;     //Defog Model,0~automatically,1~manual
    BYTE    byDefogLevel;     //Defog Level,1-7Levels, Default Level is 4.Level 1 is 0.5;Level 2 is 0.55;Level 3 is 0.60;Level 4 is 0.65;Level 5 is 0.70;Level 6 is 0.75;Level 7 is 0.80.(Defog Model is manual,Parameters effective)
    BYTE    byRes[33];
}NET_DVR_DEFOG_LCD, *LPNET_DVR_DEFOG_LCD;

//Screen Wall
typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD    dwSize;
    BYTE    byEnable; //Enable Screen Wall.0-Disable;1-Enable
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

//Screen Pos
typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD     dwSize;
    BYTE     byScreenRowNum;//Screen Row Num.
    BYTE     byScreenColNum;//Screen Col Num.
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;
/*******************************LCD end******************************************/
typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize;
    DWORD     dwChanNo;   //Video and Audio Channel NO., if the binding is enabled, voice intercom channel is then bound as the audio source for the channel
    BYTE      byEnable;   //enable voice intercom as the audio input source: 0 - not enabled 1 - Enabled
    BYTE      byRes[31];          //res
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
    DWORD    dwMaxRelRecordChanNum;
    DWORD    dwRelRecordChanNum;
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30/*64*/];
    BYTE    byEnablePreset[MAX_CHANNUM_V30];
    BYTE    byPresetNo[MAX_CHANNUM_V30];
    BYTE    byEnableCruise[MAX_CHANNUM_V30];
    BYTE    byCruiseNo[MAX_CHANNUM_V30];
    BYTE    byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE    byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/];
    BYTE  byRes[224];
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{
    DWORD dwSize;
    BYTE    byEnable;
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;
    DWORD   dwMaxRelAlarmOutChanNum;
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/];
    DWORD     dwMaxRecordChanNum;
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];
    DWORD dwEnablePresetChanNum;
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/];
    BYTE byRes2[516];
    DWORD dwEnableCruiseChanNum;
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/];
    DWORD dwEnablePtzTrackChanNum;
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30];
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;;
    BYTE     byEnableCS;  //start CS  0-close 1-enable
    BYTE     byRes[511];
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;


typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize;
    BYTE  byValid;
    BYTE    byRecord;
    DWORD   dwRelatedHD;  //Relate HD
    BYTE    byOffLineRecord;  //Off Line Recording Function 0-close 1-open
    BYTE     byRes[63];
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

#define  MAX_CAMERAID_LEN    64
typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;
    DWORD             dwRecordType; //The video type: 0- scheduled recording, 1- motion detection, 2- semaphore (IO) alarm, 3- semaphore (IO) alarm or motion detection, 4- semaphore (IO) alarm and motion detection, 5- command trigger, 6- manual recording, 7- vibration alarm, 8- environment alarm, 9- intelligent alarm (including retrograde, transboundary, item lost, remnants, and so on), 10- tampering alarm 
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //Start Time
    NET_DVR_TIME_EX   struStopTime;
    DWORD             dwStoragePoolID;
    BYTE              byFormatType;     //video format type,1-original,2-RTP,3-PS,4-TS,5-private,6-FLV,7-ASF,8-3GP,9-RTP+PS(GB28181),0xff-Invalid 
    BYTE  byVideoEncType;   //Video Code Type:  0-private h264;1-standard H264;2-standard MPEG4;5-MPEG2;7-M-JPEG;0xfe- auto;0xff-invalid 
    BYTE  byAudioEncType;   //Audio Code Type:  0- G722; 1- G711_U; 2- G711_A;5-MP2L2;6-G726;7-AAC;0xfe- auto,0xff-invalid 
    BYTE   	          byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char       cStartTimeDifferenceH;   
    char       cStartTimeDifferenceM;   
    char       cStopTimeDifferenceH;    
    char       cStopTimeDifferenceM;    
    BYTE              byRes[120];
}NET_DVR_UPLOAD_RECORD_INFO, *LPNET_DVR_UPLOAD_RECORD_INFO;


#define NET_DVR_GET_TEST_VERSION_HEAD           268435441   
#define NET_DVR_SET_TEST_VERSION_HEAD           268435442   
#define NET_DVR_GET_TEST_VERSION_HEAD_V1        268435443   
#define NET_DVR_SET_TEST_VERSION_HEAD_V1        268435444   
#define NET_DVR_GET_TEST_VERSION_HEAD_V2        268435445   
#define NET_DVR_SET_TEST_VERSION_HEAD_V2        268435446   
#define NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0    268435447   
#define NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0    268435448  

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //heart check time,Unit (ms), min 30s, max 120s, while set Cfg ,0 meas use the default 120s
    DWORD   dwCheckOnlineNetFailMax;  //Since the maximum  number of reasons for the failure of the network,
    //Exceed the value of the SDK before the callback user exception, while set cfg ,0 means use the default value of 1
    BYTE    byRes[256];
}NET_DVR_LOCAL_CHECK_DEV, *LPNET_DVR_LOCAL_CHECK_DEV;

typedef struct tagNET_DVR_LOCAL_PTZ_CFG
{
    BYTE   byWithoutRecv;     //0-recv,1-without recv
    BYTE   byRes[63];
}NET_DVR_LOCAL_PTZ_CFG, *LPNET_DVR_LOCAL_PTZ_CFG;

typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE    byVersion;
    BYTE    byRes[63];
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;


//External Device CFG 2013-11-19
typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-,1- remote reading head device, 2- entrance control machine, all information of 3-LED screen 0xff- (using long connection access)
    BYTE   byRelativeIndex;//Other 0- (retention), index (relative to the access type (1~8 0xff-) all information using long connection access)
    //    BYTE   byLaneID;// Lane ID  
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND, *LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//Other 0-, 1- remote reading head device, 2- entrance control machine, 3-LED screen
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE    byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//Device IP 144
            WORD     wDevPort;//Device Port
            BYTE     byRes[510];
        }struRrReader;//Long distance reading head device

        struct
        {
            BYTE byRs485No; //RS485 Number
            BYTE byDevCtrlCode;//Code address, used to distinguish the equipment (1-255)
            BYTE byAutoIssuedData;//Whether automatic send no automatic card data 0-, 1- automatically.
            BYTE byOfflineDetEnable;//Offline Detection Enable,0-Close,1-Open
            BYTE byDetCycle;//Detection Cycle(0~60 s)
            BYTE byRes[651];
        }struGateway;//Entrance control machine

        struct
        {
            BYTE byExternalMode;//0-RS485,1-Network
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP address 144
            WORD wDevPort;//Device Port
            BYTE byRs485No; //RS485 No.
            BYTE byDevCtrlCode;//Code address, used to distinguish the equipment (1-255)
            //led screen display is controlled by control card, different control card display type support in different ways
            BYTE byCtrlCardType;//Control card type 0- retention (invalid value) 1- EQ2013
            BYTE byLedScreenType;//Screen type 0- monochrome screen 1- double color screen
            BYTE byLedScreenUse;//Screen uses 0- other 1- location screen 2- screen prompts 3- fee screen
            BYTE byLedDisplayMode;//The screen font display see instructions
            char sLedCustomInfo[MAX_LED_INFO];//The screen font display information
            DWORD dwLedScreenH;//Display height takes LED points
            DWORD dwLedScreenW;//Display width is required on the LED points
            BYTE byRes1[236];
        }struLed;//led screen
    }uExternalDevInfo; //By the byExternalMode value to determine which effectively
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;


typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//Device Name
    BYTE   byExternalDevTpye;//External Device Tpye
    BYTE   byRelativeIndex;//Relative Index
    BYTE   byOnline;//0-Not online,1-online
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS, *LPNET_DVR_EXTERNAL_DEVSTATUS;


typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;
    BYTE   byOfflineDetEnable;//Offline Enable 0-Close,1-Open
    BYTE   byDetCycle;//Detection Cycle
    BYTE   byDevCtrlCode;//Detection Ctrl Code
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG, *LPNET_DVR_ENTRANCEDET_CFG;

typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD   dwSize;
    BYTE   byDevCtrlCode;//Device Ctrl Code
    BYTE   byManualIssuedData;//Manual Issued Data 0-Disable,1-Enable
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND, *LPNET_DVR_ENTRANCEDEV_COMMAND;

typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize;
    BYTE   byDevCtrlCode;//Device Ctrl Code
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL, *LPNET_DVR_ENISSUED_DATADEL;

typedef  struct  _tagNET_ITS_PASSVEHICLE_COST_ITEM
{
    DWORD   dwSize;
    DWORD   dwPassVehicleID; //Pass Vehicle ID
    BYTE    byIntime[MAX_TIME_LEN]; //In Time, Time format: yyyymmddhh24missfff
    BYTE    byOuttime[MAX_TIME_LEN]; //Out Time, Time format:yyyymmddhh24missfff
    BYTE    byCardNo[MAX_CARD_LEN];   //Card No
    BYTE    byPlateInfo[MAX_LICENSE_LEN]; //Plate Info
    float   fPayCost;       //Pay Cost
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //Operator Name
    BYTE    byVehicleType; //Vehicle Type  0-Small Vehicle 2-Big Vehicle
    BYTE    byRes1[3];
    DWORD   dwPayRuleID; // Pay Rule ID
    DWORD   dwFreeRuleID; // Free Rule ID
    BYTE    byRes2[256];
}NET_ITS_PASSVEHICLE_COST_ITEM, *LPNET_ITS_PASSVEHICLE_COST_ITEM;

typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //Operator Name
    BYTE    byOperatorCard[MAX_CARD_LEN]; //Operator Card
    BYTE    byStartTime[MAX_TIME_LEN];//Start Time, Time format:yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //End Time, Time format:yyyymmddhh24miss
    float   fTotal_Pay;    //Total Pay
    DWORD   dwTotal_Records;   //Total Records
    BYTE    byRes[64];
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;

typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//Synchronization ouput number(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND, *LPNET_DVR_IOOUT_COND;

typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD dwSize;
    BYTE   byWorkMode;//0-alarm ouput,1-Strobe Lamp(default)
    BYTE   byRes1[3];
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//default state 0-low level(default),1-high level
            BYTE   byWorkState;//work state  0-low lever(default),1-high level,2-pulse
            BYTE   byFreqMulti;//frequency multiplication,range[1,15]
            BYTE   byDutyRatio;//duty ratio, range[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;    //set enable time of flash light: 0-disalbe;1-enable
            NET_DVR_SCHEDTIME  struFlashLightTime;//flash light enable time period
            BYTE   byRes1[116];
        }struStrobeLamp;    // valid when byWorkMode value is 1-Strobe Lamp
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG, *LPNET_DVR_IOOUT_CFG;

//signal light Synchronization Configuration

typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//phase, range[0,360]
    BYTE   byLineLock;//Synchronous power, 0-disable,1-enable
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG, *LPNET_DVR_SIGNAL_SYNCCFG;

typedef struct
{
    DWORD    dwSize;
    BYTE    byEnable;// enable EZVIZ access 0~disable,1~enable
    BYTE    byDeviceStatus; //Whether the equipment online,0-Reserve,1-Online,2-Offline
    BYTE    byAllowRedirect;    // allow redirection, 0-Retain, 1-yes, 2-no
    BYTE    byDomainName[MAX_DOMAIN_NAME];
    BYTE    byRes1;
    BYTE    byVerificationCode[NET_SDK_MAX_VERIFICATION_CODE_LEN/*32*/];//verification Code
    BYTE    byNetMode;
    BYTE    byOfflineStatus;    //Offline specific status of the device
    BYTE    byEnableTiming;// enable EZVIZ Timing 0~disable,1~enable
    BYTE    byRes2;
    BYTE    byOperateCode[NET_SDK_MAX_OPERATE_CODE_LEN];  //operate code
    BYTE    byRes[344];
}NET_DVR_EZVIZ_ACCESS_CFG, *LPNET_DVR_EZVIZ_ACCESS_CFG;


#define MAX_DISPLAY_NUM         512  //max display channel number
#define MAX_LEDCONTENT_NUM      512  //max length of virtual led content
#define MAX_PPT_CHAN            128

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//enable video wall,0-disable,1-enable
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//video wall scale,base on reference coordinate 
    BYTE    sName[NAME_LEN]; //name of video wall
    BYTE     byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//display channel No.
    BYTE  byDispChanType;/*display channel mode,1-BNC,2-VGA,3-HDMI,4-DVI,5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI adapter,10-3GSDI,11-VGA/DVI adapter, 12-HDBaseT,13-HDTVI, 14-TVI, 0xff-invaild*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM, *LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/];
    BYTE   byRes[128];
}NET_DVR_DISPLAYCFG, *LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byCoordinateType;//Coordinate type:0-Reference coordinates, 1-Actual coordinates
    BYTE  byRes1[2];
    DWORD dwVideoWallNo;  //video wall No., one byte video wall No. + three byte reserved
    DWORD dwDisplayNo;    //diaplay channel No.   
    NET_DVR_RECTCFG_EX struRectCfg; //position of dispaly channel on the video wall
    BYTE    byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION, *LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //window enable, 0-disable,1-enable
    BYTE  byWndOperateMode;  //Window operation mode, 0 - coordinate system, 1 - resolution coordinates
    BYTE  byRes1[6];
    DWORD dwWindowNo;//window No.
    DWORD dwLayerIndex;//layer index of window
    NET_DVR_RECTCFG_EX struRect;//position of window on the video wall
    NET_DVR_RECTCFG_EX struResolution; //Window to coordinate resolution, get or set effective according to the resolution of the coordinates
    DWORD dwXCoordinate;
    DWORD dwYCoordinate;
    BYTE  byRes2[36];
}NET_DVR_VIDEOWALLWINDOWPOSITION, *LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    DWORD dwWindowNo; //window No.
    DWORD dwSceneNo;  //scene No.
    DWORD dwDestWallNo; //dest wall no
    DWORD dwDestSceneNo;//dest scene no
    BYTE byRes[12];
}NET_DVR_VIDEO_WALL_INFO, *LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM
{
    DWORD   dwSize;
    BYTE    byEnable; //enable virtual led, 0-disable,1-enable
    BYTE    byDispMode;//display mode,1-transparent,2-translucent,3-cover
    BYTE    byWndOperateMode;
    BYTE    byType;
    BYTE    byDirection;
    BYTE    byTimeType;
    BYTE    byDateFormat;
    BYTE    byTimeFormat;
    NET_DVR_RGB_COLOR struContentColor;//font color
    NET_DVR_RGB_COLOR struBackColor;//background color
    NET_DVR_RECTCFG_EX struRect;
    DWORD   dwContentNum;/*content length*/
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; /*content of led*/
    BYTE    byMoveMode;  //move mode,1-normal,2-smooth,3-static    
    BYTE    byFontSize; //font size,1-1 time,2-2 times,3-4 times
    BYTE    byMoveDirection; //move direction,0-default(left to right),1-left to right,2-right to left,3-top to buttom,4-buttom to top
    BYTE    byMoveSpeed; //character move speed,1-speed1,2-speed2
    NET_DVR_RECTCFG_EX struResolution;
    DWORD   dwXCoordinate;
    DWORD   dwYCoordinate;
    BYTE    byHourFormat;
    BYTE    byAMFormat;
    BYTE    byPMFormat;
    BYTE    byAlignmentX;
    BYTE    byAlignmentY;
    BYTE    byFontType;  //font type, 0-default,1-Simsun,2-boldface,3-regular script,255-custom
    BYTE    byRes2[90];
}NET_DVR_VIRTUALLED_PARAM, *LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //image cut mode,1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE, *LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{
    DWORD  dwSize;
    DWORD  dwSerialPort; //current use serial port 
    BYTE byProtocolType; //serial protocol type ,1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 , 4-LCD-DLP, 5-LCD-S3 , 6-LCD-D20,7-LCD-L2,8-LCD-Z1,9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+  
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT, *LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//scene name
    BYTE  byEnable;//scene valid, 1-valid,0-invalid
    BYTE  bySceneIndex;     //scene index,only for getting
    BYTE  byRes[78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //video wall information
    DWORD dwCmd; //scene control command,1-scene switch,2-initialize scene,3-force switch,4-save current scene to
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{
    DWORD dwSize;
    DWORD dwDisplayNo;  //display channel No., assign 0xffffffff to operate all display channels
    BYTE  byEnable;     //enable display, 0-disable, 1-enable
    BYTE  byChanType;   //channel type to show, 1-display channel No.,2-screen No.
    BYTE  byRes1[2];
    DWORD dwWallNo;     //wall no,1 byte wall No.(high bit)+3 bytes 0,valid when display screen No.
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO, *LPNET_DVR_SHOW_CONTROL_INFO;



typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;    //buffer pointer
    DWORD   nLen;    //buffer length
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //condition buffer
    NET_DVR_BUF_INFO struInParamBuf;         //parameter buffer
    DWORD  dwRecvTimeout;      //receive timeout, unit:ms,assign 0 to use default timeout
    BYTE   byRes[32];
}NET_DVR_IN_PARAM, LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf; //output buffer
    void*  lpStatusList;         //status buffer    
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM, LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;
    DWORD dwChannel;   //audio channel combine(1 byte device no+1 byte subboard no +2 byte audio channel no)
    BYTE  byRes[48];
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO;

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //audio channel name 
    BYTE          byEnable; //enable the audio, 0-close 1-open
    BYTE          byAudioSwitchType; //audio switch type, 1-according to IPC source, 2- according to window decode
    BYTE          byRes[2];
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //audio source information it is avalid when byAudioSwitchType is 1
    DWORD         dwWindowNo; //Window No( 1 byte wall No. + 1 byte sub window No. + 2byte window No.)
    BYTE          byRes2[28];
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //serial work mode,1-RS484,2-RS232
    BYTE byFunType; //function type,1-matrix serial control,2-screen control,3-serial data through 4-PPP Mode  5-Console mode 6-Direct connect 7-Keyboard control 8-Monitor control 9-PTZ control
    BYTE byDataBit;// data bit 0-5bit,1-6bit,2-7bit,3-8bit;
    BYTE byStopBit;// stop bit,  0-1bit,1-2bit;
    DWORD dwBaudRate;//baud rate 0-50,1-75,2-110,3-150,4-300,5-600,6-1200,7-2400,8-4800,9-9600,10-19200, 11-38400,12-57600,13-76800,14-115.2k;
    BYTE byParity;//check 0-no check,1-odd,2-even;
    BYTE byFlowcontrol;// 0-no control,1-soft control,2-hard control
    WORD wProtocol;//serial protocol
    BYTE byVariable;  //is variable,1-not 2-variable
    BYTE byGateWayEnable; //is used in gate way ,0-yes, !0-no
    BYTE byRes[30];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

#define MAX_SUBBOARD_NUM        42        //C10s  subboard number 
#define MAX_SINGLE_BOARD_EXCEPTION_NUM 16 //single board exception number 

typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;
    BYTE       byBoardType;    //board type, 0-mainboard, 1-DVI-I input, 2-YPbPr input, 3-BNC input, 4-SDI input, 5-DVI double link inupt, 6-ordinary decode input, 7-DVI-I output, 8-SDI output, 9-enhance decode input, 10-DP input, 11-HDTVI input, 12-HDBaseT output, 13-HDMI input, 14-HDBaseT input, 15-DVI-T input, 16-HDMI output,17-HDMI-HD input ,18-HDMI-UHD input , 19-DP_UHD input, 0xff-unknow
    BYTE       byInterfaceNum;  //interface number 
    BYTE       byStatus;        //status 0-except 1-normal 
	BYTE       bySyncStatus;   // Ultra HD board sync status, 0 - sync not enabled, 1- sync enabled
    DWORD      dwSlotNo;       //slot No where the board is in .
    BYTE       byRes2[32];
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //backboard type , 1-4U, 2-8U, 3-13U, 0xff-unknow
    BYTE      bySoltNum;        //solt number
    BYTE      byBoardNum;   //vaild number
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //the first byBoardNum items is vaild 
    BYTE       byRes2[32];
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE         byExceptNum;         //Exception number 
    BYTE        byRes1[3];
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //Major type 
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //Minor type 
    BYTE        byRes2[32];
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;

typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0 mobile detection,
    1 video occlusion,
    2 video loss,
    3  PIR alarm,
    4  wireless alarm,
    5  emergency alarm,
    6  intelligent capture,
    7  face detection,
    8  boundary detection detection,
    9  regional intrusion detection,
    10 scene change detection,
    11 Abnormal detection,
    0xff alarm input
    */
    BYTE  byAlarmType;
    //linkage action 0- is invalid, 1- screenshots upload FTP, 2-Jpeg screenshots upload Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    // alarm input number or the channel number or wireless number
    // (when byAlarmType ==0xff, dwChannel represents the alarm input number)
    // (when byAlarmType ==4, said dwChannel is the wireless serial number)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND, *LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum; // alarm correlation channel number triggered (read-only) maximum support number
    //initial value of dwRelateChan is an array of 0xFFFFFFFF; fill in the actual channel number;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG, *LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //Enable proportion variable times configuration 0-disable, 1-able
    BYTE   byPresetFreezing; //Enable the preset video freeze 0-disable, 1-able
    BYTE   byPresetSpeed;//Preset speed grade 1--8, the default 4
    BYTE   byKeyboardCtrlSpeed;//Manual speed grade 0-low,1-middle,2-high 
    BYTE   byAutoScanSpeed;//Scanning speed grade: 1--40, the default 28
    BYTE   byZoomingSpeed;//Zoom speed: 1--3, the default 3
    BYTE   byManualControlSpeed;// Manual Control Speed: 0- res,1-human,2-nonMotorVehicle, 3-motorVehicle, 4-adaptive
    BYTE   byPTZMotionTrack;//PTZ Motion Track 0-open, 1-close
    BYTE   byRes[124];
}NET_DVR_PTZ_BASICPARAMCFG, *LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //Lens multiple display: 1-2 seconds, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPtStatus;//Azimuth display: 1-2 second, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPresetStatus;//Preset title display: 1-2 second, 2-5 second, 3-10 second, 0xff- 0- normally closed, normally open, the default 2 seconds
    BYTE   byPositionDisplayFormat;//Azimuth display format 0- in accordance with PT display (P179|T-02), 1- in accordance with the direction of display (SE123|T-02)
    BYTE   byRes[124];
}NET_DVR_PTZ_OSDCFG, *LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //Power off memory models: Oxff-, 1-30, 2-60 disable seconds seconds seconds seconds, 3-300, 4-600, default is 30 seconds
    BYTE   byRes[127];
}NET_DVR_PTZ_POWEROFFMEMCFG, *LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byLimitMode;//The limiting mode 0- retention, 1- key control limit, 2- scanning limit
    BYTE   byRes[63];
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable,1-able
    BYTE   byLimitStatus; //The limit state 0- is not limiting, 1- has a limit (not editable)

    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCFG, *LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byLimitMode; //Limiting 0- retention, 1- key control limit, 2- scanning limit
    BYTE   byWorkMode;//0-set,1-clear
    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCTRL, *LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode;//PTZ lock control 0- unlock, 1-lock
    BYTE   byRes[123];
}NET_DVR_PTZ_LOCKCFG, *LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE   byRes[64];
}NET_DVR_PTZLOCKINFO_COND, *LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec;//Remaining Sec
    BYTE    byRes[128];
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;
    WORD   wRouteNo;
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND, *LPNET_DVR_CRUISEPOINT_COND;

typedef struct
{
    WORD    wPresetNo;
    WORD    wDwell;
    BYTE    bySpeed;
    BYTE    bySupport256PresetNo;//256th preset point compatibility before whether the force
    BYTE    byRes[6];
}NET_DVR_CRUISEPOINT_PARAM, *LPNET_DVR_CRUISEPOINT_PARAM;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISE_POINT_NUM];
    BYTE     Res[64];
}NET_DVR_CRUISEPOINT_V40, *LPNET_DVR_CRUISEPOINT_V40;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISEPOINT_NUM_V50];
    BYTE   Res[64];
}NET_DVR_CRUISEPOINT_V50, *LPNET_DVR_CRUISEPOINT_V50;


//2014-03-15 Set Limit scanning parameters
typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //Channel Number
    BYTE    byLinearScanType; //Limiting type, 0- retention, 1- left boundary setting, 2- right boundary setting
    BYTE    byRes[63];
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

//Stream attach information
typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //Structure Size
    BYTE  byStreamWithVca; //Add vca info in stream,which can be available for later retrieval.0-not add,1-add
    BYTE  byRes[127];      //
}NET_DVR_STREAM_ATTACHINFO_CFG, *LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;  //default route, 0 means struEtherNet[0], 1 means struEtherNet[1]
    BYTE   byNetworkCardNum;      //the usable netcard number in  the device 
    BYTE   byCurDetectType;// current detection area type,0-Polygon,1-Detection line
    BYTE   byRes1;
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD]; //etherNet card 
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byAllPreset; //Remove all the preset point:0-disable,1-able
    BYTE   byAllPatrols; //Remove all the patrols:0-disable,1-able
    BYTE   byAllPatterms; //Remove all the patterms:0-disable,1-able
    BYTE   byAllPrivacyMasks; //Remove all the privacy masks:0-disable,1-able
    BYTE   byAllPTZLimited; //Remove all the ptz limit:0-disable,1-able
    BYTE   byAllScheduledTasks; //Remove all the scheduled tasks:0-disable,1-able
    BYTE   byAllParkAction; //Remove all the park action:0-disable,1-able
    BYTE   byRes[125];
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //PTZPrioritize:0-Rs485,1-net(default)
    BYTE   byRes[3];
    DWORD  dwDelay; //2---200s
    BYTE   byRes1[124];
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byWorkMode;//0-Set,1-Clear
    BYTE   byRes[127];
}NET_DVR_INITIALPOSITIONCTRL, *LPNET_DVR_INITIALPOSITIONCTRL;

typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byRegionalID; //RegionalID  1~24
    //Delete the corresponding current ID privacy information 0- retention, deletion of 1- (WriteOnly)
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62];
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable,1-able
    //Privacy zone configuration parameters are displayed  0-disable,1-able(ReadOnly)
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0- reserves, 1- gray, red, green, 2- 3- 4- 5-, 6- blue, orange yellow, 0xff- mosaic
    BYTE   byActiveZoomRatio;//Shielding rate:1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON  struRegion;
    //The current regional coordinate is valid or not (0-disable, 1-able is for a single locale regional coordinate information, and a single scene of locale regional coordinate information)
    BYTE   byCurrentRegionEnable;
    // 0- byActiveZoomRatio ;1- fActiveZoomRatio(Support curActiveZoomRatioType)
    BYTE   byCurZoomRatio;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable 0-disable,1-able
    BYTE   byRes[127];
}NET_DVR_PRIVACY_MASKS_ENABLECFG, *LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//Enable 0-disable,1-able
    BYTE  byRes[3];
    DWORD dwDuration;//Duration: 0--300 seconds, the default 300 seconds
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG, *LPNET_DVR_SMARTTRACKCFG;

typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;
    BYTE   byRes[128];
}NET_DVR_ZOOMRATIOCTRL, *LPNET_DVR_ZOOMRATIOCTRL;

typedef struct tagNET_MATRIX_CAMERAINFO
{
    DWORD dwGlobalCamId;      
    BYTE  sCamName[NAME_LEN]; 
    DWORD dwMatrixId;        
    DWORD dwLocCamId;       
    BYTE  byValid;  
    BYTE  byPtzCtrl; 
    BYTE  byUseType; 
    BYTE  byUsedByTrunk;
    BYTE  byTrunkReq; 
    BYTE  byRes1[3];
    NET_DVR_TIME struInstallTime;
    BYTE  sPurpose[NAME_LEN];
    BYTE  byRes2[20];
}NET_MATRIX_CAMERAINFO, *LPNET_MATRIX_CAMERAINFO;


typedef struct tagNET_MATRIX_MONITORINFO
{
    DWORD    dwGloalMonId; 
    BYTE    sMonName[NAME_LEN];
    DWORD    dwMatrixId;  
    DWORD    dwLocalMonId;
    BYTE    byValid;   
    BYTE    byTrunkType; 
    BYTE    byUsedByTrunk;
    BYTE    byTrunkReq;
    NET_DVR_TIME struInstallTime;
    BYTE    sPurpose[NAME_LEN];
    BYTE    byRes[20];
}NET_MATRIX_MONITORINFO, *LPNET_MATRIX_MONITORINFO;

typedef struct tagNET_DVR_MATRIXDATABASE
{
    DWORD dwDevType;
    DWORD dwParam; 
    BYTE  byFileType;
    BYTE  byRes[3];
} NET_DVR_MATRIXDATABASE, *LPNET_DVR_MATRIXDATABASE;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
    /*Subsystem type, 1-decode subsystem, 2-code subsystem, 3-cascading output subsystem, 4-cascading input subsystem, 5-distributor subsystem, 6-alarm host subsystem,
    7-smart subsystem, 8-V6 decode subsystem, 9-V6 subsystem, 10-transform subsystem, 11-X86 server subsystem, 12-UItra HD input subsystem, 13-X86 center server board,
    14-X86 business server board,15-IPC fusion subsystem,16-siber switch subsystem,17-X86 joint subsystem,18-general joint subsystem,19-audio subsystem, 0-NULL*/
    BYTE        bySubSystemType;
    //subsystem channel number, for distributor subsystem, it means 485 serial number (just for get)
    BYTE        byChan;
    BYTE        byLoginType;//Login type, 1-direction 2-DNS, 3-peanuthull 
    BYTE        bySlotNum;//slot number, (just for getting)
    BYTE        byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;        /*IPaddress (can change)*/
    NET_DVR_IPADDR   struSubSystemIPMask;//subnet mask 
    NET_DVR_IPADDR   struGatewayIpAddr;    /* gateway address*/
    WORD        wSubSystemPort;        //subsystem port (can change)
    BYTE        byRes2[6];
    BYTE        sUserName[NAME_LEN];    /*username (just for getting)*/
    BYTE        sPassword[PASSWD_LEN];    /*password (can change)*/
    char        sDomainName[MAX_DOMAIN_NAME];//domain name (can change)
    char        sDnsAddress[MAX_DOMAIN_NAME];/*domain name or ip address*/
    BYTE        sSerialNumber[SERIALNO_LEN];//serial number (just for getting)
    BYTE        byBelongBoard;//belong board, from 1 to start, 0xff means invaild 
    BYTE        byInterfaceType;//interface type,0-none, 1-BNC,2-VGA,3-HDMI,4-DVI,5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI adapter,10-3GSDI,11-VGA/DVI adapter,12-HDTVI,13-HDBaseT,14-DP,15-DVIT,16-TVI,17-VSCREEN,18-miniDP,0xff-invaild
    BYTE        byInterfaceNums;//interface number,0xff means invaild
    BYTE        byInterfaceStartNum;//interface number to start,0xff means invaild
    BYTE        byDeviceName[20];//subsystem name 
    BYTE        byAudioChanNums;  //audio channel number
    BYTE        byAudioChanStartNum; //the start of audio channel
    BYTE        byAudioChanType;   //audio channel type, 0-invalid, 1-audio in, 2-audio out
    BYTE        byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

#define  MAX_SUBSYSTEM_NUM_V40  120
typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V40
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V40 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V40, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_SUBSYSTEM_BASIC_INFO
{
    DWORD       dwSize;
    BYTE        bySubSystemType;
    BYTE        bySubSystemNo;//sub system no
    BYTE        byInterfaceType;
    BYTE        byRes1;
    DWORD       dwChan;
    NET_DVR_IPADDR   struSubSystemIP;//IP
    NET_DVR_IPADDR   struSubSystemIPMask;//mask
    NET_DVR_IPADDR   struGatewayIpAddr; //gate way
    WORD        wSubSystemPort;        //port
    BYTE        byRes2[6];
    BYTE        sSerialNumber[SERIALNO_LEN];//serial only get
    BYTE        byBelongBoard;//belong board no
    BYTE        byBelongBoardH; //belong board no high bit
    BYTE        byRes3[2];
    BYTE        byDeviceName[20];//sub system name
    DWORD       dwStartChanNo;//start no
    BYTE        byDevNo; //device no
    BYTE        byRes4[63];
}NET_DVR_SUBSYSTEM_BASIC_INFO, *LPNET_DVR_SUBSYSTEM_BASIC_INFO;

typedef struct NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE
{
    DWORD dwSize;
    DWORD dwErrorCode; //error
    BYTE   byDevNo; //device no
    BYTE    bySubSystemNo;//system no
    BYTE   byRes[30];
} NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE, *LPNET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE;

typedef struct NET_DVR_CAMERA_INFO_RESPONSE
{
    DWORD dwErrorCode; //error
    DWORD dwCamId; //cam no
    BYTE   byRes[4];
} NET_DVR_CAMERA_INFO_RESPONSE, *LPNET_DVR_CAMERA_INFO_RESPONSE;

typedef struct NET_DVR_MONITOR_INFO_RESPONSE
{
    DWORD dwErrorCode; //error
    DWORD dwMonId; /*mon no*/
    BYTE   byRes[4];
} NET_DVR_MONITOR_INFO_RESPONSE, *LPNET_DVR_MONITOR_INFO_RESPONSE;

typedef struct tagNET_DVR_AUDIO_INFO
{
    DWORD    dwSize;
    BYTE    byAudioChanType;
    BYTE       byRes1[3];
    DWORD    dwAudioNo;
    BYTE      byRes2[16];
}NET_DVR_AUDIO_INFO, *LPNET_DVR_AUDIO_INFO;



//Dial Switch Cfg
typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//Dial Switch State
    BYTE   byRes[28];
}NET_DVR_DIAL_SWITCH_CFG, *LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS
{
    NET_DVR_TIME_EX struInspectStart; //inspect start time
    NET_DVR_TIME_EX struInspectEnd;   //inspect End time
    NET_DVR_IPADDR  struIP;           //lost records IP addresses
    DWORD  dwChanNo;
    DWORD  dwIDIndex;                //Encoder ID
    BYTE   sName[STREAM_ID_LEN];       //Encoder Name
    NET_DVR_TIME_EX struLossStartTime; //lost record start Time
    NET_DVR_TIME_EX struLossEndTime;   //lost record End Time
    DWORD  dwLostNum;                 //lost record num. 0xffffffff -- all records lost
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION
{
    NET_DVR_IPADDR  struIP;
    DWORD  dwChanNo;
    DWORD  dwIDIndex;
    BYTE   sName[STREAM_ID_LEN];
    BYTE   byExceptionCase;           //exception reason,0-write exception 1-network exception
    BYTE   byRes[307];
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;


typedef struct tagNET_ALARM_RESOURCE_USAGE
{
    BYTE   byLevel;    // 0-normal, 1-One alarm limit 2-Two alarm limit 3-Three alarm limit  
    BYTE   byRes[491];
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION
{
    BYTE    byReason;    // 0 - Recording Volume least ,1-Volume error 2-No volume lun
    BYTE    byRes1[3];
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //volume ID
    BYTE    byRes[452];
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;

typedef union tagNET_ALARM_CVR_SUBINFO_UNION
{
    BYTE byLen[492];
    NET_ALARM_RECORDFILE_LOSS     struRecordLost;
    NET_ALARM_STREAM_EXCEPTION     struStreamException;
    NET_ALARM_RESOURCE_USAGE     struResourceUsage;
    NET_ALARM_RECORD_EXCEPTION   struRecordException;
}NET_ALARM_CVR_SUBINFO_UNION, *LPNET_ALARM_CVR_SUBINFO_UNION;

#define  MAX_VARIABLE_DATA_NUM    65535   


typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //Alarm subtype 0 - encoder (channel) signal alarms; 1 - Volume II private damage; 2 - NVR service exits; 3 - encoder abnormal state; 4 - system clock anomaly; 5 - recording volume remaining capacity is too low; 6 - encoder (channel) motion detection alarm; 
    // 8 - encoder (channel) Tampering; 8 - video loss alarm; 9 - real-time video monitoring and alarm; 10 - resource utilization alarm; 11 - CVR auto repair abnormal 12 - Video Abnormal
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //Substructure alarm when the alarm type is 8,9,10,11,12 Commonwealth valid
    BYTE             byRes[256];
    DWORD            dwNumber; //Variable number of data
    WORD             *pNO; //When type is 0,3,6,7, there might be channel number; When type is 5, there may be a disk number. The range of values ??that can be represented as 0 to 65535   
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

//host recording control add by xzx
typedef struct tagNET_DVR_CONTROL_START_CFG //start recording info
{
    BYTE    byUseDefine; //use define, 0-use default,1-use define
    BYTE    byRes1;
    WORD    wCourseIndex; //course index
    BYTE    byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//one key delay recording control info
{
    BYTE    byUseDefine; //use define , 0-use default,1-use define
    BYTE    byRes1;
    WORD    wDelayTime; //recording delay time
    BYTE    byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;

typedef union tagNET_DVR_CONTROL_INFO_UNION
{
    BYTE    byLen[132];
    NET_DVR_CONTROL_START_CFG  struStartCfg;   //one key start
    NET_DVR_CONTROL_DELAY_CFG  struDelayCfg;  //one key delay
}NET_DVR_CONTROL_INFO_UNION, *LPNET_DVR_CONTROL_INFO_UNION;

typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD    dwSize;
    WORD    wCmdType;    //control,0-one key start,1-one key end,2-one key pause,3-one key resume,4-one key delay,5- a button to start shielding 6- a key to stop shielding

    BYTE    byRes1[2]; //res
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //control info, use with control cmd
    BYTE    byRes[256]; //res
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD     dwSize;
    DWORD    dwOneKeyDelayTime; //one key delay time
    BYTE     byDirectedMode; //record mode,0-auto record,1-manual record,2-semi-automatic record
    BYTE     byClassroomType;    //classroom type, 0-invalid,1-mian classroom,2-sub classroom
    BYTE     byCourseDataStorageEnabled;//Class data is stored in hard disks, 0 - not stored, 1 - storage 
    BYTE     byElectronicEnlargeMode;//Whether electronic amplification is used, 0 - no use, 1 - use 
    BYTE     byRes[124];
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_STATISTIC_DATA_COND
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //Statistical object types, see TARGET_TYPE
    NET_DVR_TIME   struStartTime;//Began to count time 
    NET_DVR_TIME   struStopTime;//End to count time 
    BYTE        byRes[280];
}NET_DVR_STATISTIC_DATA_COND, *LPNET_DVR_STATISTIC_DATA_COND;

typedef struct tagNET_DVR_STATISTIC_DATA_CFG
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //Statistical object types, see TARGET_TYPE
    NET_DVR_TIME   struStartTime;//The event start time 
    NET_DVR_TIME   struStopTime;//The event end time 
    BYTE        byRes[300];
}NET_DVR_STATISTIC_DATA_CFG, *LPNET_DVR_STATISTIC_DATA_CFG;

//typedef enum
//{
//    NET_SDK_ALL_TARGET = 0,          
//    NET_SDK_PPT_TARGET_ALARM,     
//    NET_SDK_PPT_TARGET_VIEW,      
//    NET_SDK_STU_SINGLE_ALARM,     
//    NET_SDK_STU_SINGLE_VIEW,       
//    NET_SDK_SUT_MULT_ALARM,       
//    NET_SDK_STU_MULT_VIEW,         
//    NET_SDK_STU_TEACHER_VIEW,     
//    NET_SDK_TEA_UP_DOWN_ALARM,  
//    NET_SDK_TEA_START_VIEW,        
//    NET_SDK_BLA_WRITE_ALARM,      
//    NET_SDK_BLA_WRITE_VIEW,       
//    NET_SDK_TEA_FULL_VIEW,         
//    NET_SDK_TEA_START_ALARM,      
//    NET_SDK_TEA_WALK_ALARM,      
//    NET_SDK_TEA_LEFT_ALARM,       
//    NET_SDK_TEA_RUN_ALARM,        
//    NET_SDK_TEA_MULT_ALARM       
//}TARGET_TYPE;


typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30];
    //SDI chan
    BYTE   byCameraType[MAX_CHANNUM_V30];     //cameratype
    BYTE   byRes[64];
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE                byProtocolType;    //protocol type 0-FTP,1-SFTP
    BYTE                byRes1;     //res
    WORD                wFTPPort;  //port
    BYTE                   byAddress[MAX_DOMAIN_NAME];  //IP or doamin,if doamin is with '.',than it's ip
    BYTE                szUserName[NAME_LEN/*32*/];        //admin
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //password
    BYTE                szCustomDir[128];    //cunstom dir
    BYTE                byRes[12]; //res
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //publish URL info
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE                byProtocolType;    //protocol type 0-FTP,1-SFTP
    BYTE                byRes1;     //res
    WORD                wFTPPort;  //port
    BYTE               byAddress[MAX_DOMAIN_NAME];  //IP or doamin,if doamin is with '.',than it's ip
    BYTE                szUserName[NAME_LEN/*32*/];        //admin
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //password
    BYTE                  byDirLevel;                     /*0 = use root dir,1 = use top dir,2=use sub dir*/
    BYTE                byTopDirMode;         /* Top Dir 0x1-use device name,0x2 = use device ID,0x3 = use device IP Address       0xff=use selfdefine*/
    BYTE                bySubDirMode;         /*Sub Dir 0x1=use channel name,0x2=use channel number,0x3=use course name, 0x4-use time,0xff-use selfdefine*/
    BYTE              byRes2;
    BYTE               byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*self define Top Dir*/
    BYTE               bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*self define Sub Dir*/
    BYTE                byRes[72];
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;

typedef  union tagNET_DVR_PUBLISH_ADD_UNION
{
    BYTE    byLen[256];
    NET_DVR_PUBLISH_HTTP_CFG struHttpCfg; //http cfg
    NET_DVR_PUBLISH_FTP_CFG  struFtpCfg;  //ftp cfg
    NET_DVR_PUBLISH_FTP_CFG_DIR struDirFtpCfg;  // support sub dir ftp
}NET_DVR_PUBLISH_ADD_UNION, *LPNET_DVR_PUBLISH_ADD_UNION;

typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO
{
    BYTE    byPublish; //0-no publish, 1-publish
    BYTE    byRes1[3];
    DWORD  dwStreamType;
    //&0x1-main 
    //&0x2-sub
    //&0x4-three
    BYTE    byRes[12];     //res
}NET_DVR_RECORD_PUBLISH_INFO, *LPNET_DVR_RECORD_PUBLISH_INFO;


typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;
    BYTE   byPublishType;    //0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3];
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //publish addr 
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30];
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //direct chan publish
    BYTE                  byUploadTime;      //enable upload by Timer,1-disable, 2-enable
    BYTE                byTimerMode;
    BYTE                  byUploadStartHour;
    BYTE                byUoploadStartMin;
    BYTE                byRes[1020];
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;
    BYTE  byUseDefine;  //0-use default config,1-use define publish config
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //record chan publish
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //direct chan publish
    NET_DVR_TIME_EX  struStartTime;  //record start time
    NET_DVR_TIME_EX  struEndTime;   //record end time
    BYTE       byRes[64];
}NET_DVR_ONEKEY_PUBLISH_CFG, *LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD    dwSize;
    char    sCourseName[COURSE_NAME_LEN/*32*/];
    char    sInstructorName[INSTRUCTOR_NAME_LEN/*16*/]; //teacher
    char    sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];  //description
    BYTE    byIndex;
    BYTE    byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime;   //course start end time
    WORD  wCourseIndex;        //course index
    WORD  wSessionIndex;        //session index
    BYTE  byRes[4];
}NET_DVR_EACH_LESSON_INFO, *LPNET_DVR_EACH_LESSON_INFO;

typedef struct tagNET_DVR_CURRICULUM_CFG
{
    DWORD  dwSize;
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/]; //lession info
    BYTE   byRes[256];
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;

typedef  struct  tagNET_DVR_DATE_
{
    WORD         wYear;        //year
    BYTE        byMonth;        //month    
    BYTE         byDay;        //day                        
}NET_DVR_DATE, *LPNET_DVR_DATE;

typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD    dwSize;
    BYTE    byEnablePPTDetect;
    BYTE    byPptDetLevel;
    BYTE    byEnablePartScreen;
    BYTE    byRes1;
    WORD    wX;
    WORD    wY;
    WORD    wWidth;
    WORD    wHeight;
    DWORD   dwChangePixelNum;
    BYTE    byRes[28];
}NET_DVR_PPT_DETECT_CFG, *LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_SCREEN_SWITCH_
{
    DWORD dwSize;
    BYTE  byRes[64];
}NET_DVR_SCREEN_SWITCH, *LPNET_DVR_SCREEN_SWITCH;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD    dwSize;
    BYTE    byChan[MAX_PPT_CHAN];
    BYTE    byRes[32];
}NET_DVR_PPT_CHANNEL_CFG, *LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;
    BYTE   byRes[11];
    DWORD  dwStreamType;  //Stream Type
    //&0x1-main stream
    //&0x2-sub stream
    //&0x4-stream three
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD     dwSize;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //directed chan info
    BYTE    byRes[256];
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

/****************************** LCD V1.2 begin*************************************/
#define MAX_SCREEN_ADDRESS_LEN 16 //Max address length 
#define MAX_DAY_TIME_POINT 8   //max time point every day 
#define MAX_TIME_POINT     16  //max time point every year 

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //
    BYTE byPassWord[PASSWD_LEN]; //
    NET_DVR_IPADDR struIPAddr; //
    WORD wPort; //
    BYTE byRes[24];
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;

typedef union tagNET_DVR_SCREEN_BASE_INFO
{
    BYTE byScreenAddress[MAX_SCREEN_ADDRESS_LEN]; //feature code , when the way adding device is zero , it is vaild.  
    NET_DVR_DEV_IP_INFO struIPInfo; //screen IP address information 
    BYTE byRes[100];
}NET_DVR_SCREEN_BASE_INFO, *LPNET_DVR_SCREEN_BASE_INFO;

typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //enable ,0-disable,1-enable
    BYTE byDevAddType; //the way add device,0-feature code(when server and screen using serial port communication),1-IP address(when server and screen using net communication)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //screen device base information
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG, *LPNET_DVR_SCREEN_INDEX_CFG;

//simulate remote control parameter
typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE        byControlType;    //1-power on, 2-power off, 3-signal, 4-menu, 5-sure, 6-up, 7-down, 8-left, 9-right, 11-back to last level, 12-digital key
    BYTE        byControlParam; //operate parameter, when operate type is 12, it means key value(0-9), other invaild.   
    BYTE        byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

//screen wall parameter
typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //switch.0-close;1-open
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

//Zoom Area parameter
typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;    //Zoom Area command,1-enlarge,2-reduction
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //enlarge area,total screen size is 1920*1920. it is invaild when the command is reduction    
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;


typedef  union tagNET_DVR_SCREEN_CONTROL_PARAM
{
    NET_DVR_INPUT_INTERFACE_CTRL    struInputCtrl;
    NET_DVR_DISPLAY_COLOR_CTRL         struDisplayCtrl;
    NET_DVR_DISPLAY_POSITION_CTRL     struPositionCtrl;
    NET_DVR_SIMULATE_REMOTE_CTRL struSimulateRemoteCrtl; //simulate remote key control
    NET_DVR_SCREEN_WALL_CTRL struScreenWallCtrl; //screen wall control 
    NET_DVR_AREA_ZOOM_CFG struZoomArea;  //Zoom Area parameter 
    BYTE        byRes[16];
}NET_DVR_SCREEN_CONTROL_PARAM, *LPNET_DVR_SCREEN_CONTROL_PARAM;

typedef struct tagNET_DVR_SCREEN_CONTROL
{
    DWORD     dwSize;
    DWORD      dwCommand;     /*comamnd, 1-open, 2-close, 3-choose screen input source, 4-colour control, 5-position control */
    BYTE       byProtocol;      //serial protocol type, 1:LCD-S1,2:LCD-S2
    BYTE    byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE       byRes2[52];
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{
    DWORD   dwSize;
    BYTE    bySerialNo;        //serial No.
    BYTE    byRes[2];
    BYTE       byProtocol;             // Serial protocol type,  1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 , 4-LCD-DLP, 5-LCD-S3 , 6-LCD-H1,7-LCD-L2,8-LCD-Z1,0xff-invaild,
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-invaild
    DWORD      dwCommand;             //command, 1-open, 2-close, 3-choose screen input source, 4-colour control, 5-position control, 6-simulate remote control, 7-screen display status, 8-show feature code(this command use the default start point(0,0),width and height set to 0xffffffff), 
    //9-screen wall control 10-recover default parameter, 11-show Ip(this command use the default start point(0,0),width and height set to 0xffffffff)    
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE    byWallNo;        // wall No.
    BYTE    byDevNo;         //device No.
    BYTE    bySubboardNo;    //subboard No.
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX struRect;
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo;
    BYTE byWallNo;
    BYTE byEnable; //0-disable,1-enable
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //splice area, when get the parameter, it is all zero
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG, *LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;    //input source, see INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;        //no signal display model, 1-blue screen, 1-black screen 3-Logo
    BYTE  byRes[30];
}NET_DVR_MSC_SCREEN_INTERFACE_CFG, *LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

//Back light configure 
typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //black light,0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG, *LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//screen picture parameter
typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE    byEnable;    // 0-disable 1-enable
    BYTE    bySubWindowSource;    //Sub windows Source,see INPUT_INTERFACE_TYPE
    BYTE    bySubWindowBorderColor;    //Sub window border colour, 1-blue,2-black
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //sub windows position,screen total size is 1920*1920
    BYTE    byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG, *LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//fan status,0-close,1-open
    BYTE           byFanExceptionStatus;    //fan exception status,0-not support,1-normal 2-exception
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //working hour,unit:hour
    BYTE           byVersion[VERSION_LEN];//sofeware version
    int            iTemperature; //board temperature unit:Centigrade , accurate to a bit
    BYTE             byTempState;     //board temperature status,0-not support ,1-normal,2-exception
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE, *LPNET_DVR_SCREEN_WORK_STATE;

//boot logo parameter
typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to display logo,0-not to ,1-display
    BYTE byRes[31];
}NET_DVR_BOOT_LOGO_CFG, *LPNET_DVR_BOOT_LOGO_CFG;

typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //whether to mute, 0-no, 1-yes
    BYTE    byVolume; //volume, 0-100
    char    byBalance; //audio balance, -50 - +50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;

//screen parameter union
typedef union tagNET_DVR_MSC_SCREEN_PARAM
{
    NET_DVR_MSC_SCREEN_INTERFACE_CFG struInterfaceCfg; //input source parameter 
    NET_DVR_SCREEN_FAN_WORK_MODE_CFG struFanWorkMode; //fan work mode parameter
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA signal parameter 
    NET_DVR_SCREEN_MENU_CFG struMenuCfg; //screen menu parameter
    NET_DVR_VIDEO_OUT_CFG struOutEffectCfg; //display parameter
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemperatureCfg; //color temperature parameter
    NET_DVR_ADC_CFG struAdcCfg; //ADC parameter 
    NET_DVR_SCREEN_EDGE_CFG struScreenEdgeCfg; //screen edge parameter
    NET_DVR_MSC_SCREEN_BACKLIGHT_CFG struBacklight; //back light parameter
    NET_DVR_MSC_SCREEN_PIP_CFG struPicInPicCfg; //screen picture parameter
    NET_DVR_DEFOG_LCD struDefog; //defog parameter
    NET_DVR_SCREEN_WORK_STATE struWorkState; //screen work state parameter
    NET_DVR_BOOT_LOGO_CFG struBootLogoCfg; //boot display logo parameter 
    NET_DVR_LCD_AUDIO_CFG struAudioCfg; //audio parameter 
    BYTE byRes[256];
}NET_DVR_MSC_SCREEN_PARAM, *LPNET_DVR_MSC_SCREEN_PARAM;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //parameter type , 1-input source,2-fan work mode,3-VGA signal,4-screen menu,5-display,6-color temperature,7-ADC,8-screen edge,9-back light,10-screen picture,11-defog,12-screen work state,13-boot display logo  14-audio parameter  
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //screen parameter
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG, *LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //screen area
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG, *LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo;
    BYTE byParamType; //parameter type , 1-input source,2-fan work mode,3-VGA signal,4-screen menu,5-display,6-color temperature,7-ADC,8-screen edge,9-back light,10-screen picture,11-defog,12-screen work state,13-boot display logo  14-audio parameter 
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND, *LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //whether to use this setting, 0-disable,1-enable
    BYTE bySwitchType; //switch,0-close,1-open
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //switch time point
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME, *LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //0-disable,1-enable
    BYTE bySwitchType; //switch type,0-close,1-open
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //switch time point
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT, *LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //week switch plan
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //time to switch 
	BYTE byRes1[3];
	BYTE byEnable;//Whether to enable timer switch,0-disable,1-enable
	BYTE byRes[60];
}NET_DVR_TIME_SWITCH_CFG, *LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //delay time ,0-3000,unit:ms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME, *LPNET_DVR_DELAY_TIME;

/****************************** LCD V1.2 end **************************************/




/***********************68xxSeries of binocular 3D camera***********************/
//calibration Type
typedef enum _BV_CALIBRATION_TYPE_ENUM_
{
    ENUM_BV_CALIBRATION_NONE = 0,
    ENUM_BV_CALIBRATION_DIRECT = 1, //Direct calibration
    ENUM_BV_CALIBRATION_SAMPLE = 2, //Sample calibration
} BV_CALIBRATION_TYPE_ENUM;


//Sample calibration
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{
    BYTE  byCalibPtID;       //Calibration ID,Range[1,5]
    BYTE  byRes1[3];
    NET_VCA_POINT struPoint; //Coordinates of calibration points
    BYTE  byRes2[16];
}NET_DVR_BV_SAMPLE_CALIB_POINT, *LPET_DVR_BV_SAMPLE_CALIB_POINT;

//Start calibration sample input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //Camera height, unit: cm
    DWORD  dwHumanHeight;  //Human Height,unit: cm
    BYTE    byRes[248];
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM, *LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//The calibration set samples the input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //Calibration ID.
    BYTE byRes[228];
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM, *LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//end sample calibration input parameters
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256];
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM, *LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//Sample calibration input parameters
typedef union tagNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION
{
    BYTE byRes[256];
    NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM struCalibBegin; //Begin calibration
    NET_DVR_BV_SAMPLE_CALIB_SET_PARAM struCalibSet; //Set calibration
    NET_DVR_BV_SAMPLE_CALIB_END_PARAM struCalibEnd; //End calibration
}NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION, *LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//calibration Enum
typedef enum _BV_SAMPLE_CALIB_CMD_ENUM
{
    ENUM_BV_SAMPLE_CALIB_BEGIN = 1,   //Begin calibration
    ENUM_BV_SAMPLE_CALIB_SETTING = 2,   //Set calibration
    ENUM_BV_SAMPLE_CALIB_END = 3    //End calibration
}BV_SAMPLE_CALIB_CMD_ENUM;

//Sample calibration
typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{
    DWORD   dwSize;
    DWORD   dwChannel;  //Channel No
    BYTE    byCommand;  //calibration command, see BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //calibration Param
    BYTE    byRes2[256];
}NET_DVR_BV_SAMPLE_CALIBRATION, *LPNET_DVR_BV_SAMPLE_CALIBRATION;

//Sample calibration Point Info
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;
    DWORD  dwCameraHeight; //Camera Height,Unit:cm
    float  fPitchAngle;    //Camera Pitch Angle[0, 60],
    float  fInclineAngle;  //Camera Incline Angle[-20,20]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //Sample calibration 
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPointEx[MAX_SAMPLE_NUM_EX/*7*/]; //Sample calibration extension
    BYTE  byRes[60];
}NET_DVR_BV_SAMPLE_CALIB_CFG, *LPNET_DVR_BV_SAMPLE_CALIB_CFG;

//Binocular image correction parameters
typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{
    float   fCamInternalMatrix[3][3];  //camera intrinsic matrix
    float   fDistCoeffs[8];            //Lens distortion coefficient
    float   fRotateMatrix[3][3];       //After correction of the rotation matrix
    float   fProjectMatrix[3][4];      //After correction of the projection matrix
    BYTE    byRes[64];
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

//Left and right camera calibration parameters
typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;
    float  fReprojectMatrix[4][4];   //projection matrix
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //left camera calibration parameters
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //Right camera calibration parameters
    BYTE    byLensType;             //Camera Lens Type,0-Unknow,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm,9-2.0mm,10-2.8mm,11-4.3mm
    BYTE    byRes1[3];
    float   fRotateMatrix[3][3];//Rotate Matrix
    float   fTransMatrix[3];//Trans Matrix
    DWORD dwOriImgWidth; //width 1920*1080
    DWORD dwOriImgHeight; //height 1920*1080
    BYTE    byRes[196]; //res
} NET_DVR_BV_CORRECT_PARAM, *LPNET_DVR_BV_CORRECT_PARAM;


//Output Video Type
typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;
    BYTE   byType;      //output video type, 1- mosaic, 2- depth map
    BYTE   byRes[63];
}NET_DVR_OUTPUT_VIDEO_TYPE, *LPNET_DVR_OUTPUT_VIDEO_TYPE;
/***********************68xxSeries of binocular 3D camera***********************/

#define MAX_CHECK_485CHAN        64    

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD        dwSize;
    DWORD        dwRS485Chan[MAX_CHECK_485CHAN];
    DWORD        dwSensorChan[4];
    BYTE         byRes[32];
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

//Complete Restore Ctrl
typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize; //struct size
    DWORD   dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byPictureType;
    BYTE    byRes1[3];
    NET_DVR_TIME_V30 struTime;
    char*        sPictureBuffer;
    DWORD        dwPictureLength;
    DWORD    dwPicMangeNo;
    BYTE    sPicName[NAME_LEN];
    BYTE     byUseType;    
    BYTE     byRes[91];
}NET_DVR_UPLOAD_PICTURE_INFO, *LPNET_DVR_UPLOAD_PICTURE_INFO;

#define  MAX_UPLOADFILE_URL_LEN      240
typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN];   //url
    BYTE  byRes[260];//
} NET_DVR_UPLOAD_FILE_RET, *LPNET_DVR_UPLOAD_FILE_RET;

#define MAX_FACE_PIC_NUM  30  
typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];
    BYTE     byRes[64];
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;
typedef union tagNET_DVR_PIC_EXTRA_INFO_UNION
{
    BYTE   byUnionLen[544];
    NET_DVR_FACE_EXTRA_INFO struFaceExtraInfo;
}NET_DVR_PIC_EXTRA_INFO_UNION, *LPNET_DVR_PIC_EXTRA_INFO_UNION;

typedef struct    tagNET_DVR_FIND_PICTURE_V40
{
    char    sFileName[PICTURE_NAME_LEN];
    NET_DVR_TIME struTime;
    DWORD dwFileSize;
    char    sCardNum[CARDNUM_LEN_V30];
    BYTE   byPlateColor;
    BYTE   byVehicleLogo;
    BYTE   byFileType;
    BYTE   byRecogResult;
    char   sLicense[MAX_LICENSE_LEN/*16*/];
    BYTE   byEventSearchStatus;
    BYTE   byRes1[2];    
    BYTE   byThermometryUnit;
    float  fFaceSnapTemperature; 
    BYTE   byRes[68];        
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo;
}NET_DVR_FIND_PICTURE_V40, *LPNET_DVR_FIND_PICTURE_V40;

typedef struct    tagNET_DVR_FIND_PICTURE_V50
{
    char        sFileName[PICTURE_NAME_LEN];
    NET_DVR_TIME struTime;
    DWORD    dwFileSize;
    char        sCardNum[CARDNUM_LEN_V30];
    BYTE   byPlateColor;
    BYTE   byVehicleLogo;
    BYTE   byFileType;
    BYTE   byRecogResult;
    char   sLicense[MAX_LICENSE_LEN/*16*/];
    BYTE   byEventSearchStatus;
    NET_DVR_ADDRESS struAddr;
    BYTE   	        byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char     cTimeDifferenceH;   
    char     cTimeDifferenceM;   
    BYTE   byRes[253];       
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo;
}NET_DVR_FIND_PICTURE_V50, *LPNET_DVR_FIND_PICTURE_V50;

typedef struct tagNET_DVR_THUMBNAILS_COND
{
    DWORD  dwSize;             // Structure size 
    NET_DVR_STREAM_INFO   struStreamInfo; //src Info
    BYTE   bySearchDataType;   // Find data type 0 - I frame data (CVR along the way, most 1 s 28 I frame), 1 - image data 
    BYTE   byRes1[3];
    NET_DVR_TIME_V30  struStartTime;      //Start time of image search
    NET_DVR_TIME_V30  struStopTime;       // End time of image search
    DWORD  dwIntervalTime;  //Second time interval, unit, range: 0 ~ 24 * 60 * 60, if find over time is equal to find the start time, fill 0, fill in the other value is invalid 
    BYTE   byRes2[512];
}NET_DVR_THUMBNAILS_COND, *LPNET_DVR_THUMBNAILS_COND;

typedef struct    tagNET_DVR_THUMBNAILS_RESULT   //Search results structure
{
    BYTE     byResultDataType;      // Find the result data type 0 - I frame data (CVR along the way, most 1 s 28 I frame), 1 - system header data, 2 - image data 
    BYTE     byIFrameType;          // I frame type, 0- data frame, 1- reference frame (this data needs to be fed into the playback library, but not the image display)
    BYTE     byRes1[2];
    NET_DVR_TIME_SEARCH struTime;        //data time
    BYTE     byRes[252];
    DWORD   dwFileSize;            //data size
    char*     pBuffer;                //data
}NET_DVR_THUMBNAILS_RESULT, *LPNET_DVR_THUMBNAILS_RESULT;

/*********************************IPC 5.2.2***************************************/

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byAlarmConfidence;    //alarmConfidence, 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRecordConfidence;   //recordConfidence , 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRes[60];
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;

typedef    struct tagNET_DVR_REGION_ENTRANCE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byEnableHumanMisinfoFilter;//0-false 1-true
    BYTE        byEnableVehicleMisinfoFilter;//0-false 1-true
    BYTE        byRes1[1];
    NET_DVR_REGIONENTRANCE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_ENTRANCE_DETECTION, *LPNET_DVR_REGION_ENTRANCE_DETECTION;

typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //channel 
    DWORD dwRegion;         //region id
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;
    BYTE byAlarmConfidence;    //alarmConfidence, 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRecordConfidence;   //recordConfidence , 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRes[60];
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef    struct tagNET_DVR_EVENT_TRIGGER
{
    DWORD        dwSize;//struct size
    NET_DVR_HANDLEEXCEPTION_V41 struHandleException;     //handle exception
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40]; //record trigger channel,index from 0, invalid after 0xffffffff
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //preset info
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //cruise info
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //track info
    BYTE        byDirection;//direction: 0-res,1-both,2-forward,3-reverse
    BYTE        byRes2[255];
}NET_DVR_EVENT_TRIGGER, *LPNET_DVR_EVENT_TRIGGER;

typedef struct tagNET_DVR_DENSEFOGDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//enable
    BYTE   bySensitivity;  //sensitivity parameters,range from 0 to 100
    BYTE   byRes[258];
}NET_DVR_DENSEFOGDETECTION_CFG, *LPNET_DVR_DENSEFOGDETECTION_CFG;
/********************************IPC FFThe license plate  Start****************************/
typedef struct tagNET_DVR_FTPUPLOAD_PARAM
{
    char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
    char szCameraName[MAX_CAMNAME_LEN/*32*/];
    BYTE byRes[64];
}NET_DVR_FTPUPLOAD_PARAM, *LPNET_DVR_FTPUPLOAD_PARAM;

//char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
//Content is the fixed string   capture_time,plate_No,alarm_type,camera_name
//The array subscript said order 

//char szCameraName[MAX_CAMNAME_LEN/*32*/];
//Depends on the situation of field represents the content of camera_name szRuleTypeItem 
typedef struct tagNET_DVR_FTPUPLOADCFG
{
    DWORD dwSize;
    BYTE byEventType; //Event type, default, 0-1 - vehicle detection
    BYTE byMode; //Picture naming pattern, default, 0-1 - custom 
    BYTE byRes[62];
    NET_DVR_FTPUPLOAD_PARAM  struCustomVehicle[MAX_FTPNAME_NUM/*12*/];
    BYTE byRes1[1024];
}NET_DVR_FTPUPLOADCFG, *LPNET_DVR_FTPUPLOADCFG;


/********************************IPC The license plate  End****************************/

typedef    struct tagNET_DVR_EVENT_SCHEDULE
{
    DWORD        dwSize;//struct size
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*arm time*/
    NET_DVR_SCHEDTIME struHolidayAlarmTime[MAX_TIMESEGMENT_V30]; /*holiday arm time*/
    BYTE        bySceneID[MAX_DAYS][MAX_TIMESEGMENT_V30];//Scene Id
    BYTE        byRes[72];
}NET_DVR_EVENT_SCHEDULE, *LPNET_DVR_EVENT_SCHEDULE;
typedef struct  tagNET_DVR_ANR_ARMING_HOST
{
    DWORD   dwSize;//sizeof(NET_DVR_ANR_ ARMING_HOST)
    NET_DVR_IPADDR struANRArmingHostIpAddr; //Offline continuingly host IP address 
    WORD    wANRAlarmHostPort; //Offline continuingly host their port 
    BYTE     byANRAlarmType;//Continuingly without Internet connection type, 0 - SDK private continuingly without Internet connection, 1 - ehome continuingly without Internet connection
    BYTE     byConfirmMechanismEnabled;// Whether open the way to connect their confirmation mechanism, 0 to retain, 1 - there are no open 2 - open 
    BYTE     byRes[512];
}NET_DVR_ANR_ARMING_HOST, *LPNET_DVR_ANR_ARMING_HOST;
typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byAlarmConfidence;    //alarmConfidence, 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRecordConfidence;   //recordConfidence , 0-low,1-mediumLow,2-mediumHigh,3-high
    BYTE byRes[60];
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;

typedef    struct tagNET_DVR_REGION_EXITING_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byEnableHumanMisinfoFilter;//0-false 1-true
    BYTE        byEnableVehicleMisinfoFilter;//0-false 1-true
    BYTE        byRes1[1];
    NET_DVR_REGIONEXITING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_EXITING_DETECTION, *LPNET_DVR_REGION_EXITING_DETECTION;

typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    BYTE byRes[62];             //
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;

typedef    struct tagNET_DVR_LOITERING_DETECTION
{
    DWORD        dwSize;//region range
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_LOITERING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_LOITERING_DETECTION, *LPNET_DVR_LOITERING_DETECTION;

typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE byObjectOccup; //occupation,[1-100]
    BYTE bySensitivityLevel; //SensitivityLevel,[1-100] def=65
    BYTE byDurationTime; //DurationTime,[1-600]s def=3s
    BYTE byFilterTime; //FilterTime,[1-10]mins def=1
    BYTE byMinTriggerNumber; //MinTriggerNumber,[2-50],def=5
    BYTE byLinkageTime; //LinkageTime,[5-30]s,def=5s
    BYTE byRes[58];     //res
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;

typedef    struct tagNET_DVR_GROUP_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_GROUPDETECTION_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_GROUP_DETECTION, *LPNET_DVR_GROUP_DETECTION;

typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byDetectionTarget;    //Detection Target
    BYTE byRes[62];
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;

typedef    struct tagNET_DVR_RAPIDMOVE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable,0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_RAPIDMOVE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_RAPIDMOVE_DETECTION, *LPNET_DVR_RAPIDMOVE_DETECTION;

typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    BYTE byRes[62];             //
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;

typedef    struct tagNET_DVR_PARKING_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_PARKING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_PARKING_DETECTION, *LPNET_DVR_PARKING_DETECTION;

typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    WORD wTimeThreshold;//time threshold,[5-3600],unit:s
    BYTE byTimeThresholdMode;//(wo)0-byTimeThreshold  ,1-wTimeThreshold
    BYTE byRes[59];  //
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_UNATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_UNATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_UNATTENDED_BAGGAGE_DETECTION, *LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//region range
    BYTE bySensitivity;        //sensitivity,[1-100]
    BYTE byTimeThreshold; //time threshold,[0-10],unit:s
    WORD wTimeThreshold;//time threshold,[5-3600],unit:s
    BYTE byTimeThresholdMode;//(wo)0-byTimeThreshold  ,1-wTimeThreshold
    BYTE byRes[59];  //
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_ATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable:0- no,1- yes
    BYTE        byRes1[3];
    NET_DVR_ATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_ATTENDED_BAGGAGE_DETECTION, *LPNET_DVR_ATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //channel
    DWORD dwStreamType;     //stream type:0- main stream,1- sub stream,2- third stream
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //ebable:0- no,1- yes
    BYTE        byRes1[3];
    WORD      wResolutionWidth; //resolution width
    WORD      wResolutionHeight; //resolution height
    NET_VCA_POLYGON    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

#define MAX_DIALNUM_LENGTH  32
typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD        dwSize;//struct size
    BYTE        byEnabled;  //enable wireless dial:0-no,1- yes
    BYTE       byDialMode; // 0-Auto,1-Manual,default manual,set dial schedule,offline time,manual dial only manual
    BYTE       byNetworkMode; //0-auto,1-4GFirst,2-3GFirst,3-manualto2G,4-manualto3G,5-manualto4G,6-cableFirst
    BYTE        byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //dial number
    BYTE       byUserName[NAME_LEN]; //user name
    BYTE       byPassword[NAME_LEN]; //password
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //UIM card num
    BYTE       byVerifProtocol;  // 0-Auto,1-CHAP,2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //off line time,30-65535,unit:s,valid only manual
    BYTE       byNetAPN[NAME_LEN];  //private net APN
    BYTE       byEnabled4G;  //4G on or off: 0-no, 1-yes
    BYTE       byEnabledDNS;  //DNS  on or off: 0-no, 1-yes
    BYTE       byRes3[30];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;

typedef    struct tagNET_DVR_WIRELESSDIAL_SCHEDULE
{
    DWORD        dwSize;//struct size
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*arm time*/
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //holiday time
    BYTE        byRes[128];
}NET_DVR_WIRELESSDIAL_SCHEDULE, *LPNET_DVR_WIRELESSDIAL_SCHEDULE;

#define MAX_LENGTH_32   32
typedef    struct tagNET_DVR_WIRELESSDIAL_STATUS
{
    DWORD        dwSize;//struct size
    BYTE        byRealtimeMode[MAX_LENGTH_32]; //realtime mode(CDMA 1x,EVDO,HYBRID,GSM,GPRS,EDGE,WCDMA,HSDPA,HSUPA,HSPA,TDSCDMA,TD-LTE,FDD-LTE)
    BYTE        byUIMStatus[MAX_LENGTH_32]; /*UIM status(UNKNOWN,VALID,NOVALID,ROAM,NOEXIST,WRONGPINCODE,NONETWORKSERVICE, 
                                                ONLYSUPPORTEMERGENCYCALL,PINCODELOCKED)*/
    DWORD       dwSignalQuality; //signal quality,1-5
    BYTE        byDialStatus[MAX_LENGTH_32]; /*dial status(disconnect,dialing,success,shmError,certificationFailure,
                                             invalidDialingCharacters,networkTimeout,wirelessModemError,SIMError, networkError, unknown)*/
    NET_DVR_IPADDR    struIpAddr;  //IP address
    NET_DVR_IPADDR    struIPMask;  //mask address
    NET_DVR_IPADDR    struGatewayIPMask;  //gateway address
    NET_DVR_IPADDR    struDnsServerIpAddr; //DNS address
    BYTE        byRes[256];
}NET_DVR_WIRELESSDIAL_STATUS, *LPNET_DVR_WIRELESSDIAL_STATUS;

/****************************IPC 5.2.6********************************************/
typedef    struct tagNET_DVR_LITESTORAGE
{
    DWORD        dwSize;
    BYTE        byEnable; /*Enable 0-disable,1-enable*/
    BYTE        byStorageTime;/*Storage Time 1-30 */
    BYTE        byLevel; //Level Param,0-invalid Value(Res),1-low, 2-medium, 3-high;
    BYTE        byRes;
    float       fCapacity;//Capacity  ro
    BYTE        byDefLowStorageTime;//  ro
    BYTE        byDefMediumStorageTime; //  ro
    BYTE        byDefHighStorageTime; //   ro
    BYTE        byRes1[61];
}NET_DVR_LITESTORAGE, *LPNET_DVR_LITESTORAGE;

typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;
    NET_VCA_POLYGON  struRegion;//Region
    BYTE        byRes[64];
}NET_DVR_CALIBRATION, *LPNET_DVR_CALIBRATION;
/****************************IPC 5.2.6********************************************/

typedef    struct tagNET_DVR_WIRELESSDIAL_CONNECT
{
    DWORD        dwSize;//struct size
    DWORD       dwInterface; //interface id,1,2-
    BYTE        byEnableConnect; //enable connect,0-disconnect,1-connect
    BYTE        byRes[255];
}NET_DVR_WIRELESSDIAL_CONNECT_PARAM, *LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM;

typedef    struct    tagNET_DVR_STD_CONFIG
{
    void*        lpCondBuffer;        //[in]condition parameter,eg.channel
    DWORD        dwCondSize;            //[in] the size of condition parameter
    void*        lpInBuffer;            //[in]input parameter(struct)
    DWORD        dwInSize;            //[in] the size of input parameter
    void*        lpOutBuffer;        //[out]output parameter(XML format)
    DWORD        dwOutSize;            //[in]  the size of output parameter
    void*        lpStatusBuffer;        //[out]status parameter(XML format)
    DWORD        dwStatusSize;        //[in] the size of status parameter
    void*       lpXmlBuffer;    //[in/out]
    DWORD       dwXmlSize;      //[in/out]
    BYTE        byDataType;     //[in]
    BYTE        byRes[23];
}NET_DVR_STD_CONFIG, *LPNET_DVR_STD_CONFIG;

typedef    struct    tagNET_DVR_STD_ABILITY
{
    void*        lpCondBuffer;    //[in]condition parameter,eg.channel
    DWORD        dwCondSize;        //[in] the size of condition parameter
    void*        lpOutBuffer;    //[out]output parameter(XML format)
    DWORD        dwOutSize;        //[in] the size of output parameter
    void*        lpStatusBuffer;    //[out]status parameter(XML format)
    DWORD        dwStatusSize;    //[in] the size of status parameter
    DWORD        dwRetSize;        //[out]the returned data size,the size of output parameter or status parameter
    BYTE        byRes[32];
}NET_DVR_STD_ABILITY, *LPNET_DVR_STD_ABILITY;

typedef struct tagNET_DVR_STD_CONTROL
{
    void*        lpCondBuffer;    //[in]condition parameter,eg.channel
    DWORD        dwCondSize;        //[in] the size of condition parameter
    void*        lpStatusBuffer;    //[out]status parameter(XML format)
    DWORD        dwStatusSize;    //[in] the size of status parameter
    void*       lpXmlBuffer;    //[in/out]
    DWORD       dwXmlSize;      //[in/out]
    BYTE        byDataType;     //[in]
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;

typedef struct tagNET_DVR_MIME_UNIT
{
    //Content-Disposition: form-data; name="upload"; filename="C:\Users\test\Desktop\11.txt"
    //Content-Type: text/plain
    char szContentType[32];               //Content-Type
    char szName[MAX_FILE_PATH_LEN];       //name
    char szFilename[MAX_FILE_PATH_LEN];   //filename
    DWORD dwContentLen;                   //Content-length
    char* pContent;                       //buffer
    BYTE bySelfRead;
    BYTE byRes[15];
}NET_DVR_MIME_UNIT, *LPNET_DVR_MIME_UNIT;

typedef struct tagNET_DVR_MIME_DATA
{
    BYTE  byContentType;   //file type: 0-invalid, 1-json, 2-bmp
    BYTE  byRes1[3];
    void  *lpContent;  //file content
    DWORD  dwContentSize;  //file size
    char  sContentID[32];  //Content-ID
    BYTE  byRes[512];
}NET_DVR_MIME_DATA, *LPNET_DVR_MIME_DATA;

typedef struct tagNET_DVR_FORM_DATA_CFG
{
    DWORD  dwSize;  //
    void  *lpBuffer;  //buffer of NET_DVR_MIME_DATA
    DWORD  dwBufferSize;  //buffer size
    BYTE byNumOfMultiPart;  // 0-invalid
    BYTE   byRes[67];
}NET_DVR_FORM_DATA_CFG, *LPNET_DVR_FORM_DATA_CFG;

/*********************************IPC 5.2.2***************************************/
typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
    DWORD   dwSize;
    void*    lpRequestUrl;
    DWORD    dwRequestUrlLen;
    void*    lpInBuffer;
    DWORD    dwInBufferSize;
    DWORD   dwRecvTimeOut;
    BYTE    byForceEncrpt;
    BYTE    byNumOfMultiPart;
    BYTE    byMIMEType;
    BYTE    byRes[29];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
    DWORD   dwSize;
    void*    lpOutBuffer;
    DWORD    dwOutBufferSize;
    DWORD   dwReturnedXMLSize;
    void*    lpStatusBuffer;
    DWORD    dwStatusSize;
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    void*     lpDataBuffer;                     
#else
    void*     lpDataBuffer;                     
    BYTE    byRes2[4];
#endif  
    BYTE    byNumOfMultiPart;
    BYTE    byRes[23];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;

typedef struct tagNET_DVR_JSON_DATA_CFG
{
    DWORD  dwSize;  //sizeof(NET_DVR_JSON_DATA_CFG)
    void  *lpJsonData;  //Json data
    DWORD  dwJsonDataSize;  //Json data size
    void  *lpPicData;  //picture data
    DWORD  dwPicDataSize;  //picture data size
    DWORD   dwInfraredFacePicSize;   
    void*  lpInfraredFacePicBuffer;    
    BYTE   byRes[248]; 
}NET_DVR_JSON_DATA_CFG, *LPNET_DVR_JSON_DATA_CFG;

//Entrance guard  V1.0
typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //hour 
    BYTE byMinute; //minute
    BYTE bySecond; //second
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //begin time
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //end time
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byDoorStatus; //door status(control ladder status),0-invaild, 1-sleep, 2-always open(free), 3-always close(forbidden), 4-ordinary status(used by door plan)
    BYTE byVerifyMode; //verify method, 0-invaild, 1-swipe card, 2-swipe card +password(used by card verify ) 3-swipe card(used by card verify) 4-swipe card or password(used by card verify)
    //5-fingerprint, 6-fingerprint and passwd, 7-fingerprint or swipe card, 8-fingerprint and swipe card, 9-fingerprint and passwd and swipe card,
    //10-face or finger print or swipe card or password,11-face and finger print,12-face and password,13-face and swipe card,14-face,15-employee no and password,
    //16-finger print or password,17-employee no and finger print,18-employee no and finger print and password,
    //19-face and finger print and swipe card,20-face and password and finger print,21-employee no and face,22-face or face and swipe card
    //22-fingerprint or face, 23-card or face or password 24-card or face or password 25-card or face,26-card or face or fingerprint ,27-card or fingerprint or password
    //28-face or password,29-employee and face and password,30-card or face or face and card31-face or finger or password32-iris33-face or finger or card or iris34-face or card or password or iris
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //time segment parameter 
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //week plan parameter
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable
    BYTE byRes1[3];
    NET_DVR_DATE struBeginDate; //holiday begin date
    NET_DVR_DATE struEndDate; //holiday end date
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //time segment parameter 
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_COND
{
    DWORD dwSize;
    DWORD dwHolidayPlanNumber; //Holiday plan number 
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_PLAN_COND, *LPNET_DVR_HOLIDAY_PLAN_COND;

typedef struct tagNET_DVR_WEEK_PLAN_COND
{
    DWORD dwSize;
    DWORD dwWeekPlanNumber; //Week plan number 
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_WEEK_PLAN_COND, *LPNET_DVR_WEEK_PLAN_COND;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable 
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //holiday group name 
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //holiday plan No. fill in from the front side, invalid when meet zero.
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_COND
{
    DWORD dwSize;
    DWORD dwHolidayGroupNumber; //Holiday group number 
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_GROUP_COND, *LPNET_DVR_HOLIDAY_GROUP_COND;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable 
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //template name 
    DWORD dwWeekPlanNo; //week plan no. 0 invalid
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //holiday group. fill in from the front side, invalid when meet zero.
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;

typedef struct tagNET_DVR_PLAN_TEMPLATE_COND
{
    DWORD dwSize;
    DWORD dwPlanTemplateNumber; //Plan template number, starting from 1, the maximum value from the entrance guard capability sets 
    WORD wLocalControllerID; //On the controller serial number[1,64], 0 is invalid 
    BYTE byRes[106];
}NET_DVR_PLAN_TEMPLATE_COND, *LPNET_DVR_PLAN_TEMPLATE_COND;

#define UNLOCK_PASSWORD_LEN                        8 //unlock password len
#define LOCAL_CONTROLLER_NAME_LEN                  32//On the controller name length 
typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //door name 
    BYTE byMagneticType; //magnetic type, 0-always close 1-always open
    BYTE byOpenButtonType; //open button type,  0-always close 1-always open
    BYTE byOpenDuration; //open duration time, 1-255s(ladder control relay action time)
    BYTE byAccessibleOpenDuration; //accessible open duration , 1-255s  
    BYTE byMagneticAlarmTimeout; //magnetic alarm time out , 0-255s,0 means not to alarm
    BYTE byEnableDoorLock; //whether to enable door lock, 0-disable, 1-enable
    BYTE byEnableLeaderCard; //whether to enable leader card , 0-disable, 1-enable
    BYTE byLeaderCardMode; //First card mode, 0 - first card function is not enabled, and 1 - the first card normally open mode, 2 - the first card authorization mode (using this field, the byEnableLeaderCard is invalid ) 
    DWORD dwLeaderCardOpenDuration; //leader card open duration 1-1440minNET_DVR_CARD_CFG
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //stress ppassword 
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //super password
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN]; //remove code
    BYTE byUseLocalController; //Read-only, whether the connection on the local controller, 0 - no, 1 - yes
    BYTE byRes1;
    WORD wLocalControllerID; //Read-only, on-site controller serial number, 1-64, 0 on behalf of unregistered 
    WORD wLocalControllerDoorNumber; //Read-only, on-site controller door number, 1-4, 0 represents the unregistered 
    WORD wLocalControllerStatus; //Read-only, on-site controller online status: 0 - offline, 1 - online, 2 - loop of RS485 serial port 1 on 1, 3 - loop of RS485 serial port 2 on 2, 4 - loop of RS485 serial port 1, 5 - loop of RS485 serial port 2, 6 - loop 3 of RS485 serial port 1, 7 - the loop on the RS485 serial port on the 3 4 2, 8 - loop on the RS485 serial port 1, 9 - loop 4 of RS485 serial port 2 (read-only) 
    BYTE byLockInputCheck; //Whether to enable the door input detection (1 byte, 0 is not enabled, 1 is enabled, is not enabled by default) 
    BYTE byLockInputType; //Door lock input type 
    BYTE byDoorTerminalMode; //Gate terminal working mode 
    BYTE byOpenButton; //Whether to enable the open button 
    BYTE byLadderControlDelayTime; //ladder control delay time,1-255min
    BYTE byRes2[43];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //plan template No. 0 means cancel relation,resolve default status(ordinary status)
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //plan template No. 0 means cancel relation,resolve default status(swipe card)
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //whether to enable , 0-disable 1-enable
    BYTE byBeginTimeFlag;
    BYTE byEnableTimeFlag;
    BYTE byTimeDurationNo;
    NET_DVR_TIME_EX struBeginTime; //valid begin time
    NET_DVR_TIME_EX struEndTime; //valid end time 
    BYTE byTimeType;
    BYTE byRes2[31];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable , 0-disable 1-enable
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //group valid parameter
    BYTE byGroupName[GROUP_NAME_LEN]; //group name 
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //whether to use group combination, 0-disable 1-enable     
    BYTE byMemberNum; //the number of member can swipe
    BYTE bySequenceNo; //group swipe sequence No. 
    BYTE byRes;
    DWORD dwGroupNo;  //group No,0xffffffff means remote control,0xfffffffe means super password 
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable  
    BYTE byEnableOfflineVerifyMode; //whether to use host offline to verify , 0-disable 1-enable  
    BYTE byRes1[2];
    DWORD dwTemplateNo; //use plan template No. with  mutil card function
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //group combination
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable  
    BYTE bySwipeIntervalTimeout; //swipe interval time out , 1-255s default 10s    
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //group swipe parameter
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO_V50
{
    BYTE byEnable; //whether to use group combination, 0-disable 1-enable
    BYTE byMemberNum; //the number of member can swipe
    BYTE bySequenceNo; //group swipe sequence No.
    BYTE byRes;
    DWORD dwGroupNo;  //group No,0xffffffff means remote control,0xfffffffe means super password
}NET_DVR_GROUP_COMBINATION_INFO_V50, *LPNET_DVR_GROUP_COMBINATION_INFO_V50;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG_V50
{
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable
    BYTE byEnableOfflineVerifyMode; //whether to use host offline to verify , 0-disable 1-enable
    BYTE byRes1[2];
    DWORD dwTemplateNo; //use plan template No. with  mutil card function
    NET_DVR_GROUP_COMBINATION_INFO_V50 struGroupCombination[GROUP_COMBINATION_NUM]; //group swipe parameter
}NET_DVR_MULTI_CARD_GROUP_CFG_V50, *LPNET_DVR_MULTI_CARD_GROUP_CFG_V50;

typedef struct tagNET_DVR_MULTI_CARD_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //whether to use mutil card group, 0-disable 1-enable 
    BYTE bySwipeIntervalTimeout; //swipe interval time out , 1-255s default 10s 
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG_V50 struGroupCfg[NET_SDK_MULTI_CARD_GROUP_NUM_20]; //group swipe parameter
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG_V50, *LPNET_DVR_MULTI_CARD_CFG_V50;

#define CARD_PARAM_CARD_VALID       0x00000001  //card valid parameter 
#define CARD_PARAM_VALID            0x00000002  //valid period parameter
#define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
#define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
#define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
#define CARD_PARAM_GROUP            0x00000040  //belong group parameter
#define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
#define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter
#define CARD_PARAM_EMPLOYEE_NO      0x00000400  //employee no
#define CARD_PARAM_NAME             0x00000800  //name
#define CARD_PARAM_DEPARTMENT_NO    0x00001000  //department no
#define CARD_SCHEDULE_PLAN_NO       0x00002000  //schedule plan no
#define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //schedule plan type
#define CARD_ROOM_NUMBER            0x00008000  //room number
#define CARD_SIM_NO                 0x00010000  //SIM number(phone number)
#define CARD_FLOOR_NUMBER           0x00020000  //floor number
#define CARD_USER_TYPE              0x00040000  //user type

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // the card parameter need to modify, valid when set card parameter, use by bit, every bit means a kind of parameter, 1 means modify, 0 means not 
    // #define CARD_PARAM_CARD_VALID       0x00000001 //card valid parameter 
    // #define CARD_PARAM_VALID            0x00000002  //valid period parameter
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
    // #define CARD_PARAM_GROUP            0x00000040  //belong group parameter
    // #define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No
    BYTE byCardValid; //whether is a vaild card,0-invalid,1-valid(use to delete card, 0 means delete card when setting, it will be 1 when getting)
    BYTE byCardType; //card type ,1-ordinary card,2-accessible card,3-block list card, 4-patrol card,5-stress card,6-super card,7-client card,8-remove card, default ordinary card  
    BYTE byLeaderCard; //whether is leader card, 0-no, 1-yes 
    BYTE byRes1;
    DWORD dwDoorRight; //door right , accord to bit, 1-has right 0-no right, from low bit to high bit means door 1-N have right
    NET_DVR_VALID_PERIOD_CFG struValid; //valid period parameter
    DWORD dwBelongGroup; //belong group , according to bit, 1-belong 0-not belong, from low bit to high bit means belong group 1-N 
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //card password 
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //card right plan, value is from plan template No. use or method when same door has different plan template  
    DWORD dwMaxSwipeTime; //max card time, 0 means infinite time
    DWORD dwSwipeTime; //has swiped card
    WORD wRoomNumber;  //room number
    SHORT wFloorNumber;   //floor number
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //card number, 0xffffffff means to get all card information when getting
    BYTE  byCheckCardNo; //whether to verify card No. 0-not to verify, 1-verify
    BYTE           byRes1[3];
    WORD wLocalControllerID; //On-site controller serial number, said to the local controller issued offline card parameters, 0 is access control host 
    BYTE  byRes2[2];
    DWORD dwLockID;  //lock ID
    BYTE  byRes3[20];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No 
    DWORD dwCardUserId;
    BYTE byRes[12];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;


typedef struct tagNET_DVR_CARD_USER_INFO_CFG
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN]; //user name
    BYTE	byAssociateNetUser;//associate net user
    BYTE byRes2[255];         //byRes2[0]--user num
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //door status week plan
#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //card reader verify week plan
#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //card right week plan
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //door status holiday plan
#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //card reader verify holiday plan 
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //card right holiday plan
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //door status holiday group
#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //card reader verify holiday group 
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //card right holiday group 
#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //door status plan template
#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //card reader verify plan template
#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //card right plan template
#define ACS_PARAM_CARD                         0x00001000 //card parameter 
#define ACS_PARAM_GROUP                        0x00002000 //group parameter 
#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //anti sneak config
#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //event card linkage
#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //card passwd open door parameter
#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //The number of statistical parameters
#define ACS_PARAM_BLOCKLIST_PICTURE           0x00040000 //block list picture
#define ACS_PARAM_ID_BLOCKLIST                0x00080000 //ID card block list parameters 
#define ACS_PARAM_EXAM_INFO                     0x00100000 //exam info parameter
#define ACS_PARAM_EXAMINEE_INFO                 0x00200000 //examinee info parameter
#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //when upgrade device,get failed face

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //parameter type , according to bit
    // #define ACS_PARAM_DOOR_STATUS_WEEK_PLAN       0x00000001 //door status week plan
    // #define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //card reader verify week plan
    // #define ACS_PARAM_CARD_RIGHT_WEEK_PLAN      0x00000004 //card right week plan
    // #define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN 0x00000008 //door status holiday plan
    // #define ACS_PARAM_VERIFY_HOLIDAY_PALN        0x00000010 //card reader verify holiday plan 
    // #define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN   0x00000020 //card right holiday plan
    // #define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP  0x00000040 //door status holiday group
    // #define ACS_PARAM_VERIFY_HOLIDAY_GROUP 0x00000080 //card reader verify holiday group 
    // #define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP   0x00000100 //card right holiday group
    // #define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE 0x00000200 //door status plan template
    // #define ACS_PARAM_VERIFY_PALN_TEMPLATE 0x00000400//card reader verify plan template
    // #define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE  0x00000800 //card right plan template
    // #define ACS_PARAM_CARD                         0x00001000 //card parameter 
    // #define ACS_PARAM_GROUP                        0x00002000 //group parameter 
    // #define ACS_PARAM_ANTI_SNEAK_CFG              0x00004000 //anti sneak config
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //event card linkage
    //#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //card passwd open door parameter
    //#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //The number of statistical parameters
    //#define ACS_PARAM_BLOCK_LIST_PICTURE        0x00040000 //block list picture
    //#define ACS_PARAM_ID_BLOCK_LIST             0x00080000 //ID card block list parameters 
    //#define ACS_PARAM_EXAM_INFO                     0x00100000 //exam info parameter
    //#define ACS_PARAM_EXAMINEE_INFO                 0x00200000 //examinee info parameter
    //#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //when upgrade device,get failed face
    WORD wLocalControllerID; //controller serial number [1,64],0 represent entrance guard host 
    BYTE byRes[30];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use anti sneak function, 1-enable, 0-disable
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //anti sneak card reader No.   
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //whether to join in anti sneak path. 1-join  0-not join in 
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //follow up card reader No, zero means don't care the anti sneak card reader No 
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //by bit,0-can,1-can not
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //by bit,0-can,1-can not
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //by bit,0-can,1-can not
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //by bit,0-can,1-can not
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM];          //by bit,0-can,1-can not
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];       //by bit,0-can,1-can not
    BYTE    byRes[256];
}NET_DVR_PHONE_DOOR_RIGHT_CFG, *LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to use multi door interlock, 1-enable 0-disable 
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //mutil door interlock parameter, fill in with door No.
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disable 
    BYTE byCardReaderType; //card reader type,1-DS-K110XM/MK/C/CK,2-DS-K192AM/AMP,3-DS-K192BM/BMP,4-DS-K182AM/AMP,5-DS-K182BM/BMP,6-DS-K182AMF/ACF,7-wiegand or 485 not online,8- DS-K1101M/MK,9- DS-K1101C/CK,10- DS-K1102M/MK/M-A
    //11- DS-K1102C/CK,12- DS-K1103M/MK,13- DS-K1103C/CK,14- DS-K1104M/MK,15- DS-K1104C/CK,16- DS-K1102S/SK/S-A,17- DS-K1102G/GK,18- DS-K1100S-B,19- DS-K1102EM/EMK,20- DS-K1102E/EK,
    //21- DS-K1200EF,22- DS-K1200MF,23- DS-K1200CF,24- DS-K1300EF,25- DS-K1300MF,26- DS-K1300CF,27- DS-K1105E,28- DS-K1105M,29- DS-K1105C,30- DS-K182AMF,31- DS-K196AMF,32-DS-K194AMP
    //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C,35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/MF/SF/EF,37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
    //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED polarity,0-negative,1-positive
    BYTE byErrorLedPolarity; //Error LED polarity,0-negative,1-positive
    BYTE byBuzzerPolarity; //buzzer polarity,0-negative,1-positive
    BYTE bySwipeInterval; //swipe interval, unit: second
    BYTE byPressTimeout;  //press time out, unit:second
    BYTE byEnableFailAlarm; //whether to enable fail alarm, 0-disable 1-enable
    BYTE byMaxReadCardFailNum; //max reader card fail time
    BYTE byEnableTamperCheck;  //whether to support tamper check, 0-disable ,1-enable
    BYTE byOfflineCheckTime;  // offline check time, Uint second
    BYTE byFingerPrintCheckLevel;   //fingerprint check lever,1-1/10,2-1/100,3-1/1000,4-1/10000,5-1/100000,6-1/1000000,7-1/10000000,8-1/100000000,9-3/100,10-3/1000,11-3/10000,12-3/100000,13-3/1000000,14-3/10000000,15-3/100000000,16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byUseLocalController; //Read-only, whether the connection on the local controller, 0 - no, 1 - yes
    BYTE byRes1;
    WORD wLocalControllerID; //Read-only, on-site controller serial number, 1-64, 0 on behalf of unregistered 
    WORD wLocalControllerReaderID; //Read-only, on-site controller card reader ID, 0 represents the unregistered 
    WORD wCardReaderChannel; //Read-only, card reader communication channel number, 0 wiggins or offline, 1 - RS485A, 2 - RS485B 
    BYTE byRes[16];
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //whether to enable, 1-enable, 0-disabl
    BYTE byCardReaderType; //card reader type,1-DS-K110XM/MK/C/CK,2-DS-K192AM/AMP,3-DS-K192BM/BMP,4-DS-K182AM/AMP,5-DS-K182BM/BMP,6-DS-K182AMF/ACF,7-wiegand or 485 not online,8- DS-K1101M/MK,9- DS-K1101C/CK,10- DS-K1102M/MK/M-A
    //11- DS-K1102C/CK,12- DS-K1103M/MK,13- DS-K1103C/CK,14- DS-K1104M/MK,15- DS-K1104C/CK,16- DS-K1102S/SK/S-A,17- DS-K1102G/GK,18- DS-K1100S-B,19- DS-K1102EM/EMK,20- DS-K1102E/EK,
    //21- DS-K1200EF,22- DS-K1200MF,23- DS-K1200CF,24- DS-K1300EF,25- DS-K1300MF,26- DS-K1300CF,27- DS-K1105E,28- DS-K1105M,29- DS-K1105C,30- DS-K182AMF,31- DS-K196AMF,32-DS-K194AMP
    //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C,35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/MF/SF/EF,37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
    //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED polarity,0-negative,1-positive
    BYTE byErrorLedPolarity; //Error LED polarity,0-negative,1-positive
    BYTE byBuzzerPolarity; //buzzer polarity,0-negative,1-positive
    BYTE bySwipeInterval; //swipe interval, unit: second
    BYTE byPressTimeout;  //press time out, unit:second
    BYTE byEnableFailAlarm; //whether to enable fail alarm, 0-disable 1-enable
    BYTE byMaxReadCardFailNum; //max reader card fail time
    BYTE byEnableTamperCheck;  //whether to support tamper check, 0-disable ,1-enable
    BYTE byOfflineCheckTime;  //offline check time, Uint second
    BYTE byFingerPrintCheckLevel; //fingerprint check lever,1-1/10,2-1/100,3-1/1000,4-1/10000,5-1/100000,6-1/1000000,7-1/10000000,8-1/100000000,9-3/100,10-3/1000,11-3/10000,12-3/100000,13-3/1000000,14-3/10000000,15-3/100000000,16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byUseLocalController; //read only,weather connect with local control:0-no,1-yes
    BYTE  byRes1;
    WORD wLocalControllerID; //read only,local controller ID, byUseLocalController=1 effective,1-64,0 present not register
    WORD wLocalControllerReaderID; //read only,local controller reader ID,byUseLocalController=1 effective,0 present not register
    WORD wCardReaderChannel; //read only,card reader channel,byUseLocalController=1 effective,0-wiegand or offline,1-RS485A,2-RS485B
    BYTE byFingerPrintImageQuality; //finger print image quality,0-no effective,1-weak qualification(V1),2-moderate qualificatio(V1),3-strong qualification(V1),4-strongest qualification(V1),5-weak qualification(V2),6-moderate qualification(V2),7-strong qualification(V2),8-strongest qualification(V2)
    BYTE byFingerPrintContrastTimeOut; //finger print contrast time out,0-no effective,1-20 present:1s-20s,0xff-infinite
    BYTE byFingerPrintRecogizeInterval; //finger print recogize interval,0-no effective,1-10 present:1s-10s,0xff-no delay
    BYTE byFingerPrintMatchFastMode; //finger print match fast mode,0-no effective,1-5 present:fast mode 1-fast mode 5,0xff-auto
    BYTE byFingerPrintModuleSensitive; //finger print module sensitive,0-no effective,1-8 present:sensitive level 1-sensitive level 8
    BYTE byFingerPrintModuleLightCondition; //finger print module light condition,0-no effective,1-out door,2-in door
    BYTE byFaceMatchThresholdN; //range 0-100
    BYTE byFaceQuality; //face quality,range 0-100
    BYTE byFaceRecogizeTimeOut; //face recogize time out,1-20 present:1s-20s,0xff-infinite
    BYTE byFaceRecogizeInterval; //face recogize interval,0-no effective,1-10 present:1s-10s,0xff-no delay
    WORD wCardReaderFunction; //read only,card reader function
    BYTE byCardReaderDescription[CARD_READER_DESCRIPTION]; //read only,card reader description
    WORD wFaceImageSensitometry; //face image sensitometry,range 0-65535
    BYTE byLivingBodyDetect; //living body detect,0-no effective,1-disable,2-enable
    BYTE byFaceMatchThreshold1; //range 0-100
    WORD wBuzzerTime; //buzzer time,range 0-5999(s) 0 present yowl
    BYTE byFaceMatch1SecurityLevel; //1:1 security level,0-invalid,1-normal,2-more secure,3-extremely secure
    BYTE byFaceMatchNSecurityLevel; //1:N security level,0-invalid,1-normal,2-more secure,3-extremely secure
    BYTE byEnvirMode;//environment conditions 0-invalid 1-indoor 2-other
    BYTE byLiveDetLevelSet;//living body detect threshold,0-invalid,1-low,2-normal,3-high
    BYTE byLiveDetAntiAttackCntLimit;//anti-attack limit 0-invalid,1-255,the times limit,get value by abilities
    BYTE byEnableLiveDetAntiAttack;//enbale 0-invlid,1-disable,2-enable
    BYTE bySupportDelFPByID;//read only,support delete finger print by ID:0-invalid,1-not support,2-support
    BYTE byFaceContrastMotionDetLevel;//face contrast motion detect level: 0-invalid,1-low,2-middle,3-high,0xff-disable
    BYTE byDayFaceMatchThresholdN; //day range 0-100
    BYTE byNightFaceMatchThresholdN; //night range 0-100
    BYTE byFaceRecogizeEnable; //face recogize enable:0-invalid,1-open,2-close
    BYTE byBlockListMatchThreshold; //block list threshold 0-100
    BYTE byRes3;
    BYTE byDefaultVerifyMode; //read only,default verify mode
    DWORD dwFingerPrintCapacity;//readonly,capacity
    DWORD dwFingerPrintNum;//readonly,num of fingerprint
    BYTE byEnableFingerPrintNum;//readonly 
    BYTE byEnableReverseCardNo; //reverse cardno 0-no 1-yes
    BYTE byRes2[2];
    DWORD dwIndependSwipeIntervals;
    BYTE byRes[224];
}NET_DVR_CARD_READER_CFG_V50, *LPNET_DVR_CARD_READER_CFG_V50;

typedef struct tagNET_DVR_FAILED_FACE_COND
{
    DWORD dwSize;
    BYTE byRes[128];          //reserve
}NET_DVR_FAILED_FACE_COND, *LPNET_DVR_FAILED_FACE_COND;

typedef struct tagNET_DVR_FAILED_FACE_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  byErrorCode;  //error code 
    BYTE byRes1[3];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN];
    BYTE byRes[92];
}NET_DVR_FAILED_FACE_INFO, *LPNET_DVR_FAILED_FACE_INFO;

typedef struct tagNET_DVR_FACE_PARAM_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //enable card reader,0-disable,1-enable
    DWORD dwFaceNum; //get or set face number,when get:0xffffffff presents get all face info
    BYTE  byFaceID;  //face id,effective value:1-2   0xff presnets all face
    BYTE  byRes[127];
}NET_DVR_FACE_PARAM_COND, *LPNET_DVR_FACE_PARAM_COND;

typedef struct tagNET_DVR_FACE_PARAM_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    DWORD dwFaceLen;     //face length <DES>
    char* pFaceBuffer;  //face buffer
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //enable card reader
    BYTE  byFaceID;     //face id,effective value 1-2
    BYTE  byFaceDataType;   //face data type:0-template(default),1-picture
    BYTE  byRes[126];
}NET_DVR_FACE_PARAM_CFG, *LPNET_DVR_FACE_PARAM_CFG;

typedef struct tagNET_DVR_FACE_PARAM_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //card reader recv status,0-fail,1-success,
    BYTE  byErrorMsg[ERROR_MSG_LEN];
    DWORD dwCardReaderNo;  //card reader no
    BYTE  byTotalStatus;  //total status
    BYTE  byFaceID;     //face id,effective value 1-2
    BYTE  byRes[130];
}NET_DVR_FACE_PARAM_STATUS, *LPNET_DVR_FACE_PARAM_STATUS;

typedef struct tagNET_DVR_FACE_PARAM_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //enable card reader
    BYTE  byFaceID[MAX_FACE_NUM];        //need del face id,0 present-no del,1-del this face
    BYTE  byRes1[42];
}NET_DVR_FACE_PARAM_BYCARD, *LPNET_DVR_FACE_PARAM_BYCARD;

typedef struct tagNET_DVR_FACE_PARAM_BYREADER
{
    DWORD dwCardReaderNo;  //card reader no
    BYTE byClearAllCard;  //whether del all card face info,0-del face info through card no,1-del all face info
    BYTE byRes1[3];
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE byRes[548];
}NET_DVR_FACE_PARAM_BYREADER, *LPNET_DVR_FACE_PARAM_BYREADER;

typedef union tagNET_DVR_DEL_FACE_PARAM_MODE
{
    BYTE uLen[588];   //union length
    NET_DVR_FACE_PARAM_BYCARD       struByCard;     //del face param by card
    NET_DVR_FACE_PARAM_BYREADER     struByReader;   //del face param by reader
}NET_DVR_DEL_FACE_PARAM_MODE, *LPNET_DVR_DEL_FACE_PARAM_MODE;

typedef struct tagNET_DVR_FACE_PARAM_CTRL
{
    DWORD dwSize;
    BYTE  byMode;   //del mode,0-del face param by card,1-del face param by reader
    BYTE  byRes1[3];
    NET_DVR_DEL_FACE_PARAM_MODE struProcessMode;  //process mode
    BYTE  byRes[64];
}NET_DVR_FACE_PARAM_CTRL, *LPNET_DVR_FACE_PARAM_CTRL;

typedef    struct tagNET_DVR_LOCAL_CONTROLLER_STATUS_COND
{
    DWORD            dwSize;
    WORD wLocalControllerID; //On the controller serial number, 0 to represent all (distract controller no)
    BYTE                    byRes[306];
}NET_DVR_LOCAL_CONTROLLER_STATUS_COND, *LPNET_DVR_LOCAL_CONTROLLER_STATUS_COND;

typedef struct tagNET_DVR_LOCAL_CONTROLLER_STATUS
{
    DWORD            dwSize;
    WORD wLocalControllerID; //On the controller serial number (distract controller no)
    BYTE byLocalAntiDismantleStatus; //On-site controller tamper condition, 0 to shut down, 1 to open it 
    BYTE byPowerSupplyStatus; //Equipment state of power supply, 1 - ac power supply, 2 - battery power supply 
    WORD wBatteryVoltage; //Battery voltage value, actual value multiplied 10 units: v 
    BYTE byBatteryLowVoltage; //Whether the battery is in low pressure state, 0 - no, 1 - is 
    BYTE byFireAlarm; //Fire alarm, 0 - normal, alarm 1 - short, 2 - disconnect the alarm 
    BYTE bySerialNumber[SERIALNO_LEN];  //Equipment serial number 
    BYTE byMagneticStatus[MAX_DOOR_NUM];// Magnetic door status: 0 normally closed, normally open, 1 2 damage short-circuit alarm, 3 damage breaking alarm, 4 abnormal alarm 
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //Lock state, 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //Card reader online status, 0 - not online, 1 - online 
    WORD wLocalControllerStatus; //Read-only, on-site controller online status(distract controller online status): 0 - offline, 1 on 1 - online, 2 - loop of RS485 serial port 1 on 1, 3 - loop of RS485 serial port 2 on 2, 4 - loop of RS485 serial port 1, 5 - loop of RS485 serial port 2, 6 - loop 3 of RS485 serial port 1, 7 - the loop on the RS485 serial port on the 3 4 2, 8 - loop on the RS485 serial port 1, 9 - loop 4 of RS485 serial port 2 (read-only) 
    BYTE byRes2[122];
}NET_DVR_LOCAL_CONTROLLER_STATUS, *LPNET_DVR_LOCAL_CONTROLLER_STATUS;

typedef struct tagNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG
{
    DWORD            dwSize;
    BYTE byLocalControllerName[LOCAL_CONTROLLER_NAME_LEN]; //On the controller name 
    WORD wLocalControllerID; //On the controller serial number 
    WORD    wDevPort;                 // Equipment port 
    NET_DVR_IPADDR    struDevIP;       // The device IP address 
    NET_DVR_IPADDR    struSubnetMask;  // Subnet mask 
    NET_DVR_IPADDR    struGateway;     // Gateway equipment 
    BYTE         bySearchProgress; //Search progress, 0 means did not start, 100 indicates synchronization is complete 
    BYTE         byEffectData;//For valid data, 0 means effective, 1 said equipment returns only search progress, as the heartbeat packets 
    BYTE byRes[302];
}NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG, *LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //door lock status, 0-disable 1-enable
    BYTE byDoorStatus[MAX_DOOR_NUM]; //door status
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //magnetic status 0-close 1-open
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //case status, 0-no input, 1-input
    WORD wBatteryVoltage; //vattery voltage , multiply 10, unit: V
    BYTE byBatteryLowVoltage; //Is battery in low voltage, 0-no 1-yes
    BYTE byPowerSupplyStatus; //power supply status, 1-alternating current supply, 2-battery supply
    BYTE byMultiDoorInterlockStatus; //multi door interlock status, 0-close 1-open
    BYTE byAntiSneakStatus; //anti sneak status, 0-close 1-open
    BYTE byHostAntiDismantleStatus; //host anti dismantle status, 0-close, 1-open
    BYTE byIndicatorLightStatus; //Indicator Light Status 0-offLine,1-Online
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //card reader online status, 0-offline 1-online
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //card reader anti dismantle status, 0-close 1-open
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //card reader verify mode, 1-swipe 2-swipe+password 3-swipe card 4-swipe card or password
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//alarm in setup alarm status,0- alarm in disarm status, 1 - alarm in arm status
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //alarm in status, 0-alarm in no alarm, 1-alarm in has alarm 
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //alarm out status, 0-alarm out no alarm, 1-alarm out has alarm 
    DWORD dwCardNum; //add card number
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_ACS_WORK_STATUS_V50
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM_256];//door lock status(relay status), 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byDoorStatus[MAX_DOOR_NUM_256]; //Door status(floor status), 1 - dormancy, 2 - normally open state, 3 - normally closed state, 4 - ordinary state
    BYTE byMagneticStatus[MAX_DOOR_NUM_256]; //magnetic status 0 normally closed,1 normally open, 2 damage short - circuit alarm, 3 damage breaking alarm, 4 abnormal alarm
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //case status, 0-no input, 1-input    
    WORD wBatteryVoltage; //vattery voltage , multiply 10, unit: V
    BYTE byBatteryLowVoltage; //Is battery in low voltage, 0-no 1-yes
    BYTE byPowerSupplyStatus; //power supply status, 1-alternating current supply, 2-battery supply
    BYTE byMultiDoorInterlockStatus;//multi door interlock status, 0-close 1-open
    BYTE byAntiSneakStatus; //anti sneak status, 0-close 1-open
    BYTE byHostAntiDismantleStatus; //host anti dismantle status, 0-close, 1-open
    BYTE byIndicatorLightStatus; //Indicator Light Status 0-offLine,1-Online
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM_512]; //card reader online status, 0-offline 1-online
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM_512]; //card reader anti dismantle status, 0-close 1-open
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM_512]; //card reader verify mode, 1-swipe 2-swipe+password 3-swipe card 4-swipe card or password
    BYTE  bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//alarm in setup alarm status,0- alarm in disarm status, 1 - alarm in arm status
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //alarm in status, 0-alarm in no alarm, 1-alarm in has alarm 
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //alarm out status, 0-alarm out no alarm, 1-alarm out has alarm 
    DWORD dwCardNum; //add card number
    BYTE byFireAlarmStatus; //Fire alarm status is displayed: 0 - normal, short-circuit alarm 1 -, 2 - disconnect the alarm 
    BYTE byBatteryChargeStatus; //battery charge status: 0-invalid;1-chargingg;2-uncharged
    BYTE byMasterChannelControllerStatus; //master channel controller status: 0-invalid;1-offline;2-online
    BYTE bySlaveChannelControllerStatus; //slave channel controller status: 0-invalid;1-offline;2-online
    BYTE byAntiSneakServerStatus; //anti sneak server status:0-invalid,1-disable,2-normal,3-offline
    BYTE byRes3[3];
    DWORD dwAllowFaceNum;
    DWORD dwBlockFaceNum;
    BYTE byRes2[108];
}NET_DVR_ACS_WORK_STATUS_V50, *LPNET_DVR_ACS_WORK_STATUS_V50;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //host buzzer, 0-not trigger, 1-trigger
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //card reader buzzer, 0-not trigger, 1-trigger
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // associate alarm out, 1- associate 0-not associate 
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //associate door whose ID is ranage 1 to N , 0-not associate 1-associate(open door)
    BYTE  byDoorClose[MAX_DOOR_NUM]; //associate door whose ID is ranage 1 to N , 0-not associate 1-associate(close door)
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //Channel number 
    BYTE    byPSpeed;  // The X axis control the speed value (1-64) 
    BYTE    byTSpeed;  // The Y axis control the speed value (1-64) 
    BYTE    byZSpeed;  // z speed
    BYTE    byPDirect; // P direction, 1 - left, 2 - right 
    BYTE    byTDirect; // T direction, 1 - left, 2 - right 
    BYTE    byZDirect;  //direction  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL;

typedef enum _ENUM_UPGRADE_TYPE
{
    ENUM_UPGRADE_DVR = 0, //rdinary device upgrade 
    ENUM_UPGRADE_ADAPTER = 1, //DVR adpater upgrade
    ENUM_UPGRADE_VCALIB = 2,  //smart library upgrade
    ENUM_UPGRADE_OPTICAL = 3, //optical upgrade 
    ENUM_UPGRADE_ACS = 4, //acs upgrade
    ENUM_UPGRADE_AUXILIARY_DEV = 5, //auxiliary device upgrade
    ENUM_UPGRADE_LED = 6, //LED receive and send card upgrade
    ENUM_UPGRADE_INTELLIGENT = 7,
}ENUM_UPGRADE_TYPE;

typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No, 0 means invalid 
    BYTE byCardType; //card type,1-ordinary card,2-accessible card,3-block list card, 4-patrol card,5-stress card,6-super card,7-client card, 0 means invalid
    BYTE byAllowListNo; //allow list No, 1-8, 0 means invalid
    BYTE byReportChannel; //report channel, 1-alarmin updata, 2-center group 1, 3-center group 2, 0 means invalid
    BYTE byCardReaderKind;//4 - fingerprint head
    DWORD dwCardReaderNo; // card reader No, 0 means invalid
    DWORD dwDoorNo; //door No(floor No), 0 means invalid
    DWORD dwVerifyNo; //mutilcard verify No. 0 means invalid
    DWORD dwAlarmInNo;  //alarm in No, 0 means invalid
    DWORD dwAlarmOutNo; //alarm out No 0 means invalid
    DWORD dwCaseSensorNo; //case sensor No 0 means invalid
    DWORD dwRs485No;    //RS485 channel,0 means invalid
    DWORD dwMultiCardGroupNo; //multicard group No. 
    WORD wAccessChannel;    //Staff channel number 
    BYTE  byDeviceNo; //device No,0 means invalid
    BYTE  byDistractControlNo;//distract control,0 means invalid
    DWORD dwEmployeeNo; //employee No,0 means invalid
    WORD wLocalControllerID; //On the controller number, 0 - access the host, 1-64 on behalf of the local controller 
    BYTE  byInternetAccess; //Internet access ID 
    BYTE    byType;     //Alarm type
    BYTE  byMACAddr[MACADDR_LEN]; //mac addr
    BYTE  bySwipeCardType;//swipe card type
    BYTE  byMask; //wear mask:1-unknown,2-no,3-yes
    DWORD dwSerialNo;
    BYTE  byChannelControllerID; //channel controller ID
    BYTE  byChannelControllerLampID; //channel controller lamp ID
    BYTE  byChannelControllerIRAdaptorID; //channel controller IR adaptor ID
    BYTE  byChannelControllerIREmitterID; //channel controller IR emitter ID
    BYTE  byHelmet;//wear helmet: 1-unknown, 2-no, 3-yes
    BYTE  byRes[3];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_EVENT_INFO_EXTEND
{
    DWORD dwFrontSerialNo; //front serial No
    BYTE  byUserType; //user type
    BYTE  byCurrentVerifyMode; //current verify mode
    BYTE  byCurrentEvent; //current event
    BYTE  byPurePwdVerifyEnable; 
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee No
    BYTE  byAttendanceStatus; //0-undefined, 1-checkIn, 2-checkOut, 3-breakOut, 4-breakIn, 5-overtimeIn, 6-overtimeOut
    BYTE  byStatusValue; //Attendance Status Value
    BYTE  byRes2[2];
    BYTE  byUUID[NET_SDK_UUID_LEN/*36*/]; //UUID
    BYTE  byDeviceName[NET_DEV_NAME_LEN];
    BYTE  byRes[24];
}NET_DVR_ACS_EVENT_INFO_EXTEND, *LPNET_DVR_ACS_EVENT_INFO_EXTEND;

typedef struct tagNET_DVR_ACS_EVENT_INFO_EXTEND_V20
{
    BYTE byRemoteCheck; //remote check(0-invalid,1-not need(default),2-need)
    BYTE byThermometryUnit; //thermometry unit(0-celsius(default),1-fahrenheit,2-kelvin)
    BYTE byIsAbnomalTemperature; //is abnomal temperature(0-no,1-yes)
    BYTE byRes2;
    float fCurrTemperature; //face temperature
    NET_VCA_POINT struRegionCoordinates; //face temperature region coordinates
    DWORD dwQRCodeInfoLen; //QR code info len
    DWORD dwVisibleLightDataLen; //visible light data len
    DWORD dwThermalDataLen; //thermal data len
    char *pQRCodeInfo; //QR code info buffer
    char *pVisibleLightData; //visible light data buffer
    char *pThermalData; //thermal data buffer
    BYTE  byAttendanceLabel[64];
    BYTE  byRes[960];
}NET_DVR_ACS_EVENT_INFO_EXTEND_V20, *LPNET_DVR_ACS_EVENT_INFO_EXTEND_V20;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //alarm major, reference to macro
    DWORD dwMinor; //alarm minor, reference to macro
    NET_DVR_TIME struTime; //time 
    BYTE    sNetUser[MAX_NAMELEN];//net operator user
    NET_DVR_IPADDR    struRemoteHostAddr;//remote host address
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo;
    DWORD dwPicDataLen;   //picture length, when 0 ,means has no picture
    char    *pPicData;  //picture data
    WORD  wInductiveEventType; //Inductive event type, 0- invalid.
    BYTE    byPicTransType;        //Image data transmission mode: 0-binary; 1 - the url
    BYTE    byRes1;
    DWORD dwIOTChannelNo;    //IOT channel
    char    *pAcsEventInfoExtend;
    BYTE    byAcsEventInfoExtend;
    BYTE    byTimeType; //time type:0-local time,1-UTC time(struTime struct)
    BYTE    byRes2;
    BYTE    byAcsEventInfoExtendV20;
    char    *pAcsEventInfoExtendV20;
    BYTE byRes[4];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;


#define JUDGE_MAX_VIDEOOUT_NUM 9

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3];
    DWORD   dwChanNo;
    BYTE    bySensitivity;
    BYTE    byPriority;
    WORD    wDelayTime;
    BYTE    byRes2;
    BYTE    byEnablePreset;
    WORD    wPreset;
    WORD    wBase;
    BYTE    byRes3[2];
    BYTE    byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];
    BYTE    byRes[255];
}NET_DVR_AUDIO_ACTIVATION_CFG, *LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;
    BYTE   byIROutPort;
    BYTE   byIRCmdIndex;
    BYTE   byRes[254];
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

#define  MAX_IR_CMD_NAME_LEN    32   
#define  MAX_IR_CMD_NUM         32   

typedef struct tagNET_DVR_INFRARED_CMD_INFO
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];
    BYTE   byRes[8];
} NET_DVR_INFRARED_CMD_INFO, *LPNET_DVR_INFRARED_CMD_INFO;


typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;
    BYTE      sIROutName[MAX_IR_CMD_NAME_LEN];
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG, *LPNET_DVR_INFRARED_CMD_NAME_CFG;

typedef enum tagIR_LEARN_SEND_DATA_TYPE_ENUM
{
    ENUM_SENDDATA = 0x0,
    ENUM_SEND_LEARN_IR_CMD_START,
    ENUM_SEND_LEARN_IR_CMD_END = 0x2
}IR_LEARN_SEND_DATA_TYPE_ENUM;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;
    BYTE  byIROutPort;
    BYTE  byIRCmdIndex;
    BYTE  byRes[30];
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;
    BYTE   bySaveLearnInfo;
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END, *LPNET_DVR_INFRARED_LEARN_END;

#define MAX_VIDEOIN_TYPE_NUM  10    

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;
    WORD  wInNum;
    WORD  wStartNo;
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;

typedef  struct tagNET_DVR_TRIAL_SYSTEM_INFO
{
    DWORD dwSize;
    BYTE   byVideoInTypeNum;
    BYTE   byRes1[3];
    NET_DVR_VIDEOIN_TYPE_INFO struVideoIn[MAX_VIDEOIN_TYPE_NUM];
    BYTE   byRes[512];
} NET_DVR_TRIAL_SYSTEM_INFO, *LPNET_DVR_TRIAL_SYSTEM_INFO;




typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;
    BYTE    byCaseNo[CASE_NO_LEN];
    BYTE    byCaseName[CASE_NAME_LEN];
    BYTE    byLitigant1[LITIGANT_LEN];
    BYTE    byLitigant2[LITIGANT_LEN];
    BYTE    byChiefJudge[CHIEF_JUDGE_LEN];
    BYTE    byCaseType;
    BYTE    byShowCaseInfoTime;
    BYTE    byRes1[2];
    char    sCaseTypeCustom[NET_SDK_CASETYPE_LEN/*32*/];
    BYTE    byRes[220];
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;

#define     MICROPHONE_NUM            16
#define     FAN_NUM                8
#define     FPGA_NUM                8
#define     MAIN_BOARD                8
#define  LOCAL_INPUT_NUM        24
#define  LAMP_STATE_NAME        32
#define  LAMP_NAME                32
#define FILE_NAME_LEN            32
typedef  struct _NET_DVR_REMOTE_PLAY_
{
    DWORD    dwSize;
    BYTE    byFileName[FILE_NAME_LEN];
    BYTE    byVideoOut[7];
    BYTE    byRes1[5];
    BYTE    byType;
    BYTE      byRes[31];
}NET_DVR_REMOTE_PLAY, *LPNET_DVR_REMOTE_PLAY;

typedef  struct _NET_DVR_TRIAL_MICROPHONE_STATUS
{
    DWORD     dwSize;
    BYTE    byMicrophoneStatus[MICROPHONE_NUM];
    BYTE    byRes[32];
}NET_DVR_TRIAL_MICROPHONE_STATUS, *LPNET_DVR_TRIAL_MICROPHONE_STATUS;

typedef  struct _NET_DVR_TRIAL_HOST_STATUS
{
    DWORD  dwSize;
    DWORD  dwFanSpeed[FAN_NUM];
    WORD   wMainBoardTemp[MAIN_BOARD];
    BYTE   byFpgaTempWarn[FPGA_NUM];
    BYTE   byRes[32];
}NET_DVR_TRIAL_HOST_STATUS, *LPNET_DVR_TRIAL_HOST_STATUS;

typedef  struct _NET_DVR_LOCAL_INPUT_INFO_
{
    DWORD      dwSize;
    BYTE      byChannelName[NAME_LEN];
    BYTE      byRes[32];
}NET_DVR_LOCAL_INPUT_INFO, *LPNET_DVR_LOCAL_INPUT_INFO;

typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE     byEnable;
    BYTE     byRes1[3];
    BYTE     byLampName[LAMP_NAME];
    BYTE     byLampState1[LAMP_STATE_NAME];
    BYTE     byLampState2[LAMP_STATE_NAME];
    BYTE     byLampState3[LAMP_STATE_NAME];
    BYTE     byRes[32];
}NET_DVR_LAMP_STATUS, *LPNET_DVR_LAMP_STATUS;

typedef  struct _NET_DVR_LAMP_OUT
{
    DWORD        dwSize;
    NET_DVR_LAMP_STATUS  struLampInfo[2];
    BYTE  byRes[256];
}NET_DVR_LAMP_OUT, *LPNET_DVR_LAMP_OUT;

typedef  struct _NET_DVR_LAMP_CONTROL
{
    DWORD     dwSize;
    BYTE  byLampNo;
    BYTE  byLampStateNo;
    BYTE  byRes[14];
}NET_DVR_LAMP_CONTROL, *LPNET_DVR_LAMP_CONTROL;

//TPS Param
typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE                byStart;          // Start Code
    BYTE                byCMD;         // CMD
    WORD                wSpaceHeadway;        //unit:m
    WORD                wDeviceID;      // Device ID
    WORD                wDataLen;       // Data Length
    BYTE                byLane;         // Lane
    BYTE                bySpeed;        // Speed(KM/H)
    BYTE                  byLaneState;     // Lane State;0- no, 1- flow, 2- crowded, 3- plug
    BYTE                  byQueueLen;       // Queue Length
    WORD                wLoopState;     //loop state,0-leave,1-enter
    WORD                wStateMask;     //loop state mask
    DWORD               dwDownwardFlow; //current Lane(byLane) downward flow
    DWORD               dwUpwardFlow;   //current Lane(byLane) upward flow
    BYTE                byJamLevel;     //Jam level,1-lightly,2-Moderately,3-Heavily 
    BYTE               byVehicleDirection; //0-unknown,1-up2down,2-down2up
    BYTE               byJamFlow;          //jam flow
    BYTE                byChannelizationLane;         //Channelized lane number (channelized means the change in the number of lanes, generally the number of lanes at the intersection)
    BYTE                byVehicleType; //Model identification: 0-unknown, 1-passenger car (large), 2-freight car (large), 3-passenger car (small), 4-non-motor vehicle
    BYTE               byRes1[5];        //res
    WORD                wTimeHeadway;        //unit:m
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

//TPS Info
typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;
    DWORD                 dwChan;//Channel No.
    NET_DVR_TIME_V30      struTime;    //Detection Time
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// TPS Param
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//Win64 and linux64 under the pointer to 8 bytes
    BYTE*                 pAddInfoBuffer;
#else
    /*Additional information pointer to NET_DVR_TPS_ADDINFO*/
    BYTE*                 pAddInfoBuffer;
    BYTE                  byRes2[4];
#endif  
    /*Additional information identification(NET_DVR_TPS_ADDINFO)*/
    BYTE                  byAddInfoFlag;
    BYTE                  byRes1[3];      // res
    DWORD                 dwDeviceIDEx;   // Device ID Extension 
    BYTE                  byRes[8];       // res
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE                  byLane;             // Lane
    BYTE                  bySpeed;             //Speed
    WORD                  wArrivalFlow;        //arrival flow
    DWORD               dwLightVehicle;      // Light Vehicle Num
    DWORD               dwMidVehicle;        // Mid Vehicle Num
    DWORD               dwHeavyVehicle;      // Heavy Vehicle Num
    DWORD               dwTimeHeadway;      // Time Headway
    DWORD               dwSpaceHeadway;     // Space Headway
    float               fSpaceOccupyRation; // Space Occupy Ration
    float               fTimeOccupyRation;  // Time Occupy Ration
    BYTE                  byStoppingTimes; //average stopping times
    BYTE               byQueueLen;       // queue length
    BYTE                byFlag;          //upload flag 0-T1,1-T2
    BYTE                  byVehicelNum;         //vehicel number
    WORD                  wDelay;         //average delay
    BYTE                byRes1[6];               // res
    DWORD               dwNonMotor;      // nonmotor number
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE                byStart;          // Start Code
    BYTE                byCMD;         // CMD
    BYTE                byRes[2];
    WORD                wDeviceID;      // Device ID
    WORD                wDataLen;       //Data Len
    BYTE                byTotalLaneNum;  // Total Lane Num
    BYTE                byRes2[3];
    DWORD               dwDeviceIDEx;      // Device ID Extend
    BYTE                byRes1[8];
    NET_DVR_TIME_V30    struStartTime;    //Start Time
    DWORD                dwSamplePeriod;    //Sample Period
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;
    DWORD                 dwChan;//Channel No.
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// TPS Statistics Param
    DWORD           dwJsonLen;//Json alarm length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//Win64 and linux64 pointer to 8 bytes
    BYTE*                 pJsonBuf;
#else
    //Json alarm information pointer, whose Json corresponds to the EventNotificationAlert Json Block
    BYTE*                 pJsonBuf;
    BYTE                  byRes2[4];
#endif  
    BYTE                  byJsonInfoFlag;          //Whether there is Json transmission data, 0- none, 1- yes
    BYTE                  byBrokenNetHttp;         //Broken net HTTP(0 - not continuingly, 1 - continuingly)
    BYTE                  byRes[114];
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;


//Ctrl Type
#define     DPC_CORRECT                1    //Correct
#define     DPC_CORRECT_CANCEL         2    //Correct Cancel
#define     DPC_CROSS_DISPALY_OPEN     3    //Cross Dispaly Open
#define     DPC_CROSS_DISPALY_CLOSE    4    //Cross Dispaly Close
#define     DPC_POINT                  5    //Point
#define     DPC_UP                     6    //Up
#define     DPC_DOWN                   7    //Down
#define     DPC_RIGHT                  8    //Right
#define     DPC_LEFT                   9    //Left
#define     DPC_ALL_CORRECT            10   //All Correct
#define     DPC_SAVE                   11   //Save

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    WORD    wCtrlType;
    BYTE    byDPCMode;//Bad point correction mode: 0 - manual correction, 1 - automatic correction 
    BYTE    byRes;
    NET_VCA_POINT struPoint; /*Image plane coordinate input, normalized to 0-1*/
    BYTE    byRes1[64];
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

//FFC Manual Info
typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE   byRes[64];
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

//FFC Background Info
typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE   byRes[64];
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

//Storage Server Switch
typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    BYTE   byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER]; //Picure Switch
    BYTE   byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER];  //Add Info Switch
    BYTE   byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,
*LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;

//Force Stop Forensics
typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //display No.
    BYTE  bySubWinNo;  //subWindow No.
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //alarm time 
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //code source info 
    BYTE  *byAlarmPic; //alarm picture memory 
    DWORD dwAlarmPicSize; //alarm picture size , unit:BYTE
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //enable overlay alarm logo, 0-not, !0-overlay  
    BYTE byFlash;   // whether to flash, 0-not !0-flash
    WORD wFlashTime; //flash time, unit:second, value , get range from ability.  
    DWORD dwLogoX;  //logo X coordinate,decode window total size:1920*1920
    DWORD dwLogoY;  //logo Y coordinate
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //wheter to upload alarm picture , 0-not !0-upload
    BYTE byOverlayTargetInfo; //wheter to overlay target information, 0-not  !0-overlay 
    BYTE byOverlayRuleInfo; //wheter to overlay smart rule information , 0-not !0-overlay 
    BYTE byPicQuality;            //picture quality  0-best, 1-better, 2-soso
    /*picture size, get from the ability
    0-CIF,           1-QCIF,           2-D1,         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720),
    6-VGA,           7-XVGA,           8-HD900p,     9-HD1080,     10-2560*1920,
    11-1600*304,     12-2048*1536,     13-2448*2048,  14-2448*1200, 15-2448*800,
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576,
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(current use resolution)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //overlay logo configure  
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //picture configure 
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//picture name 
    BYTE   byUsed; //has used,0-no,1-yes 
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO, *LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD    dwSize;
    DWORD    dwOutputPicNo;  //picture No.
    BYTE    byEnable; //whether to show , 0-not show 1-show
    BYTE    byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//logo position,the range of the output size is 1920 * 1920
    BYTE    byFlash;  //whether to flash, 1-flash, 0-not flash
    BYTE    byTranslucent; //whether to translucent, 1-translucent, 0-not translucent
    BYTE    byRes2[2];                //
    DWORD    dwOutputPicWinNo; //output picture window No.(1 byte device No. + 1byte output No. + 2byte output picture No),vaild when get all
    BYTE    byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG, *LPNET_DVR_OUTPUT_PIC_CFG;

#define MAX_OSD_LEN                 64   //output OSD length 
typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //whether to display OSD, 0-not 1-display
    BYTE     byFontSize; //Font Size, 1-big, 2-middle, 3-small
    BYTE     byOSDColor; //OSD colosr set,0-default, 1-black,2-white,3-red,4-green,5-blue
    BYTE     byRes1[1];
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD content 
    NET_DVR_RECTCFG_EX struRect;//OSD position, the range of the output size is 1920 * 1920
    DWORD dwOsdWinNo; //output OSD window No.(1 byte device No. + 1byte output No. + 2byte output OSD No),vaild when get all
    BYTE     byRes2[32];                //
}NET_DVR_OUTPUT_OSD_CFG, *LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //display Channel, (1byte device No+1byte retain+2byte display channel No)
    BYTE  byRelateAudio; //relate audio channel 
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //relate audio subwindow No(1byte Wall No+1byte sub window NO+ 2byte Window No)
    DWORD dwChannel; //encode channel, vaild when get all
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD    dwSize;
    BYTE    bySensorChan[64];
    BYTE    byAlarmInChan[64];
    BYTE    byAlarmOutChan[64];
    BYTE    by485Chan[64];
    BYTE    byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;

typedef struct
{
    DWORD    dwSize;
    BYTE    byOutScale[8];
    BYTE    byRes[16];
}NET_DVR_OUT_SCALE_CFG, *LPNET_DVR_OUT_SCALE_CFG;


typedef    struct     tagNET_DVR_MONITOR_LOCATION_COND
{
    DWORD   dwSize;
    DWORD   dwChan;
    /*
    0 MPR Mode
    1 HVT Mode
    ...
    */
    BYTE    byRelateType;
    BYTE    byRes[63];
}NET_DVR_MONITOR_LOCATION_COND, *LPNET_DVR_MONITOR_LOCATION_COND;


typedef    struct     tagNET_DVR_MONITOR_LOCATION_CFG
{
    DWORD   dwSize;
    BYTE    byMonitoringSiteID[MAX_ID_LEN/*48*/];        //Montioring Site ID
    BYTE    byDeviceID[MAX_ID_LEN/*48*/];                //Device ID
    BYTE    byDirectionNo;     //Monitoring direction; 1-Up, 2-Down, 3-Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other direction
    BYTE    byRes1[3];
    BYTE    byMonitorInfo[MONITORSITE_ID_LEN/*48*/];          //Monitor Info
    BYTE    byRes[128];
}NET_DVR_MONITOR_LOCATION_CFG, *LPNET_DVR_MONITOR_LOCATION_CFG;


typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //Channel No.
    BYTE    byRes[64];
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;
    BYTE    byAlarmStatus;//Alarm Status
    BYTE    byRes[3];
    WORD    wAlarmDealyTime;//Alarm Dealy Time
    WORD    wDisAlarmDealyTime;//Alarm Dealy Delay Time
    BYTE    byRes1[64];
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{
    DWORD    dwSize;
    BYTE    byCommuMode;            //Communication Mode,0-compatibility mode,1-security mode
    BYTE    byRes1[2];
    BYTE    byWebAuthentication;    //web Authentication 0-digest,1-basic,2-digest/basic
    BYTE    byRtspAuthentication;   //rtsp Authentication 0-disable,1-basic,2-digest,3-digest/basic;
    BYTE    byTelnetServer;         //telnet Server 0-Close,1-Open
    BYTE    bySSHServer;            // SSH Server 0-Close,1-Open
    BYTE    byIllegalLoginLock;     //Login Lock, 0-Open(def),1-Close
    BYTE    byStreamEncryption;     //Stream Encryption 0-no Encryption,1-encryption
    BYTE    byAntiAttack;          //Whether open attack prevention function, 0 - is not enabled, 1 - to enable (socket delay 5 s closed) 
    BYTE    byRes[26];
}NET_DVR_SECURITY_CFG, *LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD    dwSize;
    BYTE     byRes[3];
    BYTE     byLockCount;      //0-lock function disable,the other value means locked count
    DWORD  dwLockTime;       //lock time
    BYTE     byRes1[128];
} NET_DVR_PASSWORD_MANAGE_CFG, *LPNET_DVR_PASSWORD_MANAGE_CFG;

typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD    dwSize;
    BYTE    byUnlockType;    //0-invalid , 1-Unlock by IP,2-Unlock all IP
    BYTE    byIPVersion;    //1-IPV4,2-IPV6,when byUnlockType is 1,this param is valid 
    BYTE    byRes1[2];
    NET_DVR_IPADDR struIPAddr;        //IP Address
    BYTE     byRes[64];
} NET_DVR_UNLOCK_INFO, *LPNET_DVR_UNLOCK_INFO;

typedef  struct  tagNET_DVR_LOCKED_INFO
{
    DWORD    dwSize;
    BYTE    byIPType;    //IP mode 0-invalid,1-IPV4,2-IPV6
    BYTE    byRes1[3];
    NET_DVR_IPADDR struIPAddress;
    BYTE    byRes[20];
} NET_DVR_LOCKED_INFO, *LPNET_DVR_LOCKED_INFO;


typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;


#define DIALPASSWD_LEN  32 

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;    /* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;    /* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;    /* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;


typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];        /* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];    /* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];    /* password, eg. "card" */
    BYTE byApn[NAME_LEN];        /* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;        /* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;    /* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

#define MAX_PHONE_NUM                32

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;        /* 0: disable; 1: enable 3g */
    BYTE byDialMethod;        /* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;    /* switch methold: 0: auto switch;1:3G first,2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* AlarmIn Dial; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;        /* auto off line when no connection exist,5~65535 Min */
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;
    BYTE byNetType;
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;


/* UIM card information */
typedef enum
{
    UIM_UNKNOWN = 0,
    UIM_VALID = 1,
    UIM_NOVALID = 4,
    UIM_ROAM = 11,
    UIM_NOEXIST = 255
}UIM_INFO;

/* real 3g mode */
typedef enum
{
    /* evdo */
    RMODE_CDMA1X = 12,
    RMODE_EVDO = 14,
    RMODE_CDMAHYBRID = 18,
    /* wcdma */
    RMODE_GSM = 21,
    RMODE_GPRS = 22,
    RMODE_EDGE = 23,
    RMODE_WCDMA = 24,
    RMODE_HSDPA = 25,
    RMODE_HSUPA = 26,
    RMODE_HSPA = 27,
    /* tdscdma */
    RMODE_TGSM = 31,
    RMODE_TGPRS = 32,
    RMODE_TEDGE = 33,
    RMODE_TDSCDMA = 34,
    RMODE_TDHSDPA = 35,
    RMODE_TDHSUPA = 36,
    RMODE_TDHSPA = 37
}REAL_MODE;

typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;        /* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;        /* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;            /* signal RSSI */
    DWORD dwDialStatus;        /* dial status */
    NET_DVR_IPADDR struLocalIp;    /* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;    /* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;    /* wireless networks netmask */
    NET_DVR_IPADDR struDns;        /* wireless networks DNS */
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

#define MAX_ALLOWLIST_NUM            8 
#define NET_SDK_MAX_ALLOWLIST_NUM_32 32

#define HARDDISKFULL_EXCEPTION      0x0    
#define HARDDISKERROR_EXCEPTION     0x1    
#define ETHERNETBROKEN_EXCEPTION    0x2    
#define IPADDRCONFLICT_EXCEPTION    0x3    
#define ILLEGALACCESS_EXCEPTION     0x4     
#define VI_EXCEPTION                0x5    
#define VS_MISMATCH_EXCEPTION       0x6     
#define VIDEOCABLELOSE_EXCEPTION    0x7    
#define AUDIOCABLELOSE_EXCEPTION    0x8    
#define ALARMIN_EXCEPTION           0x9   
#define MASKALARM_EXCEPTION         0xa    
#define MOTDET_EXCEPTION            0xb     
#define RECORDING_EXCEPTION         0xc    
#define WIRELESS_EXCEPTION          0xd   
#define PIR_EXCEPTION                0xe    
#define CALLHELP_EXCEPTION          0xf    

#define AUDIO_DETECTION_EXCEPTION              0x10   
#define SCENECHANGE_DETECTION_EXCEPTION        0x11   
#define DEFOCUS_DETECTION_EXCEPTION            0x12   
#define FACE_DETECTION_ENTRANCE_EXCEPTION      0x13    
#define LINE_DETECTION_ENTRANCE_EXCEPTION      0x14    
#define FIELD_DETECTION_ENTRANCE_EXCEPTION     0x15   
#define REGION_EXITING_EXCEPTION               0x16   
#define REGION_ENTRANCE_EXCEPTION              0x17  
#define LOITERING_EXCEPTION                    0x18   
#define GROUP_EXCEPTION                        0x19   
#define RAPIDMOVE_EXCEPTION                    0x1a   
#define PARKING_EXCEPTION                      0x1b    
#define UNATTENDEDBAGGAGE_EXCEPTION            0x1c    
#define ATTENDEDBAGGAGE_EXCEPTION              0x1d 
#define DATATRAFFIC_EXCESS                     0x1e    
#define VOLTAGEINSTABLE_EXCEPTION              0x1f    
#define ALL_EXCEPTION                          0xff    


#define PHONECFG_RECEIVE_SMS        0x0    
#define PHONECFG_SMS_CONTROL        0x1   
#define PHONECFG_CALL_CONTROL       0x2
#define PHONECFG_SMS_REBOOT         0x3    /*support sms reboot*/
#define PHONECFG_DOOR_CONTROL       0x4    /*support door control*/ 
#define PHONECFG_SMS_GET_DAIL_STATUS       0x5   /* support SMS to get dial-up status*/

typedef struct tagNET_DVR_PHONECFG
{
    BYTE byAllowList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32];
    BYTE byAlarmHandler[32];
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struAllowList[MAX_ALLOWLIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;

typedef struct tagNET_DVR_PHONECFG_V50
{
    BYTE byAllowList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32];
    BYTE byAlarmHandler[32];
    BYTE byAcsPassword[16];
    BYTE byName[NAME_LEN/*32*/];
    BYTE byRes[80];
} NET_DVR_PHONECFG_V50, *LPNET_DVR_PHONECFG_V50;

typedef struct tagNET_DVR_SMSRELATIVEPARAM_V50
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG_V50 struAllowList[NET_SDK_MAX_ALLOWLIST_NUM_32];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM_V50, *LPNET_DVR_SMSRELATIVEPARAM_V50;

#define NET_SDK_MONITOR_ID_LEN 64 //Monitor ID length

typedef struct tagNET_DVR_ACS_EVENT_COND
{
    DWORD dwSize;
    DWORD dwMajor;
    DWORD dwMinor;
    NET_DVR_TIME    struStartTime;
    NET_DVR_TIME    struEndTime;
    BYTE byCardNo[ACS_CARD_NO_LEN];
    BYTE byName[NAME_LEN];
    BYTE byPicEnable;
    BYTE byTimeType; //time type:0-device local time(default),1-UTC time
    BYTE byRes2[2];
    DWORD dwBeginSerialNo;
    DWORD dwEndSerialNo;
    DWORD dwIOTChannelNo; //IOT channel number, 0-invalid
    WORD  wInductiveEventType; //Inductive event types, 0 - invalid
    BYTE   bySearchType;      //Search mode: 0-reserve, 1-search by event source (channel number is non-video channel number at this time), 2-search by monitor point ID
    BYTE   byEventAttribute;
    char     szMonitorID[NET_SDK_MONITOR_ID_LEN/*64*/];          //monitor ID
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE byRes[140];
}NET_DVR_ACS_EVENT_COND, *LPNET_DVR_ACS_EVENT_COND;

typedef struct tagNET_DVR_ACS_EVENT_DETAIL
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN];
    BYTE byCardType;
    BYTE byAllowListNo;
    BYTE byReportChannel;
    BYTE byCardReaderKind;
    DWORD dwCardReaderNo;
    DWORD dwDoorNo;
    DWORD dwVerifyNo;
    DWORD dwAlarmInNo;
    DWORD dwAlarmOutNo;
    DWORD dwCaseSensorNo;
    DWORD dwRs485No;
    DWORD dwMultiCardGroupNo;
    WORD wAccessChannel;
    BYTE  byDeviceNo;
    BYTE  byDistractControlNo;
    DWORD dwEmployeeNo;
    WORD wLocalControllerID;
    BYTE  byInternetAccess;
    BYTE  byType;
    BYTE  byMACAddr[MACADDR_LEN];
    BYTE  bySwipeCardType;
    BYTE  byEventAttribute;
    DWORD dwSerialNo;
    BYTE  byChannelControllerID;
    BYTE  byChannelControllerLampID;
    BYTE  byChannelControllerIRAdaptorID;
    BYTE  byChannelControllerIREmitterID;
    DWORD dwRecordChannelNum; //record channels number
    char    *pRecordChannelData;//record channels
    BYTE  byUserType;
    BYTE  byCurrentVerifyMode;
    BYTE  byAttendanceStatus; //0-undefined, 1-checkIn, 2-checkOut, 3-breakOut, 4-breakIn, 5-overtimeIn, 6-overtimeOut
    BYTE  byStatusValue; //Attendance Status Value
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN];
    BYTE  byRes1;
    BYTE  byMask;
    BYTE  byThermometryUnit;
    BYTE  byIsAbnomalTemperature;
    float fCurrTemperature;
    NET_VCA_POINT struRegionCoordinates;
    BYTE  byRes[48];
}NET_DVR_ACS_EVENT_DETAIL, *LPNET_DVR_ACS_EVENT_DETAIL;

typedef struct tagNET_DVR_ACS_EVENT_CFG
{
    DWORD dwSize;
    DWORD dwMajor;
    DWORD dwMinor;
    NET_DVR_TIME struTime;
    BYTE    sNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR    struRemoteHostAddr;
    NET_DVR_ACS_EVENT_DETAIL struAcsEventInfo;
    DWORD dwPicDataLen;
    char    *pPicData;
    WORD  wInductiveEventType; //Inductive event types, 0 - invalid
    BYTE byTimeType;
    BYTE byRes1;
    DWORD dwQRCodeInfoLen;
    DWORD dwVisibleLightDataLen;
    DWORD dwThermalDataLen;
    char *pQRCodeInfo;
    char *pVisibleLightData;
    char *pThermalData;
    BYTE byRes[36];
}NET_DVR_ACS_EVENT_CFG, *LPNET_DVR_ACS_EVENT_CFG;

typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;            /* the index of sms */
    BYTE byStatus;            /* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;        /* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

#define    MAX_SMSCONTENT_LEN        140
typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;

//pin 
typedef enum
{
    CPIN_READY = 1,
    CPIN_PIN = 2,
    CPIN_PUK = 3,
    CPIN_PIN2 = 4,
    CPIN_PUK2 = 5
}PIN_READY;

typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;        /* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;    /* remain input PIN times */
    BYTE byPukTimes;    /* remain input PUK times */
    BYTE bEnableLock;    /* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;

typedef enum
{
    PIN_ENABLE = 1,
    PIN_DISABLE = 2,
    PIN_VERIFY = 3,
    PUK_VERIFY = 4,
    PIN_CHANGE = 5
}PIN_CMD;
#define MAX_PIN_LEN        12  
typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;        /* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];        /* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];    /* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;
/********************************SDK API definition*********************************/

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC enable 0-disable, 1-enable
    BYTE  byMode;              //auto limit wave mode, 0-fast, 1-common-,2-slow
    BYTE  byFilterQValue;      //Q value(Oct), 0-1/40,1-1/10, defalut:1/40 Oct
    BYTE  byStaticFilterNum;   //Filter Num, 0-12  
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG, *LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct _NET_DVR_DSP_PARAMETER_CFG
{
    BYTE  byFBCEnable;         //FBC enable 0-disable, 1-enable
    BYTE  byVolume;            //Input volume values range 0~255
    BYTE  byRes[22];
}NET_DVR_DSP_PARAMETER_CFG, *LPNET_DVR_DSP_PARAMETER_CFG;

typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;
    DWORD  dwHighPassFilter;         //High Pass Filter value:0-127
    DWORD  dwNoiseMargin;            //Noise Margin value:0-127
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //auto limit wave info, When the audio input type is wavein efficient   
    NET_DVR_DSP_PARAMETER_CFG  struDSPParameter;  //Digital signal processing chip parameters
    BYTE   byRes[40];
}NET_DVR_MIX_AUDIOIN_CFG, *LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;
    BYTE    byModulatorEnbale;  //Modulator Enbale
    BYTE    byPostFilter;       //Post Filter  0-close,1-open
    BYTE    byLimitPressure;    //Limit Pressure 0-close,1-open
    BYTE    byRes1;
    WORD    wModulatorValue;    //Modulator Value value:0-127
    WORD    wTriggerTime;       //Trigger Time, value:0-127
    WORD    wFreeTime;          //Free Time, value:0-127
    BYTE    byCompressThreshold; //Compress Threshold 0-1X,1-2X,2-4X,3-8X   
    BYTE    byCompressMode;     //Compress Mode 0-hard,1-soft
    BYTE    byCompressRate;    //Compress Rate 
    BYTE    byRecoveryGain;    //Recovery Gain 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //Output Gain; 0 ~100(Negative)
    BYTE    byOutputMute;      //Output mute, 0- close, 1- open
    int     iOutputGainEx;      //Output gain expansion, return positive for magnification, negative for reduction
    BYTE    bySoundQualityHanding;      //Sound quality processing, 0- close, 1- open
    BYTE    byRes[55];
}NET_DVR_MIX_AUDIOOUT_CFG, *LPNET_DVR_MIX_AUDIOOUT_CFG;

#define MAX_AUDIOOUT_PRO_TYPE                8    //Audio out process type
typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD    dwSize;
    WORD    wVolume[MAX_AUDIOOUT_PRO_TYPE];      //volume  0-127
    BYTE    byPhantomPowerSupply;    //user phantom power supply or not,0-invalid,1-no,2-yes
    BYTE    byEnableAEC;    //enable AEC or not, 0-disable,1-enable
    WORD    wTalkVolume;   
    BYTE    byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];    //enable FBC or not, 0-disable,1-enable
    WORD    wVolumeEx[MAX_AUDIOOUT_PRO_TYPE];      //volume extend  0-127
    BYTE    byRes[4];
}NET_DVR_VOLUME_CFG, *LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG
{
    DWORD       dwSize;
    BYTE         byResolution;     //resolution 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080, 5-3840*2160
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

//2014-12-03  T1Test state structure
typedef struct
{
    DWORD  dwSize;//structure size
    WORD   wPort;  //port
    //(Device through port control (port number of the device end is fixed, the upper not configured), start a separate socket connection, separate T1 test interactive content, go XML format)
    //0- close (close connection thread device, the release port), 1 open (separate from the internal device connection thread)
    BYTE   byPortState;
    BYTE   byRes[61];
}NET_DVR_T1TEST_PARAMCFG, *LPNET_DVR_T1TEST_PARAMCFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];
    WORD   wPort;
    BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO, *LPNET_DVR_ADDR_DOMAIN_INFO;

#define MAX_CENTERNUM_V40     6
//alarm host network config
typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD    dwSize;
    BYTE    byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];
    WORD    wAuxiliaryAlarmPort;
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40];
    BYTE    byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

//alarm linkage param config
typedef struct tagNET_DVR_ALARM_LINKAGE_PARAM
{
    DWORD    dwSize;
    WORD     wChanRec;                          //linkage REC NVR channel information
    BYTE     byRes1[2];
    WORD     wRecTime[MAX_LINKAGE_CHAN_NUM];    //the REC time of alarmed
    WORD     wChanPic;                          //linkage drag picturn NVR channel information
    BYTE     byRes2[2];
    BYTE     byPicNum[MAX_LINKAGE_CHAN_NUM];    //the screenshot number of alarmed
    BYTE     byTriggerEnabled[ALARMHOST_ALARMOUT_NUM];//Is the value linkaging trigger, 0-no,1-yes     
    BYTE     bySensorJointAlarmOut[ALARMHOST_ALARMOUT_NUM];//telemetering linkage trigger by type, bit0=1-limit 1,bit1=1-limit 2,bit2=1-limit 3,bit3=1-limit 4,bit4=1-error
    BYTE   	 byRes3[128];     	//reverse
}NET_DVR_ALARM_LINKAGE_PARAM, *LPNET_DVR_ALARM_LINKAGE_PARAM;


typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];

    /*country index
    0-The algorithms library does not support,1-CZ - Czech Republic,2-FRA - France,
    3-DE - Germany,4-E - Spain, 5-IT - Italy,6-NL - Netherlands,7-PL - Poland,8-SVK - Slovakia, 9-BY - Belorussia, 10-MDA - Moldova,11-RU - Russia,12-UA - Ukraine,
    169-Canada, 172-US, 227-Australia, 0xfe-Unrecognized
    */
    BYTE  byCountry;                   // country index
    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;
    NET_VCA_RECT       struVcaRect;
    DWORD              dwFaceScore;
    BYTE               byVcaRectOnly;   //VcaRectOnly:0-n; 1-y
    BYTE               byRes1[3];
    DWORD              dwPID;   //picture id
    DWORD              dwFaceSearchNum;//face search number
    NET_VCA_RECT       struMultiVcaRect[NET_DVR_MAX_FACE_SEARCH_NUM];// byVcaRectOnly=1
    BYTE                byRes[136];
    BYTE               *pImage;
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD              dwSearchType;
    BYTE   byHumanMisinfo;//0-false 1-true
    BYTE                byRes[251];
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef union tagNET_DVR_SMARTSEARCH_PIC_UNION
{
    BYTE                byLen[256];
    NET_DVR_VEHICLE_PARA     struVehiclePara; //Vehicle
    NET_VCA_HUMAN_FEATURE    struHumaFeature; //Huma Feature
    NET_DVR_FACE_PIC_DATA_INFO   struHumaPic;     //Huma Pic  
    NET_DVR_BEHAVIOUR_COND   struBehaviourCond;  //Behaviour      
}NET_DVR_SMARTSEARCH_PIC_UNION, *LPNET_DVR_SMARTSEARCH_PIC_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA
{
    DWORD                dwChanNo;
    DWORD                byStreamID[STREAM_ID_LEN];
    NET_DVR_TIME_EX         struStartTime;
    NET_DVR_TIME_EX         struEndTime;
    WORD                wSearchType;            //Search type   0-Vehicle ,1-Huma Feature  2-Huma Pic,3-Behaviour
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;
    BYTE   	    byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char cStartTimeDifferenceH;   
    char cStartTimeDifferenceM;   
    char cStopTimeDifferenceH;    
    char cStopTimeDifferenceM;    
    BYTE               byRes[59];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;
    NET_VCA_RECT   struVcaRect;
    BYTE           byRes2[236];
}NET_DVR_FACE_SUB_PIC_INFO, *LPNET_DVR_FACE_SUB_PIC_INFO;


typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT      struVcaRect;
    WORD         wPeopleNum;       //area number
    BYTE         byRes2[238];
}NET_DVR_BEHAVIOR_INFO, *LPNET_DVR_BEHAVIOR_INFO;

typedef union tagNET_DVR_PIC_FEATURE_UNION
{
    BYTE                         byLen[256];
    NET_DVR_PLATE_INFO              struPlateInfo;
    NET_DVR_FACE_SUB_PIC_INFO       struFaceSubInfo;
    NET_DVR_BEHAVIOR_INFO           struBehavior;
}NET_DVR_PIC_FEATURE_UNION, *LPNET_DVR_PIC_FEATURE_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];
    NET_DVR_TIME_EX     struTime;
    DWORD   dwFileSize;
    WORD    wPicType;
    BYTE    byRes1[2];
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;
    BYTE   	    byISO8601;  //0-cTimeDifferenceH&cTimeDifferenceM is invalid 1- TimeDifference is valid
    char cTimeDifferenceH;
    char cTimeDifferenceM;
    BYTE        byRes[29];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET;

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;
    BYTE  byRes[31];
}NET_DVR_T1TEST_SEND_DATA_BUZZER, *LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef union NET_DVR_T1TEST_DATA_UNION
{
    BYTE  byUnionLen[32];
    NET_DVR_T1TEST_SEND_DATA_BUZZER struBuzzer;
    NET_DVR_TIME_V30  struCurTime;
}NET_DVR_T1TEST_DATA_UNION, *LPNET_DVR_T1TEST_DATA_UNION;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;
    BYTE  byDataType;
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA, *LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG
{
    DWORD       dwSize;
    BYTE         byEnable;
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

#define MAX_LEN_256                     256 
#define MAX_GROUP_RECORD_NUM            10
typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize;
    DWORD  dwAreaID;
    DWORD  dwMonitorID;
    BYTE   byIsNeedGroup;
    BYTE   byRes[127];
}NET_DVR_AREA_MONITOR_COND, *LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;
    BYTE  byDelType;
    DWORD  dwAreaID;
    DWORD  dwMonitorID;
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND, *LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLOCKLIST_ALARM_COND
{
    DWORD       dwSize;
    BYTE        byType;
    BYTE        byRes1[3];
    DWORD       dwFaceID;
    DWORD       dwMaxSnapNum;
    BYTE        byRes[256];
}NET_DVR_BLOCKLIST_ALARM_COND, *LPNET_DVR_BLOCKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;
    DWORD        dwStorageID;
    BYTE        byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLOCKLIST_ALARM_RECORD
{
    DWORD          dwSize;
    DWORD            dwSnapFacePicID;
    DWORD            dwRegisterID;
    DWORD            dwGroupNo;
    BYTE            byRes[128];
}NET_DVR_BLOCKLIST_ALARM_RECORD, *LPNET_DVR_BLOCKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_INFO
{
    DWORD          dwSize;
    DWORD          dwGroupID;
    DWORD            dwGroupNo;
    BYTE            byGroupType;
    BYTE            byRes1;
    WORD            wThreshold;
    DWORD            dwListNum;
    BYTE            szGroupName[NAME_LEN];
    BYTE            szRemark[MAX_LEN_256];
    BYTE            byStorageAddr[MAX_DOMAIN_NAME];
    WORD            wStoragePort;
    BYTE            byRes[126];
}NET_DVR_BLOCKLIST_GROUP_INFO, *LPNET_DVR_BLOCKLIST_GROUP_INFO;


typedef struct tagNET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD
{
    DWORD          dwSize;
    DWORD            dwGroupRecordID;
    DWORD            dwGroupNo;
    DWORD            dwFaceDBID;
    DWORD            dwFaceRecordID;
    BYTE            byAlarmLevel;
    BYTE            byRes1[3];
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;
    BYTE            byRes[256];
}NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD, *LPNET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;
    DWORD            dwRecordID;
    BYTE            byRes[64];
}NET_DVR_BLOCKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLOCKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_RECORD_CFG
{
    DWORD          dwSize;
    DWORD            dwRecordNum;
    NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM];
    BYTE            byRes[256];
}NET_DVR_BLOCKLIST_GROUP_RECORD_CFG, *LPNET_DVR_BLOCKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_CFG
{
    DWORD          dwSize;
    DWORD            dwGroupNum;
    NET_DVR_BLOCKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM];
    BYTE            byRes[256];
}NET_DVR_BLOCKLIST_GROUP_CFG, *LPNET_DVR_BLOCKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_COND
{
    DWORD        dwSize;
    DWORD            dwGroupID;
    BYTE            byRes[64];
}NET_DVR_BLOCKLIST_GROUP_COND, *LPNET_DVR_BLOCKLIST_GROUP_COND;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM
{
    DWORD           dwSize;
    BYTE            byMouseEvent;
    BYTE            byRes1[3];
    NET_VCA_POINT   struPoint;
    BYTE            byRes[64];
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

//Radar Alarm Info
typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD        dwSize;
    DWORD        dwRadarTriggerTimeSecond;//Radar Trigger Time  ;Unit:s
    DWORD        dwRadarTriggerTimeMSecond;//Radar Trigger Time,Unit:ms
    DWORD        dwVedioTriggerTimeSecond;//Vedio Trigger Time ,Unit:s
    DWORD        dwVedioTriggerTimeMSecond;//Vedio Trigger Time ,Unit:ms
    DWORD        dwVedioRadarDiffTimeMSecond;//Vedio Radar Differ Time,Unit:ms
    DWORD        dwRadarSpeed;//Radar Speed
    BYTE         byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

/************************************ACS begin*********************************/
#define MAX_FINGER_PRINT_LEN            768  //max finger print len
typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card NO
    DWORD dwFingerPrintLen;     //fingerprint len
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //the card reader which finger print send to,according to the values,0-not send,1-send
    BYTE  byFingerPrintID;     //finger ID,[1,10]
    BYTE  byFingerType;       //finger type  0-normal,1-stress
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG, *LPNET_DVR_FINGER_PRINT_CFG;

#define ERROR_MSG_LEN      32 
typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //Fingerprint reader state, press the bytes, 0 - failure, 1 -, 2 - the fingerprint module is not online, 3 - try again or poor quality of fingerprint, 4 - memory is full, 5 - existing the fingerprints, 6 - existing the fingerprint ID, illegal fingerprint ID, 7-8 - don't need to configure the fingerprint module 
    BYTE  byFingerPrintID;     //finger ID,[1,10]
    BYTE  byFingerType;        //finger type  0-normal,1-stress
    BYTE  byTotalStatus;  //
    BYTE  byRes1;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //Issued false information, when the byCardReaderRecvStatus is 5, said existing fingerprint matching card number 
    DWORD dwCardReaderNo;  //Grain number card reader, can be used to return issued by mistake 
    BYTE  byRes[24];
}NET_DVR_FINGER_PRINT_STATUS, *LPNET_DVR_FINGER_PRINT_STATUS;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //which card reader to send,according to the values
    DWORD dwFingerPrintNum; //the number send or get. if get,0xffffffff means all
    BYTE  byFingerPrintID;     //finger ID,[1,10],   0xff means all
    BYTE  byCallbackMode;     //
    BYTE  byRes1[26];
}NET_DVR_FINGER_PRINT_INFO_COND, *LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_CFG_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card NO
    DWORD dwFingerPrintLen; 	//fingerprint len
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //the card reader which finger print send to,according to the values,0-not send,1-send
    BYTE  byFingerPrintID;     //finger ID,[1,10]
    BYTE  byFingerType;       //finger type  0-normal,1-stress,2-patrol,3-super,4-dismissing
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE  byLeaderFP[MAX_DOOR_NUM_256]; //leader finger print
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_CFG_V50, *LPNET_DVR_FINGER_PRINT_CFG_V50;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //Fingerprint reader state, press the bytes, 0 - failure, 1 -, 2 - the fingerprint module is not online, 3 - try again or poor quality of fingerprint, 4 - memory is full, 5 - existing the fingerprints, 6 - existing the fingerprint ID, illegal fingerprint ID, 7-8 - don't need to configure the fingerprint module, 10-card reader version low(not support employee No)
    BYTE  byFingerPrintID;     //finger print ID,[1,10]
    BYTE  byFingerType;       //finger type  0-normal,1-stress,2-patrol,3-super,4-dismissing
    BYTE  byTotalStatus;  //
    BYTE  byRecvStatus;    //recv status:0-success,1-finger no error,2-finger print type error,3-card no error,4-finger print not link employee no or card no,5-employee No not exist,6-finger print data len zero,7-illegal card reader No,8-illegal employee No
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //Issued false information, when the byCardReaderRecvStatus is 5, said existing fingerprint matching card number
    DWORD dwCardReaderNo;  //Grain number card reader, can be used to return issued by mistake
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE  byErrorEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //Issued false information, when the byCardReaderRecvStatus is 5, said existing fingerprint matching employee no
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_STATUS_V50, *LPNET_DVR_FINGER_PRINT_STATUS_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //which card reader to send,according to the values
    DWORD dwFingerPrintNum; //the number send or get. if get,0xffffffff means all
    BYTE  byFingerPrintID;     //finger print ID,[1,10],   0xff means all
    BYTE  byCallbackMode;     //
    BYTE  byRes2[2];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE  byRes1[128];
}NET_DVR_FINGER_PRINT_INFO_COND_V50, *LPNET_DVR_FINGER_PRINT_INFO_COND_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //be enable card reader,according to the values
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];        //finger print ID,according to the values,0-not delete,1-delete
    BYTE  byRes1[34];
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;
    BYTE  byClearAllCard;  //clear all card,0-delete by card,1-delete all card
    BYTE  byRes1[3];
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byRes[548];
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE
{
    BYTE   uLen[588];
    NET_DVR_FINGER_PRINT_BYCARD       struByCard;     //delete by card
    NET_DVR_FINGER_PRINT_BYREADER     struByReader;   //delete by reader
}NET_DVR_DEL_FINGER_PRINT_MODE,*LPNET_DVR_DEL_FINGER_PRINT_MODE;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //delete mode,0-delete by card,1-delete by reader
    BYTE  byRes1[3];
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //delete mode
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD_V50
{
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //be enable card reader,according to the values
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];      //finger ID,according to the values,0-not delete,1-delete
    BYTE  byRes1[2];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
}NET_DVR_FINGER_PRINT_BYCARD_V50, *LPNET_DVR_FINGER_PRINT_BYCARD_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER_V50
{
    DWORD dwCardReaderNo;
    BYTE  byClearAllCard;  //clear all card,0-delete by card(employee no),1-delete all card(employee no)
    BYTE  byRes1[3];
    BYTE  byCardNo[ACS_CARD_NO_LEN]; 
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE  byRes[516];
}NET_DVR_FINGER_PRINT_BYREADER_V50, *LPNET_DVR_FINGER_PRINT_BYREADER_V50;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE_V50
{
    BYTE   uLen[588];
    NET_DVR_FINGER_PRINT_BYCARD_V50       struByCard;     //delete by card(employee no)
    NET_DVR_FINGER_PRINT_BYREADER_V50     struByReader;   //delete by reader
}NET_DVR_DEL_FINGER_PRINT_MODE_V50, *LPNET_DVR_DEL_FINGER_PRINT_MODE_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL_V50
{
    DWORD dwSize;
    BYTE  byMode;          //delete mode,0-delete by card(employee no),1-delete by reader
    BYTE  byRes1[3];
    NET_DVR_DEL_FINGER_PRINT_MODE_V50 struProcessMode;  //delete mode
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_INFO_CTRL_V50, *LPNET_DVR_FINGER_PRINT_INFO_CTRL_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_STATUS_V50
{
    DWORD dwSize;
    DWORD dwCardReaderNo;
    BYTE  byStatus;
    BYTE  byRes[63];
}NET_DVR_FINGER_PRINT_INFO_STATUS_V50, *LPNET_DVR_FINGER_PRINT_INFO_STATUS_V50;

typedef enum _ACS_DEV_SUBEVENT_ENUM_
{
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,
    EVENT_ACS_NET_BROKEN,                   
    EVENT_ACS_NET_RESUME ,                  
    EVENT_ACS_LOW_BATTERY,                  
    EVENT_ACS_BATTERY_RESUME,
    EVENT_ACS_AC_OFF,
    EVENT_ACS_AC_RESUME,
    EVENT_ACS_SD_CARD_FULL,
    EVENT_ACS_LINKAGE_CAPTURE_PIC,
    EVENT_ACS_IMAGE_QUALITY_LOW,
    EVENT_ACS_FINGER_PRINT_QUALITY_LOW,
    EVENT_ACS_BATTERY_ELECTRIC_LOW,
    EVENT_ACS_BATTERY_ELECTRIC_RESUME,
    EVENT_ACS_FIRE_IMPORT_SHORT_CIRCUIT,
    EVENT_ACS_FIRE_IMPORT_BROKEN_CIRCUIT,
    EVENT_ACS_FIRE_IMPORT_RESUME,
    EVENT_ACS_MASTER_RS485_LOOPNODE_BROKEN,
    EVENT_ACS_MASTER_RS485_LOOPNODE_RESUME,
    EVENT_ACS_LOCAL_CONTROL_OFFLINE,
    EVENT_ACS_LOCAL_CONTROL_RESUME,
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN,
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME,
    EVENT_ACS_DISTRACT_CONTROLLER_ONLINE,
    EVENT_ACS_DISTRACT_CONTROLLER_OFFLINE,
    EVENT_ACS_FIRE_BUTTON_TRIGGER,
    EVENT_ACS_FIRE_BUTTON_RESUME,
    EVENT_ACS_MAINTENANCE_BUTTON_TRIGGER,
    EVENT_ACS_MAINTENANCE_BUTTON_RESUME,
    EVENT_ACS_EMERGENCY_BUTTON_TRIGGER,
    EVENT_ACS_EMERGENCY_BUTTON_RESUME,
    EVENT_ACS_RES,
    EVENT_ACS_SUBMARINEBACK_COMM_BREAK,
    EVENT_ACS_SUBMARINEBACK_COMM_RESUME,
    EVENT_ACS_REMOTE_ACTUAL_GUARD,
    EVENT_ACS_REMOTE_ACTUAL_UNGUARD,
    EVENT_ACS_MOTOR_SENSOR_EXCEPTION,
    EVENT_ACS_CAN_BUS_EXCEPTION,
    EVENT_ACS_CAN_BUS_RESUME,
    EVENT_ACS_GATE_TEMPERATURE_OVERRUN,
    EVENT_ACS_IR_EMITTER_EXCEPTION,
    EVENT_ACS_IR_EMITTER_RESUME,
    EVENT_ACS_LAMP_BOARD_COMM_EXCEPTION,
    EVENT_ACS_LAMP_BOARD_COMM_RESUME,
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_EXCEPTION,
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_RESUME,
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_ALARM,
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_RESUME,
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM,
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME,
    EVENT_ACS_STAY_EVENT,
    EVENT_ACS_LEGAL_EVENT_NEARLY_FULL,
    EVENT_ACS_FIRE_IMPORT_ALARM = 52,
    EVENT_ACS_NOMASK_ALARM,
    EVENT_ACS_FIREMATRIX_EVENT
}ACS_DEV_SUBEVENT_ENUM;

typedef enum _ACS_ALARM_SUBEVENT_ENUM_
{
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,    
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,       
    EVENT_ACS_ALARMIN_EXCEPTION,            
    EVENT_ACS_ALARMIN_RESUME,               
    EVENT_ACS_CASE_SENSOR_ALARM,            
    EVENT_ACS_CASE_SENSOR_RESUME            
}ACS_ALARM_SUBEVENT_ENUM;

typedef enum _ACS_DOOR_SUBEVENT_ENUM_
{
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN  = 0,        
    EVENT_ACS_LEADER_CARD_OPEN_END,             
    EVENT_ACS_ALWAYS_OPEN_BEGIN ,               
    EVENT_ACS_ALWAYS_OPEN_END,                  
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,               
    EVENT_ACS_ALWAYS_CLOSE_END,                 
    EVENT_ACS_LOCK_OPEN,                        
    EVENT_ACS_LOCK_CLOSE,                       
    EVENT_ACS_DOOR_BUTTON_PRESS,                
    EVENT_ACS_DOOR_BUTTON_RELEASE,              
    EVENT_ACS_DOOR_OPEN_NORMAL,                 
    EVENT_ACS_DOOR_CLOSE_NORMAL ,               
    EVENT_ACS_DOOR_OPEN_ABNORMAL,               
    EVENT_ACS_DOOR_OPEN_TIMEOUT,                
    EVENT_ACS_REMOTE_OPEN_DOOR,                 
    EVENT_ACS_REMOTE_CLOSE_DOOR,                
    EVENT_ACS_REMOTE_ALWAYS_OPEN,               
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,              
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,                   
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,              
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,            
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,           
    EVENT_ACS_MULTI_VERIFY_SUCCESS,                     
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,            
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,  
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,          
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,
    EVENT_ACS_REMOTE_CAPTURE_PIC,
    EVENT_ACS_DOORBELL_RINGING,
    EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM,
    EVENT_ACS_CALL_CENTER,
    EVENT_ACS_FIRSTCARD_AUTHORIZE_BEGIN,
    EVENT_ACS_FIRSTCARD_AUTHORIZE_END,
    EVENT_ACS_DOORLOCK_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_DOORLOCK_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_DOORLOCK_INPUT_EXCEPTION,
    EVENT_ACS_DOORCONTACT_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_DOORCONTACT_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_DOORCONTACT_INPUT_EXCEPTION,
    EVENT_ACS_OPENBUTTON_INPUT_SHORT_CIRCUIT,
    EVENT_ACS_OPENBUTTON_INPUT_BROKEN_CIRCUIT,
    EVENT_ACS_OPENBUTTON_INPUT_EXCEPTION,
    EVENT_ACS_DOORLOCK_OPEN_EXCEPTION,
    EVENT_ACS_DOORLOCK_OPEN_TIMEOUT,
    EVENT_ACS_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE,
    EVENT_ACS_CALL_LADDER_RELAY_BREAK,
    EVENT_ACS_CALL_LADDER_RELAY_CLOSE,
    EVENT_ACS_AUTO_KEY_RELAY_BREAK,
    EVENT_ACS_AUTO_KEY_RELAY_CLOSE,
    EVENT_ACS_KEY_CONTROL_RELAY_BREAK,
    EVENT_ACS_KEY_CONTROL_RELAY_CLOSE,
    EVENT_ACS_REMOTE_VISITOR_CALL_LADDER,
    EVENT_ACS_REMOTE_HOUSEHOLD_CALL_LADDER,
    EVENT_ACS_LEGAL_MESSAGE,
    EVENT_ACS_ILLEGAL_MESSAGE,
    EVENT_ACS_TRAILING,
    EVENT_ACS_REVERSE_ACCESS,
    EVENT_ACS_FORCE_ACCESS,
    EVENT_ACS_CLIMBING_OVER_GATE,
    EVENT_ACS_PASSING_TIMEOUT,
    EVENT_ACS_INTRUSION_ALARM,
    EVENT_ACS_FREE_GATE_PASS_NOT_AUTH,
    EVENT_ACS_DROP_ARM_BLOCK,
    EVENT_ACS_DROP_ARM_BLOCK_RESUME,
    EVENT_ACS_REMOTE_CONTROL_CLOSE_DOOR,
    EVENT_ACS_REMOTE_CONTROL_OPEN_DOOR,
    EVENT_ACS_REMOTE_CONTROL_ALWAYS_OPEN_DOOR
}ACS_DOOR_SUBEVENT_ENUM;

typedef enum _ACS_CARD_READER_SUBEVENT_ENUM_
{
    EVENT_ACS_STRESS_ALARM = 0,                            
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,
    EVENT_ACS_LEGAL_CARD_PASS,                          
    EVENT_ACS_CARD_AND_PSW_PASS,                        
    EVENT_ACS_CARD_AND_PSW_FAIL,                        
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,                     
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,               
    EVENT_ACS_CARD_NO_RIGHT,                            
    EVENT_ACS_CARD_INVALID_PERIOD,                      
    EVENT_ACS_CARD_OUT_OF_DATE,                         
    EVENT_ACS_INVALID_CARD,                             
    EVENT_ACS_ANTI_SNEAK_FAIL,                          
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,
    EVENT_ACS_FINGERPRINT_INEXISTENCE,
    EVENT_ACS_FACE_VERIFY_PASS,
    EVENT_ACS_FACE_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_PW_VERIFY_PASS,
    EVENT_ACS_FACE_AND_PW_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_PW_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_CARD_VERIFY_PASS,
    EVENT_ACS_FACE_AND_CARD_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_CARD_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_PASS,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_FAIL,
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_PASS,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT,
    EVENT_ACS_FACE_RECOGNIZE_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_PW_PASS,
    EVENT_ACS_EMPLOYEENO_AND_PW_FAIL,
    EVENT_ACS_EMPLOYEENO_AND_PW_TIMEOUT,
    EVENT_ACS_HUMAN_DETECT_FAIL,
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_PASS,
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_FAIL,
    EVENT_ACS_DOOR_OPEN_OR_DORMANT_FAIL,
    EVENT_ACS_AUTH_PLAN_DORMANT_FAIL,
    EVENT_ACS_CARD_ENCRYPT_VERIFY_FAIL,
    EVENT_ACS_SUBMARINEBACK_REPLY_FAIL,
    EVENT_ACS_PASSWORD_MISMATCH,
    EVENT_ACS_EMPLOYEE_NO_NOT_EXIST,
    EVENT_ACS_COMBINED_VERIFY_PASS,
    EVENT_ACS_COMBINED_VERIFY_TIMEOUT,
    EVENT_ACS_VERIFY_MODE_MISMATCH,
    EVENT_ACS_PSW_ERROR_OVER_TIMES,
    EVENT_ACS_PSW_VERIFY_PASS,
    EVENT_ACS_PSW_VERIFY_FAIL,
    EVENT_ACS_ORCODE_VERIFY_PASS,
    EVENT_ACS_ORCODE_VERIFY_FAIL,
    EVENT_ACS_HOUSEHOLDER_AUTHORIZE_PASS,
    EVENT_ACS_BLUETOOTH_VERIFY_PASS,
    EVENT_ACS_BLUETOOTH_VERIFY_FAIL,
    EVENT_ACS_INFORMAL_MIFARE_CARD_VERIFY_FAIL,
    EVENT_ACS_CPU_CARD_ENCRYPT_VERIFY_FAIL,
    EVENT_ACS_NFC_DISABLE_VERIFY_FAIL,
    EVENT_ACS_EM_CARD_RECOGNIZE_NOT_ENABLED,
    EVENT_ACS_M1_CARD_RECOGNIZE_NOT_ENABLED,
    EVENT_ACS_CPU_CARD_RECOGNIZE_NOT_ENABLED,
    EVENT_ACS_ID_CARD_RECOGNIZE_NOT_ENABLED,
    EVENT_ACS_CARD_SET_SECRET_KEY_FAIL,
    EVENT_ACS_DESFIRE_CARD_ENCRYPT_VERIFY_FAIL,  
    EVENT_ACS_DESFIRE_CARD_RECOGNIZE_NOT_ENABLED,
    EVENT_ACS_IRIS_VERIFY_PASS,
    EVENT_ACS_IRIS_VERIFY_FAIL,
    EVENT_ACS_IRIS_BIOASSAY_FAIL
}ACS_CARD_READER_SUBEVENT_ENUM;

typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //main event type,0-device,1-alarmin,2-door,3-card reader
    WORD          wSubEventType;                      //sub event type
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;

typedef  union tagNET_DVR_EVETN_CARD_LINKAGE_UNION
{
    BYTE                           byCardNo[ACS_CARD_NO_LEN];
    NET_DVR_EVENT_LINKAGE_INFO  struEventLinkage;
    BYTE                           byMACAddr[MACADDR_LEN];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN];
}NET_DVR_EVETN_CARD_LINKAGE_UNION,*LPNET_DVR_EVETN_CARD_LINKAGE_UNION;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD            dwSize;
    BYTE              byProMode;                          //linkage type,0-by event,1-by card
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //event source ID,when the main event is device ,it not use; when the main event is door ,it is the door No; when the main event is card reader ,it is the card reader No; when the main event is alarmin,it is the alarmin ID; 0xffffffff means all
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //linkage alarmout NO,according to the values,0-not linkage,1-linkage
    BYTE           byRes2[32];
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //whether linkage open door,according to the values,0-not linkage,1-linkage
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //whether linkage close door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //whether linkage normal open door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //whether linkage normal close door,according to the values,0-not linkage,1-linkage
    BYTE           byMainDevBuzzer;                    //whether linkage main device buzzer, 0-not linkage,1-linkage
    BYTE           byCapturePic;                    //whether linkage capture picture, 0-no, 1-yes
    BYTE           byRecordVideo;                   //whether linkage record video, 0-no, 1-yes
    BYTE           byRes3[29];
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //linkage reader buzzer,according to the values,0-not linkage,1-linkage
    BYTE           byRes[128];
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V50
{
    DWORD            dwSize;
    BYTE              byProMode;                          //linkage type,0-by event,1-by card, 2-by mac  
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //event source ID,when the main event is device ,it not use; when the main event is door ,it is the door No; when the main event is card reader ,it is the card reader No; when the main event is alarmin,it is the alarmin ID; 0xffffffff means all
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //Linkage mode parameters 
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //linkage alarmout NO,according to the values,0-not linkage,1-linkage
    BYTE           byRes2[32];
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //whether linkage open door,according to the values,0-not linkage,1-linkage
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //whether linkage close door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //whether linkage normal open door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //whether linkage normal close door,according to the values,0-not linkage,1-linkage
    BYTE           byMainDevBuzzer;                    //whether linkage main device buzzer, 0-not linkage,1-linkage
    BYTE           byCapturePic;                    //whether linkage capture picture, 0-no, 1-yes
    BYTE           byRecordVideo;                   //whether linkage record video, 0-no, 1-yes
    BYTE           byRes3[29];
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //linkage reader buzzer,according to the values,0-not linkage,1-linkage
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //Associated alarm output shut down, in bytes, 0-not linkage,1-linkage 
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //Associated slip protection, in bytes, 0-not linkage,1-linkage
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //Removal associated protection zones, in bytes, 0-not linkage,1-linkage
    BYTE           byRes[500];
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V50, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V51
{
    DWORD           dwSize;
    BYTE            byProMode;                          //linkage type,0-by event,1-by card,2-mac addr,3-employee no
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //event source ID,when the main event is device,it not use:when the main event is door,it is the door No:when the main event is card reader,it is the card reader No:when the main event is alarmin,it is the alarmin ID:0xffffffff means all
    NET_DVR_EVETN_CARD_LINKAGE_UNION   uLinkageInfo;  //Linkage mode parameters 
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //linkage alarmout NO,according to the value,0-not linkage,1-linkage
    BYTE           byRes2[32];
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //whether linkage open door,according to the values,0-not linkage,1-linkage
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //whether linkage close door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //whether linkage normal open door,according to the values,0-not linkage,1-linkage
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //whether linkage normal close door,according to the values,0-not linkage,1-linkage
    BYTE           byMainDevBuzzer;                    //whether linkage main device buzzer,0-not linkage,1-linkage
    BYTE           byCapturePic;                    //whether linkage capture picture, 0-no, 1-yes
    BYTE           byRecordVideo;                   //whether linkage record video, 0-no, 1-yes
    BYTE           byMainDevStopBuzzer;             //main dev stop buzzer, 0-not linkage, 1-linkage
    WORD           wAudioDisplayID;
    BYTE           byAudioDisplayMode;
    BYTE           byRes3[25];
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //linkage reader buzzer,according to the values,0-not linkage,1-linkage
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //Associated alarm output shut down,in bytes,0-not linkage,1-linkage 
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //Associated slip protection,in bytes,0-not linkage,1-linkage
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //Removal associated protection zones,in bytes, 0-not linkage,1-linkage
    BYTE           byReaderStopBuzzer[MAX_CARD_READER_NUM_512]; //whether linkage reader stop buzzer,in bytes, 0-not linkage,1-linkage
    BYTE           byRes[512];
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V51, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V51;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_COND
{
    DWORD dwSize;
    DWORD dwEventID; //Event ID 
    WORD wLocalControllerID; //On the controller serial number [1, 64]
    BYTE byRes[106];
}NET_DVR_EVENT_CARD_LINKAGE_COND, *LPNET_DVR_EVENT_CARD_LINKAGE_COND;

typedef struct tagNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;
    DWORD dwAudioID;      //audio ID
    BYTE  byRes[256];
}NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM, *LPNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM;

typedef struct tagNET_DVR_CLIENT_CALIBFILE_PARAM
{
    DWORD dwSize;
    DWORD dwFileLen;   //file length
    BYTE  byChannel;     //channel
    BYTE  byFileType;    //0-3200W calibration file ,1-800W calibration file
    BYTE  byRes[22];
}NET_DVR_CLIENT_CALIBFILE_PARAM, *LPNET_DVR_CLIENT_CALIBFILE_PARAM;

typedef struct tagNET_DVR_RATIOSTITCHING_PARAM
{
    DWORD  dwSize;
    DWORD  dwFileLen;    //file length
    BYTE   byChannel;    //channel
    BYTE   byRes[23];
}NET_DVR_RATIOSTITCHING_PARAM, *LPNET_DVR_RATIOSTITCHING_PARAM;

typedef struct tagNET_DVR_VIDEOWALL_MATERIAL_COND
{
    DWORD dwSize;
    BYTE byWallNo;   //videowall number, start from 1
    BYTE byWindowType;   //window type, 0-picture&text window, 1-subtitle window
    BYTE byFileType;   //file type, 0-picture
    BYTE byRes1;   
    DWORD dwWindowNo;	//window number, start from 1
    DWORD dwMaterialNo;	//material number, start from 1
    BYTE  byRes[32];
}NET_DVR_VIDEOWALL_MATERIAL_COND, *LPNET_DVR_VIDEOWALL_MATERIAL_COND;

typedef struct tagNET_DVR_CORRECT_TABLE_3200W_PARAM 
{
    DWORD dwSize;
    DWORD dwFileLen;     //file length
    BYTE  byChannel;     //channel
    BYTE  byFileType;    //0-3200W calibration file ,1-800W calibration file
    BYTE  byRes[22];
}NET_DVR_CORRECT_TABLE_3200W_PARAM, *LPNET_DVR_CORRECT_TABLE_3200W_PARAM;

typedef struct tagNET_DVR_FOUR_CAMERAS_PICTURES
{
    DWORD dwSize;
    DWORD dwFileLen;    //file length
    BYTE byChannel;     //channel
    BYTE byRes[23];
}NET_DVR_FOUR_CAMERAS_PICTURES, *LPNET_DVR_FOUR_CAMERAS_PICTURES;

typedef struct tagNET_DVR_DEVTYPE_CALIBFILE_PARAM
{
    DWORD  dwSize;
    DWORD  dwFileLen;     //file length
    BYTE   byChannel;     //channel
    BYTE   byFileType;    //0-3200W calibration file ,1-800W calibration file
    BYTE   byRes[22];
}NET_DVR_DEVTYPE_CALIBFILE_PARAM, *LPNET_DVR_DEVTYPE_CALIBFILE_PARAM;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;
    BYTE   byIsStartAddr; //whether start addr,0-no,1-yes
    BYTE   byHostNo;      //host NO,1-8
    BYTE   byRes[34];
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;
    BYTE  byRes[5];
    WORD wFollowUpCardReader; //the card reader in the anti sneak host
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //whether join anti aneak,1-join,0-not join
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //the follow sneak host info
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //start reader NO
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE         byEnable;             //whether join anti aneak,1-join,0-not join
    BYTE          byAntiSnealHostNo;
    WORD         wReaderID;
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //the follow sneak reader info
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD           dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];
    BYTE            byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD           dwSize;
    BYTE            byRS485Backup;  //whether use RS485,0-not use,1-use
    BYTE            byShowCapPic;    //whether show capture picture,0-no,1-yes
    BYTE            byShowCardNo;    //whether show card number,0-no,1-yes
    BYTE            byShowUserInfo;  //whether shou user info,0-no,1-yes
    BYTE            byOverlayUserInfo;//whether overlay user info,0-no,1-yes
    BYTE            byVoicePrompt;  //whether voice prompt,0-no,1-yes
    BYTE             byUploadCapPic;     //whether upload capture picture,0-no,1-yes
    BYTE             bySaveCapPic;   //whether save capture picture,0-no,1-yes
    BYTE            byInputCardNo;  //whether input card NO by key,0-no,1-yes
    BYTE            byEnableWifiDetect;  //whether enable wifi detect,0-no,1-yes
    BYTE            byEnable3G4G;  //3G,4G enable
    BYTE            byProtocol;
    BYTE byRes[500];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_PLATFORM_VERIFY_CFG
{
    DWORD       dwSize;
    DWORD        dwDoorNo; //Gate number 
    BYTE        byResultType; //rtification result type, 0: illegal, 1: legal 
    BYTE        byRes1[3];
    BYTE        byScreenDisplay[MAX_SCREEN_DISPLAY_LEN]; //LED display screen, used to display authentication information 
    BYTE        byRes[300];                  // Keep byte 
}NET_DVR_PLATFORM_VERIFY_CFG, *LPNET_DVR_PLATFORM_VERIFY_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN];
    BYTE byCardPassword[CARD_PASSWORD_LEN];
    DWORD dwErrorCode; //the error cade when get,0-success
    BYTE byCardValid; //whether card valid,used when delete card,0-invalid,1-valid
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_PERSON_STATISTICS_CFG
{
    DWORD dwSize;
    BYTE byEnableStatistics;  //Whether to open the number statistics, 0: don't open; 1: open; 
    BYTE byEnableOfflineStatistics;  //Whether open offline number statistics, 0: don't open; 1: open; 
    BYTE byCountSignalStatisticalStandard;
    BYTE byRes[605];
}NET_DVR_PERSON_STATISTICS_CFG, *LPNET_DVR_PERSON_STATISTICS_CFG;

typedef struct tagNET_DVR_ACS_SCREEN_DISPLAY_CFG
{
    DWORD dwSize;
    DWORD dwFontSize; // font size   
    DWORD dwRowSpacing; // line spacing, the unit: pixel; 
    DWORD dwColumnSpacing;// column spacing, the unit: pixel;  
    DWORD dwFirstRowPosition; // starting line position in which screen block, 0-0, 1:1/8:, 2-2/8, / 8, Deborah / 8, 5:5/8, the man / 8: and yet / 8; 
    BYTE byDegree; // character display orientation Angle, 0-0 degrees (normal), 1-90 (edge); 
    BYTE byScreenType;// screen type, 0 - DC48270RS043_01T, 1 - DC80480B070_03T;  
    BYTE byRes[306];
}NET_DVR_ACS_SCREEN_DISPLAY_CFG, *LPNET_DVR_ACS_SCREEN_DISPLAY_CFG;

typedef struct tagNET_DVR_GATE_TIME_CFG
{
    DWORD dwSize;
    DWORD dwHoldOnALarmTime;  //Continuation of alarm buzzer time, unit of ms 
    DWORD dwHoldOnGateOpenTime;  //Gate is received before the shutdown command to continue keeping open time, unit of ms 
    DWORD dwPostponeIntrusionAlarmTime;  //Delay trigger into cheating alarm, the unit of ms 
    DWORD dwNoLaneAccessTimeLimitTime;  //Channel received pass certification signal effectively, but no one to pass a timeout alarm time, unit s 
    DWORD dwSafetyZoneStayTime;  //Channel signal received effective passage certification, passengers stranded after arrive safety channel timeout alarm time, unit s 
    BYTE byIRTriggerTimeoutTime;  //IR trigger timeout time, the unit of s(0-255)
    BYTE byRes[299];
}NET_DVR_GATE_TIME_CFG, *LPNET_DVR_GATE_TIME_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //
    DWORD dwErrorCode; //the error cade when send,0-success
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;
/************************************ACS end*********************************/


/**********************Set vehicle two recognition tasks*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    char   sDataIndex[DATA_INDEX_LEN];//Data Index 
    WORD   wTaskNo;//Task No
    BYTE   byRes1[2];
    NET_VCA_RECT  struPlateRect;//Plate Rect
    char   sLicense[MAX_LICENSE_LEN/*16*/];//License
    DWORD  dwRecogOperate;//Recog Operate
    DWORD  dwDataUploadType; //Data Upload Type
    DWORD  dwPostID;//ID
    NET_DVR_TIME_V30 struPostTime;//post time
    DWORD  dwJsonLen; //Json data length
    BYTE	*pJsonBuffer;//Json data buffer
    BYTE   byRes[107];
    BYTE   byPicDataType;//Picture Data Type
    char   sPicDataPath[256]; //Picture Data Path
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;

typedef struct tagNET_DVR_VEHICLERECOG_TASK_RESULT
{
    DWORD  dwSize;
    // device data index
    char     sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[256];
}NET_DVR_VEHICLERECOG_TASK_RESULT, *LPNET_DVR_VEHICLERECOG_TASK_RESULT;
/**********************Set vehicle two recognition tasks*************************/

/**********************Get vehicle two recognition tasks*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    char   sDataIndex[DATA_INDEX_LEN];//Data Index 
    WORD   wTaskNo;//Task No
    BYTE   byTask;
    BYTE   byRes1;
    // device data index
    char   sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[60];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    char   sDataIndex[DATA_INDEX_LEN];//Data Index
    WORD   wTaskNo;//Task No
    WORD   wTaskProgress;//Task Progress
    BYTE   byTaskState;//Task State
    BYTE   byRes1[3];
    DWORD  dwRecogOperate;
    DWORD  dwPostID;
    NET_DVR_TIME_V30 struPostTime;
    DWORD  dwJsonLen; //Json data len(res)
    BYTE   *pJsonBuffer;//Json data buffer,(res)
    BYTE   byRes[104];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;
/**********************Get vehicle two recognition tasks*************************/

/**********************Upload a secondary vehicle identification data Begin*************************/
typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //struct
//Serial number and data (upload data NET_DVR_VEHICLE_RECOG_CFG corresponding fields in sDataIndex)
    char   sDataIndex[DATA_INDEX_LEN];
//Tasking number and (upload data  NET_DVR_VEHICLE_RECOG_CFG corresponding fields in wTaskNo)
    WORD  wTaskNo; 
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;// plate location
    char  sLicense[MAX_LICENSE_LEN/*16*/];//License plate number
    BYTE  byVehicleType;    //Vehicle type, the reference:VTR_RESULT
    BYTE  byColorDepth;     //Body color shades, dark reference 0-, 1- light-colored
    BYTE  byColor;         //Body color, reference:VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //Vehicle main brand
    BYTE  byVehicleSubLogoRecog; //Vehicle sub-brand
    BYTE  byPilotSafebelt;//0- represents the unknown, 1-not wearing a seatbelt , 2- seatbelt
    BYTE  byCopilotSafebelt;//0- represents the unknown, 1-not wearing a seatbelt , 2- seatbelt
    BYTE  byPilotSunVisor;//0- represents the unknown, do not open the visor 1-, 2- open visor
    BYTE  byCopilotSunVisor;//0- represents the unknown, do not open the visor 1-, 2- open visor
    BYTE  byVehicleModel;// Vehicle Model
    WORD  wVehicleLogoRecog;  //Vehicle main brand 
    BYTE  byRes1[251];
    // 0- to upload data directly; 1- cloud storage server URL URL original picture data into the data, images length becomes URL length
    BYTE  byDataType;
    /*
Upload picture type information:
 bit0- vehicle Figure: 0 - do not upload, 1- upload;
 bit1- license plate Figure: 0 - do not upload, 1- upload;
 bit2- face sub-graph (main drive): 0 - do not upload, 1- upload;
 bit3- face sub-graphs (co-pilot): 0 - do not upload, 1- upload;
 bit4- belt Recognition (main drive): 0 - do not upload, 1- upload;
 bit5- belt Recognition (copilot): 0 - do not upload, 1- upload;
    */
    DWORD  dwPicType; //0: No picture information;: Vehicle Figure;: license plate diagram;
    BYTE    *pVehicleBuffer;    //Vehicle picture data pointer
    DWORD  dwVehicleBufferLen ;// Vehicle picture data length
    BYTE    *pPlateBuffer;    //License plate picture data pointer
    DWORD  dwPlateBufferLen ;// License plate picture data length
    BYTE    *pPilotFaceBuffer;    //Face subgraph (main drive) picture data pointer
    DWORD  dwPilotFaceBufferLen ;// Face subgraph (main drive) picture data length
    BYTE    *pCopilotFaceBuffer;    //Face subgraph (copilot) picture data pointer
    DWORD  dwCopilotFaceBufferLen ;// Face subgraph (copilot) picture data length
    BYTE    *pPilotSafebeltBuffer;    //Seatbelt identification (primary drive) picture data pointer
    DWORD  dwPilotSafebeltBufferLen ;// Seatbelt identification (primary drive) picture data length
    BYTE    *pCopilotSafebeltBuffer;// Seatbelt Recognition (copilot) picture data pointer
    DWORD  dwCopilotSafebeltBufferLen ;// Seatbelt Recognition (copilot) picture data length
    NET_VCA_RECT  struVehicleRect ;//Vehicle Rect
    NET_VCA_RECT  struPilotRect ;//Pilot Rect
    NET_VCA_RECT  struCopilotRect ;//Copilot Rect
    BYTE    *pJsonBuffer;//Json data pointer
    DWORD   dwJsonBufferLen;// Json data length
    DWORD   dwPostID;//ID
    NET_DVR_TIME_V30 struPostTime;//post time
    BYTE    Res2[56];
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

/**********************Upload a secondary vehicle identification data End*************************/


/**********************video alarm host V2.0 begin*************************/

#define MAX_ZONE_LINKAGE_CHAN_NUM    4    /* zone linkage  max channel num*/

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD                    dwSize;
    BYTE                    byAddressType;    //0 - ipv4/ipv6,1 - domain
    BYTE                    byRes1;
    WORD                    wServerPort;//server port
    union
    {
        struct
        {
            BYTE             szDomain[MAX_DOMAIN_NAME];
            BYTE             byRes1[80];
        }struDomain;//server domain
        struct
        {
            NET_DVR_IPADDR   struIp;
        }struAddrIP;//ip address
    }unionServer;            
    WORD wInterval;    //alarm interval time,0-30s
    BYTE byRes[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE    byDDNSType;        //0 - invalid,1 - IPServer,2 - hiDDNS
    BYTE    byRes1;
    WORD    wDDNSPort;                        
    BYTE    byServerAddr[MAX_DOMAIN_NAME];    
    BYTE    byDevName[MAX_DOMAIN_NAME];        
    BYTE    byDevSerialNum[SERIALNO_LEN];        
    BYTE    byAddressType;    //0 - ipv4/ipv6,1 - domain
    BYTE    byRes2;
    WORD     wDevPort;
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                                    //domain
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                                    //IP address
    }unionDevAddr;//use IP address or domain according to byAddressType                
    BYTE      sUserName[NAME_LEN/*32*/];    
    BYTE    sPassword[PASSWD_LEN/*16*/];
    DWORD    dwChannel;    //linkaged channel
    BYTE    byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD    dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];
    BYTE    byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG
{
    BYTE    byDevSerialNo[SERIALNO_LEN];  
    DWORD    dwChannel;       
    BYTE    byRes[64];
}NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG, *LPNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG
{
    WORD    wZoneNo;
    BYTE    byRes1[2];
    NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG struSingleChanCfg[MAX_ZONE_LINKAGE_CHAN_NUM];
    BYTE    byRes2[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST_
{
    DWORD    dwSize;
    NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG struAssociatedChanCfg[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;    //screen id
    BYTE byOnOffLine;    //whether online,0-offline,1-online,when Screen is on offline, the other parameter has no mean. 
    BYTE byTempState;    //board temperature state, 0-normal, 1-exception
    BYTE byFanState;        //fan state, 0-close, 1-open
    BYTE byFanException;    //fan exception state, 0-no support, 1-normal, 2-exception
    BYTE byTemperature;    //board temperature, unit: .c
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

/**********************video alarm host V2.0 end*************************/


//Sensor Info Upload
typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //Sensor Name
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //Sensor Channel
    BYTE    byReboot; //0~ No Reboot,1~Reboot
    BYTE    byPowerSupply;// 0-No power supply,1-Power supply
    BYTE    byStatusType;//Device status:0:normal;1:abnormal;2:alarm
    BYTE    bySensorType;//SensorType;SENSOR_TYPE
    float      fVoltageValue;//Voltage Value
    float    fCurrentValue;//Current Value
    float   fActualValue;//Actual Value
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //Description
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

//Capture Upload
typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize; 
    NET_DVR_TIME_V30  struTime;
    DWORD    dwChannel;//Channel
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//Picture Len
    BYTE    *pBuffer;    //Picture Buffer
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;


//B10 V2.4 
typedef struct  //
{
    BYTE byPort;   //
    BYTE byMasterSlaveProperty;   //master slave property in port  1-master  2-slave
    BYTE byPortEthernetType;  //,1-fast port,2-gigabit port
    BYTE byRes[9]; 
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;
typedef struct  //
{
    DWORD   dwSize; 
    BYTE     byEnable;     //
    BYTE     byProtoType;  //1-optical transceiver network protocol(private),2-videoplatform network protocol(private),3-G8032 protocol(public)
    BYTE   byBandWidth;   //ring bandwidth,1-fast,2-gigabit
    BYTE     byRes1;        //
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //ring port
    BYTE      byRes2[60];    //
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;
typedef struct  //
{
    DWORD   dwSize;   
    BYTE     byStatus;              //ring status,1-normal 2-disconnect
    BYTE     byMasterSlaveProperty ; // 1-master  2-slave
    BYTE     byRes[62];            //
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//
    BYTE        byJoinSubSystem;// 
    BYTE        byJoinDispNum;// 
    BYTE        byJoinSubWindowNum;// 
    BYTE        byDecodeAbility;   //
    BYTE        byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

//Fire Detection Alarm
typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize; 
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Absolutely Time
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byPicTransType;        //Image data transmission mode: 0-binary; 1 - the url
    BYTE    byRes1;
    DWORD   dwPicDataLen;//Picture Date Len
    BYTE    *pBuffer;    //Picture Buffer
    NET_VCA_RECT struRect;
    NET_VCA_POINT struPoint;
    WORD    wFireMaxTemperature;
    WORD    wTargetDistance;
    BYTE    byStrategyType;
    BYTE    byAlarmSubType;
    BYTE    byPTZPosExEnable;
    BYTE    byRes2;
    NET_PTZ_INFO struPtzPosEx;
    DWORD   dwVisiblePicLen;
    BYTE    *pVisiblePicBuf;
    BYTE    *pSmokeBuf;
    WORD    wDevInfoIvmsChannelEx;  
    BYTE    byRes3;
    BYTE    byFireScanWaitMode;
    DWORD   dwVisibleChannel;
    BYTE    byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char    cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char    cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE    byRes[49];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

typedef struct tagNET_SDK_MANUALTHERM_BASICPARAM
{
    DWORD        dwSize;
    WORD         wDistance;//Distance (m) [0, 10000] 
    BYTE         byDistanceUnit;//0-m 1-feet 2-centimeter
    BYTE         byRes1[1]; //res
    float        fEmissivity;//emissivity 
    BYTE         byRes[64];
}NET_SDK_MANUALTHERM_BASICPARAM, *LPNET_SDK_MANUALTHERM_BASICPARAM;

typedef struct tagNET_SDK_FIRESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;
    BYTE      byEnabled;
    BYTE      byShieldZoom;
    BYTE      byMaskType;
    BYTE      byRegionType;
    BYTE      byShowEnabled;
    BYTE         byRes1[2];
    char           szMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON struRegion;
    BYTE         byRes[32];
}NET_SDK_FIRESHIELDMASK_REGION, *LPNET_SDK_FIRESHIELDMASK_REGION;

#define MAX_FIRESHIELDMASK_REGION 24
typedef struct tagNET_SDK_FIRESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;
    BYTE       byShieldAreaTransparency; 
    BYTE         byDisplayShieldAreaEnabled;//
    BYTE         byRes1[1]; //
    NET_SDK_FIRESHIELDMASK_REGION struMaskRegion[MAX_FIRESHIELDMASK_REGION/*24*/];
    BYTE         byRes[256];
}NET_SDK_FIRESHIELDMASK_CFG, *LPNET_SDK_FIRESHIELDMASK_CFG;

typedef struct tagNET_SDK_SMOKESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;
    BYTE      byEnabled;
    BYTE      byShieldZoom;
    BYTE      byMaskType;
    BYTE      byRegionType;
    BYTE      byShowEnabled;
    BYTE         byRes1[2];
    char           szMaskName[NAME_LEN/*32*/];
    NET_VCA_POLYGON struRegion;
    BYTE         byRes[32];
}NET_SDK_SMOKESHIELDMASK_REGION, *LPNET_SDK_SMOKESHIELDMASK_REGION;

#define MAX_SMOKESHIELDMASK_REGION 24
typedef struct tagNET_SDK_SMOKESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;
    BYTE      byShieldAreaTransparency; 
    BYTE         byDisplayShieldAreaEnabled;//
    BYTE         byRes1[1]; //
    NET_SDK_SMOKESHIELDMASK_REGION struMaskRegion[MAX_SMOKESHIELDMASK_REGION/*24*/];
    BYTE         byRes[256]; //
}NET_SDK_SMOKESHIELDMASK_CFG, *LPNET_SDK_SMOKESHIELDMASK_CFG;

typedef struct tagNET_SDK_AREASCAN_CFG
{
    DWORD        dwSize;
    BYTE        byScanState;
    BYTE         byRes[259];
}NET_SDK_AREASCAN_CFG, *LPNET_SDK_AREASCAN_CFG;

typedef struct tagNET_SDK_FIRESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    BYTE        byRegionID;
    BYTE         byRes[127];
}NET_SDK_FIRESHIELDMASK_COND, *LPNET_SDK_FIRESHIELDMASK_COND;

typedef struct tagNET_SDK_SMOKESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    BYTE        byRegionID;
    BYTE         byRes[127];
}NET_SDK_SMOKESHIELDMASK_COND, *LPNET_SDK_SMOKESHIELDMASK_COND;

//Fire Detection
typedef struct tagNET_DVR_SMOKEDETECTION_CFG
{
    BYTE    byEnable;//
    BYTE    bySensitivity; //1~100--50
    BYTE    byPatrolSensitivity; //1~100--50
    BYTE    byDoubleCheckSensitivity; //1~100--50
    BYTE    byRes[56];
}NET_DVR_SMOKEDETECTION_CFG, *LPNET_DVR_SMOKEDETECTION_CFG;

typedef    struct tagNET_DVR_ALARMSTRATEGY_PARAM
{
    BYTE   byStrategyType;
    BYTE   byRes[15];
}NET_DVR_ALARMSTRATEGY_PARAM, *LPNET_DVR_ALARMSTRATEGY_PARAM;

typedef    struct tagNET_DVR_FIREDETECTION_CFG
{
    DWORD    dwSize;
    BYTE    byEnabled;     //Enabled,0~Enable,1~disable
    BYTE    bySensitivity; //Sensitivity: 1~100 Default:5s
    BYTE    byFireComfirmTime;//Time : 0-120s  Default:5s
    BYTE    byFireRegionOverlay;//Fire Region Overlay.
    BYTE    byDetectionMode;
    BYTE    byFireFocusMode;
    BYTE    byFireZoomMode;   //Fire Zoom Mode
    BYTE    byFirezoomLevel; //Fire zoom Level
    BYTE    bySmokeFireEnabled;
    BYTE    byFireManualWaitEnabled;// Fire Manual Wait Enabled
    BYTE    byCancelRepeatedAlarmEnabled;//  
    BYTE    byApplicationSceneMode;// 
    DWORD   dwInstallationHeight;// 
    BYTE    byFireSourceDetection;// 0-dynamicFire 1-smokingMode
	BYTE    bySmokeAuxiliaryDetectionEnabled;//Smoke Auxiliary Judgment Enables Enabling, Detection Mode is Effective when Secondary Judgment 0-no 1-yes
    BYTE    byverificationSensitivity;  //Quadratic confirmation sensitivity, range 1-100s, default 50s
    BYTE	byFireAlgorithmMode; //Firepoint algorithm mode, 0:invalid, 1:pattern recognition, 2: machine learning
    BYTE    byAgriculturalMachineryFilterEnabled;  //Agricultural Machinery Filter Module Enabled, 0:Not Enabled, 1:Enabled
    BYTE    byWaterReflectionEnabled;  //Surface Sunlight Reflector Module Enabled, 0:Not Enabled, 1:Enabled
    BYTE    byPatrolSensitivity;  //Cruise detection sensitivity (for fire detection), range 1-100s, default 50s
    BYTE    byRes[33];
    NET_DVR_ALARMSTRATEGY_PARAM struAlarmStrategy;
    NET_DVR_SMOKEDETECTION_CFG struSmokeCfg;
}NET_DVR_FIREDETECTION_CFG,*LPNET_DVR_FIREDETECTION_CFG;

typedef  struct tagNET_DVR_THERMALPOWER_PARAM
{
    DWORD   dwSize;
    BYTE    byPowerSwitch;
    BYTE    byRes[123];
}NET_DVR_THERMALPOWER_PARAM, *LPNET_DVR_THERMALPOWER_PARAM;

typedef  struct tagNET_DVR_PTZABSOLUTEEX_CFG
{
    DWORD            dwSize;
    NET_PTZ_INFO     struPTZCtrl;
    DWORD            dwFocalLen;
    float            fHorizontalSpeed;//Horizontal Speed:0.01-1000.00
    float            fVerticalSpeed;//Vertical Speed:0.01-1000.00
    BYTE             byZoomType;// Zoom Type;0~ absoluteZoom,1~ focalLen
    BYTE             byRes[123];
}NET_DVR_PTZABSOLUTEEX_CFG, *LPNET_DVR_PTZABSOLUTEEX_CFG;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    BYTE    bySubSystemType; 
    BYTE    byConnectStatus;
    BYTE    byMatrixNum;
    BYTE    bySubSystemNum;
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE    byBindStatus;
    BYTE    bySlotNum ;
    BYTE    byUsedTrunk;
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;


#define  MAX_OPTICALFIBER_NUM  16
// typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
// {
//     BYTE  bySubSystemType;
//     BYTE  byChanNum;
//     BYTE  byStartChan;
//     BYTE  bySlotNum ; 
//     BYTE  byRes1[4];
//     union
//     {
//         BYTE byRes[200];        
//         struct
//         {
//             BYTE byDecode;       
//             BYTE byNeedPreAllocDec; 
//             BYTE byVACType;  
//             BYTE byRes[197];
//         }struVACSystemAbility;
//         struct
//         {
//             BYTE  byVGANums;
//             BYTE  byBNCNums;
//             BYTE  byHDMINums;
//             BYTE  byDVINums;
//             BYTE  byLayerNums ;
//             BYTE  bySpartan;
//             BYTE  byDecType; 
//             BYTE  byOutputSwitch;
//             BYTE  bySDINums;
//             BYTE  byRes1[38];               
//             BYTE  byDecoderType ;
//             BYTE  byRes2[152];
//         }struDecoderSystemAbility;
//         struct
//         {
//             BYTE  byCoderType;
//             BYTE  byOptical;
//             BYTE  byOpticalSubChan;             
//             BYTE  bySupportAVSeparate;
//             BYTE  byRes[196];
//         }struCoderSystemAbility;
//         struct
//         {
//             WORD    wTrunkAbility;
//             BYTE    byOpticalFiberNum;
//             BYTE    byRes[197];
//         }struInputSystemAbility;
//         struct
//         {
//             WORD    wTrunkAbility;
//             BYTE    byOpticalFiberNum;
//             BYTE    byRes[197];
//         }struOutputSystemAbility;
//         struct
//         {
//             BYTE    by485Num;
//             BYTE    bySlotNum;
//             BYTE    byRes[198];
//         }struCodeSpitterSystemAbility;
//         struct
//         {
//             WORD    wAlarmInNums;
//             WORD    wAlarmOutNums;
//             BYTE  byAlarmBoxEnable[4][8];
//             BYTE  bySupportContact; 
//             BYTE  byRes[163];
//         }struAlarmHostSystemAbility;
//         struct
//         {
//             BYTE  byOpticalFiberNum;
//             BYTE  byRes1[3];
//             WORD    wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
//             BYTE  byRes2[164];
//         }struInOutputSystemAbility;
//         struct
//         {
//             BYTE  bySupportRingProtocol;   
//             BYTE  bySupportRingNums; 
//             BYTE  bySupportPortNums;  
//             BYTE  byRes[1]; 
//             DWORD dwPortSupportRingProto; 
//             BYTE  byRes2[192];
//         } struFiberSwitchSystemAbility;    
//     }struAbility;
// }NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;
    BYTE    byDecodeSubSystemNums;
    BYTE    bySupportNat;
    BYTE    byInputSubSystemNums;
    BYTE    byOutputSubSystemNums;
    BYTE    byCodeSpitterSubSystemNums;
    BYTE    byAlarmHostSubSystemNums;
    BYTE    bySupportBigScreenNum;
    BYTE    byVCASubSystemNums;
    BYTE    byV6SubSystemNums;
    BYTE    byV6DecoderSubSystemNums;
    BYTE    bySupportBigScreenX;
    BYTE    bySupportBigScreenY;
    BYTE    bySupportSceneNums;
    BYTE    byVcaSupportChanMode;
    BYTE    bySupportScreenNums;
    BYTE    bySupportLayerNums;
    BYTE    byNotSupportPreview;
    BYTE    byNotSupportStorage;
    BYTE    byUploadLogoMode;
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE    by485Nums;
    BYTE    by232Nums;
    BYTE    bySerieStartChan;
    BYTE    byScreenMode;
    BYTE    byDevVersion;
    BYTE    bySupportBaseMapNums;
    WORD    wBaseLengthX;
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;      
    BYTE    bySupportPreAllocDec;   
    BYTE    bySupportDecAutoManage; 
    BYTE    byTranDevSubSystemNums; 
    BYTE    byFiberSwitchNums;  
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

#define MAX_MASK_AREA_NUM                   8   //mask area num

typedef struct tagNET_DVR_AREA_MASK_CFG   
{
    DWORD  dwSize;   
    BYTE   byEnable;//enable mask   0-enable 1-yes
    BYTE   byMaskThick;  //0- Thin code, 1- code, 2- thick code, thin code block size is 8*8, in the code 16*16, thick 32*32 code.  
    BYTE   byAutoMask;//Whether automatic mosaics are enabled 0- no, 1- yes
    BYTE   byRes1;
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM]; 
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_RESOLUTION_SWITCH
{
    DWORD            dwSize;
    BYTE             byResolutionType;//0-all,1-20:9,2-20:6,3-originalStream
    BYTE             byRes[127];
}NET_DVR_RESOLUTION_SWITCH, *LPNET_DVR_RESOLUTION_SWITCH;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG   
{
    DWORD  dwSize;   
    BYTE   byEnable; 
    char   byBassValue;   //High bass value, range of -12-12 value is large sound more fine, the smaller the contrary, 0- said the constant sound
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //WiFi mode DHCP range configuration
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;  
    NET_DVR_IPADDR   struEndAddr;  
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;


typedef struct tagNET_DVR_WIFI_CLIENT_INFO
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;  
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //The connection speed   unit:KB
    BYTE        byRSSIValue;   //The received signal strength, the value is negative, transmission without assignment, the range of 0~-110dbm, the greater the value, the stronger the signal representative
    BYTE        byRes1;        
    WORD        wBandwidth;     //band width  unitKB 
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG 
{
    DWORD       dwSize;               
    DWORD       dwChannel;            
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;


//Indoor Device ID
typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //Floor No.
    WORD  wRoomNumber;    //Room No.
    WORD  wDevIndex;      //Device Index, 0-10
    BYTE  byRes[122];      
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

//Outdoor Device ID
typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //period[0,9]
    WORD wBuildingNumber; //Building No.
    WORD wUnitNumber;  //Unit No.
    SHORT wFloorNumber;  //Floor No.
    WORD wDevIndex;     // Device Index, Start From 0
    BYTE byRes[118]; 
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

//Outdoor Fence Device ID
typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //period[0,9]
    WORD wDevIndex;  //Device Index ,Start From 0
    BYTE byRes[124];  
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

//manage Uint Device ID
typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //period[0,9]
    WORD wDevIndex;  //Device Index ,Start From 0
    BYTE byRes[124];  
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;

 typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION
{   
    BYTE byLen[128] ;  
    NET_DVR_INDOOR_UNIT_DEVICEID struIndoorUnit;   //Indoor 
    NET_DVR_OUTDOOR_UNIT_DEVICEID struOutdoorUnit; //Outdoor
    NET_DVR_MANAGE_UNIT_DEVICEID struManageUnit; //manage unit 
    NET_DVR_OUTDOOR_FENCE_DEVICEID struFenceUnit; //outdoor fence
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struVillaOutdoorUnit;  //villa out door unit
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struAgainConfirmUnit;  //again confirm unit
}NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;

 
typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{   
    DWORD dwSize;  
    BYTE byUnitType;   //Device Type, 1-Outdoor, 2-manage,4-outdoor fence
    BYTE byIsAutoReg;  //auto register, 0-no, 1-yes
    BYTE byRes1[2];     
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit;  
    BYTE byRes2[128];  
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;


typedef enum tagPRIVILEGE_PASSWORD_TYPE_ENUM
{    
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1,         //engineering 
    ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2,         //set up alarm
    ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK  = 3, //house holder unlock
    ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING  = 4,      //anti-hijacking
    ENUM_PRIVILEGE_PASSWORD_PUBLIC1 = 5, //public 1
    ENUM_PRIVILEGE_PASSWORD_PUBLIC2 = 6, //public 2
    ENUM_PRIVILEGE_PASSWORD_PUBLIC3 = 7, //public 3
    ENUM_PRIVILEGE_PASSWORD_SENDCARD = 8 //send card password
}PRIVILEGE_PASSWORD_TYPE_ENUM;
 
typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{   
    DWORD  dwSize; 
    BYTE   byPwdType;                     // PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];     
    BYTE   byOldPassword[PASSWD_LEN];   //old password
    BYTE   byNewPassword[PASSWD_LEN];   //new password
    BYTE   byRes2[128]; 
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;


 
typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;     //Max Monitoring Time, [10,60]s
    DWORD dwMaxRingTime;         //Max Ring Time [15,60]s
    DWORD dwCallForwardingTime; //call forwarding time,[0,20]s
    DWORD dwRingDurationTime;   //ring duration time[30,60]s
    BYTE  byRes[112];     
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime;     //Max Message Time [30,60]s
    DWORD dwMaxTalkTime;         //Max Talk Time,[90,120]s
    BYTE  byRes[120];             
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;


typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //Max Monitoring Time, [10,60]s
    DWORD dwMaxRingTime;        //Max Ring Time [15,60]s
    DWORD dwMaxTalkTime;        //Max Talk Time,[90,120]s
    BYTE  byRes[116];           
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;

 
typedef union tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION
{   
    BYTE byLen[128];  
    NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG struIndoorUnit;  
    NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG struOutdoorUnit; //outdoor/out fence
    NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG struManageUnit; //manage Unit
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;

 
typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{   
    DWORD dwSize; 
    BYTE byUnitType; //Device Type, 1-Outdoor, 2-manage, 3-Indoor,4-outdoor fence
    BYTE byRes1[3];   
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit;  
    BYTE byRes2[128];  
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;


typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit;  
    NET_DVR_IPADDR struManageUnit;   
    NET_DVR_IPADDR struSIPServer;      
    NET_DVR_IPADDR struAgainUnit;   
    BYTE                 byOutDoorType;          //The main entrance Unit type, 0 retention, 1- unit door Unit, 2- villa door Unit
    BYTE              byOutInConnectMode;  //connect mode of outdoor device and indoor device:1-in the same lan,2-in different lan;
    BYTE              byIndoorConnectMode;  //connect mode of indoor devices:1-wireless,2-wired;
    BYTE            byRes1;
    NET_DVR_IPADDR  struIndoorUnit;
    BYTE  byManageCenterID[32];
    BYTE           byRes[268];
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;

 
typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{   
    NET_DVR_IPADDR struMainOutdoorUnit;  
    NET_DVR_IPADDR struManageUnit;  
    NET_DVR_IPADDR struSIPServer;      
    BYTE           byManageCenterID[32];
    BYTE           byRes[560];
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;

 
typedef struct tagNET_DVR_AGAIN_RELATEDEV
{   
    NET_DVR_IPADDR   struSIPServer;       //SIP IP
    NET_DVR_IPADDR   struCenterAddr;      //center IP
    WORD             wCenterPort;         //Center Port
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //indoor device IP
    NET_DVR_IPADDR struAgainAddr; //major again unit(minor again unit would set)
    BYTE             byRes[444];
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;

typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP server IP
    BYTE   byRes[880];       
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;


 
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION
{   
    DWORD dwRes[256] ;  
    NET_DVR_INDOOR_UNIT_RELATEDEV struIndoorUnit;       //indoor uint 
    NET_DVR_OUTDOOR_UNIT_RELATEDEV struMainOutdoorUnit; //outdoor/out fence
    NET_DVR_MANAGE_UNIT_RELATEDEV struManageUnit;           //manage Unit
    NET_DVR_OUTDOOR_UNIT_RELATEDEV  struVillaUnit;      //Villa Unit
  NET_DVR_AGAIN_RELATEDEV         struAgainUnit;      //again Unit
}NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;

 
typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{   
    DWORD dwSize;     
    BYTE byUnitType;                 //Device Type, 1-Outdoor, 2-manage, 3-Indoor,4-outdoor fence
    BYTE byRes1[3];      
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit;  
    BYTE byRes2[128];  
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_PANORAMIC_LINKAGE
{
    DWORD   dwSize;
    DWORD   dwChannel;
    BYTE  byType;
    BYTE  byRes1[3];
    BYTE        byMACAddr[MACADDR_LEN];
    BYTE      byRes2[2];
    NET_DVR_IPADDR   struDevIP;
    DWORD    dwPicLen;
    char      *pPicBuff; 
    BYTE       byRes[128];
}NET_DVR_PANORAMIC_LINKAGE, *LPNET_DVR_PANORAMIC_LINKAGE;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize;                     
    DWORD dwGatewayIndex;             //Gateway Index, Start From 1
    BYTE   byCommand; //command,0-close door 1-open door 2-always open 3-resume
    BYTE     byLockType; //lock type,0-normal,1-smart lock
    WORD    wLockID; //lock ID
    BYTE   byControlSrc[NAME_LEN];
    BYTE  byControlType; //open door type,1-monitor,2-calling
    BYTE  byRes3[3];
    BYTE  byPassword[PASSWD_LEN];       //password,need byLockType=1
    BYTE  byRes2[108];  
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;


 
typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData;      
    DWORD dwPicDataLen;  
    BYTE   byRes[32];  
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;

 
typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize;  
    NET_DVR_TIME_EX struTime;   //notice time
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN];     //Notice Number
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];        //Notice Theme
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN];   //Notice Detail
    BYTE   byLevel;                                 //level, 1-Advertising information; 2- property information; 3- alarm information
    BYTE   byPicNum;  
    BYTE   byRes1[2];         
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM];    
    BYTE   byRes2[128];     
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;

    
typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize;     
    BYTE   byPassword[PASSWD_LEN];     
    BYTE   byRes[128];     
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;

    
typedef enum tagUNLOCK_TYPE_ENUM
{    
    ENUM_UNLOCK_PASSWORD = 1,     //password unlock
    ENUM_UNLOCK_HIJACKING  = 2, //hijacking unlock
    ENUM_UNLOCK_CARD = 3,         //card unlock
    ENUM_UNLOCK_HOUSEHOLDER  = 4,     //house holder unlock
    ENUM_UNLOCK_CENTER_PLATFORM = 5, //Center unlock
    ENUM_UNLOCK_BLUETOOTH = 6, //bluetooth unlock
    ENUM_UNLOCK_QR_CODE = 7,   //QR code unlock
    ENUM_UNLOCK_FACE = 8,           //face unlock
    ENUM_UNLOCK_FINGERPRINT = 9,     //fingerprint unlock
    ENUM_UNLOCK_DYNAMIC_CODE = 10      //dynamic code unlock
}UNLOCK_TYPE_ENUM;


 
// typedef enum tagALARM_ZONE_TYPE_ENUM
// {    
//     ENUM_ALARM_ZONE_SMOKE = 1,         //Smoke
//     ENUM_ALARM_ZONE_GAS  = 2,          //GAS
//     ENUM_ALARM_ZONE_INFRARED = 3,     //Infrared
//     ENUM_ALARM_ZONE_MAGNETIC  = 4,     //magnetic
//     ENUM_ALARM_ZONE_MANUAL = 5         //manual
// }ALARM_ZONE_TYPE_ENUM;

 
typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType;          
    BYTE   byRes1[3];     
    BYTE   byControlSrc[NAME_LEN]; //Control Src, Credit card unlocking card number, bluetooth unlocking ezviz app account, QR code unlocking visitor phone number, in other cases as the equipment number
    DWORD  dwPicDataLen; 
    BYTE*  pImage; 
    DWORD  dwCardUserID; 
    SHORT  nFloorNumber;//valid when credit card unlocking
    WORD   wRoomNumber; //valid when credit card unlocking
    WORD   wLockID;
    BYTE   byRes2[2];
    BYTE   byLockName[LOCK_NAME_LEN];
    BYTE   byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //employee no
    BYTE   byMask; //0-reserved 1-unknow 2-no mask 3-mask
    BYTE   byRes[135];
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;


typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //Notice Number
    BYTE   byRes[224]; 
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;

typedef struct tagNET_DVR_AUTH_INFO    //not used
{
    BYTE   byAuthResult; //auth result:0-invalid,1-auth success,2-auth failed
    BYTE   byAuthType; //auth type:0-invalid,1-finger print,2-face
    BYTE   byRes1[2];
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //card no
    DWORD dwPicDataLen;
    BYTE*  pImage;
    BYTE   byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN/*32*/]; 
    BYTE   byRes[180];  //
}NET_DVR_AUTH_INFO, *LPNET_DVR_AUTH_INFO;

typedef struct tagNET_DVR_UPLOAD_PLATE_INFO
{
    char sLicense[MAX_LICENSE_LEN];      //license plate
    BYTE   byColor;                      //license color, reference VCA_PLATE_COLOR
    BYTE   byRes[239];
}NET_DVR_UPLOAD_PLATE_INFO, *LPNET_DVR_UPLOAD_PLATE_INFO;


typedef struct tagNET_DVR_SEND_CARD_INFO
{
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //card NO.
    BYTE   byRes[224];  //reserved
} NET_DVR_SEND_CARD_INFO, *LPNET_DVR_SEND_CARD_INFO;

//magnetic door status
typedef struct tagNET_DVR_MAGNETIC_DOOR_STATUS
{
    BYTE   byMagneticDoorStatus; //status 1-open 2-close
    BYTE   byRes[255];  //
} NET_DVR_MAGNETIC_DOOR_STATUS, *LPNET_DVR_MAGNETIC_DOOR_STATUS;

typedef union tagNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
{
    BYTE byLen[256]; 
    NET_DVR_UNLOCK_RECORD_INFO struUnlockRecord;             //Unlock Record
    NET_DVR_NOTICEDATA_RECEIPT_INFO struNoticedataReceipt;     //Noticedata Receipt
    NET_DVR_AUTH_INFO struAuthInfo; //auth info(not used)
    NET_DVR_UPLOAD_PLATE_INFO struUploadPlateInfo; //upload plate info
    NET_DVR_SEND_CARD_INFO struSendCardInfo; //1,related to function of outdoor device send card ,upload this information when swiping card;2,ivalid card swipe
    NET_DVR_MAGNETIC_DOOR_STATUS struMagneticDoorStatus; //magnetic door status
}NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON,*LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;

// 
typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize;  
    NET_DVR_TIME_EX struTime; 
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //Device No.
    BYTE   byEventType; //Event Type, 1-Unlock Record,2-Noticedata Receipt,3-Auth Info,4-Upload Plate Info,5-invalid card swipe,6-outdoor device send card info(need enable function of send card ),7-mask detect event,8-magnetic door status
    BYTE   byPicTransType;        //Image data transmission mode: 0-binary; 1 - the url
    BYTE   byRes1[2];
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo;  
    DWORD dwIOTChannelNo;    //IOT channel
    BYTE  byRes2[252];
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;

 
typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN];     //Zone Name
    DWORD  dwZonendex;                 //Zone Index
    BYTE   byZoneType;                 //Zone Type, See ALARM_ZONE_TYPE_ENUM
    BYTE   byRes[219];   
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

typedef struct tagNET_DVR_LOCK_ALARM_INFO
{
    DWORD   dwLockID;   //lock ID,from 0 start
    BYTE    byRes[252]; 
}NET_DVR_LOCK_ALARM_INFO, *LPNET_DVR_LOCK_ALARM_INFO;

typedef union tagNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION
{
    BYTE byLen[256];  
    NET_DVR_ZONE_ALARM_INFO struZoneAlarm; 
    NET_DVR_LOCK_ALARM_INFO struLockAlarm;  
}NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION,*LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;


 
typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;  
    NET_DVR_TIME_EX struTime;                 //Alarm Time
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN];     //Device No.
    BYTE  byAlarmType;                         //Alarm type  
    BYTE  byRes1[3];     
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo;  
    WORD  wLockID;
    BYTE  byRes3[2];
    DWORD dwIOTChannelNo;    //IOT channel
    BYTE  byRes2[248];
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;


typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;
    BYTE byNumber;
    BYTE byDressType;
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;
    char*  pPicBuffer;
    BYTE byRes1[24];
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD     dwSize;
    DWORD     dwRelativeTime; 
    DWORD    dwAbsTime; 
    NET_VCA_DEV_INFO  struDevInfo;
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    BYTE  byPeopleAlarmType; 
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;

typedef    struct tagNET_DVR_SUPPLEMENTLIGHT
{
    BYTE        byEnable;
    BYTE          byMode;
    BYTE        byHighBeamBrightness;
    BYTE        byLowBeamBrightness;
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;    
    WORD        wFilteringTime;
    BYTE        byBrightness;
    BYTE        bySensitivity;
    BYTE        byBrightnessRegulatMode;
    BYTE        byMaxBrightness;
    BYTE        byRes[58];
}NET_DVR_SUPPLEMENTLIGHT,*LPNET_DVR_SUPPLEMENTLIGHT;

typedef    struct tagNET_DVR_EXTERNALDEVICE
{
    DWORD        dwSize;
    NET_DVR_SUPPLEMENTLIGHT struSupplementLight;        
    BYTE        byRes[512];
}NET_DVR_EXTERNALDEVICE,*LPNET_DVR_EXTERNALDEVICE;
typedef    struct tagNET_DVR_TEMPERATURE_TRIGGER_COND
{
    DWORD     dwSize;
    DWORD     dwChan;
    DWORD     dwPreset;
    BYTE      byRes[256];
}NET_DVR_TEMPERATURE_TRIGGER_COND, *LPNET_DVR_TEMPERATURE_TRIGGER_COND;
typedef    struct tagNET_DVR_BUILTIN_SUPPLEMENTLIGHT
{
    DWORD        dwSize;
    BYTE          byMode;
    BYTE        byBrightnessLimit;
    BYTE        bySupplementLightMode;
    BYTE        byMixedLightRegulatMode;
    BYTE        byLrLightBrightness;
    BYTE        byHighLrLightBrightness;
    BYTE        byHighBrightnessLimit;
    BYTE        byLowLrLightBrightness;
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;    
    BYTE        byLowBrightnessLimit;
    BYTE        byWhiteLightBrightness;
    BYTE        byIrLightbrightnessLimit;
    BYTE        byWhiteLightbrightnessLimit;
    BYTE        byRes1[252];
}NET_DVR_BUILTIN_SUPPLEMENTLIGHT,*LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT;


typedef struct tagNET_DVR_OIS_CFG
{
    DWORD        dwSize;
    BYTE        byMode;
    BYTE        byOISLevel;
    BYTE        byOISSensitivity;
    BYTE        byRes[125];
}NET_DVR_OIS_CFG, *LPNET_DVR_OIS_CFG;

typedef struct tagNET_DVR_MACFILTER_CFG
{
    DWORD      dwSize;
    BYTE       byEnabled;  //0-N,1-Y
    BYTE       byPermissionType; //0-F,1-P
    BYTE       byRes1[2];
    BYTE       szMacAddress[MAC_ADDRESS_NUM][MACADDR_LEN];
    BYTE       byRes[128];
}NET_DVR_MACFILTER_CFG, *LPNET_DVR_MACFILTER_CFG;

typedef    struct tagNET_DVR_EAGLEFOCUSING_SENCE
{
    BYTE    byRuleType;//Rule type, 0 - line
    BYTE    bySceneID;// Scene ID, 0- reservations, 1 is to represent the scene 1,2 Scene 2, the rest of the analogy
    WORD    wRate;//Magnification, 50-100
    NET_VCA_POLYGON struRegion;// Regional scope
    BYTE    bySpotNum;//How many points on the calibration line calibration, 3-5, default 3
    BYTE    byRes[127];
}NET_DVR_EAGLEFOCUSING_SENCE, *LPNET_DVR_EAGLEFOCUSING_SENCE;

typedef struct tagNET_DVR_EAGLEFOCUSING_CALCFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//0-N,1-Y
    BYTE    byRes1[3];
    NET_DVR_EAGLEFOCUSING_SENCE struEagleFoucsing[MAX_SENCE_NUM/*16*/];
    BYTE   byRes[512];
}NET_DVR_EAGLEFOCUSING_CALCFG, *LPNET_DVR_EAGLEFOCUSING_CALCFG;

typedef struct tagNET_DVR_EAGLEFOCUSING_CTRL
{
    DWORD    dwSize;
    BYTE     byEnable;
    BYTE     byHeightCompensationEnable;
    BYTE     byHeightCompensationValue;
    BYTE     byRes[509];
}NET_DVR_EAGLEFOCUSING_CTRL, *LPNET_DVR_EAGLEFOCUSING_CTRL;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION
{
    BYTE        byRuleID;//Rule ID
    BYTE        byMode;//0-default Mode,1-pix Mode,2-actual Mode
    BYTE        byStrategy;// 0-area,1-widthHeight (<!---,if mode == pix Mode -->)
    BYTE        byPriority;//Priority 0-default, 1-low,2-mid,3-high
    NET_VCA_POLYGON struMaxTargetSize;//Max Target Size
    NET_VCA_POLYGON struMinTargetSize;//Min Target Size
}NET_DVR_SMARTCALIBRATION_REGION, *LPNET_DVR_SMARTCALIBRATION_REGION;

typedef struct tagNET_DVR_SMARTCALIBRATION_CFG
{
    DWORD        dwSize;
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//VCA Type
    BYTE        byRes[3];
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_CFG, *LPNET_DVR_SMARTCALIBRATION_CFG;


typedef struct tagNET_DVR_SMARTCALIBRATION_COND
{
    DWORD        dwSize;
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//VCA Type
    BYTE        byRes[3];
    DWORD        dwChannel;//Channel
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_COND, *LPNET_DVR_SMARTCALIBRATION_COND;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION_CFG
{
    DWORD        dwSize;
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_REGION_CFG, *LPNET_DVR_SMARTCALIBRATION_REGION_CFG;

typedef    struct tagNET_DVR_OSD_BATTERY_POWER_CFG
{
    DWORD dwSize;
    NET_VCA_POINT  struOSDBatteryPower;
    BYTE   byOSDBatteryPower;
    BYTE    byRes[63];
}NET_DVR_OSD_BATTERY_POWER_CFG, *LPNET_DVR_OSD_BATTERY_POWER_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;                     
    BYTE    byIOUseType;             //Use Type, 0- forbidden, 1-The door open button, 2-Door status, 0xff-Sel-define
    BYTE    byRes[63];                  
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;                     
    BYTE    byIOUseType;             //Use Type, 0-forbidden, 1-Electric lock, 0xff-Sel-define
    BYTE    byRes[63];                  
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;                 
    BYTE    byEnable;                   //enabled , 0-no, 1-yes
    BYTE    byRes1;                         
    BYTE    byInterfaceType;             //Interface Type, 0-no, 1-RS485,2-Network
    BYTE    byRS485Protocol;             //RS485 , 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 1 effective
    BYTE    byNetworkType;              //Network, 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 2  effective
    BYTE    byRes[63];                 
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;                 
    BYTE    byEnable;                   //enabled , 0-no, 1-yes
    BYTE    byRes1;                         
    BYTE    byInterfaceType;             //Interface Type, 0-no, 1-RS485,2-Network
    BYTE    byRS485Protocol;             //RS485 , 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 1 effective
    BYTE    byNetworkType;              //Network, 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 2  effective
    BYTE    byRes2;                        
    WORD    wServerPort;                //Ladder control server port number, when the card protocol type for the 1- private effective
    NET_DVR_IPADDR    struServerIP;        //Server IP when the card protocol type for the 1- private effective
    BYTE    byRes[256];              
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V50
{
    DWORD   dwSize;
    BYTE    byEnable;                 //enabled , 0-no, 1-yes
    BYTE    byNegativeFloor;           //negative floor
    BYTE    byInterfaceType;           //Interface Type, 0-no, 1-RS485,2-Network
    BYTE    byRS485Protocol;        //RS485 , 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 1 effective
    BYTE    byNetworkType;         //Network, 0-Unknown, 1-private, 0xff-Sel-define, When the byInterfaceType value is 2  effective
    BYTE    byElevatorControlType;      //Elevator Control Type: 0-invalid,1-DS-K2201,2-DS-K2210,0xff-custom
    WORD    wServerPort;            //Ladder control server port number, when the card protocol type for the 1- private effective
    NET_DVR_IPADDR    struServerIP; //Server IP when the card protocol type for the 1- private effective
    BYTE    sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN]; //user name, when the card protocol type for the 1- private effective
    BYTE    sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN]; //password, when the card protocol type for the 1- private effective
    BYTE    byRes[256];
}NET_DVR_ELEVATORCONTROL_CFG_V50, *LPNET_DVR_ELEVATORCONTROL_CFG_V50;

typedef struct tagNET_DVR_ROOM_CUSTOM_COND
{
    DWORD   dwSize;
    DWORD   dwRoomNumber; //room number(set valid, get invalid)
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_COND, *LPNET_DVR_ROOM_CUSTOM_COND;

typedef struct tagNET_DVR_ROOM_CUSTOM_CFG
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //former room no
    DWORD   dwCustomRoomNo; //custom room no
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_CFG, *LPNET_DVR_ROOM_CUSTOM_CFG;

typedef struct tagNET_DVR_ROOM_CUSTOM_STATUS
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //former room no
    BYTE    byStatus;  //status:0-invalid,1-failed,2-processing,3-success
    BYTE    byRes[127];
}NET_DVR_ROOM_CUSTOM_STATUS, *LPNET_DVR_ROOM_CUSTOM_STATUS;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN];         //VIS Dev ID
    BYTE  byDeviceName[NAME_LEN];          //Device Name
    BYTE  bySourceType;                    //Source Type, 0-Meaningless, 1-IPC,2-DVR/DVS/NVR,3-outdoor,4-out fence,5-again device
    BYTE  byRes[255];                  
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;



typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];        //Device No.
    BYTE    byRes[64];                           
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;                                   
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //Device No.
    BYTE        byMACAddr[MACADDR_LEN];             //mac addr
    BYTE        byRes1[2];                         
    BYTE        sSerialNumber[SERIALNO_LEN];        //Serial No.
    NET_DVR_IPADDR   struDevIP;                      
    NET_DVR_TIME_EX struRegisterTime;               //Register Time
    BYTE        byRegisterType;                     //RegisterType, 0-res,1-outdoor, 2-manage Unit,3-Indoor,4-out fence,5-Villa door,6-Two confirmation ,7-8700,8-4200
    BYTE        byRes[127];                         
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;

typedef struct tagNET_DVR_CALLER_INFO
{
    DWORD dwSize;        
    WORD   wBuildingNo;    
    SHORT   wFloorNo;    
    BYTE   byZoneNo;     
    BYTE   byUnitNo;
    BYTE   byDevNo;  
    BYTE    byDevType;  
    BYTE    byLockNum;
    BYTE   byHighDevNo; 
    BYTE   byRes1[2];    
    BYTE   byVoipNo[16];  
    BYTE   byRes[80];  
}NET_DVR_CALLER_INFO, *LPNET_DVR_CALLER_INFO;

typedef struct tagNET_DVR_CALL_STATUS
{
    DWORD dwSize;
    BYTE   byCallStatus; 
    BYTE   byRes[127];
}NET_DVR_CALL_STATUS, *LPNET_DVR_CALL_STATUS;

#define MAX_SERVER_DEVICE_NUMBER              16
typedef struct tagNET_DVR_SERVER_DEVICE_CFG
{
    BYTE    byDeviceName[NAME_LEN]; 
    BYTE       byDeviceType; 
    BYTE       byDeviceID;
    BYTE    byLockNum; 
    BYTE    byRes[5]; 	  
}NET_DVR_SERVER_DEVICE_CFG, *LPNET_DVR_SERVER_DEVICE_CFG;

typedef struct tagNET_DVR_SERVER_DEVICE_INFO
{
    DWORD   dwSize; 
    DWORD     dwDeviceNum; 
    NET_DVR_SERVER_DEVICE_CFG    struDeviceCfg[MAX_SERVER_DEVICE_NUMBER];  
    BYTE    byRes[200];       
}NET_DVR_SERVER_DEVICE_INFO, *LPNET_DVR_SERVER_DEVICE_INFO;

typedef  struct  tagNET_DVR_SENSOR_VALUE
{
    float   fMinValue; //Min Value
    float   fMaxValue; //Max Value
    BYTE    byRes[8];
}NET_DVR_SENSOR_VALUE, *LPNET_DVR_SENSOR_VALUE;

typedef  struct  tagNET_DVR_HISTORICAL_QUERY_PARAM //Historical Query Param
{
    NET_DVR_TIME_V30 struStartTime;//Start Time  
    NET_DVR_TIME_V30 struEndTime;//End Time
    NET_DVR_SENSOR_VALUE struVoltageValue; //Voltage Value; Unit: V 
    NET_DVR_SENSOR_VALUE struCurrentValue; //Current Value; Unit: mA
    NET_DVR_SENSOR_VALUE struTemperatureValue;//Temperature Value,Unit: 
    NET_DVR_SENSOR_VALUE struHumidityValue;//Humidity Value
    BYTE   bySwitchStatus;//Switch Status, 0~Close,1~Open
    BYTE   bySensorStatus; //Sensor Status; 
    BYTE   byRes[66];
}NET_DVR_HISTORICAL_QUERY_PARAM, *LPNET_DVR_HISTORICAL_QUERY_PARAM;

typedef  struct  tagNET_DVR_SENSOR_COND 
{
    DWORD  dwSize; 
    BYTE   byQueryType; //Query Type
    BYTE   byDeviceType; //Device Type
    BYTE   byDeviceID; //Device ID
    BYTE   byRes1;
    NET_DVR_HISTORICAL_QUERY_PARAM struHistoricalQueryParam; //Historical Query Param
    BYTE   byRes[64];
}NET_DVR_SENSOR_COND,*LPNET_DVR_SENSOR_COND;

typedef  struct  tagNET_DVR_SENSOR_CFG
{
    DWORD  dwSize; 
    BYTE   byEnable; //Enable 
    BYTE   byDeviceType; //Device Type
    BYTE   byDeviceID; //Device ID
    BYTE   byRes1;
    NET_DVR_TIME_V30 struTime;//Time
    BYTE   byIsFirst; //Is First
    BYTE   byIsSwitchOn; //Is SwitchOn
    BYTE   bySensorStatus; //Sensor Status
    BYTE   bySensorType; //Sensor Type
    float  fVoltage; //Voltage
    float  fCurrent; //Current
    float  fTemperatureValue;//Temperature Value
    float  fHumidityValue;//Humidity Value
    BYTE   bySensorName[SENSORNAME_LEN/*32*/]; //Sensor Name
    BYTE   byDescription[MAX_SENSORDESCR_LEN/*64*/]; //Description
    float  fActualValue;  //actually value
    BYTE   byUnit[SENSORUNIT_LEN/*32*/];   //unit word
    BYTE   byRes[220];
}NET_DVR_SENSOR_CFG,*LPNET_DVR_SENSOR_CFG;

typedef    struct tagNET_DVR_SENSOR_SWITCH_COND
{
    DWORD     dwSize;
    BYTE     byDeviceType; //Device Type
    BYTE     byDeviceID; //Device ID
    BYTE     bySwitch; //Switch
    BYTE     byRes[125];
}NET_DVR_SENSOR_SWITCH_COND,*LPNET_DVR_SENSOR_SWITCH_COND;

typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;     
    BYTE   byServerID[DEV_ID_LEN];  //SIP Server ID;
    WORD   wPort;                   //SIP Port
    BYTE   byRes1[2];   
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;           //Survival period, unit: s, default: 3600
    BYTE   byMaxHeartbeatTimeOut;    //The maximum heartbeat timeout, default: 3
    BYTE   byAutoAddIpc;            //Whether to enable the automatic add IPC, 0- disable, the 1- enable
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];
    BYTE   byRes[190];
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;

typedef    struct    tagNET_DVR_ACTIVATECFG
{
    DWORD   dwSize;    //struct size
    BYTE    sPassword[PASSWD_LEN];    //activate password
    BYTE    byLoginMode; //0-Private 1-ISAPI
    BYTE    byHttps;    //0-not use HTTPS, 1-use HTTPS
    BYTE    byRes[106];
}NET_DVR_ACTIVATECFG,*LPNET_DVR_ACTIVATECFG;

typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;    //struct size
    BYTE        byMode;    //0-activate by channel,1-activate by address
    BYTE        bySelfDefinePassword;//whether self-define password,0-no,1-yes,2-yes, and a custom password for the IPC
    BYTE        sPassword[PASSWD_LEN];//self-define password
    BYTE        sUserName[NAME_LEN];//username
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union size
        struct
        {
            DWORD       dwChannelNo;//channel number
            BYTE        byRes[508];
        }struChannelInfo;//channel information
        struct
        {
            NET_DVR_IPADDR   struIp;//IP address
            WORD    wPort;//port
            BYTE    sProtocolDesc[DESC_LEN];//protocol type
            BYTE    byMacAddr[MACADDR_LEN];//mac address
            BYTE    byRes[344];
        }struAddrInfo;//IP address get from NET_DVR_SADPINFO
    }unActivateDeviceInfo;
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-invalid,1-IPC not activate,2-risk password,3-weak password,4-medium password,5-strong password;byDigitalChanPasswordStatus[0]--the first digital channel
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_CAMERACHAN_SERIALCFG
{
    DWORD    dwSize;
    DWORD   dwBaudRate;
    BYTE    byDataBit;
    BYTE    byStopBit;
    BYTE    byParity;
    BYTE    byFlowcontrol;
    WORD    wPTZProtocol;
    BYTE    byRes1[6];
    DWORD   dwSerialPort;
    BYTE    bySerialAddress;
    BYTE    byRes[15];
}NET_DVR_CAMERACHAN_SERIALCFG, *LPNET_DVR_CAMERACHAN_SERIALCFG;

//Turn direction information
typedef struct tagNET_DVR_TURN_DIRECTION_PARAM
{
    BYTE   byLine;//Steering line number
    BYTE   byStatus;//Turn line state, 0- unknown, 1- in, 2- out
    BYTE   byRes[38];
}NET_DVR_TURN_DIRECTION_PARAM, *LPNET_DVR_TURN_DIRECTION_PARAM;

//Stop line information
typedef struct tagNET_DVR_STOP_LINE_PARAM
{
    BYTE   byStatus;//Stop line state, 0- unknown, 1- in, 2- out
    BYTE   byRes[39];
}NET_DVR_STOP_LINE_PARAM, *LPNET_DVR_STOP_LINE_PARAM;

//TPS Additional information
typedef struct tagNET_DVR_TPS_ADDINFO
{
    NET_DVR_LLPOS_PARAM struFirstLLPos;
    NET_DVR_LLPOS_PARAM struLastLLPos;
    char            sLicense[MAX_LICENSE_LEN/*16*/];//License plate number
    NET_DVR_TURN_DIRECTION_PARAM    struTurnDirection;//Turn direction information
    NET_DVR_STOP_LINE_PARAM  struStopLine;//Stop line information    
    BYTE   byRes[884];
}NET_DVR_TPS_ADDINFO, *LPNET_DVR_TPS_ADDINFO;

//Additional vehicle information
typedef struct tagNET_DVR_VEHICLE_ADDINFO
{
    NET_DVR_LLPOS_PARAM struLLPos;
    char   sVehicleNo[LEN_64]; 
    BYTE   byVehicleMonitorTaskID[64];
    BYTE   byUUID[LEN_64]; //UUID
    BYTE   byRes[832];
}NET_DVR_VEHICLE_ADDINFO, *LPNET_DVR_VEHICLE_ADDINFO;

typedef struct tagNET_DVR_SMOKEDETECTION_ALARM
{
    NET_PTZ_INFO struPTZPos;
    NET_PTZ_INFO struThermalPTZPos;
    NET_DVR_LLPOS_PARAM struLLPos;
    NET_VCA_RECT  struSmokePos;
    BYTE   byRes[256];
}NET_DVR_SMOKEDETECTION_ALARM, *LPNET_DVR_SMOKEDETECTION_ALARM;

//Sensor Info
typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE        bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//Horizontal Width 
    float       fVerWidth;//Vertical Width 
    float       fFold;//Fold
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

//PTZ Param
typedef struct
{
    float   fPanPos;//Pan Pos
    float   fTiltPos;//Tilt Pos
    float   fZoomPos;//Zoom Pos
    BYTE    byRes[16] ;
}NET_DVR_PTZPOS_PARAM, *LPNET_DVR_PTZPOS_PARAM;

//GIS Info
typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO    struDevInfo;//Device Info
    float   fAzimuth;//Azimuth
    BYTE    byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE    byLongitudeType;//Longitude Type,0-east,1-West
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM    struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM    struLongitude; /*Longitude*/
    float   fHorizontalValue;//Horizontal Value
    float   fVerticalValue;//Vertical Value
    float   fVisibleRadius;//Visible Radius
    float   fMaxViewRadius;//Max View Radius
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor Info
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz 
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

//prevent damage 
typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD        dwSize;
    DWORD         dwRelativeTime; //Relative Time
    DWORD        dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO    struDevInfo;//Device Info
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;

//Centralized Ctrl
typedef    struct tagNET_DVR_CENTRALIZEDCTRL_CFG
{
    DWORD        dwSize;
    BYTE        byEnable;
    BYTE        byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE        byLongitudeType;//Longitude Type,0-east,1-West
    BYTE        byRes1;
    NET_DVR_LLI_PARAM    struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM    struLongitude; /*Longitude*/
    DWORD       dwTimeOut;//Time Out
    BYTE        byControlType;//Control Type
    BYTE        byRes[127];
}NET_DVR_CENTRALIZEDCTRL_CFG,*LPNET_DVR_CENTRALIZEDCTRL_CFG;

//Gis Info
typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;
    float  fAzimuth;//Azimuth
    float  fHorizontalValue;//Horizontal Value
    float  fVerticalValue;//Vertical Value
    float  fVisibleRadius;//Visible Radius
    float  fMaxViewRadius;//Max View Radius
    BYTE   byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE   byLongitudeType;//Longitude Type,0-east,1-West
    BYTE byPTZPosExEnable;
    BYTE byRes1;
    NET_DVR_LLI_PARAM      struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM      struLongitude; /*Longitude*/
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor Info
    NET_PTZ_INFO struPtzPosEx;
    float   fMinHorizontalValue;
    float   fMaxHorizontalValue;
    float   fMinVerticalValue;
    float   fMaxVerticalValue;
    BYTE  byRes[220];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;

//Equipment cruise mode 
typedef    struct tagNET_DVR_CRUISE_PARAM
{
    DWORD    dwSize;
    BYTE    byCruiseMode;// cruise mode,0~continuous ,1~reset point 
    BYTE    byRes[123];
}NET_DVR_CRUISE_PARAM, *LPNET_DVR_CRUISE_PARAM;

//Equipment environmental temperature and humidity information structure 
typedef struct tagNET_DVR_TEMP_HUMI_INFO
{
    DWORD    dwSize;
    NET_DVR_TIME_V30      struCurrentTime; // current time 
    float        fTemperature;//Equipment environment temperature, accurate to two decimal places, (-273-1000 degrees c)
    float        fHumidity;// Equipment environment humidity, accurate to two decimal places. The unit is: % 
    BYTE       byRes[256];
}NET_DVR_TEMP_HUMI_INFO, *LPNET_DVR_TEMP_HUMI_INFO;

typedef struct tagNET_SDK_POINT_THERMOMETRY
{
    float        fPointTemperature;/*Point temperature measuring the current temperature */
    NET_VCA_POINT  struPoint;//Point temperature measurement coordinates 
    BYTE       byRes[20];
}NET_SDK_POINT_THERMOMETRY, *LPNET_SDK_POINT_THERMOMETRY;


typedef struct tagNET_SDK_REGION_THERMOMETRY
{
    float            fMaxTemperature;//highest temperature 
    float            fMinTemperature;//lowest temperature 
    float            fAverageTemperature;//average temperature 
    float            fTemperatureDiff;//temperature difference 
    NET_VCA_POLYGON struRegion;
    BYTE       byRes[20];
}NET_SDK_REGION_THERMOMETRY, *LPNET_SDK_REGION_THERMOMETRY;

typedef    struct tagNET_SDK_MANUALTHERM_RULE
{
    BYTE       byRuleID;//Rule ID 0 - said invalid, starting from 1 
    BYTE       byEnable;
    BYTE       byRes1[2];
    char         szRuleName[NAME_LEN/*32*/];//Rule name
    BYTE       byRuleCalibType;//Rules calibration type
    BYTE       byRes2[3];
    NET_SDK_POINT_THERMOMETRY struPointTherm;//Point temperature measurement 
    NET_SDK_REGION_THERMOMETRY struRegionTherm; //Regional temperature measurement 
    BYTE      byRes[512];
}NET_SDK_MANUALTHERM_RULE, *LPNET_SDK_MANUALTHERM_RULE;

typedef    struct tagNET_SDK_MANUAL_THERMOMETRY
{
    DWORD        dwSize;
    DWORD        dwChannel;
    DWORD      dwRelativeTime; // relative time scale (read-only) 
    DWORD    dwAbsTime;      // absolute time scale (read-only) 
    BYTE       byThermometryUnit;//Temperature measurement unit: 0 (), 1 (H), 2 (K) 
    BYTE       byDataType;//State of data types: 0 - testing, 1 - start, 2 - end (read-only) 
    BYTE      byRes1[6];
    NET_SDK_MANUALTHERM_RULE struRuleInfo;
    BYTE      byRes[512];
}NET_SDK_MANUAL_THERMOMETRY, *LPNET_SDK_MANUAL_THERMOMETRY;

//Vandalproof Alarm Cfg
typedef    struct tagNET_DVR_VANDALPROOFALARM_CFG
{
    DWORD    dwSize;
    BYTE    bySensitivity;
    BYTE    byUploadEnabled;//Upload Enabled
    BYTE    byVoiceWarningEnabled;//Voice Warning Enabled
    BYTE    byEnable;
    BYTE    byRes[124];
}NET_DVR_VANDALPROOFALARM_CFG,*LPNET_DVR_VANDALPROOFALARM_CFG;

typedef    struct tagNET_DVR_AZIMUTHINFO
{
    DWORD        dwSize;
    float       fDegree;// azimuth degree (accurate to two decimal places) 
    BYTE        byAzimuth;//azimuth info (0-northeast,1-northwest,2-southeast,3-southwest,4-east,5-west,6-south,7-north)
    BYTE        byRes[127];
}NET_DVR_AZIMUTHINFO,*LPNET_DVR_AZIMUTHINFO;

//Compass Cond
typedef    struct tagNET_DVR_COMPASS_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//Channel
    BYTE        byRes[128];
}NET_DVR_COMPASS_COND,*LPNET_DVR_COMPASS_COND;

typedef    struct tagNET_DVR_POSITION_CFG
{
    DWORD     dwSize;
    BYTE     bySoftWorkMode;//Work Mode 0-auto,1-manual
    BYTE     byRes[127];
}NET_DVR_POSITION_CFG,*LPNET_DVR_POSITION_CFG;

typedef    struct tagNET_DVR_STREAMING_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    BYTE        byStreamType;
    BYTE        byRes[127];
}NET_DVR_STREAMING_COND,*LPNET_DVR_STREAMING_COND;

//Satellite positioning Cfg
typedef    struct tagNET_DVR_SATELLITETIME_CFG
{
    DWORD        dwSize;
    BYTE        byEnable;//Enable
    BYTE        byRes;
    WORD        wTimeInterval;//Time Interval (s)
    BYTE        byRes1[124];
}NET_DVR_SATELLITETIME_CFG,*LPNET_DVR_SATELLITETIME_CFG;

//truck sort by axle num
typedef enum
{
    AXLE_TYPE_UNKNOWN = 0x0000,         //unknown
    //2 Axle
    AXLE_TYPE_2AXLE_12 = 0x0200,
    //3 Axle
    AXLE_TYPE_3AXLE_122_1 = 0x0300,
    AXLE_TYPE_3AXLE_122_2,
    AXLE_TYPE_3AXLE_15,
    AXLE_TYPE_3AXLE_112,
    //4 Axle
    AXLE_TYPE_4AXLE_125_1 = 0x0400,
    AXLE_TYPE_4AXLE_152,
    AXLE_TYPE_4AXLE_125_2,
    AXLE_TYPE_4AXLE_1222,
    AXLE_TYPE_4AXLE_115,
    //5 Axle
    AXLE_TYPE_5AXLE_155_1 = 0x0500,
    AXLE_TYPE_5AXLE_1125_1,
    AXLE_TYPE_5AXLE_155_2,
    AXLE_TYPE_5AXLE_1125_2,
    AXLE_TYPE_5AXLE_129,
    AXLE_TYPE_5AXLE_1522,
    AXLE_TYPE_5AXLE_11222,
    //6 Axle
    AXLE_TYPE_6AXLE_159_1 = 0x0600,
    AXLE_TYPE_6AXLE_159_2,
    AXLE_TYPE_6AXLE_1155_1,
    AXLE_TYPE_6AXLE_1155_2,
    AXLE_TYPE_6AXLE_159_3,
    AXLE_TYPE_6AXLE_159_4,
    AXLE_TYPE_6AXLE_1129,
    AXLE_TYPE_6AXLE_11522_1,
    AXLE_TYPE_6AXLE_11522_2,
}TRUCK_AXLE_MODEL;

typedef enum _TOOLWAY_VEHICLE_TYPE
{
    TOOLWAY_RESULT_OTHER = 0,  
    TOOLWAY_PASSENGER_VEHICLE_CLASS_1_MINI = 1,
    TOOLWAY_PASSENGER_VEHICLE_CLASS_1_SMALL = 2,
    TOOLWAY_PASSENGER_VEHICLE_CLASS_2_MIDDLE = 3,
    TOOLWAY_PASSENGER_VEHICLE_CLASS_2_TRAILER = 4,
    TOOLWAY_PASSENGER_VEHICLE_CLASS_3_LARGR = 5,
    TOOLWAY_PASSENGER_VEHICLE_CLASS_4_LARGR = 6,
    TOOLWAY_GOODS_VEHICLE_CLASS_1 = 7,
    TOOLWAY_GOODS_VEHICLE_CLASS_2 = 8,
    TOOLWAY_GOODS_VEHICLE_CLASS_3 = 9,
    TOOLWAY_GOODS_VEHICLE_CLASS_4 = 10,
    TOOLWAY_GOODS_VEHICLE_CLASS_5 = 11,
    TOOLWAY_GOODS_VEHICLE_CLASS_6 = 12,
    TOOLWAY_MOTOR_VEHICLE_CLASS_1 = 13,
    TOOLWAY_MOTOR_VEHICLE_CLASS_2 = 14,
    TOOLWAY_MOTOR_VEHICLE_CLASS_3 = 15,
    TOOLWAY_MOTOR_VEHICLE_CLASS_4 = 16,
    TOOLWAY_MOTOR_VEHICLE_CLASS_5 = 17,
    TOOLWAY_MOTOR_VEHICLE_CLASS_6 = 18
}TOOLWAY_VEHICLE_TYPE;


//Vehicle Weight
typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //Whether overweight
    BYTE      byAxleNum;              //Axle Num
    WORD      wAxleModel;            //see enum TRUCK_AXLE_MODEL
    float     fOverWeight;           //OverWeight 
    float     fWeight;               //Vehice Weight
    float     fLimitWeight;          //Limit Weight
    float     fAxleLen;              //Axle Len
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/];       //Device description information
    WORD      wAxleWeight[MAX_TRUCK_AXLE_NUM/*10*/];    //Axle weight array
    WORD      wAxleDistance[MAX_TRUCK_AXLE_NUM/*10*/];  //Axle distance array,unit mm.
    DWORD     dwLength;                 //Vehicle Length unit cm
    DWORD     dwWidth;                  //Vehicle Widthunit cm
    DWORD     dwHeight;                 //Vehicle Heightunit cm
    BYTE      byTollwayVehicleType;     //TOOLWAY_VEHICLE_TYPE
    BYTE      byRes2[11];               //res
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

// Plate Result V50
typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;        //Structure size
    DWORD   dwMatchNo;  //Matched Serial Number. (consisting of the vehicle serial number, data type and lane number)
    BYTE    byGroupNum;    //Amount of the picture groups (the amount of pictures captured when one vehicle passing by. The data can be used for the Time Delay Matching.)
    BYTE    byPicNo;    //Continuous captured pictures serial number. (indicating the complete of the receiving.)
    BYTE    bySecondCam;    //Whether set the second camera to snapshot (e.g. prospect camera of far and near scene capture, rear camera of front and rear capture)
    BYTE    byFeaturePicNo; //electric alarm of running red light, which picture taken to be close-up, 0xff- not take
    BYTE    byDriveChan;    //Triggering lane No.
    BYTE    byVehicleType;     //Vehicle type,refer to VTR_RESULT
    BYTE    byDetSceneID;//Detecting Scene ID[1,4], 
    // 0- no additional attributes, 1- standard yellow cars (banner), 2- dangerous goods vehicle
    //this Attribute is useless, use byYellowLabelCar and byDangerousVehicles
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //Rules broken type adopts the international standard definition
    BYTE    byIllegalSubType[8];   //Rules broken sub-type
    BYTE    byPostPicNo;    //The captured picture number to be traffic mount picture when the rule is broken,0xff- not take
    BYTE    byChanIndex;        //Camera No. (reserved)
    WORD    wSpeedLimit;        //Speed upper limit(valid when overspeed)
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex
    BYTE    byVehiclePositionControl;  /* vehicle position control flag,0~No,1~With,
                                       (PUT /ISAPI/Traffic/channels//vehiclePositionControl? Format = json)*/
    NET_DVR_PLATE_INFO  struPlateInfo;     //Plate info. structure
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //Vehicle info
    BYTE    byMonitoringSiteID[48];        //Camera No.
    BYTE    byDeviceID[48];                //Device No.
    BYTE    byDir;            //Monitoring direction; 1- Up, 2- Down, 3- Bi-directional, 4- Westward, 5- Northward, 6-Eastward, 7-Southward, 8-Other directio
    BYTE    byDetectType;    //Detecting methods: 1- Triggered by induction coil, 2- Triggered by video, 3- Triggered by multi-frame detection, 4-Triggered by radar.
    BYTE    byRelaLaneDirectionType;//ITC_RELA_LANE_DIRECTION_TYPE
    BYTE    byCarDirectionType; //Car Direction Type
    DWORD   dwCustomIllegalType; //Custom Illegal Type
    BYTE*   pIllegalInfoBuf;    //Illegal Info Buf
    BYTE    byIllegalFromatType; //Illegal Fromat Type
    BYTE    byPendant;//  Pendant,0-Unknow, 1-No,2-Yes
    BYTE    byDataAnalysis;            //0-Data Not Analysis, 1-Data Analysis
    BYTE    byYellowLabelCar;        //Yellow Label Car; 0-Unknow, 1-No,2-Yes
    BYTE    byDangerousVehicles;    //Dangerous Vehicles; 0-Unknow, 1-No,2-Yes
    //The following field contains Pilot characters are main driving, contains Copilot characters are sub driving
    BYTE    byPilotSafebelt;//Pilot Safe belt
    BYTE    byCopilotSafebelt;//Copilot Safe belt
    BYTE    byPilotSunVisor;//Pilot Sun Visor
    BYTE    byCopilotSunVisor;//Copilot Sun Visor
    BYTE    byPilotCall;// Pilot Call
    //The 0-open, 1-close(dedicated to the historical data based on block and allow list matching, whether to open a sign of success)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-RealTime Data,1-Historical Data
    NET_DVR_TIME_V30  struSnapFirstPicTime;//End time (MS) (captured the first picture time.)
    DWORD   dwIllegalTime;//Illegal duration (MS) = captured the last picture time - to capture the first picture of the time
    DWORD   dwPicNum;        //The picture count (different with picGroupNum, represent the picture count attached by this information, picture info defined by struVehicleInfoEx    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //Picture info, check picture, at most 6 pictures at one time
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //Vehicle Weight 
    BYTE     byRes[256];
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;


typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-out arm,1-stay arm,2-immedately arm,3-disarm
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;


typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byNormalSchedTimeOn; 
    BYTE byMandatoryAlarm;//0-unforced arm,1-forced arm
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;

#define MAX_ALLOWLIST_PHONE_NUM      16

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD    dwSize; 
    BYTE    byEnable; //0-disable,1-enable
    BYTE    byRes1[3];
    BYTE    byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD    dwArmRight; 
    DWORD    dwDisArmRight; 
    DWORD    dwClearAlarmRight; 
    BYTE    byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/]; 
    DWORD    dwNonZoneReport; 
    BYTE    byIntervalTime; 
    BYTE    byRes2;
    WORD    wDefineIntervalTime;
    BYTE    byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD    dwSize;
    BYTE    byModuleType;    //1-Keyboard,2-trigger,3-zone,e,4-network
    BYTE    byKeyBoardType;    //1-LCD,2-LED
    BYTE    byTriggerType;    //1--local trigger, 2--4 trigger,3--8 trigger,4--single trigger,5--32 trigger
    BYTE    byZoneType;        //1--local zone,2--single zone,3--double zone,4--8 zone,5--8 sensor zone, 6-1Zone&Trigger
    WORD    wModuleAddress;    //0~255,0xFFFF--invalid
    BYTE    byRes2[2];
    char    sModelInfo[32];
    char    sDeviceVersionInfo[32];
    BYTE    byRes[128];
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ALARMHOST_DETECTOR_INFO
{
    DWORD		dwSize;
    BYTE     byDetectorSerialNo[16];   //serial number
    DWORD   dwAlarmIn;   //zone number
    WORD    wDetectorType;   // DETECTOR_TYPE
    BYTE   	byRes[126];      
}NET_DVR_ALARMHOST_DETECTOR_INFO, *LPNET_DVR_ALARMHOST_DETECTOR_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE                       byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{   
    DWORD  dwSize; 
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/];
    BYTE   byRes[64];
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD        dwSize; 
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE        byRes[256]; 
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD        dwSize;
    BYTE        byBeforeAlarmPic;
    BYTE        byAfterAlarmPic;
    WORD          wInterval; 
    BYTE        byResolution;//1-CIF,2-2CIF,3-4CIF,4-QCIF,5-WD1,6-VGA,7-XVGA,8-720P,9-1080P
    BYTE           byRes[63];
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

#define PRIOR_SCHEDTIME            30

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD    dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE    byEnable;
    BYTE    byRes1[3];
    BYTE    bySubSystem[32];
    BYTE    byMandatoryAlarm;
    BYTE    byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType;     
    BYTE    byUploadAlarmRecoveryReport;    
    BYTE    byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  
    BYTE    byAssociateSirenOut[8];    
    BYTE    byTamperResistor;//0-invalid 1-2.2 ,2--3.3, 3-4.7 ,4-5.6 , 5-8.2 ,0xff-manual
    BYTE    byRes2[3];
    float    fTamperResistorManual;
    BYTE    byRes3[36]; 
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;

typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byAssociateNetUser;
    WORD    wRemoteCtrllerID;//start from 1
    BYTE    sDevSn[16];
    BYTE    byArmRight;        
    BYTE    byDisArmRight;    
    BYTE    byArmReportRight;
    BYTE    byDisArmReportRight;
    BYTE    byClearAlarmRight;    
    BYTE    bySubSystemID;       /* 1~8 */
    BYTE    byKeyboardAddr;       
    BYTE    byEnableDel;   //delete user,0-close delete,1-open delete
    BYTE    byAlwaysOpenRight;
    BYTE    byOpeningDirection;
    BYTE    byRes3[2];
    BYTE    byName[NAME_LEN];
    BYTE    byRes2[28];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


typedef struct tagNET_DVR_KEYBOARD_CFG
{
    DWORD    dwSize;
    BYTE    byEnableLock;    //enable keyborad alarm  0-disable,1-enable
    BYTE    byErrorTimes;    //enter error password times, then lock the keyborad
    WORD    wLockTime;        //lock time,sencond
    BYTE    byRes[128];
}NET_DVR_KEYBOARD_CFG, *LPNET_DVR_KEYBOARD_CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD    dwSize;
    BYTE    byCommOperatorNum[NAME_LEN/*32*/];//communication operator munber
    BYTE    byQueryCode[16];
    BYTE    byBusinessType;//0-fare,1-flow
    BYTE    byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD    dwSize;
    BYTE    by3GBusiness[1024];//3G business message
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD    dwSize;
    WORD    wdelayTime;//delay preview time,unit:second
    BYTE    byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD    dwSize;
    DWORD    dwDevNo;
    BYTE    byDevType;    //0-keyboard,1-movement,2-net module,3-router,4-zone,5-RS485 wireless extend module,6-temp ctrl module,7-electric Lock Module,8 netPortPowerSupply
    BYTE    byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD    dwSize;
    SHORT   nFloorNumber;    //floor number
    WORD    wRoomNumber;    //rom number
    BYTE    byManageCenter;    //whether call manage center
    BYTE    byRes1[3];
    BYTE    byCalledName[64];    //valid with standard sip mode, means called name, support character of letter, number,'@' and '.'
    BYTE  byRes[60];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD    dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD    dwSize;
    DWORD   dwCmdType;      //Signaling type 0- to cancel the call, answer the call 1- 2- refused to local incoming call 3- called 4- the end of the call bell timeout 5-end call 6-device is calling 7-client is call 8-indoor not online
    WORD wPeriod;  //
    WORD wBuildingNumber; //
    WORD wUnitNumber;  //
    SHORT wFloorNumber;  //
    WORD  wRoomNumber;    //
    WORD  wDevIndex; //device index
    BYTE    byUnitType; //unit type
    BYTE    byRes[115];
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;


typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD    dwSize;
    BYTE    sCaseNo[INQUEST_CASE_NO_LEN];    
    BYTE    sCaseName[INQUEST_CASE_NAME_LEN];    
    BYTE    sCustomInfo1[CUSTOM_INFO_LEN];    
    BYTE    sCustomInfo2[CUSTOM_INFO_LEN];    
    BYTE    sCustomInfo3[CUSTOM_INFO_LEN];    
    BYTE    byShowCaseInfoTime; /* 1~60s*/
    BYTE    byShowCaseInfo;    //0-not,1-display
    BYTE    byPosition;        //0-up-left,1-bottom-left
    BYTE    byRes1;
    BYTE    byCustomInfo4[CUSTOM_INFO_LEN];     //Custom information 4, the field is invalid if the case number has content
    BYTE    byCustomInfo5[CUSTOM_INFO_LEN];     //Custom information 5, the field is invalid if the case name has content
    BYTE    byRes[128]; 
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD    dwSize;
    DWORD    dwChannel;
    BYTE    byShowCaseInfoTime;    
    BYTE    byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD    dwSize;
    BYTE    byLocalRight[MAX_RIGHT];  
    BYTE    byRemoteRight[MAX_RIGHT];
    BYTE    byNetAudioRight[MAX_CHANNUM_V40];  
    BYTE    byRes[512*9];      
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //0-disable,1-enable
    BYTE    byRes1[3];
    DWORD    dwMixCnt;  
    BYTE    bySrcChan[MAX_MIX_CHAN_NUM];   
    BYTE    byLineIn[MAX_LINE_IN_CHAN_NUM];
    BYTE    byMic[MAX_MIC_CHAN_NUM];    
    BYTE    byMixAudioDelay;    //0-63
    BYTE    byRes2[127];
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

//*************************************************************
typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD dwSize;
    DWORD   dwChannel;
    NET_DVR_TIME_EX   struStartTime;
    BYTE   byReportType;//report Type:1-day,2-week,3-month,4-year
    BYTE   byStatType;//stat Type:Bit0-age,Bit1-sex,Bit2-number of people
    BYTE   byEnableProgramStatistics; //According to the statistics show, 0 - no, 1 - is
    BYTE   byRes1;
    DWORD  dwPlayScheduleNo; //According to the statistics show the related schedule number
    BYTE   byRes[120];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_FILECOND_MEDICAL
{
    LONG lChannel;//channel 
    DWORD dwFileType;//record file type
    DWORD dwIsLocked;
    DWORD dwUseCardNo;
    BYTE sCardNumber[32];//card number
    NET_DVR_TIME_SEARCH_COND struStartTime;//start time
    NET_DVR_TIME_SEARCH_COND struStopTime;//stop time
    char            szPatientID[64];
    DWORD        dwBigFileType; // 0-normal segment search,1-big file search          
    BYTE          byRes[252];
}NET_DVR_FILECOND_MEDICAL, *LPNET_DVR_FILECOND_MEDICAL;

typedef struct tagNET_DVR_FIND_PICTURE_MEDICAL_PARAM
{
    DWORD  dwSize;
    LONG   lChannel;
    /*Image type to search: 0- scheduled capture, 1- motion detection capture, 2- alarm capture,
    3- motion detection or alarm capture, 3-motion detection and alarm capture, 6- manual capture,
    9-VCA, 0x0d facedetect,0xe NULL,Oxf field detection,0x25-face snap,0x26-Offline temperature alarm,0x2a-getup,0x2b-advreschheight,0x2c-toilettarry,0x2d-safetyHelmet,0x2e-perimeterCapture,0x2f-humanRecognition,0x30-faceSnapModeling, 0x31-mixedTargetDetection,0x32-alarmInAlarm,0x33-emergenceCall,0x34-consultAlarm,0x35-unregisteredStreetVendor,0xff- all types*/
    BYTE   byFileType;
    BYTE   byNeedCard;     //Whether need card number
    BYTE   byProvince;
    BYTE   byRes1;  
    NET_DVR_TIME  struStartTime;//Start time of image search
    NET_DVR_TIME  struStopTime;//End time of image search
    char     szPatientID[64];
    BYTE     byRes[256];
}NET_DVR_FIND_PICTURE_MEDICAL_PARAM, *LPNET_DVR_FIND_PICTURE_MEDICAL_PARAM;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;
    DWORD    dwYouth;
    DWORD    dwMidLife;
    DWORD    dwElderly;
    DWORD    dwChild;
    DWORD    dwAdolescent;
    DWORD    dwPrime;
    DWORD    dwMidage;
    BYTE   byRes[48];
}NET_DVR_AGEGROUP_PARAM,*LPNET_DVR_AGEGROUP_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;
    DWORD    dwFemale;
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;
    NET_DVR_TIME_EX   struEndTime;
    BYTE   byStatType;//stat Type:Bit0-age,Bit1-sex,Bit2-number of people
    BYTE   byRes[7];
    DWORD  dwPeopleNum;
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;
    NET_DVR_PROGRAM_INFO struProgramInfo;        //program info
    BYTE   byRes1[76];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

//Traffic Data Query Cond
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
    DWORD  dwSize;
    DWORD  dwQueryCond;//Query Cond
    DWORD  dwChannel;//Channel
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    char   sLicense[MAX_LICENSE_LEN/*16*/];//sLicense
    DWORD  dwPlateType;//Plate Type
    DWORD  dwPlateColor;//Plate Color
    DWORD  dwVehicleColor;//Vehicle Color
    DWORD  dwVehicleType;//Vehicle Type
    DWORD  dwIllegalType;//Illegal Type
    DWORD  dwEventType;//Event Type 
    DWORD  dwForensiceType;// Forensice Type
    WORD   wVehicleLogoRecog;  //Vehicle Logo Recog
    BYTE   byLaneNo;//Lane No
    BYTE   byDirection;//Direction     
    WORD   wMinSpeed;//Min Speed
    WORD   wMaxSpeed;//Max Speed
    BYTE   byDataType;//Data Type
    BYTE   byExecuteCtrl;//Execute Ctrl
    BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

//Traffic Picture Param
typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30     struRelativeTime; //Relative Time
    NET_DVR_TIME_V30    struAbsTime;  //Abs Time
    char szPicName[PICTURE_NAME_LEN/*64*/];//Pictrue Name
    BYTE  byPicType;//Pictrue Type
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

//Traffic Data Query
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
    DWORD  dwSize;
    DWORD  dwChannel;//Channel([1~32])
    char   sLicense[MAX_LICENSE_LEN/*16*/];
    DWORD  dwPlateType;//Plate Type
    DWORD  dwPlateColor;//Plate Color
    DWORD  dwVehicleColor;//Vehicle Color
    DWORD  dwVehicleType;//Vehicle Type
    DWORD  dwIllegalType;//Illegal Type
    DWORD  dwEventType;//Event Type
    DWORD  dwForensiceType;//Forensice Type
    WORD   wVehicleLogoRecog;  //Vehicle Logo Recog
    BYTE   byLaneNo;//Lane No
    BYTE   byDirection;//Direction    
    WORD   wSpeed;//Speed
    BYTE   byDataType;//Data Type
    BYTE   byRes[253];
    NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//Traffic Flow Query Cond
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
    DWORD  dwSize;
    DWORD  dwQueryCond;//Query Cond
    DWORD  dwChannel;//Channel
    DWORD  dwResChan[10];//Res Chan
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE   byLaneNo;//Lane No
    BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

//Traffic Flow Query
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
    DWORD  dwSize;
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    DWORD  dwChannel;//Channel
    DWORD  dwFlow;//Flow
    BYTE   byLaneNo;//Lane No    
    BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

 
typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //picture Type,0-jpg
    BYTE   byRes1[3];        
    DWORD  dwPicWidth;       //picture width
    DWORD  dwPicHeight;      //picture height
    DWORD  dwPicDataLen;     //pic Data length
    char*  byPicDataBuff;    
    BYTE   byRes2[32];       
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD       dwSize;
    BYTE       byEnable;       //Enabled  0-disable, 1-enable
    BYTE       byRuleID;       //Rule ID
    BYTE       byColorBlockNo;  //color block no. ,Start From 1
    BYTE       byRes1;      
    NET_DVR_PIC_INFO  struPicInfo;  //picture color info
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD        dwSize;
    DWORD       dwChannel;      //Channel No
    BYTE        byRuleID;       //Relate ID 
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD        dwSize; 
    BYTE        byEnable;        
    BYTE        byTriggerMode;  
    BYTE        byUploadPic;    
    BYTE        byRes1;         
    DWORD       dwTimeInterval;  
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType; 
    BYTE        byRelRecordChan[MAX_IVMS_IP_CHANNEL];     
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//Alarm Time
    BYTE        byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD                dwSize;
    NET_VCA_DEV_INFO    struDevInfo;        //Device Info
    NET_DVR_TIME_EX     struTime;           //Alarm Time
    BYTE                byLampStatus;       //Lamp Status 0-closed  1-opened
    BYTE                byRes1[3];          
    DWORD               dwPicDataLen;       
    char*               pPicData;           
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
    DWORD    dwSize;
    BYTE    byDevAddr;    //0-master device,1-15 slave device
    BYTE    byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

//Private Protocol Cfg
typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD          dwSize;   
    NET_DVR_IPADDR     struIP; //IP
    WORD          wPort;//Port
    BYTE          byEnable;   //enable 0-remain,1-open,2-close
    BYTE         byRes;
    DWORD        dwInterval;//Intercal
    BYTE         byServerType;//Server Type
    BYTE         byEcryptedSMSEnable;//Ecrypted SMS Enable
    BYTE         byAlgorithm;//Algorithm
    BYTE         byAcauisitionMode;//The acquisition mode, 0 - basic information, 1 - virtual identity information, 2 - basic information + virtual identity information
    DWORD        dwDistanceLimit;//Distance limit, the unit: m
    BYTE         byPKModeEnable;//PK mode enable, 0-reserve, 1-close,2-open
    BYTE         byMACAddrReductionEnable;//MAC address reduction enable, 0-reserve, 1-close, 2-open
    BYTE         byRes1[214];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//Secret Key Len
    char         szSecretKey[MAX_SECRETKEY_LEN/*512*/];//Secret Key
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

//Debug CMD
typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD     dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

//Debug Info
typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD     dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;



#define MAX_SSID_LEN    32   //SSID len
#define MAX_WS_PASSWD_LEN    64   //passwd len
typedef    struct tagNET_DVR_WIRELESSSERVER
{
    DWORD        dwSize;
    BYTE        byWLanShare;//whether use wlan share, 0-close,1-open
    BYTE        byBroadcastSSID;//whether use SSID broadcast 0-close,1-open
    BYTE        bySecurityMode;//security mode, 0- not-encrypted,1-WPA,2-WPA2(now only support 2)
    BYTE        byAlgorithmType; //algorithm type 1-TKIP,2-AES
    char        szSSID[MAX_SSID_LEN/*32*/];//ssid
    char        szPassWord[MAX_WS_PASSWD_LEN/*64*/]; //passwd
    BYTE        byDefaultPassword;//whether default password 0-no,1-yes
    BYTE      	byWifiApModeType;//Enable WlanAP Hotspot Mode 0-Close 1-Open 2-Automation
    BYTE        byRes[254];
}NET_DVR_WIRELESSSERVER,*LPNET_DVR_WIRELESSSERVER;

typedef    struct tagNET_DVR_CONNECTDEV_COND
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byRes[128];
}NET_DVR_CONNECTDEV_COND,*LPNET_DVR_CONNECTDEV_COND;

typedef    struct tagNET_DVR_CONNECTDEV_CFG
{
    DWORD       dwSize;
    BYTE        byID;//serial number
    BYTE        byRes[1];
    BYTE        byMACAddr[MACADDR_LEN/*6*/];    //mac address
    NET_DVR_IPADDR    struDVRIP;//DVR ip
    NET_DVR_TIME  struConnectTime;// connect time
    BYTE        byRes1[256];
}NET_DVR_CONNECTDEV_CFG,*LPNET_DVR_CONNECTDEV_CFG;

#define MAX_SIGNAL_JOINT_NUM       64  //max signal joint scale
typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
    DWORD    dwSize;
    BYTE  sCamName[NAME_LEN] ;  //joint signal name
    BYTE  byEnable;               //enabled,0-disabled,!0-enabled
    BYTE  byCamMode ;            //joint signal type,NET_DVR_CAM_JOINT
    BYTE  byRows ;               //row number
    BYTE  byColumns ;            //column number
    DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //signal No.,former byRows* byColumns items are valid
    DWORD dwJointNo;           //joint No., read only
    DWORD dwSignalNoJoint;      //joint signal No.,read only
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
    DWORD    dwSize;
    DWORD    dwSignalNo;     //signal No. 
    DWORD     dwCutTop;      //top pixels,0-restore
    DWORD      dwCutBottom;   //bottom pixels,0-restore
    DWORD      dwCutLeft;     //left pixels,0-restore
    DWORD      dwCutRight;    //right pixels,0-restore
    BYTE     byRes2[32];  
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM; 

typedef struct tagNET_DVR_WALL_RELATION_CFG 
{
    DWORD dwSize; 
    BYTE  byEnable;           //enable relation,0-disabled,
    BYTE  byRealWallNo ;        //real wall No.
    BYTE  byRes[14] ; 
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;


typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
    DWORD        dwSize ;
    BYTE        byValid ;     //0-invalid,!0-validNET_DVR_DISPLAYPARAM
    BYTE        byCamMode ;//reference to NET_DVR_CAM_MODE
    WORD        wInputNo ; //input signal No.
    BYTE        sCamName[NAME_LEN] ; //signal name
    NET_DVR_VIDEOEFFECT     struVideoEffect ;//video effect parameters
    NET_DVR_PU_STREAM_CFG    struPuStream ;    //ip signal configurations
    WORD        wBoardNum ;      //sub board No.,read only
    WORD        wInputIdxOnBoard ; //index of signal in sub board,read only
    DWORD    dwResolution ;//resolution
    BYTE    byVideoFormat ;//video format, reference to VIDEO_STANDARD
    BYTE    byStatus;    //signal status,0-invalid, 1-signal normal, 2-no signal, 3-exception 
    BYTE    sGroupName[NAME_LEN/*32*/];    //signal group name
    BYTE    byJointMatrix ;            //relate matrix,0-not related,1-related,valid when signal type is NET_DVR_CAM_BNC or NET_DVR_CAM_VGA or NET_DVR_CAM_DVI or NET_DVR_CAM_HDMI
    BYTE    byJointNo ;         //joint No.,read only
    BYTE    byColorMode;      //color mode, 0-self define, 1-sharp, 2-normal, 3-soft,struVideoEffect is valid when color mode is self define
    BYTE    byScreenServer; //related to screen server,0-not related,1-related
    BYTE    byDevNo;
    BYTE    byRes1;
    DWORD    dwInputSignalNo; //input signal No.(new)
    BYTE    byVideoEnctype;
    BYTE    byAudioEnctype;
    BYTE     byWallStatus;    //Signal source wall status: 0-res 1-already walled 2- not walled
    BYTE    byRes[117];
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct tagNET_DVR_AUDIO_CONTROL_INFO
{
    DWORD   dwSize;
    DWORD dwMonId;
    BYTE  bySubWindowNum;
    BYTE    byWallNo; 
    BYTE   byEnable; //audio switch,0-off,1-on
    BYTE byRes[13];
}NET_DVR_AUDIO_CONTROL_INFO, *LPNET_DVR_AUDIO_CONTROL_INFO;



typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM 
{
    DWORD    dwSize;
    WORD     wPTZProtocol;  //PTZ control protocol 
    BYTE     byRes[34];    
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM;

typedef struct tagNET_DVR_GIS_SERVER_INFO
{
    BYTE  byUserName[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struServerIP;     //GIS server IP address
    WORD  wPort;    //GIS server port
    BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
    DWORD dwSize;
    BYTE  byEnable;        //whether show base map,1-show,0-hide    
    BYTE  byBaseMapType;    //base map type,1-picture,2-virtual screen,3-GIS
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     /*base map No. ,Base map type 1:picture No;Basemap type 2:virtual screen input No.(1byte:video platform No.
    +1byte:sub board No.+1byte:input No.+1byte:0)*/
    NET_DVR_GIS_SERVER_INFO struGisServer;    //GIS server information,valid when base map type is GIS
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;


typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{    
    DWORD        dwSize;                   
    INT64       i64Capacity;             
    INT64        i64UsedSpace;            
    INT64        i64AvailableSpace;        
    BYTE          byRes[256];    
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{    
    DWORD        dwSize;               
    INT64       i64FileLen;             
    BYTE          byRes[256];        
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char        szFileID[MAX_FILE_ID_LEN];    
    BYTE        byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;



typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64    i64FileLen;        
    BYTE    byContinueUpload;
    BYTE       byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;


typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char    szFileID[MAX_FILE_ID_LEN];    
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;



typedef struct tagNET_DVR_SEND_PARAM_IN
{
    BYTE    *pSendData;        
    DWORD    dwSendDataLen;    
    NET_DVR_TIME_V30    struTime;
    BYTE    byPicType;  //1-jpg,2-bmp,3-png,4-SWF,5-GIF
    BYTE    byPicURL;   //picture With URL:0-Binary image data,1-URL
    BYTE    byUploadModeling;//upload modeling 0-binary 1-modeling data encrypted by base64
    BYTE    byRes1;
    DWORD   dwPicMangeNo;
    BYTE    sPicName[NAME_LEN];
    DWORD   dwPicDisplayTime;
    BYTE    *pSendAppendData;       //Send Append Data
    DWORD   dwSendAppendDataLen;    //Send Append Data Len
    BYTE    byRes[192];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;



typedef struct tagNET_DVR_DOWNLOAD_QOS
{
    DWORD    dwMaxSpeed;  //kbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD         dwType;                    
    BYTE         *pData;                
    DWORD         dwDataLen;            
    void*       pFileInfo;
    DWORD       dwFileInfoLen;
    BYTE        byRes[120];
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef BOOL (*DOWNLOAD_DATA_CB)( LONG lHandle, NET_DOWNLOAD_CB_INFO *pCBInfo, void *pUserData);

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    
    void                 *pUserData;        
    INT64                i64Offset;            
    BYTE                   byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

#define  NET_SDK_MAX_FILE_NAME 100  //Maximum file name 

typedef struct tagNET_DVR_UPLOAD_FILEVOLUME_PRARAM_
{
    DWORD    dwSize;
    BYTE     byFileType;  //file type 0 - video, 1 - audio
    BYTE     byFileVolnumeID;   //file volume ID (available through NET_DVR_GET_HDVOLUME_CFG) 
    BYTE     byArchive;  //0- not archive, 1- archive
    BYTE     byRes1;
    DWORD    dwFileSize;    //file size 
    char     szFileName[NET_SDK_MAX_FILE_NAME/*100*/];   //file name 
    BYTE     byRes[300];
}NET_DVR_UPLOAD_FILEVOLUME_PRARAM, *LPNET_DVR_UPLOAD_FILEVOLUME_PRARAM;

typedef struct tagNET_DVR_DOWNLOAD_FILEVOLUME_PARAM_
{
    DWORD     dwSize;
    BYTE       sUrl[MAX_UPLOADFILE_URL_LEN/*240*/];   //url
    BYTE       byRes[248];
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //Download data callback function 
    void         *pUserData;            //user parameter
}NET_DVR_DOWNLOAD_FILEVOLUME_PARAM, *LPNET_DVR_DOWNLOAD_FILEVOLUME_PARAM;

//Film Mode Cfg
typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD   dwSize;          
    BYTE    byScreenType;     //Screen Type
    BYTE    byRes[255];     
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

//Directed Strategy Cfg
typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;  
    BYTE     byDirectedStrategyType; //Directed Strategy Type
    BYTE     byRes[255];    
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

//Frame 
typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; //Frame Wide
    BYTE     byRed;   //Red
    BYTE     byGreen; //Green
    BYTE     byBlue;  //Blue
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

//Frame Cfg
typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;          
    NET_DVR_FRAME    struTopFrame;    //Top Frame
    NET_DVR_FRAME    struBottomFrame;//Bottom Frame
    NET_DVR_FRAME    struLeftFrame;    //Left Frame
    NET_DVR_FRAME    struRightFrame;    //Right Frame
    BYTE            byFrameEnable;  //Frame Enable
    BYTE            byRes[256];    
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

//Frame Cond
typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//picture No.
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

//Audio Effective Cfg
typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;          
    DWORD       dwCheckDelay;    //Check Delay
    BYTE        byThreshold;     //Threshold [0,100]
    BYTE        byVolumePercent;//Volume [0,100]
    BYTE        byPriority;     //Priority [0,100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

//Record Video Cfg
typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;          
    BYTE        byExportType;         //Export Type;0-MP4 1-AVI
    BYTE        byRes[255];       
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byStreamType;  //Stream Type
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

//RTMP Cfg
typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD       dwSize;                          
    BYTE        byEnable;                        //Enable
    BYTE         byRes1[3];
    DWORD       dwPacketLen;                     //Packet Len
    char        szURL[RTMP_URL_LEN];            //RTMP URL
    BYTE         byRes[256];              
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;

//File release
typedef  struct  tagNET_DVR_RECORDING_PUBLISH_FILE_CFG
{
    DWORD   dwSize;                        
    BYTE    byFileID[MAX_ID_LEN_128/*128*/];  //File ID
    NET_DVR_TIME_EX  struStartTime;  //Start Time
    NET_DVR_TIME_EX  struEndTime;   //End Time
    BYTE    byCmdType;  //Cmd Type
    BYTE    byFileType;  //Publish file type  0-reverse 1-timed course 2-manual course
    BYTE   byRes[254];
}NET_DVR_RECORDING_PUBLISH_FILE_CFG, *LPNET_DVR_RECORDING_PUBLISH_FILE_CFG;

//File release Progress Cond
typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //File ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

//File release Progress Cfg
typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;      
    BYTE     byPublishPercent;     //Publish Percent
    BYTE     byPublishStatus;     //Publish Status
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;

//Delete  BackGround Picture
typedef  struct  tagNET_DVR_BACKGROUND_PIC_COND
{
    DWORD    dwSize;  
    char     szFileID[MAX_ID_LEN_128/*128*/];        //File ID
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_COND, *LPNET_DVR_BACKGROUND_PIC_COND;

//BackGround Picture Cfg
typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
    DWORD    dwSize;     
    DWORD     dwPicSize;  //BackGround Picture Size
    DWORD     dwPicType;   //Picture Type,YUV:0 JPEG:1
    WORD     wPicWidth;   //Picture Width
    WORD     wPicHeight;    //Picture Height
    BYTE          byPicName[MAX_PIC_NAME_LEN/*128*/];
    BYTE         byRes[128];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

//BackGround Picture Info
typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;                
    BYTE    byEnable;             //Enable
    BYTE    byRes1[3];
    BYTE    byPicID[MAX_ID_LEN_128/*128*/];
    BYTE    byRes[300];        
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;

//Updata BackGround Picture Praram
typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
    DWORD       dwSize;
    DWORD        dwChannel; //Channel
    DWORD        dwPicSize;  //Picture Size
    WORD        wPicWidth;   //Picture Width
    WORD           wPicHeight;    //Picture Height
    char          szPicName[MAX_PIC_NAME_LEN/*128*/];   //Picture Name
    BYTE        byPicType;   //Picture Type,YUV:0 JPEG:1
    BYTE        byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;

//Low Power
typedef    struct tagNET_DVR_LOWPOWER
{
    DWORD        dwSize;
    BYTE          byMode;//Mode 0-Manual, 1- timing
    BYTE        byEnabled;//Enabled
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//Time interval    
    BYTE        byRes1[256];
}NET_DVR_LOWPOWER,*LPNET_DVR_LOWPOWER;

//Zoom linkage
typedef    struct tagNET_DVR_ZOOMLINKAGE
{
    DWORD        dwSize;
    BYTE          byEnable;//Enable 0-disable,1-Enable
    BYTE       byRes[255];
}NET_DVR_ZOOMLINKAGE,*LPNET_DVR_ZOOMLINKAGE;

typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-not upgrading,1-upgrading,2-upgrade success,3-language mismatch,4-write falsh error,5-package type mismatch,6-package version mismatch,
                            //7-network error,8-upgrade server error,9-read package error,10-no package,11-package error,12-no memory,0xff-unknown error
    BYTE    byProgress; //progress,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;

typedef    struct tagNET_DVR_FIRMWARECODE_COND
{
    DWORD  dwSize;
    DWORD  dwStartIndex;    //start index
    DWORD  dwMaxNum;    //max number once search
    BYTE   byRes[52];
}NET_DVR_FIRMWARECODE_COND,*LPNET_DVR_FIRMWARECODE_COND;

typedef    struct    tagNET_DVR_FIRMWARECODE
{
    WORD  wIndex;
    WORD  wCodeLen;    //firmware code length
    BYTE  byCode[MAX_IDCODE_LEN];//firmware code
    BYTE  byVersion[MAX_VERSIIN_LEN];//firmware version
    BYTE  byRes[12];
}NET_DVR_FIRMWARECODE,*LPNET_DVR_FIRMWARECODE;

typedef    struct    tagNET_DVR_FIRMWARECODE_LIST
{
    DWORD  dwSize;
    DWORD  dwValidCodeNum;    //valid firmware code number
    NET_DVR_FIRMWARECODE  struCode[MAX_IDCODE_NUM];
    BYTE   byRes[64];
}NET_DVR_FIRMWARECODE_LIST,*LPNET_DVR_FIRMWARECODE_LIST;

typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER 
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-not connected,1-connected
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //check from server,0-no,1-yes
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //new version available,0-no,1-yes
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //new version
    BYTE   byChangeLog[SDK_LEN_2048];  //new version change log
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN]; 
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //recommen upgrade,0-no,1-yes
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;

//Thscreen Cfg
typedef    struct tagNET_DVR_THSCREEN
{
    DWORD  dwSize;
    BYTE   byEnable;//Enable
    BYTE   byTHOSDDisplay;//OSD Display
    BYTE   byRes[2]; 
    NET_VCA_POINT   struTHOSDPoint;//OSD Point
    BYTE   byTimingMode;//Timing Mode
    BYTE   byRes1;
    WORD   wInterval;//Interval; [1,10080]m
    BYTE   byRes2[254];
}NET_DVR_THSCREEN,*LPNET_DVR_THSCREEN;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT
{
    DWORD        dwSize;
    BYTE     byType;//Adjustment mode:0-UpDown,1-LeftRight,2-rotation,3-fieldAngle,4-RGB,5-brightness,6-RGB_Ex
    BYTE     bySensorNo;//Sensor No[1,8]
    BYTE     byRes[2];
    int    iAdjustMentRange;//AdjustMent Range [-100,100] rotation[-30,30] fieldAngle[-10,10]
    BYTE     byR;//RGB para,R(red),0-100
    BYTE     byG;//RGB para,G(green),0-100
    BYTE     byB;//RGB para,B(blue),0-100
    BYTE     byRgbType;//RGB type,0-res,1-production,2-manual
    BYTE     byBrightness;//Brightness, Range 0-100,default 50
    BYTE     byRes1[3];
    WORD    wRex;//RGB para(extend),R(red),0-2048
    WORD    wGex;//RGB para(extend),R(red),0-2048
    WORD    wBex;//RGB para(extend),R(red),0-2048
    BYTE     byRes2[114];
}NET_DVR_SENSOR_ADJUSTMENT,*LPNET_DVR_SENSOR_ADJUSTMENT;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT_INFO
{
    DWORD        dwSize;
    int      iPan;//UpDown
    int      iTilt;//LeftRight
    int      iRotation;//rotation
    int      iFieldAngle;//fieldAngle
    BYTE     byR;//R,0-100
    BYTE     byG;//G,0-100
    BYTE     byB;//B,0-100
    BYTE     byRgbType;//RGB type, 0- reservation, 1- line mode, 2- manual mode
    BYTE     byBrightness;//Brightness, Range 0-100,default 50
    BYTE     byRes[3];
    WORD   wRex;//RGB para(extend),R(red),0-2048
    WORD   wGex;//RGB para(extend),R(red),0-2048
    WORD   wBex;//RGB para(extend),R(red),0-2048
    BYTE     byRes1[114];;
}NET_DVR_SENSOR_ADJUSTMENT_INFO,*LPNET_DVR_SENSOR_ADJUSTMENT_INFO;

typedef    struct tagNET_DVR_SENSOR_RESET
{
    DWORD        dwSize;
    BYTE     bySensorNo;//Sensor No[1,8]
    BYTE     byRes[127];
}NET_DVR_SENSOR_RESET,*LPNET_DVR_SENSOR_RESET;

typedef    struct tagNET_DVR_PANORAMAIMAGE
{
    DWORD    dwSize;
    BYTE     byFusionMode;//mode:0-original,1-panorama
    BYTE     byPreviewMode;// model: 1 - tracking, 2 - fixed display
    BYTE     byRes[126];
}NET_DVR_PANORAMAIMAGE,*LPNET_DVR_PANORAMAIMAGE;

typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD        dwSize;
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];     
    WORD        wPort;         
    BYTE        byRes[254] ;       
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_POINT
{
    DWORD dwX;    
    DWORD dwY;    
}NET_DVR_POINT, *LPNET_DVR_POINT;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
    DWORD dwSize;
    BYTE byEnabled;    
    BYTE byRes1[3];
    NET_DVR_POINT struRegion[RECT_POINT_NUM];
    DWORD dwOutputWidth;
    DWORD dwOutputHeight;
    BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
    DWORD dwSize;
    BYTE  byAnswerType; 
    BYTE  byProtocolType;    
    BYTE byTransmissionProtocol; //Transport protocol type, 0-invalid, 1-tcp, 2-udp 
    BYTE byRes[29];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    DWORD dwCallRate;//32~6144Kbps
    BYTE  byRes[124];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;     
    BYTE byVolume;   
    BYTE byAudioInputDisabled;  
    BYTE byAudioInputVolume;    
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef struct tagNET_DVR_HOWLING_SUPPRESSION
{
    BYTE    byEnabled;  
    BYTE    byHsSensibility;    
    BYTE    byHsMode;   
    BYTE    byRes1;
    DWORD dwHsTime; 
    BYTE    byRes2[16];
}NET_DVR_HOWLING_SUPPRESSION, *LPNET_DVR_HOWLING_SUPPRESSION;

typedef struct tagNET_DVR_TERMINAL_INPUT_AUDIO
{
    DWORD dwChannel; 
    BYTE   byGainType; 
    BYTE   byEnableSimulate; 
    BYTE   byVolumeSimulate; 
    BYTE   byEnableDigital; 
    BYTE   byVolumeDigital;  
    BYTE   byRes1[3];
    NET_DVR_HOWLING_SUPPRESSION struHsParam;
    BYTE   byRes[604];
}NET_DVR_TERMINAL_INPUT_AUDIO, *LPNET_DVR_TERMINAL_INPUT_AUDIO;


typedef union tagNET_DVR_TERMINAL_DETAIL_CTRL_PARAM
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struCallInfo;
    NET_DVR_TERMINAL_AUDIO_CTRL struAudioCtrl;
    NET_DVR_TERMINAL_INPUT_AUDIO struInputAudio;
}NET_DVR_TERMINAL_DETAIL_CTRL_PARAM, *LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;    
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;  
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;


typedef struct tagNET_DVR_POS_INFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byPosInfoOverlayEnable;// Pos superposition of information code flow control, 0 - don't stack, 1 - stack 
    BYTE    byOverlayType;//0-inOut/OUT,1-inOutPassIdHeight
    BYTE    byRes[126];
}NET_DVR_POS_INFO_OVERLAY, *LPNET_DVR_POS_INFO_OVERLAY;


typedef struct tagNET_DVR_CAMERA_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode;//Working mode, 0 to normal mode, 1 - factory calibration model 
    BYTE  byPreviewImageMode;//Preview image pattern, 0 - left eye image, 1 - in the right eye image, 2 - or so superimposed images 
    BYTE byRes[126];
}NET_DVR_CAMERA_WORK_MODE, *LPNET_DVR_CAMERA_WORK_MODE;

typedef struct tagNET_DVR_VCA_VERSION_LIST
{
    DWORD    dwSize;
    NET_DVR_VCA_VERSION  struVcaVersion[NET_SDK_VERSION_LIST_LEN/*64*/];//Algorithm library version information
    BYTE    byRes[128];
}NET_DVR_VCA_VERSION_LIST, *LPNET_DVR_VCA_VERSION_LIST;

typedef struct tagNET_DVR_SETUP_CALIB_COND
{
    DWORD dwSize;
    BYTE  byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration, 3-smart calibration
    BYTE  byRes1[3];
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees, effective when byCalibrateType is 2 
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees, effective when byCalibrateType is 2
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, effective when byCalibrateType is 2
    NET_VCA_POLYGON struAutoCalibPolygon;//Automatic calibration area, effective when byCalibrateType is 1 
    BYTE byIntelligentType;//The calibration of the intelligent type, 0 - retention, 1 - passenger flow, 2 - human attributes, 3 - behavior analysis; only in the calibration of the passenger flow of data returned by NET_DVR_SETUP_CALIB_RESULT is valid
    BYTE byRes[127];
}NET_DVR_SETUP_CALIB_COND, *LPNET_DVR_SETUP_CALIB_COND;

typedef struct tagNET_DVR_SETUP_CALIB_RESULT
{
    DWORD dwSize;
    BYTE  byCalibrateType;//1 calibration type, 0 - without the need for automatic calibration, 2 - manual calibration 
    BYTE  byRes1[3];
    float fTiltAngle;//Pitching Angle, unit: degree; Pitching Angle default: 0; Pitching Angle range: 0-180 degrees, effective when byCalibrateType is 2 
    float fHeelAngle;//Tilt Angle, the unit: degree; Default: 0 slope Angle; Angle range: - 90-90 degrees, effective when byCalibrateType is 2 
    float fHeight;//Height, height unit: cm long; Range of height default value is 300 cm, height: 200-500 cm, effective when byCalibrateType is 2 
    NET_VCA_POLYGON struCountPolygon;//Count area 
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // Direction of flow to 
    NET_VCA_LINE  struLine;//detection line
    BYTE byRes[128];
}NET_DVR_SETUP_CALIB_RESULT, *LPNET_DVR_SETUP_CALIB_RESULT;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN];
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;  
    BYTE byCallType;   
    BYTE byRes1[3];
    DWORD dwMaxResults; 
    DWORD dwSearchPos;  
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;    
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN];
    BYTE byAddressURL[MAX_URL_LEN]; 
    NET_DVR_TIME struStartTime; 
    NET_DVR_TIME struEndTime;   
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef enum tagCALL_QUERY_RESULT_STATUS
{
    CALL_QUERY_RESULT_OK = 0,     
    CALL_QUERY_RESULT_FAIL,      
    CALL_QUERY_RESULT_MORE,     
    CALL_QUERY_RESULT_NOMATCH,  
    CALL_QUERY_RESULT_PARAMERROR, 
    CALL_QUERY_RESULT_INVALIDTIME,  
    CALL_QUERY_RESULT_TIMEOUT,   
}CALL_QUERY_RESULT_STATUS;

typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; 
    BYTE   byStatus;  
    BYTE   byRes[3];  
    DWORD dwCount; 
    BYTE *pResults; 
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN]; 
    BYTE byConferenceName[NAME_LEN];
    NET_DVR_TIME struStartTime;        
    NET_DVR_TIME struEndTime;
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;

typedef union tagNET_DVR_CALL_INFO
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struTerminalCallInfo;  
    NET_DVR_CONFERENCE_CALL_INFO struConferenceCallInfo;  
}NET_DVR_CALL_INFO, *LPNET_DVR_CALL_INFO;

typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
    DWORD dwSize;
    BYTE  byAlarmType;  
    BYTE  byCallType;  
    BYTE  byAutoAnswer;
    BYTE  byCallStatusSwitch; 
    NET_DVR_CALL_INFO struCallInfo;
    BYTE  byRes2[32];    
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;    
    BYTE  byStreamType;//Stream type :0 - main stream,1 - sub stream,2 - three stream
    BYTE  byRes[31];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;    
    BYTE byVolume; 
    BYTE byAudioInputDisabled;
    BYTE byAudioInputVolume; 
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState; 
    BYTE byConferenceType; 
    BYTE byDualStreamEnabled;
    BYTE byMicPowerEnabled;    
    DWORD dwInputNo;   
    NET_DVR_CALL_INFO struCallInfo; 
    NET_DVR_AUDIO_STATUS struAudioStatus;  
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
    DWORD dwSize;
    BYTE  byEnableRoam;
    BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE  byEnableZoom;       //zoom enable, 0-disable, 1-enable
    BYTE  byAutoCutBlackEdge; //auto cut black edge enable, 0-disable, 1-enable
    BYTE  byRes1[2];
    WORD  wLEDWidth;          //resolution width
    WORD  wLEDHeight;         //resolution height
    DWORD dwRefreshRate;      //refresh rate
    DWORD dwInputNO;          //related input number
    BYTE  byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //enable, 0-disable, 1-enable
    BYTE  byRes1[3];
    DWORD dwPortNum;    //port number
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM]; //port list
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //row number
    WORD wColumn; //column number
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD   dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo; //the starting position of the display area (receive card row and column number)
    WORD    wWidth;         //the number of horizontal receive card
    WORD    wHeight;        //the number of vertical receive card
    WORD     wRecvCardWidth; //receive card width
    WORD    wRecvCardHeigt; //receive card height
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //receive card position
    WORD wRecvCardWidth;              //receive card width
    WORD wRecvCardHeigt;              //receive card height
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;      //backup enable, 0-disable, 1-enable
    BYTE byPortMode;  //port mode, 1-main, 2-backup
    BYTE byRes1[2];
    DWORD dwPairPort; //pair port
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //port enable, 0-disable, 1-enable
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup; //port backup parameters
    DWORD dwRecvCardNum; //the number of receive card connected to this card 
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM]; //the receiving card information
    DWORD dwPortNo; //the port number, access to all ports parameters effectively 
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp; //color temperature parameters 
    NET_DVR_VIDEO_OUT_CFG struVoutCfg; //display parameters 
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;        //Whether to enable the test signal, 0 - is not enabled, 1 - to enable 
    BYTE bySignalType;    //Test signal type, 1 - striped, 2 - corrugated, 3 - lattice striped, 4 - box, 5 - horizontal and vertical gray-scale consortium, 6 - board, 0xff - custom color 
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor; //signal color, when test signal type is 0xff, it is available 
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode; //no signal display mode, 1 - black screen, 2 - display manufacturer LOGO, 3 - display a custom image 
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;    //Wide input resolution, read-only
    DWORD dwResolutionHeight;    //Input high resolution, read-only 
    DWORD dwRefreshRate;        //The input signal refresh rate, read-only
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA signal parameters, VGA input is adjustable
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo; //Output numbering 
    NET_DVR_LINE_COLUMN_INFO struPosStart; //Receiving card starting position 
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //Receiving end position 
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;
    NET_DVR_LINE_COLUMN_INFO struPosStart;
    NET_DVR_LINE_COLUMN_INFO struPosEnd;
    BYTE byGammaType;
    BYTE byRes[31];
}NET_DVR_LED_GAMMA_CFG_COND, *LPNET_DVR_LED_GAMMA_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];
    BYTE byGammaModel;
    BYTE byRes[127];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;       //Transmission DCLK clock frequency, the actual value multiplied 10, unit: MHz, actual value range 1.0 - 31.3
    DWORD dwGclkRate;       //GCLK refresh the clock frequency, the actual value multiplied 10 units: MHz, actual value range 1.0 - 31.3 
    DWORD dwGclkCountNum;  //300ns GCLK count 
    BYTE  byDclkDutyRatio; //DCLK clock duty cycle, value: 25, 50, 75
    BYTE  byDclkPhase;       //DCLK phase, values: 0, 1, 2, 3 
    BYTE  byGclkNum;       //Number of effective GCLK refresh line 1, range 0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;    //The clock related parameters 
    BYTE byGrayLevel;               //The clock related parameters to gray-scale, values, 13, 14
    BYTE byRefreshRate;               //The refresh rate, a value of 1-6 
    BYTE byLineScanNum;               //The number of line scan, 0-255
    BYTE byRefreshCompleteGrayNum; //Refresh the full number of gray-scale, 0-255 
    DWORD dwHBlank;                   //Row blanking time, unit: GCLK clock number, value of 1-65535 
    DWORD dwAfterglowCtrl;           //Light control over time, the unit: GCLK clock number, value of 1-65535
    DWORD dwLineFeedTime;           //Break time, the unit: GCLK clock number, value of 1-65535 
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;        //chip 1 high byte 
    BYTE byChip1Low;        //chip 1 low byte
    BYTE byChip2High;        //chip 2 high byte 
    BYTE byChip2Low;        //chip 2 low byte
    BYTE byChip3High;        //chip 3 high byte
    BYTE byChip3Low;        //chip 3 low byte
    BYTE byChip4High;       //chip 4 high byte
    BYTE byChip4Low;        //chip 4 low byte
    BYTE byChip5High;       //chip 5 high byte
    BYTE byChip5Low;        //chip 5 low byte
    BYTE byChip6High;       //chip 6 high byte
    BYTE byChip6Low;        //chip 6 low byte
    BYTE byRes[4];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;    //The ghost to eliminate class, 0 to 5 
    BYTE byEliminateShadowy;            //Dull by the first sweep to eliminate class, 0-15 
    BYTE byGrayEqualize1;                //Low ash color compensation 1, 0 to 3
    BYTE byGrayEqualize2;                //Low ash color compensation 2, 0 to 15
    BYTE byEnableGrayUniformity;        //Low ash uniformity of ascension is open, 0 - close, 1 - to open 
    BYTE byDisableHGrayStripes;            //Low ash horizontal stripes eliminate whether open, 0 - close, 1 - to open 
    BYTE byGhostShadowEnhancedMode1;    //The ghost to eliminate enhanced mode 1 is open, 0 - close, 1 - to open 
    BYTE byGhostShadowEnhancedMode2;    //The ghost to eliminate enhanced mode 2 is open, 0 - close, 1 - to open 
    BYTE byClearBadPoint;                //Get rid of the bad point can make, 0 - can not make, 1 - can make 
    BYTE byEnableSelfDefineRegistor;    //Whether to enable custom register values, 0 - disable, 1 - enable 
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue; //The custom register parameters 
    BYTE    byEnabledExGradientOptimition; 
    BYTE    byDummyGClockCycle; 
    BYTE    byDummyGClockHighTime;
    BYTE    byFirstGClockExtendedTime;
    BYTE byRes[28];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
    DWORD dwSize;
    NET_DVR_LED_RECV_REGISTOR struFirstRegistor;    //The first group to receive card advanced parameters, custom register values for red chip register values
    NET_DVR_LED_RECV_REGISTOR struSecondRegistor;    //The second group receiving card advanced parameters, the custom value for the green chip registers values
    NET_DVR_LED_RECV_REGISTOR struThirdRegistor;    //The third group received card advanced parameters, the custom value for blue chip registers values
    BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

typedef struct tagNET_DVR_LED_CHECK_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;   //output no
    NET_DVR_LINE_COLUMN_INFO struPosStart;
    BYTE byStartPosType; //start position type,0-use Column info,1-use x,y coordinate
    BYTE byRes1[3];
    DWORD dwXCoordinate;    /*x coordinate*/
    DWORD dwYCoordinate;    /*Y cooridnate*/
    DWORD dwWidth;          /*area width*/
    DWORD dwHeight;          /*area height*/
    BYTE  byRes[8];
}NET_DVR_LED_CHECK_COND, *LPNET_DVR_LED_CHECK_COND;


enum  ADDR_QUERY_TYPE
{
    QUERYSVR_BY_COUNTRYID = 0,    //query by country id
    QUERYSVR_BY_SERVERTYPE = 1, //not use
    QUERYDEV_BY_NICKNAME_DDNS = 2, //query device info from ddns by nickname
    QUERYDEV_BY_SERIAL_DDNS = 3,    //query device info from ddns by serial no.
    CHECKDEV_BY_NICKNAME_DDNS = 4,//check device info from ddns by nickname
    CHECKDEV_BY_SERIAL_DDNS = 5,    //check device info from ddns by serial no.
    QUERYDEV_BY_NICKNAME_IPSERVER = 6, //query device info from ipserver by nickname
    QUERYDEV_BY_SERIAL_IPSERVER = 7    //query device info from ipserver by serial no.
};
#define    CLIENT_VERSION_LEN    64
//condition struct for QUERYSVR_BY_COUNTRYID
typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD    wCountryID;    //country id
    char    szSvrAddr[MAX_DOMAIN_NAME];//center server address
    char    szClientVersion[CLIENT_VERSION_LEN];//client version,eg:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;
//result struct for QUERYSVR_BY_COUNTRYID
typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    char    szAlarmSvrAddr[MAX_DOMAIN_NAME];//alarm server address
    BYTE    byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_COND
{
    WORD    wSvrType;    
    char    szSvrAddr[MAX_DOMAIN_NAME];
    char    szClientVersion[CLIENT_VERSION_LEN];
    BYTE    byRes[382];
}NET_DVR_QUERY_SERVERTYPE_COND, *LPNET_DVR_QUERY_SERVERTYPE_COND;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_RET
{
    char    szSvrAddr[MAX_DOMAIN_NAME];    
    WORD    wSvrPort;    
    BYTE    byRes[446];
}NET_DVR_QUERY_SERVERTYPE_RET, *LPNET_DVR_QUERY_SERVERTYPE_RET;

//condition struct for QUERYDEV_BY_NICKNAME_DDNS/QUERYDEV_BY_SERIAL_DDNS/CHECKDEV_BY_NICKNAME_DDNS/CHECKDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    char    szDevNickName[MAX_DOMAIN_NAME];    //device nickname
    char    szDevSerial[SERIALNO_LEN];    //device serial no.
    char    szClientVersion[CLIENT_VERSION_LEN];//client version,eg:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[272];    
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;

//result struct for QUERYDEV_BY_NICKNAME_DDNS/QUERYDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //device address
    WORD    wCmdPort;        //commad port(sdk port)
    WORD    wHttpPort;        //http port
    BYTE    byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;
//result struct for CHECKDEV_BY_NICKNAME_DDNS/CHECKDEV_BY_SERIAL_DDNS
typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE    byDevStatus;        //device status,0-normal,1-can not find,2-offline,3-not in current area
    BYTE    byRes1;
    NET_DVR_QUERY_DDNS_RET    struQueryRet;    //address information
    WORD    wRegionID;        //device register area no.[1-United States,2-south america,3-asia,4-china,5-europe,6-other] 
    BYTE    byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

//condition struct of query from ipserver
typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//resolve server address
    WORD    wResolveSvrPort;    //resolve server port
    char    szDevNickName[MAX_DOMAIN_NAME];    //device nick name
    char    szDevSerial[SERIALNO_LEN];    //device serial no.
    BYTE    byRes[334];        //
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

//result struct of query from ipserver
typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //device ip address
    WORD    wCmdPort;        //command port
    BYTE    byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //voicetalk channel
    BYTE   byres[32];                    
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;

//Stream Encryption Cond
typedef    struct tagNET_DVR_STREAMENCRYPTION_COND
{
    DWORD     dwSize;  
    DWORD   dwChan;  //Channel
    BYTE     byRes[128];
}NET_DVR_STREAMENCRYPTION_COND, *LPNET_DVR_STREAMENCRYPTION_COND;

//Stream Encryption Cfg
typedef    struct tagNET_DVR_STREAMENCRYPTION_CFG
{
    DWORD     dwSize;    
    BYTE    byEnable;  //Enable
    BYTE       byRes[255];
}NET_DVR_STREAMENCRYPTION_CFG, *LPNET_DVR_STREAMENCRYPTION_CFG;

//Revise GPS Cfg
typedef    struct tagNET_DVR_REVISE_GPS_CFG
{
    DWORD    dwSize;    
    BYTE    byLatitudeType;//Latitude Type,0-North latitude, 1-South latitude
    BYTE    byLongitudeType;//Longitude Type,0-east,1-West
    BYTE    byMode;//Mode Type 0-default,1-auto,2-manual
    BYTE    byRes;
    NET_DVR_LLI_PARAM      struLatitude;     /*Latitude*/
    NET_DVR_LLI_PARAM      struLongitude; /*Longitude*/
    BYTE    byRes1[300];
}NET_DVR_REVISE_GPS_CFG, *LPNET_DVR_REVISE_GPS_CFG;

typedef    struct tagNET_DVR_PDC_RECOMMEND
{
    DWORD       dwSize;
    WORD      wWidth;//Recommend Value[0, 1000]
    BYTE      byRes[126];
}NET_DVR_PDC_RECOMMEND,*LPNET_DVR_PDC_RECOMMEND;

typedef    struct tagNET_DVR_FLASHSTORAGE_REMOVE
{
    DWORD      dwSize;
    DWORD    dwChannel;
    BYTE     byPDCRemoveEnable;//0-false,1-true
    BYTE     byRes[127];
}NET_DVR_FLASHSTORAGE_REMOVE,*LPNET_DVR_FLASHSTORAGE_REMOVE;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

/********************************DS-TME4XX Control machine development Begin****************************/
typedef struct tagNET_DVR_PARKING_CARD
{
    DWORD  dwSize;
    DWORD  dwChannel;//The default is 1 (subsequent compatible multichannel device)
    char  szCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    BYTE  byCardType;//Card Type 0-The temporary card
    BYTE  byCardStatus;//Card Status
    BYTE  byChargeRuleID;//Charge Rule ID
    BYTE  byDelete;//Whether to delete, 0-not delete,1-delete
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

//Entrance card information upload
typedef struct tagNET_DVR_GATE_CARDINFO
{
    DWORD     dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Abs Time
    char    szCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    char    szPassVehicleID[MAX_VEHICLE_ID_LEN];//Unique identifier
    char    szInVehicleID[MAX_VEHICLE_ID_LEN];//Uniquely identifies the export of the entrance
    NET_DVR_TIME_V30  struSwipeTime;//Credit card time
    NET_DVR_TIME_V30  struCardTime;//Card storage time, namely the admission time to write, only on the export of ballot boxes useful, with 0 indicating no admission time
    BYTE    byLetPass;//Import and export clearance mode: 0- does not release (when CardType = = tickets) need to charge, 1- release, 2-The center charges release
    BYTE     byCardType;//Card type 0- fixed card, 1-  temporary card, 2- tickets
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

//loading dock operation info upload
typedef struct _tagNET_LOADING_DOCK_OPERATEINFO_
{
    DWORD   dwSize; //structure length
    BYTE    byAbsTime[32];        //abs Time,yyyymmddhhmmssxxx,e.g.20090810235959999 
    BYTE    byParkingNo[MAX_PARKNO_LEN];//Parking Number
    DWORD   dwIndex;          //Vehicle index
    char    sLicense[MAX_LICENSE_LEN];        //license Number, Note:the  small number is contained in  the Middle East; they is a SPACE between the small number and vehicle number
    BYTE    byCurrentWorkerNumber;//Current Worker Number
    BYTE    byCurrentGoodsLoadingRate;//Current Goods Loading Rate  0-None 1-a few 2-middle 3-many 4-full
    BYTE    byDoorsStatus;//Doors Status 0-closed 1-open
    BYTE    byRes1;
    DWORD   dwBackPicDataLength;//Back Picture Data Length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    BYTE    *pBackPicDataBuffer; //Back Picture Data pointer
#else
    BYTE*   pBackPicDataBuffer; // Back Picture Data pointer
    BYTE  byRes2[4];
#endif
    DWORD   dwChannel;          //Channel number, 0-unsupported (there are old devices that do not support channel number return)
    BYTE    byRes[508];
}NET_LOADING_DOCK_OPERATEINFO, *LPNET_LOADING_DOCK_OPERATEINFO;


//Gate Charge Info(COMM_GATE_CHARGEINFO_UPLOAD)
typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Abs Time
    char  sLicense[MAX_LICENSE_LEN];        //License
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //Departure ID
    char  szEntranceID[32];  //Entrance ID
    DWORD dwTotalCost;   //Total Cost
    char  szOperateName[32]; //Operate Name
    BYTE  byChargeRuleId; //Charge Rule Id
    BYTE  byVehicleType;//Vehicle Type
    BYTE  byRes[127];
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

//Parking card control structure
typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
    DWORD  dwSize;
    DWORD  dwChannel; //Channel
    BYTE  byCardType;//Card Type 0-The temporary card
    BYTE  byDeleteALL;//Whether to delete all 0-not delete,1-delete
    BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;

//TME Vehicle Result
typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //Lane ID;1~32
    BYTE    byCamLaneId; //Camera Lane ID;1~16
    BYTE    byRes1; 
    DWORD   dwChanIndex; //Channel Index
    NET_DVR_PLATE_INFO  struPlateInfo; //Plate Info
    NET_DVR_VEHICLE_INFO struVehicleInfo; //Vehicle Info
    BYTE    byMonitoringSiteID[48]; //Monitoring Site ID
    BYTE    byDeviceID[48]; //Device ID
    BYTE    byDir;     //Monitoring direction
    BYTE    byRes2; 
    WORD    wBackList; //Back List
    DWORD   dwPicNum; //Pictruce Number
    NET_ITS_PICTURE_INFO struPicInfo[4];  //Pictruce Info
    BYTE    byPassVehicleID[32];    //Vehicle ID
    BYTE    byCardNo[48]; // Card No
    BYTE    bySwipeTime[32];//Swipe Time
    DWORD   dwCharge;      //Charge
    BYTE    byHistory;     //History
    BYTE    byLetPass;     //Let Pass
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

//Magnetic Vehicle Manager register info
typedef struct tagNET_DVR_MVMRegisterInfo_
{
    DWORD  dwSize;         //size
    char   sDetectorID;   //detector ID
    char   sManagerID;    //manager ID
    char   sSim[20];       //sim card number
    DWORD  dwLocalIP;      //ipv4 address, such as dwLocalIP=0x01020304,IP is "1.2.3.4"
    DWORD  dwLocalIPMask;  //local net mask, the same format with dwLocalIP
    DWORD  dwLocalGateway; //local net gateway, the same format with dwLocalIP
    DWORD  dwDstIP;        //destination ip address, the same format with dwLocalIP
    BYTE   byMACAddr[6];   //local mac address
    WORD  wLocalPort;     //local port
    WORD  wFirmwareYear;  //year of fireware
    BYTE   byFirmwareMonth;    //month of fireware
    BYTE   byFirmwareDay;  //day of fireware
    BYTE   byMajorVersion; //major version
    BYTE   byMinorVersion; //minor version
    BYTE   byRes[170];
}NET_DVR_MVMRegisterInfo, *LPNET_DVR_MVMRegisterInfo;

//Magnetic status info
typedef struct tagNET_DVR_SingleMagneticStatus_
{
    DWORD  dwSize;             //size
    char  sDetectorID[16];       //detector ID
    char  sManagerID[16];        //manager ID
    char   sParkNum[16];       //parking number
    NET_DVR_TIME_V30 struDetectorTime;  //detection time
    DWORD  dwRssi;             //signal intensity range -137~0dbm,but this is absolute value
    BYTE   byParkinglotState;  //0-empty,1-is not empty
    BYTE   byBatteryState;     //0-100%,1-75%,2-50%,3-25%,4-less 5%
    BYTE   byDeviceState;      //0-normal,1-abnormal
    BYTE   byCMD;              //0-parking changing alarm,1-detector heartbeat
    BYTE   byRes[184];
}NET_DVR_SingleMagneticStatus, *LPNET_DVR_SingleMagneticStatus;

//Parking Vehicle Info
typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    char    szLicense[MAX_LICENSE_LEN/*16*/];//License
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//Card No
    NET_DVR_TIME_V30 struStartTime;//Start Time
    NET_DVR_TIME_V30 struEndTime;//End Time
    BYTE    byVehicleType;//Vehicle Type
    BYTE    byPlateColor;//Plate Color
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;

//The amount of payment information
typedef    struct tagNET_DVR_CHARGEACCOUNT_CFG
{
    DWORD   dwSize;
    float   fAccount;//Account
    BYTE    byRes[128];
}NET_DVR_CHARGEACCOUNT_CFG,*LPNET_DVR_CHARGEACCOUNT_CFG;

//PXMultiCtrl Configuration
typedef    struct tagNET_DVR_PXMULTICTRL_CFG
{
    DWORD        dwSize;
    DWORD        dwMultiChansWaitTime;//Wait Time(1~300s)
    BYTE         byMultiChansCapEnabled;//Enabled
    BYTE        byRes[127];
}NET_DVR_PXMULTICTRL_CFG,*LPNET_DVR_PXMULTICTRL_CFG;

//PX Offline Cfg
typedef    struct tagNET_DVR_PXOFFLINE_CFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//Enabled
    BYTE    byChargeEnabled;//Charge Enabled
    BYTE    byAlarmEnabled;//Alarm Enabled
    BYTE    byRecordSource;//Record Source
    DWORD   dwTimeWait;//Time Wait(1-300s)
    /**
    realeaseMode&(0x1<<0) Fixed the car.
    realeaseMode&(0x1<<1) Release of fixed card
    realeaseMode&(0x1<<2) Temporary vehicle release
    realeaseMode&(0x1<<3) The temporary card
    realeaseMode&(0x1<<4) No license plate
    realeaseMode&(0x1<<5) Fixed vehicle if free will automatically release
    realeaseMode&(0x1<<6) If the temporary car free automatic release 
    */
    DWORD   dwRealeaseMode; //Realease Mode
    BYTE    byVehCardmatch;//Car line card
    BYTE    bySingleInSingleOut;//Single In Single Out 
    BYTE    byRes[126];
}NET_DVR_PXOFFLINE_CFG,*LPNET_DVR_PXOFFLINE_CFG;

typedef    struct tagNET_DVR_PARKINGSAPCE_CFG
{
    DWORD    dwSize;
    DWORD     dwTotalParkingLot;//The total number of parking spaces
    DWORD    dwCurrParkingLot;//The remaining number of parking spaces
    BYTE    byRes[128];
}NET_DVR_PARKINGSAPCE_CFG,*LPNET_DVR_PARKINGSAPCE_CFG;

typedef    struct tagNET_DVR_PAPERCHARGEINFO_CFG
{
    DWORD   dwSize;
    char    szBarCode[LEN_16];//Bar Code
    char    szLicense[MAX_LICENSE_LEN]; //License
    char    szVehicleInTime[LEN_32];//Vehicle In Time(YYYY-MM-DD HH:MM:SS)
    char    szPaymentTime[LEN_32];//Payment Time(YYYY-MM-DD HH:MM:SS)
    float   fPaymentAmount;//Payment Amount
    DWORD   dwPaymentOutFailureTime;//Payment Out Failure Time
    BYTE    byVehicleOutEnabled; //Vehicle Out Enabled
    BYTE    byRes[128];
}NET_DVR_PAPERCHARGEINFO_CFG,*LPNET_DVR_PAPERCHARGEINFO_CFG;

//parking Paper parameters
typedef    struct tagNET_DVR_ILLEGALCARDFILTERING_CFG
{
    DWORD   dwSize;
    char    sLEDDefaultInfo[MAX_LED_INFO_LEN/*512*/]; // LED Default Info
    BYTE    byillegalCardFilteringEnabled;//Illegal Card Filtering Enabled
    BYTE    bySendCardSensingCoilEnabled;//Send Card Sensing Coil Enabled
    BYTE    byWiegendSensingCoilEnabled;//Wiegend Sensing Coil Enabled
    BYTE    byGateSwitchEnabled; //Gate Switch Enabled
    BYTE    byVerifyKeyWriteCardEnabled;//Verify Key Write Card Enabled
    BYTE    byNoplateTakeCardEnabled;// No plate Take Card Enabled
    BYTE    byRes[126];
}NET_DVR_ILLEGALCARDFILTERING_CFG,*LPNET_DVR_ILLEGALCARDFILTERING_CFG;

//Entrance Vehicle Card Cond
typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize; 
    DWORD   dwChannel;  //channel 
    char    szCardNo[32];//Card No
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;

//LED Display Cfg
typedef    struct tagNET_DVR_LEDDISPLAY_CFG
{
    DWORD   dwSize;
    char    sDisplayInfo[MAX_LED_INFO_LEN/*512*/]; // LED Display Info
    BYTE    byDisplayMode;//Display Mode
    BYTE    bySpeedType;//Speed Type
    BYTE    byShowPlateEnable;//Show Plate Enable,0~disable,1~enable
    BYTE    byRes1;
    DWORD   dwShowTime;//Show Time,1~60s
    BYTE    byRes[128];
}NET_DVR_LEDDISPLAY_CFG,*LPNET_DVR_LEDDISPLAY_CFG;

//Voice BroadCast Cfg
typedef    struct tagNET_DVR_VOICEBROADCAST_CFG
{
    DWORD        dwSize;
    char        sInfo[MAX_VOICE_INFO_LEN/*128*/]; //Voice BroadCast Info
    BYTE       byBroadcastNum;// Voice reports, 1~10 times 
    BYTE       byIntervalTime;// Voice time interval, 1~5s 
    BYTE        byRes[126];
}NET_DVR_VOICEBROADCAST_CFG,*LPNET_DVR_VOICEBROADCAST_CFG;

//Prper Print Format Cfg
typedef    struct tagNET_DVR_PAPERPRINTFORMAT_CFG
{
    DWORD        dwSize;
    char        sTitleInfo[MAX_LITLE_INFO_LEN/*64*/]; //Title Info
    char        sCustomInfo[MAX_CUSTOM_INFO_LEN/*64*/]; //Custom Info
    char        sPhoneNum[MAX_PHONE_NUM_LEN/*16*/];//Phone Num
    BYTE        byPrintInTimeEnabled; //Print InTime Enabled
    BYTE        byRes[127];
}NET_DVR_PAPERPRINTFORMAT_CFG,*LPNET_DVR_PAPERPRINTFORMAT_CFG;


//Lock Gate Time Cfg
typedef    struct tagNET_DVR_LOCKGATE_TIME_CFG
{
    char        sBeginTime[LEN_32];//Begin Time(HH:MM:SS)    
    char        sEndTime[LEN_32];//End Time(HH:MM:SS)
    BYTE        byRes[64];
}NET_DVR_LOCKGATE_TIME_CFG,*LPNET_DVR_LOCKGATE_TIME_CFG;

//Lock Gate Cfg
typedef    struct tagNET_DVR_LOCKGATE_CFG
{
    DWORD        dwSize;
    NET_DVR_LOCKGATE_TIME_CFG struTime[4]; //Lock Gate Time Cfg
    BYTE        byRes[128];
}NET_DVR_LOCKGATE_CFG,*LPNET_DVR_LOCKGATE_CFG;

//Parking Data State Info
typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//App Serial Num
    DWORD   dwParkingNum; //Parking Num
    DWORD   dwUpdataSerialNum; //Updata Serial Num
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;

//EPTZ parameter
typedef    struct tagNET_DVR_EPTZ_CFG
{
    DWORD dwSize;
    BYTE    byEnableEPTZ;        //whether enable EPTZ
    BYTE    byRes[503];
}NET_DVR_EPTZ_CFG, *LPNET_DVR_EPTZ_CFG;

//center point parameter
typedef    struct tagNET_DVR_CENTER_POINT_CFG
{
    DWORD dwSize;
    NET_VCA_POLYGON struRegion;
    BYTE    byRes[512];
}NET_DVR_CENTER_POINT_CFG, *LPNET_DVR_CENTER_POINT_CFG;

/********************************DS-TME4XXControl machine development End****************************/

//info publish upgrade 
typedef struct tagNET_DVR_PUBLISH_UPGRADE_COND
{
    DWORD dwSize;
    DWORD dwUpgradeType;    //Upgrade type, 1 - according to the terminal upgrade, upgrade 2 - according to the terminal groups
    DWORD dwTerminalNum;    //Upgrade of terminal format, according to the terminal when upgrading effectively
    DWORD *pTerminalNo;     //Need to upgrade the terminal number, according to the terminal when upgrading effectively
    DWORD dwGroupNo;        //Terminal groups, according to the terminal set is upgrading effectively
    BYTE  byRes[32];
}NET_DVR_PUBLISH_UPGRADE_COND, *LPNET_DVR_PUBLISH_UPGRADE_COND;

typedef struct tagNET_DVR_SUB_UPGRADE_PROGRESS
{
    DWORD dwTerminalNo; //ternmal num
    DWORD dwProgress;   //progress,0-100,101 denote exception,
}NET_DVR_SUB_UPGRADE_PROGRESS, *LPNET_DVR_SUB_UPGRADE_PROGRESS;

typedef struct tagNET_DVR_UPGRADE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress,0-100,According to the schedule for the whole set is gain schedule release schedule, according to the terminal when get progress for a single terminal schedule release schedule
    DWORD  dwSubProgressNum;    //sub progress num
    LPNET_DVR_SUB_UPGRADE_PROGRESS  lpStruSubProgress; //Each terminal schedule release schedule, according to the set of access available at the time,dwSubProgressNum NET_DVR_SUB_SCHEDULE_PROGRESS
    BYTE   byRes[32];
}NET_DVR_UPGRADE_PROGRESS_RESULT, *LPNET_DVR_UPGRADE_PROGRESS_RESULT;



//WEP Key
typedef struct tagNET_DVR_WEP_KEY_CFG
{
    char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//WEP Key, 
    BYTE    byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;


//WEP
typedef struct tagNET_DVR_WEP_CFG
{
    BYTE   byAuthenticationType;//Authentication Type
    BYTE   byDefaultTransmitKeyIndex;//Default Transmit Key Index,1~4
    BYTE   byWepKeyLenType;//Wep Key Length Type;0~   64 bit,1~  128 bit.
    BYTE   byKeyType;// Key Type;0~   ASCII,1~  Hex.
    NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP Key.
    BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

//WPA
typedef struct tagNET_DVR_WPA_CFG
{
    BYTE   byAlgorithmType; //Algorithm Type;0~TKIP, 1~AES, 2~TKIP/AES
    BYTE   byWPAKeyLen;// WPA Key Length,8~63
    BYTE   byDefaultPassword;//Default Password
    BYTE   byRes1;
    char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//Shared Key
    BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;


typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
    BYTE   bySecurityMode; //Security Mode;0~Disable,1~WEP,2~WPA-personal, 3~WPA2-personal
    NET_DVR_WEP_CFG  struWEPCfg; //WEP
    NET_DVR_WPA_CFG  struWPACfg; //WPA
    BYTE    byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

//wifi Cfg (Full Version)
typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD    dwSize;
    BYTE    byWifiAPEnabled;    // Wifi AP
    BYTE    byBroadcastEnabled; //Broadcast
    BYTE    byWlanShareEnabled; //WlanShare
    BYTE    byDHCPEnabled;  // DHCP
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType;  //IP Type, 0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr; // IP Address
    NET_DVR_IPADDR    struIPMask; // IP Mask
    NET_DVR_IPADDR    struGatewayIPMask; // Gateway IP Mask
    NET_DVR_IPADDR    struStartIPAddrPool;  //Start IP Address Pool
    NET_DVR_IPADDR    struEndIPAddrPool;  //End IP Address Pool
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS Server Ip Address
    NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg; // Wireless Security
    BYTE    byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;    //Channel No., 0 is invalid
    BYTE byChannelName[NAME_LEN]; //Channel name 
    BYTE bySignal;  //Signal state,0-no signal,1-signal,read only
    BYTE bySignalType;  //Signal type,1-SD,2-HD,read only
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;    //0-invalid,1-valid
    BYTE  byRes1[3];
    DWORD dwDevNo;    //Optical device No.
    BYTE  byDevName[NAME_LEN];   //Optical device name
    BYTE  byDevID[MAX_ID_LEN];   //Optical device ID
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM]; //Optical device channel information
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

#define MAX_OPTICAL_DEV_NODE 32     //Max node optical device number

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //Signal state,0-no signal,1-signal
    BYTE  byLinkType;    //Link type,1-ring network,2-chain network,read only
    BYTE  byPortWorkMode;    //Port work mode,0-invalid,1-main port,2-auxiliary port,valid for ring network,read only
    BYTE  byRes1[1];
    DWORD dwPairPort;    //Pair port No.,valid for ring network
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //Optical device information
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
    DWORD dwSize;
    BYTE  byEnable;    //weather relate input,0-no,!0-yes
    BYTE  byRes1[3];
    DWORD dwDevNo;    //Optical device No.
    DWORD dwOpticalPort;  //Optical port No.
    BYTE  byDevID[MAX_ID_LEN];   //OPtical device No.
    DWORD dwInputChanNo;  //Optical device input channel No.
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;

//optical fiber LLDP parameter
typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //card No.
    BYTE byPortNo;      //port No.
    BYTE byEnabledTx;   //send LLDP packet enable, 0-disable, 1-enable
    BYTE byEnabledRx;   //receive LLDP packet enable, 0-disable, 1-enable
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //LLDP enable, 0-disable, 1-enable
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //hold time, unit:s
    DWORD dwReiniTime;  //reinitialize time, unit:s
    DWORD dwPacketTime; //packet time, unit:s
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //port LLDP parameter
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

//optical fiber basic parameter
typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //port No., 0-invalid
    BYTE  byPortName[NAME_LEN];  //port name
    BYTE  byWorkMode;            //working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byBandWidth;           //bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byPortType;            //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];           //type name
    BYTE  bySerialNo[SERIALNO_LEN];       //serial No.
    BYTE  bySoftwareVersion[VERSION_LEN]; //software version
    NET_DVR_IPADDR struIPAddr;            //IP
    DWORD dwSlotNo;                          //main slot No.
    BYTE  byStructureType;                //structure type, 1-2U, 2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //net port information
    BYTE  byRes2[32];    
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                       //card No, start from 1
    BYTE  byTypeName[NAME_LEN];           //type name
    BYTE  bySerialNo[SERIALNO_LEN];       //serial No.
    BYTE  bySoftwareVersion[VERSION_LEN]; //software version
    DWORD dwMainSlot;                     //main slot No., start from 1
    BYTE  byStructureType;                //structure type, 1-2U, 2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //port information
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType; //power type, 1-single, 2-double
    BYTE  byRes1[3];
    DWORD dwSlotNum;   //main slot No.
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //net management card information
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //function card information
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

//optical fiber work status parameter
typedef struct tagNET_DVR_CARD_PORT_STATE
{
    BYTE  byValid;                 //valid, 0-invalid, 1-valid
    BYTE  byPortType;            //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byLinkState;           //connection status, 0-disconnected,1-connected
    BYTE  byRes1;
    DWORD dwSendBytes;           //send bytes
    DWORD dwRecvBytes;           //receive bytes
    DWORD dwRecvLostPackets;     //lost packets
    DWORD dwRecvCrcErrPackets;   //CRC error packets
    DWORD dwRecvFragmentPackets; //receive fragments, conflict, and too short byte packets
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
    NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];    //port status  
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
    BYTE  byEnabled; //valid, 0-invalid, 1-valid
    BYTE  byRes1[3];
    DWORD dwCardNo;  //card No.
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];    
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //net management card status
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //function card status
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

//Remote network management FOT 1.0 basic information
typedef struct tagNET_DVR_NETMGR_CARD_INFO_V50
{
    BYTE byMainSlotNo;                    
    BYTE byRes1[3];
    BYTE byTypeName[NAME_LEN];            
    BYTE bySerialNo[SERIALNO_LEN];            
    BYTE bySoftwareVersion[VERSION_LEN];    
    BYTE byHardwareVersion[VERSION_LEN];    
    NET_DVR_IPADDR struIPAddr;                
    NET_DVR_IPADDR struMask;                
    NET_DVR_IPADDR struGateway;                
    BYTE byMacAddr[6];                        
    BYTE bySlotNums;                        
    BYTE byStructureType;                       
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];
    BYTE byRes2[64];
}NET_DVR_NETMGR_CARD_INFO_V50, *LPNET_DVR_NETMGR_CARD_INFO_V50;

typedef struct tagNET_DVR_FUNC_CARD_INFO_V50
{
    BYTE byCardNo;
    BYTE byMainSlotNo;						
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            
    BYTE bySerialNo[SERIALNO_LEN];        
    BYTE bySoftwareVersion[VERSION_LEN];    
    BYTE byIsVerMismatch;                    
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    
    BYTE byHardwareVersion[VERSION_LEN];    
    BYTE bySlotNums;                        
    BYTE byStructureType;                   
    BYTE byRes3[2];
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];
    BYTE byRes4[64];
}NET_DVR_FUNC_CARD_INFO_V50, *LPNET_DVR_FUNC_CARD_INFO_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_INFO_V50
{
    BYTE byCardNo;
    BYTE byMainSlotNo; 							
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            
    BYTE bySoftwareVersion[VERSION_LEN];    
    BYTE byIsVerMismatch;                    
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    
    BYTE byHardwareVersion[VERSION_LEN];    
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];
    BYTE byRes3[64];
}NET_DVR_REMOTE_SEND_CARD_INFO_V50, *LPNET_DVR_REMOTE_SEND_CARD_INFO_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC_V50
{
    DWORD dwSize;
    BYTE byPowerType;    
    BYTE byRes1[3];
    DWORD dwSlotNum;    
    NET_DVR_NETMGR_CARD_INFO_V50 struNetCardInfo;    
    NET_DVR_FUNC_CARD_INFO_V50 struFuncCardInfo[MAX_FUNC_CARD_NUM];    
    NET_DVR_REMOTE_SEND_CARD_INFO_V50 struRemoteSendCardInfo[MAX_FUNC_CARD_NUM];    
    BYTE byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC_V50, *LPNET_DVR_FIBER_CONVERT_BASIC_V50;

//Remote network management FOT 1.0 status information
typedef struct tagNET_DVR_CARD_PORT_STATE_V50
{
    BYTE byPortNo;                    
    BYTE byPortType;              
    BYTE byLinkState;               
    BYTE byPortSpeed;
    BYTE byPortDuplexMode;           
    BYTE byRes1[3];
    BYTE byPortName[NAME_LEN];       
    DWORD dwSendBytes;      
    DWORD dwSendByteSpeed;    
    DWORD dwSendPackets;         
    DWORD dwSendPacketSpeed;
    DWORD dwRecvBytes;      
    DWORD dwRecvByteSpeed;    
    DWORD dwRecvPackets;         
    DWORD dwRecvPacketSpeed;
    DWORD dwRecvLostPackets;        
    DWORD dwRecvCrcErrPackets;         
    DWORD dwRecvFragmentPackets;    
    BYTE byRes2[48];
}NET_DVR_CARD_PORT_STATE_V50, *LPNET_DVR_CARD_PORT_STATE_V50;

typedef struct tagNET_DVR_NET_CARD_STATE_V50
{
    BYTE byMainSlotNo; 
    BYTE byRes1[3];        
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE byRes2[344];
}NET_DVR_NET_CARD_STATE_V50, *LPNET_DVR_NET_CARD_STATE_V50;

typedef struct tagNET_DVR_FUNC_CARD_STATE_V50
{
    BYTE byCardNo;
    BYTE byMainSlotNo; 	
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    
    BYTE byRes2[64];
}NET_DVR_FUNC_CARD_STATE_V50, *LPNET_DVR_FUNC_CARD_STATE_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_STATE_V50
{
    BYTE byCardNo;
    BYTE byMainSlotNo; 
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    
    BYTE byRes[64];
}NET_DVR_REMOTE_SEND_CARD_STATE_V50, *LPNET_DVR_REMOTE_SEND_CARD_STATE_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE_V50
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE_V50 struNetCardState;    
    NET_DVR_FUNC_CARD_STATE_V50 struFuncCardState[MAX_FUNC_CARD_NUM];    
    NET_DVR_REMOTE_SEND_CARD_STATE_V50 struRemoteSendCardState[MAX_FUNC_CARD_NUM];    
    BYTE  byRes[64];
}NET_DVR_FIBER_CONVERT_STATE_V50, *LPNET_DVR_FIBER_CONVERT_STATE_V50;

//optical fiber topology parameter
typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //port No., 0-invalid
    BYTE  byPortType;               //port type, 1-electricity, 2-optical, 3-multiplex
    BYTE  byLocalWorkMode;          //local working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byLocalBandWidth;         //local bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //peer type name
    BYTE  byPeerMac[MACADDR_LEN];   //peer MAC address
    DWORD dwPeerPortNo;             //peer port No.
    BYTE  byPeerWorkMode;           //peer working mode, 1-ACCESS, 2-TRUNK, 3-HYPRID
    BYTE  byPeerBandWidth;          //peer bandwidth, 1-100M, 2-1G, 3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;                    //valid, 0-invalid, 1-valid
    BYTE  byRes1[3];
    DWORD dwCardNo;                 //card No, 0-net management card, non-zero-function card
    DWORD dwSlotNum;                //used slots
    BYTE  byTypeName[NAME_LEN];        //type name
    BYTE  byLocalMac[MACADDR_LEN];  //local MAC address
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //port topology information
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM];
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

//optical fiber port remarks parameter
typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //slot No.
    DWORD dwPortNo; //port No.
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
    DWORD dwSize;
    BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //local port remarks information
    BYTE  byPeerRemarks[MAX_REMARKS_LEN];  //peer port remarks information
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;

typedef enum _EN_FIBER_CONVERT_ALARM
{
    FC_OPTICAL_PORT_LOST = 1,
    FC_ELECTRICAL_PORT_LOST,
    FC_FUNC_CARD_LOST,
    FC_CARD_DISCONNECTED,
    FC_MAX_TEMP_LIMITED,
    FC_MIN_TEMP_LIMITED,
    FC_MAX_VOLTAGE_LIMITED,
    FC_MIN_VOLTAGE_LIMITED,
}EN_FIBER_CONVERT_ALARM;

typedef enum _EN_FIBER_CONVERT_NOTIFICATION
{
    FC_OPTICAL_PORT_CONNECTED = 1,
    FC_ELECTRICAL_PORT_CONNECTED,
    FC_FUNC_CARD_INSERT,
    FC_CARD_CONNECTED,
    FC_TEMP_RECOVERY,
    FC_VOLTAGE_RECOVERY,
}EN_FIBER_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;    
    DWORD dwEvent;      
    BYTE bySlotNum;     
    BYTE byCardType;        
    BYTE byPortNo;      
    BYTE byCurTemperature; 
    WORD wCurVoltage;  
    BYTE byRes1[30];
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;

//switch alarm
typedef enum _EN_SWITCH_CONVERT_ALARM
{
    SC_OPTICAL_PORT_LOST = 1,
    SC_NETWORK_PORT_LOST,
	SC_WIRELESS_SPEED_UP_EXCEPTION,
	SC_WIRELESS_SHUTDOWN,
	SC_DEVICE_POE_MAX,
	SC_PORT_POE_POWER_OFF,
}EN_SWITCH_CONVERT_ALARM;

typedef enum _EN_SWICH_CONVERT_NOTIFICATION
{
    SC_OPTICAL_PORT_CONNECTED = 1,
    SC_NETWORK_PORT_CONNECTED,
	SC_DEVICE_POE_MAX_RECOVERY,
	SC_PORT_POE_POWER_ON,
	SC_WIRELESS_CONNECTED,
}EN_SWITCH_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_SWITCH_CONVERT_ALARM
{
    DWORD dwSize;
    BYTE  byPortNo; 
    BYTE  byPortNoEx;
    BYTE  byRes1[2];
    DWORD dwEventType; 
    DWORD dwEvent;     
    BYTE  byRes2[32];
}NET_DVR_SWITCH_CONVERT_ALARM, *LPNET_DVR_SWITCH_CONVERT_ALARM;

typedef  struct tagNET_DVR_START_FILE_TO_CLOUD_COND
{
    DWORD    dwSize; 
    BYTE    aCameraID[MAX_CAMERAID_LEN];    //camera ID
    DWORD      dwPoolID;   //storage pool ID
    DWORD      dwRepPoolID;
    WORD      wReplication;
    BYTE       byRes [178];
}NET_DVR_START_FILE_TO_CLOUD_COND,*LPNET_DVR_START_FILE_TO_CLOUD_COND;

typedef  struct     tagNET_DVR_START_PICTURE_FROM_CLOUD_COND
{
    DWORD       dwSize;
    BYTE        aCameraID[MAX_CAMERAID_LEN];    //camera ID
    NET_DVR_TIME_V30    struBeginTime;  //start time
    NET_DVR_TIME_V30    struEndTime;    //stop time
    DWORD   dwPicType;  //picture type
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    BYTE    byRes1[3];
    BYTE    byZoomType;    //0-no zoom,1-by scale,2-by quality,3-by resolution
    union
    {
        BYTE    uLen[32];
        struct
        {
            BYTE        byScale;         //1~99
        }struScale;
        struct
        {
            BYTE        byQuality;    //1~99
        }struQuality;
        struct
        {
            DWORD       dwWidth;    
            DWORD       dwHeight;
        }struResolution; 
    }uZoomParam;
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //picture data callback
    void*   pUser;    //user data pointer
    BYTE    byRes [372];
}NET_DVR_START_PICTURE_FROM_CLOUD_COND,*LPNET_DVR_START_PICTURE_FROM_CLOUD_COND;

typedef     struct    tagNET_DVR_START_PICTURE_FROM_CLOUD_RET
{
    DWORD       dwSize;
    DWORD       dwFileCount;    //file count
    BYTE        byRes[120];
}NET_DVR_START_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_START_PICTURE_FROM_CLOUD_RET;

typedef  struct 
{
    DWORD       dwSize;
    NET_DVR_TIME_V30    struTime;    //picture time
    DWORD       dwPicLen;    //picture kength
    BYTE        byPicType;    //picture type,1-jpg,2-bmp,3-png
    BYTE        byRes[107];
}NET_DVR_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_PICTURE_FROM_CLOUD_RET;

typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //ID card upload mode,0:up card number;1:up all info
    BYTE byRes1;
    BYTE byCardVerifyMode; //Credit card authentication mode, 0: remote center certification; 1: client platform authentication; 2: card open door
    BYTE byACSDevType;//Id card reader, equipment type, 1:2: IC card reader, 3: qr code reader, 4: fingerprint reader, 5: character screen + qr code reader, 6: recipient, 7: character screen, 8: fingerprint head, 9: voice module, 10: people and id card
    BYTE byDoorMode; //access mode,0:in door,1:out door
    BYTE byRes2;
    WORD wDevDetailType; //0-iDR210,1-IDM10,2-private ID card reader
    BYTE byRes[300];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;            //in mode,0-controlled;1-forbid;2-freedom;
    BYTE byOutMode;         //out mode,0-controlled;1-forbid;2-freedom;
    BYTE byWorkMode;        //work mode,0-urgent;1-repair;2-normal Close;3-normal Open; 
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

#define MAX_ID_NUM_LEN                  32
#define MAX_ID_NAME_LEN                 128
#define MAX_ID_ADDR_LEN                 280
#define MAX_ID_ISSUING_AUTHORITY_LEN    128

typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;
    BYTE  byName[MAX_ID_NAME_LEN];
    NET_DVR_DATE struBirth;
    BYTE byAddr[MAX_ID_ADDR_LEN];
    BYTE byIDNum[MAX_ID_NUM_LEN];
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];
    NET_DVR_DATE struStartDate;
    NET_DVR_DATE struEndDate;
    BYTE byTermOfValidity;
    BYTE   bySex;
    BYTE  byNation;
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;
    NET_DVR_ID_CARD_INFO    struIDCardCfg;
    DWORD dwMajor;
    DWORD dwMinor;
    NET_DVR_TIME_V30  struSwipeTime;
    BYTE    byNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR    struRemoteHostAddr;
    DWORD dwCardReaderNo;
    DWORD dwDoorNo;
    DWORD dwPicDataLen;   
    char    *pPicData;
    BYTE byCardType; 
    BYTE byDeviceNo;
    BYTE byMask; //wear mask:1-unknown,2-no,3-yes
    BYTE  byCurrentEvent; //is CurrentEvent0-invalid1-current event2- off-line event
    DWORD dwFingerPrintDataLen;
    char *pFingerPrintData;
    DWORD dwCapturePicDataLen;
    char *pCapturePicData;
    DWORD dwCertificatePicDataLen; 
    char    *pCertificatePicData;
    BYTE byCardReaderKind;
    BYTE byHelmet;//0-res, 1-unknown, 2-no helmet, 3-with helmet
    BYTE byRes3;
    BYTE    byIDCardInfoExtend;
    char    *pIDCardInfoExtend;
    DWORD dwSerialNo; //0-invalid
    BYTE byRes[168];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

typedef struct tagNET_DVR_ID_CARD_INFO_EXTEND
{
    BYTE byRemoteCheck; //remote check(0-invalid,1-not need(default),2-need)
    BYTE byThermometryUnit; //thermometry unit(0-celsius(default),1-fahrenheit,2-kelvin)
    BYTE byIsAbnomalTemperature; //is abnomal temperature(0-no,1-yes)
    BYTE byRes2;
    float fCurrTemperature; //face temperature
    NET_VCA_POINT struRegionCoordinates; //face temperature region coordinates
    DWORD dwQRCodeInfoLen; //QR code info len
    DWORD dwVisibleLightDataLen; //visible light data len
    DWORD dwThermalDataLen; //thermal data len
    char *pQRCodeInfo; //QR code info buffer
    char *pVisibleLightData; //visible light data buffer
    char *pThermalData; //thermal data buffer
    BYTE  byRes[1024];
}NET_DVR_ID_CARD_INFO_EXTEND, *LPNET_DVR_ID_CARD_INFO_EXTEND;

typedef struct tagNET_DVR_ID_CARD_BLOCKLIST_COND
{
    DWORD       dwSize;
    BYTE        byRes[256];          //reserved
}NET_DVR_ID_CARD_BLOCKLIST_COND, *LPNET_DVR_ID_CARD_BLOCKLIST_COND;

typedef struct tagNET_DVR_ID_CARD_BLOCKLIST_CFG
{
    DWORD                     dwSize;
    NET_DVR_ID_CARD_INFO      struIDCardCfg;          // ID card information
    DWORD                     dwFingerPrintDataLen;   // fingerprint data length,non 0 indicate that there are data appended
    char                      *pFingerPrintData;
    DWORD                     dwPicDataLen;           // ID card picture length,non 0 indicate that there are data appended
    char                      *pPicData;
    BYTE                      byRes[128];
}NET_DVR_ID_CARD_BLOCKLIST_CFG, *LPNET_DVR_ID_CARD_BLOCKLIST_CFG;

//A = alpha [a..z,A..Z],N = digit [0..9],S = special ['<'],B=binary data
typedef struct tagNET_DVR_PASSPORT_INFO
{
    DWORD  dwSize;
    BYTE    byOCR;            //0-no OCR,1-OCR data
    BYTE    byRes1[3];
    BYTE    byType[MAX_PASSPORT_TYPE_LEN];
    BYTE    byCountryIssue[MAX_PASSPORT_INFO_LEN];
    BYTE    byName[MAX_PASSPORT_NAME_LEN];
    BYTE    byPassportNo[MAX_PASSPORT_NUM_LEN];
    BYTE    byNationality[MAX_NATIONALITY_LEN];
    NET_DVR_DATE struBirth;
    NET_DVR_DATE struExpireDate;
    BYTE  bySex;                  //1-male,2-female
    BYTE  byRes2[35];
    BYTE  byLocalName[MAX_PASSPORT_INFO_LEN];
    BYTE  byNumber[MAX_PASSPORT_INFO_LEN];
    BYTE  byPlaceOfBirth[MAX_PASSPORT_INFO_LEN];
    BYTE  byAddr[MAX_PASSPORT_INFO_LEN];
    BYTE  byPhone[MAX_PASSPORT_INFO_LEN];
    BYTE  byJob[MAX_PASSPORT_INFO_LEN];
    BYTE  byTitle[MAX_PASSPORT_INFO_LEN];
    BYTE  byResume[MAX_PASSPORT_INFO_LEN];
    BYTE  byOtherNumber[MAX_PASSPORT_INFO_LEN];
    BYTE  byMonitoring[MAX_PASSPORT_MONITOR_LEN];
    BYTE  byRes[128];
}NET_DVR_PASSPORT_INFO, *LPNET_DVR_PASSPORT_INFO;

//passport info
typedef struct tagNET_DVR_PASSPORT_ALARM
{
    DWORD  dwSize;
    DWORD dwMajor;
    DWORD dwMinor;
    NET_DVR_TIME_V30  struSwipeTime;
    BYTE	byNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR	struRemoteHostAddr;
    DWORD dwCardReaderNo;
    BYTE  byCardType;
    BYTE byRes2[11];
    NET_DVR_PASSPORT_INFO struPassportInfo;
    DWORD dwFaceDataLen;
    char    *pFaceData;
    DWORD dwPicDataLen;
    char    *pPicData;          //[ISO/IEC 10918-1]
    DWORD dwCapturePicDataLen;
    char    *pCapturePicData;
    BYTE byRes[128];
}NET_DVR_PASSPORT_ALARM, *LPNET_DVR_PASSPORT_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;
    DWORD  dwAccessChannel;
    NET_DVR_TIME_V30  struSwipeTime;
    BYTE    byNetUser[MAX_NAMELEN];
    NET_DVR_IPADDR    struRemoteHostAddr;
    DWORD    dwEntryTimes;    //entry times
    DWORD    dwExitTimes;        //exit times
    DWORD    dwTotalTimes;        //total times; 
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;

typedef struct tagNET_DVR_ONLINEUSER_COND
{
    DWORD   dwSize; 
    DWORD  dwChannel;
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG
{
    DWORD   dwSize; 
    BYTE   byID;
    BYTE   byUserType;
    BYTE   byDataType;//Data Type
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;
    NET_DVR_TIME_V30  struLoginTime;
    char   szUserName[NAME_LEN/*32*/];
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;

//Storage Detection State
typedef    struct tagNET_DVR_STORAGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byHealthState;//Health State
    BYTE    bySDCardState;//SDcard State
    WORD    wAbnormalPowerLoss;//Abnormal Power Loss
    WORD    wBadBlocks;//Bad Blocks
    BYTE    byRemainingLife; //SD Card Remaining Life; 0~100%
    BYTE    byRes[125];
}NET_DVR_STORAGE_DETECTION,*LPNET_DVR_STORAGE_DETECTION;

//Storge Detection Alarm
typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //Relative Time
    DWORD    dwAbsTime; //Abs Time
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    DWORD   dwCardID;   //Card ID
    WORD    wAbnormalPowerLoss;//Abnormal Power Loss
    WORD    wBadBlocks;//Bad Blocks
    BYTE    byHealthState;//Health State
    BYTE    byRes1[3];
    float   fResidualLife; //SD card Residual Life0~100%
    BYTE    byRes[118];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;

//Storage Rwloack
typedef    struct tagNET_DVR_STORAGE_RWLOCK
{
    DWORD   dwSize;
    BYTE    byEnabled;//Enable
    BYTE    byRes[3];
    char    szPassWD[PASSWD_LEN/*16*/]; //New Password
    char    szOriginalPassWD[PASSWD_LEN/*16*/]; //Original Password
    BYTE    byRes1[128];
}NET_DVR_STORAGE_RWLOCK,*LPNET_DVR_STORAGE_RWLOCK;

//Storage Unloack
typedef    struct tagNET_DVR_STORAGE_UNLOCK
{
    DWORD   dwSize;
    char    szPassWD[PASSWD_LEN/*16*/]; //Password
    BYTE    byRes1[128];
}NET_DVR_STORAGE_UNLOCK,*LPNET_DVR_STORAGE_UNLOCK;

typedef    struct tagNET_DVR_PTZTRACKSTATUS
{
    DWORD        dwSize;
    BYTE          byID;//ID (the of the field byLinkageType is effective).
    BYTE      byLinkageType;//Linkage action 0- not linkage, 1- linkage ball machine equipment tracking
    BYTE      byRes[254];
}NET_DVR_PTZTRACKSTATUS,*LPNET_DVR_PTZTRACKSTATUS;

#define MAX_PROXY_COUNT 32

typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129]; 
    BYTE  byAuthType; 
    WORD  wPort;      
    BYTE  byRes2[64]; 
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD                     dwLength;         
    DWORD                    dwChannel;     
    NET_DVR_TIME_V30        struTimePoint;    
    BYTE  byID[STREAM_ID_LEN/*32*/];
    BYTE                      byRes[32];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen;     //picture length
    char     *pPicBuf;     //picture data
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;

//Manual Ranging 
typedef    struct tagNET_DVR_MANUALRANGING_CFG
{
    DWORD        dwSize;
    BYTE        byEnabled;  //Enabled
    BYTE        byRes[127];
}NET_DVR_MANUALRANGING_CFG,*LPNET_DVR_MANUALRANGING_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD           dwSize;
    BYTE           byDoorNotCloseAlarm;
    BYTE            byRes[603];
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp 
    DWORD    dwYear;            //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate
    DWORD    dwFlag;         //flag E
    DWORD    dwFilePos;      //file pos
    DWORD     dwPacketType;    //packet type:0 -file head,1 -video I frame,2- video B frame, 3- video P frame, 10- audio packet, 11- private packet
    DWORD     dwPacketSize;   //packet size
    unsigned char*    pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   // Packet Mode:0-Res,1-FU_A
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] Private data type 
    //reserved[1] Private bare data high address
    //reserved[2]Private bare data low address
    //reserved[3] Private bare data length
    //reserved[4] Private frame / packet time interval \ \ time stamp
    //reserved[5].bitIs a deep P frame,deepP:1,not deepP:0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef BOOL (CALLBACK * DEV_WORK_STATE_CB)(void* pUserdata, int iUserID, LPNET_DVR_WORKSTATE_V40 lpWorkState);

typedef struct tagNetDVRCheckDevState
{
    DWORD                dwTimeout;     
    DEV_WORK_STATE_CB    fnStateCB;
    void*                pUserData;
    BYTE                byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;

#define COURSE_NAME_LEN_128                128
#define INSTRUCTOR_NAME_LEN_64            64
#define MAX_UUID_LEN            64

typedef    struct tagNET_DVR_COURSE_LIST_COND
{
    DWORD                    dwSize;
    NET_DVR_TIME_V30        struStartTime; //course start time
    NET_DVR_TIME_V30        struEndTime; //course end time
    BYTE                       byCourseName[COURSE_NAME_LEN_128];
    BYTE                       byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE                   byCourseType; //course type,0-all,1-manual
    BYTE                    byRes[603];
}NET_DVR_COURSE_LIST_COND,*LPNET_DVR_COURSE_LIST_COND;

typedef struct  tagNET_DVR_COURSE_CFG
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;
    NET_DVR_TIME_V30        struEndTime;
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE            byRecUUID[MAX_UUID_LEN/*64*/];  //course UUID
    BYTE           byCourseType;//course type,0-all,1-manual
    BYTE            byRes[303];
}NET_DVR_COURSE_CFG, *LPNET_DVR_COURSE_CFG;

typedef struct tagNET_DVR_RECORD_STATUS
{
    DWORD       dwSize;
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];
    BYTE        byRecordStatus;         //record status,0-pause,1-shield,2-recording,3-idle
    BYTE        byRes1[3];
    DWORD       dwRecordingTime;      //recorded time, unit: second, maximum 12 * 60 * 60
    BYTE        byRes[596];
}NET_DVR_RECORD_STATUS, *LPNET_DVR_RECORD_STATUS;

typedef struct tagNET_DVR_MANUAL_CURRICULUM_CFG
{
    DWORD       dwSize;
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];
    BYTE           byCourseName[COURSE_NAME_LEN_128];
    BYTE           byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE        byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE        byCmdType;            //cmd type,0-startRecord 1-stopRecord 2-pauseRecord 3-continueRecord,4-startShield,5-stopShield
    BYTE         byRes[303];
}NET_DVR_MANUAL_CURRICULUM_CFG, *LPNET_DVR_MANUAL_CURRICULUM_CFG;

typedef struct tagNET_DVR_IMAGE_DIFF_DETECTION_CFG
{
    DWORD       dwSize;
    NET_VCA_POLYGON struRegion;
    BYTE       byEnabled;
    BYTE        byThreshold;             //[0,100]
    BYTE         bySensitivity;        //[0,100]
    BYTE        byVideoInputType;  //Video input type, 0- auto, 1- HDMI, 2-VGA
    BYTE     byRes[300];
}NET_DVR_IMAGE_DIFF_DETECTION_CFG, *LPNET_DVR_IMAGE_DIFF_DETECTION_CFG;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];
    BYTE             byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_COND, *LPNET_DVR_RECORDING_PUBLISH_FILE_COND;


typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_INFO
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;
    NET_DVR_TIME_V30        struEndTime;
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE     byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_INFO, *LPNET_DVR_RECORDING_PUBLISH_FILE_INFO;

//Screen interactive
typedef struct tagNET_DVR_SCREEN_POINT
{
    WORD wX;
    WORD wY;
}NET_DVR_SCREEN_POINT,*LPNET_DVR_SCREEN_POINT;

typedef struct tagNET_DVR_MOUSE_PARAM
{
    BYTE byMouseEvent;                  
    BYTE byRes1[3];
    NET_DVR_SCREEN_POINT struMousePoint; 
    BYTE byRes2[8];
}NET_DVR_MOUSE_PARAM, *LPNET_DVR_MOUSE_PARAM;

typedef struct tagNET_DVR_MARK_PARAM
{
       BYTE byMarkEvent;          
    BYTE byMarkTool;          
    BYTE byLineWidth;         
    BYTE byMouseEvent;         
    NET_DVR_RGB_COLOR struColor; 
    NET_DVR_SCREEN_POINT struPoint;
    BYTE byRes[4];
}NET_DVR_MARK_PARAM, *LPNET_DVR_MARK_PARAM;

typedef struct tagNET_DVR_KEYBOARD_PARM
{
    DWORD dwKeyValue; 
    BYTE  byRes[12];
}NET_DVR_KEYBOARD_PARAM, *LPNET_DVR_KEYBOARD_PARAM;

typedef struct tagNET_DVR_PPT_PARAM
{
    BYTE  byPPTAction;            
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; 
    DWORD dwPPTNo;                 
    BYTE  byRes2[4];
}NET_DVR_PPT_PARAM, *LPNET_DVR_PPT_PARAM;

typedef struct tagNET_DVR_REMOTE_CTRL_PARAM
{
    BYTE byRemoteCtrlCmd;   
    BYTE byRes1[3];
    DWORD dwCtrlParam;
    BYTE byRes2[8];
}NET_DVR_REMOTE_CTRL_PARAM, *LPNET_DVR_REMOTE_CTRL_PARAM;

typedef struct tagNET_DVR_SPOTLIGHT_PARAM
{
    BYTE  byCmd;                   
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; 
    DWORD dwRadius;                 
    BYTE  byRes2[4];
} NET_DVR_SPOTLIGHT_PARAM, *LPNET_DVR_SPOTLIGHT_PARAM;

typedef struct tagNET_DVR_TOUCHPAD_PARAM
{
    BYTE byMouseEvent; 
    BYTE byRes1[3];
    int iXDisplacement; 
    int iYDisplacement; 
    BYTE byRes2[4];
}NET_DVR_TOUCHPAD_PARAM, *LPNET_DVR_TOUCHPAD_PARAM;

typedef struct tagNET_DVR_MEDIA_LIST_PARAM
{
    BYTE byOperateCmd;
    BYTE byRes[15];
}NET_DVR_MEDIA_LIST_PARAM, *LPNET_DVR_MEDIA_LIST_PARAM;

typedef union tagNET_DVR_SCREEN_CTRL_PARAM
{
    NET_DVR_MOUSE_PARAM struMouseParam;            
    NET_DVR_MARK_PARAM struMarkParam;             
    NET_DVR_KEYBOARD_PARAM struKeyboardInfo;      
    NET_DVR_PPT_PARAM struPPTParam;                 
    NET_DVR_REMOTE_CTRL_PARAM struRemoteCtrlParam;  
    NET_DVR_SPOTLIGHT_PARAM struSpotLight;          
    NET_DVR_TOUCHPAD_PARAM struTouchPadParam;        
    NET_DVR_MEDIA_LIST_PARAM struMediaListParam;
    BYTE byRes[16];
}NET_DVR_SCREEN_CTRL_PARAM, *LPNET_DVR_SCREEN_CTRL_PARAM;

typedef struct tagNET_DVR_SCREEN_CTRL_CMD
{
    DWORD dwSize;
    BYTE  byCmdType;                            
    BYTE  byRes1[3];
    NET_DVR_SCREEN_CTRL_PARAM struScreenCtrlParam;
}NET_DVR_SCREEN_CTRL_CMD, *LPNET_DVR_SCREEN_CTRL_CMD;

typedef struct tagNET_DVR_FILE_RESPONSE_PARAM
{
    BYTE byFileState;     
    BYTE byRes1[3];
    DWORD dwErrorFileIndex; 
    BYTE byRes2[24];
} NET_DVR_FILE_RESPONSE_PARAM, *LPNET_DVR_FILE_RESPONSE_PARAM;

typedef struct tagNET_DVR_PPT_RESPONSE_PARAM
{
    BYTE  byCurrentState;   
    BYTE  byRes1[3];
    DWORD dwCurrentPage;   
    DWORD dwFileIndex;    
    DWORD dwTotalPageNum;
    BYTE  byRes2[16];
}NET_DVR_PPT_RESPONSE_PARAM, *LPNET_DVR_PPT_RESPONSE_PARAM;

typedef union tagNET_DVR_SCREEN_RESPONSE_PARAM
{
    BYTE byRes[32];
    NET_DVR_PPT_RESPONSE_PARAM  struPPTParam;  
    NET_DVR_FILE_RESPONSE_PARAM    struFileParam; 
}NET_DVR_SCREEN_RESPONSE_PARAM,*LPNET_DVR_SCREEN_RESPONSE_PARAM;

typedef struct tagNET_DVR_SCREEN_RESPONSE_CMD
{
    DWORD dwSize;
    BYTE  byResponseCmd;
    BYTE  byRes1[3];
    NET_DVR_SCREEN_RESPONSE_PARAM struResonseParam; 
    BYTE  byRes2[16];
}NET_DVR_SCREEN_RESPONSE_CMD, *LPNET_DVR_SCREEN_RESPONSE_CMD;

typedef struct tagNET_DVR_SCREEN_FILE_COND
{
    DWORD dwSize;
    BYTE  byFileType; 
    BYTE  byRes[127];
}NET_DVR_SCREEN_FILE_COND, *LPNET_DVR_SCREEN_FILE_COND;

typedef struct tagNET_DVR_SCREEN_FILE_INFO
{
    DWORD dwSize;
    DWORD dwFileIndex;    
    BYTE  byFileType;     
    BYTE  byPictureFormat;  
    BYTE  byVideoFormat;   
    BYTE  byDocumentFormat;
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH];
    DWORD dwFileSize;    
    DWORD dwPPTPage;
    BYTE  byOtherFileFormat[8];
    BYTE  byRes1[56];
}NET_DVR_SCREEN_FILE_INFO, *LPNET_DVR_SCREEN_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_CONFIG
{
    DWORD dwSize;
    BYTE  byVolume;            
    BYTE  byContrast;           
    BYTE  byBrightness;        
    BYTE  byScreenShowEnabled;  
    BYTE  byScreenLocked;      
    BYTE  byBlackScreenEnabled; 
    BYTE  byRes[30];
}NET_DVR_SCREEN_CONFIG, *LPNET_DVR_SCREEN_CONFIG;

typedef struct tagNET_DVR_SCREEM_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    BYTE  byFileType;     
    BYTE  byPictureFormat; 
    BYTE  byVideoFormat;  
    BYTE  byDocumentFormat;
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH];
    BYTE  byOtherFileFormat[8];
    BYTE  byRes1[56];
}NET_DVR_SCREEM_FILE_UPLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileIndex; 
    DWORD dwPPTPageNo;  
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;


typedef struct tagNET_DVR_TV_SCREEN_COND
{
    DWORD  dwSize;
    DWORD    dwChannel;
    WORD    wTVScreenNo;
    BYTE     byRes[62];
}NET_DVR_TV_SCREEN_COND, *LPNET_DVR_TV_SCREEN_COND;

typedef struct tagNET_DVR_TV_SCREEN_CFG
{
    DWORD    dwSize;
    DWORD    dwPicStayTime;
    BYTE     byRes[256];
}NET_DVR_TV_SCREEN_CFG, *LPNET_DVR_TV_SCREEN_CFG;

//Get equipment grab picture and additional information
typedef struct tagNET_DVR_BV_CALIB_COND
{
    DWORD  dwSize;  //stru size
    DWORD dwChannels;  //channel
    BYTE  byRes[300]; //res
}NET_DVR_BV_CALIB_COND, *LPNET_DVR_BV_CALIB_COND;

typedef struct tagNET_DVR_BV_CALIB_PIC
{
    DWORD  dwSize;
    DWORD  dwPicID;
    DWORD dwPicLen1;//
    DWORD dwPicLen2;//
    char*   pPicBuffer1;//
    char*   pPicBuffer2;//
    BYTE  byRes[600];
}NET_DVR_BV_CALIB_PIC, *LPNET_DVR_BV_CALIB_PIC;


//Get the calibration result of binocular external reference
typedef struct tagNET_DVR_BV_CALIB_PARAM
{
    DWORD  dwPicID;
    NET_VCA_POINT struPoint;//coordinate between the eyebrows
    BYTE  byRes[32]; //res
}NET_DVR_BV_CALIB_PARAM, *LPNET_DVR_BV_CALIB_PARAM;

typedef struct tagNET_DVR_BV_CALIB_INFO
{
    DWORD  dwSize;  //stru size
    DWORD  dwBVCalibNumber;
    NET_DVR_BV_CALIB_PARAM struBVCalibParam[12];
    DWORD  dwHumanHeight;  //human true height (cm)
    DWORD  dwChannel;  //channel
    BYTE  byRes[300]; //res
}NET_DVR_BV_CALIB_INFO, *LPNET_DVR_BV_CALIB_INFO;

typedef struct tagNET_DVR_BV_CALIB_RESULT
{
    DWORD  dwSize;  //stru size
    DWORD dwCameraHeight;  //camera height (cm)
    float fPitchAngle;
    float fInclineAngle;
    BYTE  byRes[300]; //res
}NET_DVR_BV_CALIB_RESULT, *LPNET_DVR_BV_CALIB_RESULT;

//Get binocular height correction data
typedef struct tagNET_DVR_BV_HCORRECTION_COND
{
    DWORD  dwSize;  //stru sizeNET_DVR_VERIFY_BV_CALIBRATION
    DWORD dwChannels;  //channel
    DWORD  dwPicID;
    BYTE  byRes[300]; //res
}NET_DVR_BV_HCORRECTION_COND, *LPNET_DVR_BV_HCORRECTION_COND;

typedef struct tagNET_DVR_BV_HCORRECTION_CFG
{
    DWORD  dwSize;  //stru size
    DWORD  dwHumanHeight;  //human true height (cm)
    BYTE  byRes[300]; //res
}NET_DVR_BV_HCORRECTION_CFG, *LPNET_DVR_BV_HCORRECTION_CFG;

typedef struct tagNET_DVR_SUB_SCHEDULE_PROGRESS
{
    DWORD dwTerminalNo; //terminal num
    DWORD dwProgress;   //terminal schedule publish progress,0-100,101 denote exception,,102 denote terminal storm not enough
}NET_DVR_SUB_SCHEDULE_PROGRESS, *LPNET_DVR_SUB_SCHEDULE_PROGRESS;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress,0-100,According to the schedule for the whole set is gain schedule release schedule, according to the terminal when get progress for a single terminal schedule release schedule
    DWORD  dwSubProgressNum;    //Get effective when schedule number, according to the group, said group under various terminal schedule number
    LPNET_DVR_SUB_SCHEDULE_PROGRESS  lpStruSubProgress; //Each terminal schedule release schedule, according to the set of access available at the time,dwSubProgressNum NET_DVR_SUB_SCHEDULE_PROGRESS
    BYTE   byRes[32];
}NET_DVR_SCHEDULE_PROGRESS_RESULT, *LPNET_DVR_SCHEDULE_PROGRESS_RESULT;

//info publish server schedule progress
typedef struct tagNET_DVR_SCHEDULE_PROGRESS_COND
{
    DWORD dwSize;
    DWORD dwScheduleNo;     //schedule num
    BYTE  byProgressType;   //progress type,1-by group,2-by termal
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //termal num,valid when byProgressType = 1
    DWORD dwTerminalNo;     //termal num,valid when byProgressType = 2
    BYTE  byRes2[32];
}NET_DVR_SCHEDULE_PROGRESS_COND, *LPNET_DVR_SCHEDULE_PROGRESS_COND;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_COND
{
    DWORD dwSize;
    BYTE   byInsertType;    //insert play type,1-material,2-program
    BYTE   byRes3[3];
    DWORD dwInsertNo;      //material no ,when byInsertType = 0,program no when byInsetType = 1
    BYTE  byProgressType;   //progress type,1-by group,2-by termal
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //termal num,valid when byProgressType = 1
    DWORD dwTerminalNo;     //termal num,valid when byProgressType = 2
    BYTE  byRes2[32];
}NET_DVR_INSERTPLAY_PROGRESS_COND, *LPNET_DVR_INSERTPLAY_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_INSERTPLAY_PROGRESS
{
    DWORD dwTerminalNo; //terminal no
    DWORD dwProgress;   //terminal insert play progress,0-100,101 denote exception,102 denote terminal storm not enough,103 cancel insert play,104 the material exchanged
}NET_DVR_SUB_INSERTPLAY_PROGRESS, *LPNET_DVR_SUB_INSERTPLAY_PROGRESS;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //main progress,0-100
    DWORD  dwSubProgressNum;    //sub progress num,is valid when get group
    LPNET_DVR_SUB_INSERTPLAY_PROGRESS  lpStruSubProgress;
    BYTE   byRes[32];
}NET_DVR_INSERTPLAY_PROGRESS_RESULT, *LPNET_DVR_INSERTPLAY_PROGRESS_RESULT;

//TME Voice Cfg
typedef    struct tagNET_DVR_TMEVOICE_CFG
{
    DWORD      dwSize;
    BYTE       byVoiceSpeed;//Voice Speed 0~100
    BYTE       byVoicePitch; //Voice Pitch 0~100
    BYTE       byVoiceVolum; //Voice Volum0~100
    BYTE       byVoicePlateEnable;//Voice Plate Enable ,0~disable,1~enable
    /*Voice Role;
    3  = Xiaoyan (female, Chinese) 
    51 = Jiu Xu (male, Chinese) 
    52 = Duo Xu (male, Chinese) 
    53 = Xiaoping (female, Chinese)
    54 = Donald Duck (male, Chinese)
    55 = Baby Xu (child, Chinese)
    */
    DWORD     dwVoiceRole; //Voice Role
    char      sInfo[MAX_TMEVOICE_LEN/*64*/]; //Info
    char      sFileName[MAX_TMEVOICE_LEN/*64*/]; //File name
    BYTE      byRes[64];
}NET_DVR_TMEVOICE_CFG,*LPNET_DVR_TMEVOICE_CFG;

//input board configuration
typedef struct tagNET_DVR_INPUT_BOARD_CFG
{
    DWORD    dwSize;
    DWORD    dwSlotNo;           //slot No.
    BYTE    byFullFrameEnable;  //full frame display enable
    BYTE    byRes[3];           //four bytes align
    BYTE    byRes1[64];         //reserved
}NET_DVR_INPUT_BOARD_CFG, *LPNET_DVR_INPUT_BOARD_CFG;

typedef struct tagNET_DVR_INPUT_BOARD_CFG_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_BOARD_CFG struBoardList[MAX_NUM_INPUT_BOARD]; //input board configuration list
}NET_DVR_INPUT_BOARD_CFG_LIST, *LPNET_DVR_INPUT_BOARD_CFG_LIST;


//Get encryption device information Condition structure
typedef struct _NET_DVR_ENCRYPT_DEVICE_COND
{
    DWORD  dwSize;     //structure size
    DWORD  dwChannel;     //channel
    BYTE   byAlgorithm; //Algorithm,0-Res,1-RSA,2-SM2
    BYTE   byModelLen; //Model Len,0-Res,1-1024 bit,2-2048 bit,3-256 bit
    BYTE   byCERTSaveLocation; //CERT Save Location,0-Res,1-encrypt chip ,2-device
    BYTE   byRes[29];
}NET_DVR_ENCRYPT_DEVICE_COND, *LPNET_DVR_ENCRYPT_DEVICE_COND;
//Get encryption device information structure
typedef struct _NET_DVR_ENCRYPT_DEVICE_INFO
{
    DWORD  dwSize;     //structure size
    BYTE   byAlgorithm; //Algorithm,0-Res,1-RSA,2-SM2
    BYTE   byModelLen; //Model Len,0-Res,1-1024 bit,2-2048 bit,3-256 bit
    BYTE   byRes1[30];  //Res
    DWORD  dwPublicKeyLen;        //PublicKey Len
    char   szPublicKey[MAX_PUBLIC_KEY_LEN];       //Public Key 
    char   szChipSerialNumber[CHIP_SERIALNO_LEN];   //Chip Serial Number
    char   szDeviceID[ENCRYPT_DEV_ID_LEN];     //device ID
    BYTE   byRes2[128];
}NET_DVR_ENCRYPT_DEVICE_INFO, *LPNET_DVR_ENCRYPT_DEVICE_INFO;
//Encrypt cert param structure
typedef struct _NET_DVR_ENCRYPT_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertType; //Cert Type,0-CA root cert,1-sign cert,2-encrypt cert,3- SM2 secret key pair
    BYTE byRes1[2]; //Res
    DWORD dwCertLen; //Cert Len
    BYTE  byRes2[32]; 
    char* pCertBuf;  //Cert Buf
}NET_DVR_ENCRYPT_CERT_PARAM, *LPNET_DVR_ENCRYPT_CERT_PARAM;


#define MAX_RING_NAME_LEN_128                128    //
typedef struct tagNET_DVR_RING_UPLOAD_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //ring ID,[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //
    DWORD     dwRingSize;   //
    BYTE        byRingType;   //ring type,0-wav
    BYTE        byRes[363];
}NET_DVR_RING_UPLOAD_CFG,*LPNET_DVR_RING_UPLOAD_CFG;

typedef struct tagNET_DVR_RING_SEARCH_COND
{
    DWORD        dwSize;
    DWORD        dwRingID; //ring ID
    BYTE        byRes[300];
}NET_DVR_RING_SEARCH_COND,*LPNET_DVR_RING_SEARCH_COND;

typedef struct tagNET_DVR_RING_SEARCH_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //
    DWORD     dwRingSize;   //
    BYTE        byRingType;   //
    BYTE        byRes[303];
}NET_DVR_RING_SEARCH_CFG,*LPNET_DVR_RING_SEARCH_CFG;


//Alarm Ctrl Cfg
typedef struct tagNET_DVR_ALARMCTRL_CFG
{
    DWORD   dwSize;
    BYTE    byListenPicUploadEnabled;//Listen Pictrue Upload Enabled
    BYTE    byRes [259];
}NET_DVR_ALARMCTRL_CFG,*LPNET_DVR_ALARMCTRL_CFG;

typedef struct tagNET_DVR_VEHICLEFLOW_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    BYTE   byLane;
    BYTE   byRes1[3];
    NET_DVR_TIME_V30 struStartTime;
    NET_DVR_TIME_V30 struEndTime;
    BYTE   byRes[256];
}NET_DVR_VEHICLEFLOW_COND, *LPNET_DVR_VEHICLEFLOW_COND;

typedef struct tagNET_DVR_VEHICLEFLOW_INFO
{
    DWORD dwVehicleFlowValue;
    BYTE   byRes[64];
}NET_DVR_VEHICLEFLOW_INFO, *LPNET_DVR_VEHICLEFLOW_INFO;

typedef struct tagNET_DVR_VEHICLEFLOW_CFG
{
    DWORD dwSize;
    NET_DVR_VEHICLEFLOW_INFO struVehFlow[MAX_VEHICLEFLOW_INFO/*24*/];
    BYTE   byRes[512];
}NET_DVR_VEHICLEFLOW_CFG, *LPNET_DVR_VEHICLEFLOW_CFG;

typedef struct tagNET_DVR_IPADDR_FILTER_COND
{
    DWORD dwSize;
    DWORD dwChannel;//Channel
    BYTE  byRes[64];
}NET_DVR_IPADDR_FILTER_COND, *LPNET_DVR_IPADDR_FILTER_COND;

typedef    struct tagNET_DVR_TEMPHUMSENSOR
{
    DWORD      dwSize;
    BYTE        byEnable;
    BYTE           byCtrlMode;
    BYTE        byTemperatureValue;//
    BYTE        byHumidityValue;//
    BYTE        byFanSwitch;//
    BYTE        byThermometryUnit;//unit:(),1-(H),2-(K)
    BYTE        byRes[62];
}NET_DVR_TEMPHUMSENSOR, *LPNET_DVR_TEMPHUMSENSOR;

//PostRadar Speed Cfg
typedef struct tagNET_DVR_POSTRADARSPEED_CFG
{
    DWORD   dwSize;
    BYTE    byLaneType; //Lane Type
    BYTE    byRes1[3];
    DWORD   dwInterval; //Interval,Unit:ms
    DWORD   dwSignSpeed;//Sign Speed,Unit:km/h
    DWORD   dwSpeedLimit;//Speed Limit,Unit:km/h
    DWORD   dwBigCarSignSpeed;//Big Car Sign Speed,Unit:km/h
    DWORD   dwBigCarSpeedLimit;//Big Car Speed Limit,Unit:km/h
    DWORD   dwLowSpeedLimit;// Low Speed Limit,Unit:km/h
    DWORD   dwBigCarLowSpeedLimit;// Big Car Low Speed Limit,Unit:km/h
    BYTE    byCheckPostEnabled; //Check Post Enabled
    BYTE    byOverSpeedEnabled; //Over Speed Enabled
    BYTE    byRes[246];
}NET_DVR_POSTRADARSPEED_CFG, *LPNET_DVR_POSTRADARSPEED_CFG;

//PostRadar Speed Param
typedef struct tagNET_DVR_POSTRADARPARAM_CFG
{
    DWORD   dwSize;
    BYTE    bySoftWareVersion[32];//Soft Ware Version
    BYTE    byID; //ID
    BYTE    byWorkMode; //Work Mode
    BYTE    bySpeedType; //Speed Type
    BYTE    byDirectionFilter; //Direction Filter
    DWORD   dwAngleCorrect;//Angle Correct[0,70]
    DWORD   dwSensitivity;// Sensitivity[11,240]
    DWORD   dwSpeedLowLimit;// Speed Low Limit[1,150km/h]
    DWORD   dwTrigDistance;// Trig Distance[0,40m]
    BYTE    byRes[256];
}NET_DVR_POSTRADARPARAM_CFG, *LPNET_DVR_POSTRADARPARAM_CFG;

typedef struct tagNET_DVR_CLOUD_URL_COND
{
    DWORD   dwSize;
    BYTE    byType;     //cloud type:0-reversed,1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byRes[63];
}NET_DVR_CLOUD_URL_COND, *LPNET_DVR_CLOUD_URL_COND;

typedef struct tagNET_DVR_CLOUD_URL
{
    DWORD   dwSize;
    char    szURL[256]; //cloud storage url
    BYTE    byRes[256];
}NET_DVR_CLOUD_URL, *LPNET_DVR_CLOUD_URL;

typedef struct tagNET_DVR_CLOUD_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;    //0-disable,1-enable
    BYTE    byType;        //cloud type 0-reverse,1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byStatus;    //status,read only 0-reverse 1-online 2-offline
    BYTE    byRes1;
    char    szAuthCode[CODE_LEN]; //authcode
    char    szAlias[ALIAS_LEN];    //alias,read only
    INT64   i64TotalCapability;            //total capacity,read only (MB)
    INT64   i64UsedSpace;                //used capacity,read only (MB)
    BYTE    byRes2[256];
}NET_DVR_CLOUD_CFG,*LPNET_DVR_CLOUD_CFG;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;    //channel
    BYTE    byRes[254];
}NET_DVR_CLOUD_UPLOADSTRATEGY_COND, *LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY
{
    DWORD    dwSize;
    BYTE    byStrategyType;    //strategy type:0-nonsense,1-record,2-picture
    BYTE    byRes1[3];
    DWORD    dwRecordType;    //it is useful when byStrategyType is 1,position representation
    /*0x00: nonsense*/
    /*0x01: all event*/
    /*0x02: motion*/
    /*0x04: alarm*/
    /*0x08: VCA*/
    BYTE    byRes[256];
}NET_DVR_CLOUD_UPLOADSTRATEGY, *LPNET_DVR_CLOUD_UPLOADSTRATEGY;


typedef  struct tagNET_DVR_RECORD_CHECK_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byCheckType;        //check type,0--check integrity,1--check integrity & lost record segment
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;
    NET_DVR_TIME_EX struEndTime;
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_COND, *LPNET_DVR_RECORD_CHECK_COND;

typedef  struct tagNET_DVR_RECORD_CHECK_RET
{
    DWORD    dwSize;
    BYTE   byRecordNotComplete;    //check integrity,0--complete,1-- not complete
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //when byCheckType=1 and byRecordNotComplete=1,this param effective
    NET_DVR_TIME_EX struEndTime;    //when byCheckType=1 and byRecordNotComplete=1,this param effective
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_RET, *LPNET_DVR_RECORD_CHECK_RET;

typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND;

typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    NET_DVR_TIME_EX struBeginTime;
    NET_DVR_TIME_EX struEndTime;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG;

typedef  struct tagNET_DVR_RECORD_PASSBACK_TASK_CFG
{
    DWORD    dwSize;
    DWORD dwTaskID;        //task ID
    BYTE   byRes[160];
}NET_DVR_RECORD_PASSBACK_TASK_CFG, *LPNET_DVR_RECORD_PASSBACK_TASK_CFG;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byType;        //check type,0--get all surplus task,1--get all surplus task by stream id, 2--get all task,3--get all task by stream id, 4--get task by task id
    BYTE    byTimeSegmentQuety; //enable time limit,0-disable,1-enable
    BYTE    byRes1[2];
    NET_DVR_STREAM_INFO    struStreamInfo;    //stream ID
    NET_DVR_TIME_EX struBeginTime;      //start time,valid when byTimeSegmentQuety is enable
    NET_DVR_TIME_EX struEndTime;        //end time,valid when byTimeSegmentQuety is enable
    DWORD dwTaskID;        //task ID, is effective only when byType equal to 4 
    BYTE    byRes[108];
}NET_DVR_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_RECORD_PASSBACK_MANUAL_COND;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET
{
    DWORD        dwSize;    
    NET_DVR_STREAM_INFO    struStreamInfo;    //stream ID
    DWORD        dwTaskID;        //task ID
    NET_DVR_TIME_EX    struStartTime;
    NET_DVR_TIME_EX    struStopTime;
    BYTE        byTaskStatus;    //task status,0--unexecuted,1--pausing,2--executed, 3--executting, 4--failed, 5--success, but only part of the video was returned, 6--success, but there is no video on the front end
    BYTE        byRes1[3];
    NET_DVR_TIME_EX    struExecuteStartTime;    //effect when byTaskStatus=1 0r 2
    NET_DVR_TIME_EX    struExecuteStopTime;    //effect when byTaskStatus=1 0r 2
    BYTE        byRes[128];
}NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET, *LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_CTRL
{
    DWORD    dwSize;
    BYTE    byControlType;    //control type,0--pause all task,1--restore all task
    BYTE    byRes[131];
}NET_DVR_RECORD_PASSBACK_MANUAL_CTRL, *LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byDelType;    //delete type,0--delete by task id,1--delete by stream id,2--delete all task
    BYTE    byRes[131];
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    DWORD    dwTaskID;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE    byRes[128];
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

typedef struct tagNET_DVR_PASSBACK_DAY
{
    BYTE    byAllDay;
    BYTE    byRes[3];
}NET_DVR_PASSBACK_DAY, *LPNET_DVR_PASSBACK_DAY;

typedef struct tagNET_DVR_PASSBACK_SCHED
{
    NET_DVR_SCHEDTIME    struPassBackTime;
    BYTE        byRes[4];
}NET_DVR_PASSBACK_SCHED, *LPNET_DVR_PASSBACK_SCHED;

typedef struct tagNET_DVR_RECORD_PASSBACK_SCH_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //0--disable,1--enable
    BYTE    byPassBackWeek;    //0--no,1--yes
    BYTE    byRes1[2];
    NET_DVR_PASSBACK_DAY    struPassBackDay[MAX_DAYS];
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE   byRes[128];
}NET_DVR_RECORD_PASSBACK_SCH_CFG, *LPNET_DVR_RECORD_PASSBACK_SCH_CFG;

//Back history record planning parameters 
typedef struct tagNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //0--disable,1--enable
    BYTE    byRes1[3];
    NET_DVR_PASSBACK_DAY        struPassBackDay[MAX_DAYS];
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE   byRes[256];
}NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG, *LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG;

typedef struct tagNET_DVR_DEV_STORAGE_CFG
{
    DWORD    dwSize;
    DWORD    dwCapacityTotal;        //read only,eg: 102400MB
    DWORD    dwFreeSpaceTotal;        //read only,MB
    DWORD    dwLockedRecordSpace;    //read only,MB
    DWORD    dwUnLockedSpace;        //read only,MB
    BYTE    byRes[512];
}NET_DVR_DEV_STORAGE_CFG, *LPNET_DVR_DEV_STORAGE_CFG;

//One key configuration CVR (V50) 
typedef struct tagNET_DVR_ONE_KEY_CFG_V50
{
    DWORD   dwSize;
    BYTE    byRaidType;   //RAID type:0-raid5,1-raid6,2-raid95(Vraid),3-Single plate model
    BYTE    bySpareRaidProportion;   //Hot spare disk: the proportion of raid (array) , 0--(0:1), 1--(1 : 1), 2--(1 : 2), 3--(1 : 3), 4--(1 : 4), 5--(1 : 5), 6--(1 : 6),7--(6:1),8--(5:1),9--(4:1),10--(3:1),11--(2:1)
    BYTE    byPicQuota;   //Image volume ratio: the range of 0 ~ 100 
    BYTE    byRes[257];
}NET_DVR_ONE_KEY_CFG_V50, *LPNET_DVR_ONE_KEY_CFG_V50;

typedef struct tagNET_DVR_ONE_KEY_RESULT_V51
{
    DWORD   dwState;    //State value
    BYTE    byProgress;   //Operation progress, 0~100
    BYTE    byRes[259];
}NET_DVR_ONE_KEY_RESULT_V51, *LPNET_DVR_ONE_KEY_RESULT_V51;


typedef struct tagNET_DVR_ONE_KEY_CFG_SAN_V50
{
    DWORD   dwSize;
    BYTE    byRaidType;   //RAID type: 0-raid5,1-raid6
    BYTE    bySpareRaidProportion;   //Hot spare disk: the proportion of raid (array) ,0--(0:1),1--(1:1),2--(1:2),3--(1:3),4--(1:4),5--(1:5),6--(1:6),7--(6:1),8--(5:1),9--(4:1),10--(3:1),11--(2:1)    
    BYTE    byRes[254];
}NET_DVR_ONE_KEY_CFG_SAN_V50, *LPNET_DVR_ONE_KEY_CFG_SAN_V50;

typedef    struct tagNET_DVR_REC_PASSBACK_BASIC_CFG
{
    DWORD        dwSize;
    DWORD     dwStartTime;    //Detection window start time 
    DWORD     dwStopTime;    //Detection window stop time
    WORD    wMaxTotalConcurrenceNum;   //Concurrent posts back because limit, is aimed at encoder, not the article back task 
    WORD    wMaxDvrConcurrenceNum;     //A single DVR concurrent back channel number limit 
    DWORD   dwSyncSpeed;     //synchronization speedunit:MbpsMax:12Mbps
    DWORD   dwRecordType;     //The video type:0xffffffffall0timing1- motion detection, 2alarm(all videos labeled as alarm type)0xff-other
    BYTE    byRes[248];
}NET_DVR_REC_PASSBACK_BASIC_CFG, *LPNET_DVR_REC_PASSBACK_BASIC_CFG;

typedef struct tagNET_DVR_ONLINE_USER_INFO_
{
    DWORD    dwSize;
    WORD    wOnlineUserCount;
    BYTE   byRes[514];
}NET_DVR_ONLINE_USER_INFO, *LPNET_DVR_ONLINE_USER_INFO;

typedef struct tagNET_DVR_RECORD_SEGMENT_COND_
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreanInfo;
    NET_DVR_TIME_EX    struStartTime;
    NET_DVR_TIME_EX    struStopTime;
    BYTE        byRes[256];
}NET_DVR_RECORD_SEGMENT_COND, *LPNET_DVR_RECORD_SEGMENT_COND;

typedef struct tagNET_DVR_RECORD_SEGMENT_RET_
{
    DWORD    dwSize;
    DWORD    dwRecordTotalSize;    //all record size , MB
    BYTE    byRes[256];
}NET_DVR_RECORD_SEGMENT_RET, *LPNET_DVR_RECORD_SEGMENT_RET;
typedef struct tagNET_DVR_ACCESSORY_CARD_INFO
{
    DWORD  dwSize;
    BYTE    szAccessoryCardInfo[MAX_ACCESSORY_CARD/*256*/];//Accessories plate (intelligent board and control board) model information 
    BYTE    byRes[512];
}NET_DVR_ACCESSORY_CARD_INFO, *LPNET_DVR_ACCESSORY_CARD_INFO;
//search info cond struct
typedef struct tagNET_DVR_SEARCH_INFO_COND
{
    DWORD                   dwSize;
    BYTE                    byCommand;    //command,0-personal,1-everyone
    BYTE                    byRes1[3];
    DWORD                   dwEmployeeNo; //employee number (it is effective when command is 0-personal)
    BYTE                    byName[NAME_LEN];   //name (it is effective when command is 0-personal)
    NET_DVR_TIME_V30        struStartTime;      //start time
    NET_DVR_TIME_V30        struEndTime;        //end time
    BYTE                    byRes[128];
}NET_DVR_SEARCH_INFO_COND, *LPNET_DVR_SEARCH_INFO_COND;

//get schedule info
typedef struct tagNET_DVR_SCHEDULE_CHOICE
{
    BYTE                    byScheduleType;        //schedule type,0-no class,1-ordinary class,2-working class
    BYTE                    byScheduleNo;       //schedule number
    BYTE                    byRes[14];
}NET_DVR_SCHEDULE_CHOICE, *LPNET_DVR_SCHEDULE_CHOICE;

//schedule plan struct
typedef struct tagNET_DVR_SCHEDULE_PLAN
{
    DWORD                   dwSize;
    BYTE                    bySchedulePlanNo;   //schedule plan number
    BYTE                    bySchedulePlanType; //schedule plan type,0-personal,1-department
    BYTE                    byEnable;           //enable
    BYTE                    byRes1;
    NET_DVR_SCHEDULE_CHOICE struScheduleChoice[DAYS_A_WEEK];  //schedule choice
    NET_DVR_TIME_V30        struStartTime;      //start time
    NET_DVR_TIME_V30        struEndTime;        //end time
    BYTE                    byHolidayNo;        //holiday number
    BYTE                    byRes[63];
}NET_DVR_SCHEDULE_PLAN, *LPNET_DVR_SCHEDULE_PLAN;
//  B20 V1.5
typedef struct tagNET_DVR_DISPINPUT_CFG
{
    DWORD  dwSize;
    DWORD  dwDispInputNo;
    DWORD  dwEDIDFileNo;
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG, *LPNET_DVR_DISPINPUT_CFG;

//get schedule info
typedef struct tagNET_DVR_SCHEDULE_INFO_CFG
{
    DWORD                  dwSize;
    DWORD                  dwEmployeeNo;        //employee number
    BYTE                   byName[NAME_LEN];    //name
    BYTE                   byDepartmentName[NAME_LEN];   //department name
    NET_DVR_SCHEDULE_PLAN  struSchedulePlan;    //schedule plan
    BYTE                   byRes[128];
}NET_DVR_SCHEDULE_INFO_CFG, *LPNET_DVR_SCHEDULE_INFO_CFG;

//get attendance suammary info
typedef struct tagNET_DVR_ATTENDANCE_SUMMARY_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //employee number
    BYTE                  byName[NAME_LEN];  //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    DWORD                 dwWorkStandard;    //work standard minutes
    DWORD                 dwWorkActual; //work actual minutes
    DWORD                 dwLateTimes;  //late times
    DWORD                 dwLateMinutes;//late minutes
    DWORD                 dwLeaveEarlyTimes;    //leave early times
    DWORD                 dwLeaveEarlyMinutes;  //leave early minutes
    DWORD                 dwOvertimeStandard;   //over time standard minutes
    DWORD                 dwOvertimeActual;     //over time actual minutes
    DWORD                 dwAttendanceStandard; //attendance standard days
    DWORD                 dwAttendanceActual;   //attendance actual days
    DWORD                 dwAbsentDays;         //absent days
    BYTE                  byRes[128];          
}NET_DVR_ATTENDANCE_SUMMARY_CFG, *LPNET_DVR_ATTENDANCE_SUMMARY_CFG;

//get attendance record info
typedef struct tagNET_DVR_ATTENDANCE_RECORD_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //employee number
    BYTE                  byName[NAME_LEN];     //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    NET_DVR_TIME_V30      struAttendanceTime;   //attendance time
    BYTE                  byRes[128];
}NET_DVR_ATTENDANCE_RECORD_CFG, *LPNET_DVR_ATTENDANCE_RECORD_CFG;

//attendance time
typedef struct tagNET_DVR_ATTENDANCE_TIME
{
    NET_DVR_TIME_V30      struOnDutyTime;   //on duty time
    NET_DVR_TIME_V30      struOffDutyTime;  //off duty time
}NET_DVR_ATTENDANCE_TIME, *LPNET_DVR_ATTENDANCE_TIME;

//get abnormal time
typedef struct tagNET_DVR_ABNORMAL_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo;     //employee number
    BYTE                  byName[NAME_LEN]; //name
    BYTE                  byDepartmentName[NAME_LEN];  //department name
    NET_DVR_ATTENDANCE_TIME struAttendanceTime[ABNORMAL_INFO_NUM]; //attendance time
    DWORD                 dwLateMinutes;    //late minutes
    DWORD                 dwLeaveEarlyMinutes; //leave early minutes
    DWORD                 dwAbsenceMinutes; //absence minutes
    DWORD                 dwTotalMinutes;   //total minutes
    BYTE                  byRes[128];
}NET_DVR_ABNORMAL_CFG, *LPNET_DVR_ABNORMAL_CFG;

typedef struct tagNET_DVR_CARD_CFG_V50
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // the card parameter need to modify, valid when set card parameter, use by bit, every bit means a kind of parameter, 1 means modify, 0 means not 
    // #define CARD_PARAM_CARD_VALID       0x00000001 //card valid parameter 
    // #define CARD_PARAM_VALID            0x00000002  //valid period parameter
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //card type parameter
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //door right parameter
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //leader card parameter
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //max swipe time parameter
    // #define CARD_PARAM_GROUP            0x00000040  //belong group parameter
    // #define CARD_PARAM_PASSWORD         0x00000080  //card password parameter
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //card right plan parameter
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //has swiped card time parameter
    // #define CARD_PARAM_EMPLOYEE_NO      0x00000400  //employee no
    // #define CARD_PARAM_NAME             0x00000800  //name
    // #define CARD_PARAM_DEPARTMENT_NO    0x00001000  //department no
    // #define CARD_SCHEDULE_PLAN_NO       0x00002000  //schedule plan no
    // #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //schedule plan type
    // #define CARD_ROOM_NUMBER            0x00008000  //room number
    // #define CARD_SIM_NO                 0x00010000  //phone number
    // #define CARD_FLOOR_NUMBER           0x00020000  //floor number
    // #define CARD_USER_TYPE              0x00040000  //user type
    BYTE byCardNo[ACS_CARD_NO_LEN]; //card No
    BYTE byCardValid; //whether is a vaild card,0-invalid,1-valid(use to delete card, 0 means delete card when setting, it will be 1 when getting)
    BYTE byCardType; //card type ,1-ordinary card,2-accessible card,3-block list card, 4-patrol card,5-stress card,6-super card,7-client card,8-remove card, 9-employee card,10-emergency card,11-emergency management card(use authorize temporary card permission,this card can not open door),default ordinary card 
    BYTE byLeaderCard; //whether is leader card, 0-no, 1-yes
    BYTE byUserType; //0-normal, 1-admin;
    BYTE byDoorRight[MAX_DOOR_NUM_256]; //door right (floor right,lock right), accord to bit, 1-has right 0-no right, from low bit to high bit means door(lock) 1-N have right
    NET_DVR_VALID_PERIOD_CFG struValid; //valid period parameter
    BYTE  byBelongGroup[MAX_GROUP_NUM_128]; //Subordinate to the group, in bytes, 1 - belongs to, 0 - does not belong to 
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //card password 
    WORD wCardRightPlan[MAX_DOOR_NUM_256][MAX_CARD_RIGHT_PLAN_NUM]; //card right plan, value is from plan template No. use or method when same door(lock) has different plan template
    DWORD dwMaxSwipeTime; //max card time, 0 means infinite time(unlock time)
    DWORD dwSwipeTime; //has swiped card
    WORD wRoomNumber;  //room number
    SHORT wFloorNumber;   //floor number
    DWORD dwEmployeeNo;   //employee no(user id)
    BYTE byName[NAME_LEN];   //name
    WORD wDepartmentNo;   //department no
    WORD wSchedulePlanNo;   //schedule plan no
    BYTE bySchedulePlanType;  //schedule plan type:0-no mean,1-personal,2-department
    BYTE byRightType;  //right type: 0-card right, 1-QR right, 2-bluetooth right
    BYTE byRes2[2];
    DWORD dwLockID;  
    BYTE byLockCode[MAX_LOCK_CODE_LEN];    
    BYTE byRoomCode[MAX_DOOR_CODE_LEN];  
    DWORD dwCardRight;      
    DWORD dwPlanTemplate;   
    DWORD dwCardUserId;    
    BYTE byCardModelType;  
    BYTE byRes3[51];
    BYTE bySIMNum[NAME_LEN/*32*/]; //SIM number (phone number)
}NET_DVR_CARD_CFG_V50, *LPNET_DVR_CARD_CFG_V50;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_COND
{
    DWORD  dwSize;
    BYTE   byFingerPrintPicType;    //pic type:0-no sense 
    BYTE   byFingerNo;              //finger no,range:1-10
    BYTE   byRes[126];
}NET_DVR_CAPTURE_FINGERPRINT_COND, *LPNET_DVR_CAPTURE_FINGERPRINT_COND;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_CFG
{
    DWORD dwSize;
    DWORD dwFingerPrintDataSize;    //finger print data size
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //finger data
    DWORD dwFingerPrintPicSize;    //finger print pic size
    char* pFingerPrintPicBuffer;       //finger print pic buffer
    BYTE  byFingerNo;              //finger no,range:1-10
    BYTE  byFingerPrintQuality;    //finger print quality,range:1-100
    BYTE  byRes[62];
}NET_DVR_CAPTURE_FINGERPRINT_CFG, *LPNET_DVR_CAPTURE_FINGERPRINT_CFG;

typedef  struct tagNET_DVR_CAPTURE_FACE_COND
{
    DWORD  dwSize;
    BYTE   byRes[128];
}NET_DVR_CAPTURE_FACE_COND, *LPNET_DVR_CAPTURE_FACE_COND;

typedef struct tagNET_DVR_FACE_FEATURE
{
    NET_VCA_RECT struFace; //face rectangular
    NET_VCA_POINT    struLeftEye;    // left eye position
    NET_VCA_POINT    struRightEye;   // right eye position
    NET_VCA_POINT    struLeftMouth;  // left mouth position
    NET_VCA_POINT    struRightMouth; // right mouth position
    NET_VCA_POINT    struNoseTip;    // nose position
}NET_DVR_FACE_FEATURE, *LPNET_DVR_FACE_FEATURE;


typedef  struct tagNET_DVR_CAPTURE_FACE_CFG
{
    DWORD  dwSize;
    DWORD  dwFaceTemplate1Size;   //face template 1 size
    char*  pFaceTemplate1Buffer;  //face template 1 buffer
    DWORD  dwFaceTemplate2Size;   //face template 2 size
    char*  pFaceTemplate2Buffer;  //face template 2 buffer
    DWORD  dwFacePicSize;         //face picture size
    char*  pFacePicBuffer;        //face picture buffer
    BYTE   byFaceQuality1;        //face quality,range:1-100
    BYTE   byFaceQuality2;        //face quality,range:1-100
    BYTE   byCaptureProgress;     //capture progress
    BYTE   byFacePicQuality;
    DWORD   dwInfraredFacePicSize;
    char*  pInfraredFacePicBuffer;
    BYTE   byInfraredFacePicQuality;
    BYTE   byRes1[3];
    NET_DVR_FACE_FEATURE struFeature;
    BYTE   byRes[56];
}NET_DVR_CAPTURE_FACE_CFG, *LPNET_DVR_CAPTURE_FACE_CFG;

typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //stream id
    BYTE    byRes[128];
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND;

typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //stream id
    BYTE    byExecutable;           //0-cannot passback,1-passback
    BYTE    byUnexecutableReason;   //reason, 0-need wait,1-cannot connect,2-stream id invalid,3-CVR abnormal,4-no video, 5-username or password error, 6-front top device incompatible, 7-other reasons
    BYTE    byRes[254];
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET;

typedef struct tagNET_DVR_STREAM_MEDIA_CFG
{
    DWORD   dwSize;
    BYTE    sUrl[MAX_URL_LEN];
    NET_DVR_IPADDR    struDMSIP; /* dms IP */
    WORD   wDMSPort;  /*dms port */
    BYTE    byRes1[2];
    DWORD   dwDomainID; /*domain id*/
    BYTE    byRes[360];
}NET_DVR_STREAM_MEDIA_CFG, *LPNET_DVR_STREAM_MEDIA_CFG;

//Ship detection a single zone configuration 
typedef struct tagNET_DVR_SHIPSDETECTION_REGION_CFG
{
    BYTE    byRuleID;
    BYTE    byEnable;     //Can make 
    BYTE  bySensitivity;  //Parameter sensitivity, range [1,100]
    BYTE    byFrameOverlayEnabled;//Whether the video overlay test box 
    BYTE   byRes[36];
    NET_ITC_POLYGON struPolygon; //Trigger zone 
    NET_VCA_LINE struTriggerLine;  //Trigger line 
}NET_DVR_SHIPSDETECTION_REGION_CFG, *LPNET_DVR_SHIPSDETECTION_REGION_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//Can make
    BYTE   byRes1[3];
    float    fLookDownUpAngle;//Equipment pitch Angle, accurate to one decimal places 
    float    fHorizontalHeight;//Equipment level, accurate to one decimal places 
    NET_DVR_SHIPSDETECTION_REGION_CFG struShipsDetectionRegion[MAX_SHIPSDETE_REGION_NUM];//Ship detection a single zone configuration 
    BYTE   byRes[256];
}NET_DVR_SHIPSDETECTION_CFG, *LPNET_DVR_SHIPSDETECTION_CFG;

typedef    struct tagNET_DVR_TEMPERATURE_COLOR
{
    BYTE     byType;//Control Type,0~High Temperature Alarm,1~Low Temperature Alarm,2~Section Temperature Alarm,3~Heat Preservation Alarm,4~null alarm
    BYTE     byRes1[3];
    int      iHighTemperature;//High Temperature, -273~10000
    int      iLowTemperature;//Low Temperature,-273~10000
    BYTE     byRes[8];
}NET_DVR_TEMPERATURE_COLOR, *LPNET_DVR_TEMPERATURE_COLOR;

typedef    struct tagNET_DVR_THERMOMETRY_BASICPARAM
{
    DWORD      dwSize;
    BYTE      byEnabled;  //Enabled:0- Disable,1- Enable
    BYTE      byStreamOverlay; //Stream Overlay:0- No,1- Yes
    BYTE      byPictureOverlay;//Picture Overlay:0- No,1- Yes
    BYTE      byThermometryRange;//Thermometry Range,0-Default,1-(-20~150),2-(0~550),3-(0-650),4-(-40~150),5-(0-1200),6-(-20-120),7-(20~350),8-(20~45),,9-(30~45)0xff-Auto
    BYTE      byThermometryUnit;//Thermometry Unit: 0-(),1-(H),2-(K).
    BYTE      byThermometryCurve;//temperature curve mode display mode, 0 - closed, 1 - pattern 1 (transverse temperature trend line mode), 2 - to mode 2 (longitudinal temperature trend line mode) ,0xff-automatic
    BYTE      byFireImageModea;//Model of fire image, 0-res, 1 - black and white, 2 - thermal detection modes, 3 - fire mode (field 0 remains, avoid compatible with interface before) 
    BYTE      byShowTempStripEnable;//Show temperature Strip Enable
    float     fEmissivity;//Emission rate (emissivity accurate to two decimal places) [0.01, 1.00] (i.e., the object of radiant energy outward) 
    BYTE      byDistanceUnit;//Distance unit: 0-meter,1-feet 2-cm
    BYTE      byEnviroHumidity;//Environment Humidity,range:0~100%
    BYTE      byRes2[2];
    NET_DVR_TEMPERATURE_COLOR struTempColor;//Thermometry Alarm Color
    int       iEnviroTemperature;//Environment Temperatrue,range:-273~10000()
    int       iCorrectionVolume;//Range:-100~100
    /*
    bit0-center point display:0-no,1-yes;
    bit1-highest point display:0-no,1-yes;
    bit2-lowest point display:0-no,1-yes;
    */
    BYTE       bySpecialPointThermType;// special point display
    BYTE       byReflectiveEnabled;//0-no,1- yes
    WORD       wDistance;//unit(m)[0,10000]
    float      fReflectiveTemperature;//Accurate to one decimal place
    float      fAlert;//Alert
    float      fAlarm;//Alarm
    float         fThermalOpticalTransmittance;// 
    float      fExternalOpticsWindowCorrection;//
    BYTE       byDisplayMaxTemperatureEnabled;//0-no 1-yes
    BYTE       byDisplayMinTemperatureEnabled;//0-no 1-yes
    BYTE       byDisplayAverageTemperatureEnabled;// 0-no 1-yes
    BYTE       byThermometryInfoDisplayposition;// 0-res 1-rules_around rule 2-top_left_of_screen
    DWORD      dwAlertFilteringTime;//Waiting time for temperature warning(s)
    DWORD      dwAlarmFilteringTime;//Waiting time for temperature alarm(s)
    BYTE       byemissivityMode; //Emissivity Configuration Types 1-Rough, 2-Rough, 3-Smoother, 4-Smooth, 0xff-Custom
    BYTE       bydisplayTemperatureInOpticalChannelEnabled;//Visible display temperature information enabled, 0-not enabled, 1 enabled
    BYTE       byDisplayCentreTemperatureEnabled;// Display CentreT emperature 0-not enabled, 1 enabled
    BYTE       byRes[49];
}NET_DVR_THERMOMETRY_BASICPARAM, *LPNET_DVR_THERMOMETRY_BASICPARAM;

typedef    struct tagNET_DVR_THERMOMETRY_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;
    WORD        wPresetNo;
    BYTE        byRes[62];
}NET_DVR_THERMOMETRY_COND, *LPNET_DVR_THERMOMETRY_COND;


typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO_PARAM
{
    BYTE    byEnabled;  //Enabled
    BYTE    byRuleID;//Rule ID
    WORD    wDistance;//Distance(m)
    float   fEmissivity;//Emissivity
    BYTE    byDistanceUnit;//0-m 1-feet 2-cm
    BYTE    byRes[2];
    BYTE    byReflectiveEnabled;//Reflective Enabled
    float   fReflectiveTemperature;//Reflective Temperature
    char    szRuleName[NAME_LEN/*32*/];//Rule Name
    BYTE    byemissivityMode; //Emissivity Configuration Types 1-Rough, 2-Rough, 3-Smoother, 4-Smooth, 0xff-Custom
    BYTE    byRes1[62];
    BYTE    byRuleCalibType;//Rule Calib Type
    NET_VCA_POINT struPoint;//Point
    NET_VCA_POLYGON struRegion;//Region
}NET_DVR_THERMOMETRY_PRESETINFO_PARAM, *LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO
{
    DWORD        dwSize;
    WORD        wPresetNo;
    BYTE        byRes[2];
    NET_DVR_THERMOMETRY_PRESETINFO_PARAM struPresetInfo[MAX_THERMOMETRY_REGION_NUM/*40*/];
}NET_DVR_THERMOMETRY_PRESETINFO, *LPNET_DVR_THERMOMETRY_PRESETINFO;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE_PARAM
{
    BYTE      byEnable;
    BYTE      byRuleID;//Rule ID
    BYTE      byRule;//Rule
    BYTE      byRes;
    char      szRuleName[NAME_LEN];//Rule Name
    float     fAlert;//Alert
    float     fAlarm;//Alarm
    float     fThreshold;//Threshold
    DWORD     dwAlertFilteringTime;//Alert Filtering Time
    DWORD     dwAlarmFilteringTime;//Alarm Filtering Time
    BYTE      byRes1[56];
}NET_DVR_THERMOMETRY_ALARMRULE_PARAM, *LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE
{
    DWORD        dwSize;
    NET_DVR_THERMOMETRY_ALARMRULE_PARAM  struThermometryAlarmRuleParam[THERMOMETRY_ALARMRULE_NUM];
    BYTE        byRes[128];
}NET_DVR_THERMOMETRY_ALARMRULE, *LPNET_DVR_THERMOMETRY_ALARMRULE;


typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM
{
    BYTE       byEnable;
    BYTE       byRuleID;//Rule ID
    BYTE       byAlarmID1;
    BYTE       byAlarmID2;
    BYTE       byRule;//Alarm temperature comparison method 0- high temperature is greater than, 1- high temperature is less than, 2- low temperature is greater than, 3- low temperature is less than, 4- average temperature is greater than, 5- average temperature is less than, 6- temperature difference is greater than, 7- temperature difference is less than 
    BYTE       byRes[3];
    float      fTemperatureDiff;//Temperature Difference
    DWORD      dwAlarmFilteringTime;//AlarmFilteringTime
    BYTE       byRes1[28];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON
{
    DWORD        dwSize;
    NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM  struDiffComparison[MAX_THERMOMETRY_DIFFCOMPARISON_NUM/*8*/];
    BYTE        byRes[64];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON;


//Realtime Thermometry Cond
typedef struct tagNET_DVR_REALTIME_THERMOMETRY_COND
{
    DWORD        dwSize;
    DWORD        dwChan;// channel number, starting at 1, 0xffffffff represents access to all channels
    BYTE        byRuleID;
    BYTE        byMode; //Mode, 0-reserved, 1-timing, 2-temperature
    WORD        wInterval; //Upload interval, only temperature difference mode is supported, 1~3600S, filling in 0 will be uploaded once as the default
    float       fTemperatureDiff;//Temperature difference
    BYTE        byRes[56];
}NET_DVR_REALTIME_THERMOMETRY_COND, *LPNET_DVR_REALTIME_THERMOMETRY_COND;

typedef struct tagNET_DVR_POINT_THERM_CFG
{
    float        fTemperature;//Temperature
    NET_VCA_POINT struPoint;//Point
    BYTE        byRes[120];
}NET_DVR_POINT_THERM_CFG, *LPNET_DVR_POINT_THERM_CFG;

typedef struct tagNET_DVR_LINEPOLYGON_THERM_CFG
{
    float       fMaxTemperature;//Max Temperature
    float        fMinTemperature;//Min Temperature
    float       fAverageTemperature;//Average Temperature
    float        fTemperatureDiff;//Temperature Difference
    NET_VCA_POLYGON struRegion;//Region
    BYTE        byRes[32];
}NET_DVR_LINEPOLYGON_THERM_CFG, *LPNET_DVR_LINEPOLYGON_THERM_CFG;

typedef struct tagNET_DVR_THERMOMETRY_UPLOAD
{
    DWORD       dwSize;
    DWORD       dwRelativeTime;     //Relative Time
    DWORD       dwAbsTime;            //AbsTime
    char        szRuleName[NAME_LEN/*32*/];//Rule Name
    BYTE        byRuleID;//Rule ID
    BYTE        byRuleCalibType;//Rule Calibration Type 0-Point,1-Region
    WORD        wPresetNo; //Preset No
    NET_DVR_POINT_THERM_CFG struPointThermCfg;
    NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
    BYTE        byThermometryUnit;//Thermometry Unit
    BYTE        byDataType;  //data type
    BYTE		byRes1;
    /*
    bit0-center point support:0-no,1-yes;
    bit1-highest point support:0-no,1-yes;
    bit2-lowest point support:0-no,1-yes;
    */
    BYTE      bySpecialPointThermType;  //special point thermtype
    float	   fCenterPointTemperature;  // Center point temperature, accurate to one decimal places(-40~1500)
    float	   fHighestPointTemperature; // Highest point  temperature, accurate to one decimal places(-40~1500)
    float	   fLowestPointTemperature; // Lowest point temperature, accurate to one decimal places(-40~1500)
    NET_VCA_POINT struHighestPoint;
    NET_VCA_POINT struLowestPoint;
    BYTE          byIsFreezedata;  //Freeze data :0-no,1-yes;
    BYTE          byFaceSnapThermometryEnabled;
    BYTE          byRes2[2];
    DWORD         dwChan; //Channel number, which takes effect when the channel number in the query condition is 0xffffffff
    NET_VCA_RECT         struFaceRect;    
    DWORD      dwTimestamp;//
    BYTE          byRes[68];
}NET_DVR_THERMOMETRY_UPLOAD, *LPNET_DVR_THERMOMETRY_UPLOAD;

//Thermometry Alarm
typedef struct tagNET_DVR_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    BYTE    byRuleID;//Rule ID
    BYTE    byThermometryUnit;//Thermometry Unit: 0-(),1-(H),2-(K)
    WORD    wPresetNo; //Preset No.
    NET_PTZ_INFO  struPtzInfo;//ptz 
    BYTE    byAlarmLevel;//0-Advance Alarm 1-Alarm
    BYTE    byAlarmType;/*Alarm Type 0-Max Temperature 1-Min Temperature 2-Average Temperature 3-Temperature Difference  4-sudden up 5-sudden down*/
    BYTE    byAlarmRule;//0-Greater than,1-Less than
    BYTE    byRuleCalibType;//Regular calibration type 0-Point,1-Region, 2-Line
    NET_VCA_POINT struPoint;//Point
    NET_VCA_POLYGON struRegion;//Region
    float   fRuleTemperature;/*Rule Temperature */
    float   fCurrTemperature;/*current Temperature  */
    DWORD   dwPicLen;//Picture Len
    DWORD   dwThermalPicLen;//Thermal Picture Len
    DWORD   dwThermalInfoLen;//Thermal Info Len
    char*   pPicBuff;//Picture
    char*   pThermalPicBuff;//Thermal Picture
    char*   pThermalInfoBuff;//Thermal Info
    NET_VCA_POINT struHighestPoint;//Highest Point
    float   fToleranceTemperature;//
    DWORD   dwAlertFilteringTime;//
    DWORD   dwAlarmFilteringTime;//
    DWORD   dwTemperatureSuddenChangeCycle;//
    float   fTemperatureSuddenChangeValue;//
    BYTE    byPicTransType;        //Image data transmission: 0-binary; 1-url
    BYTE    byRes1[3];
    DWORD   dwVisibleChannel; 
    DWORD   dwRelativeTime;   
    DWORD   dwAbsTime;        
    float   fAlarmRuleTemperature;
    BYTE    byRes[20];
}NET_DVR_THERMOMETRY_ALARM, *LPNET_DVR_THERMOMETRY_ALARM;


//Thermometry Difference Alarm
typedef struct tagNET_DVR_THERMOMETRY_DIFF_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//Channel
    BYTE    byAlarmID1;//AlarmID1
    BYTE    byAlarmID2;//AlarmID2
    WORD    wPresetNo; //Preset No.
    BYTE    byAlarmLevel;//0-Advance Alarm 1-Alarm
    BYTE    byAlarmType;//Alarm Type 0-Max Temperature 1-Min Temperature 2-Average Temperature 3-Temperature Difference
    BYTE    byAlarmRule;//0-Greater than,1-Less than
    BYTE    byRuleCalibType;//Regular calibration type 0-Point,1-Region
    NET_VCA_POINT struPoint[2];//Point
    NET_VCA_POLYGON struRegion[2];//Region
    float   fRuleTemperatureDiff;//Rule Temperature
    float   fCurTemperatureDiff;//current Temperature 
    NET_PTZ_INFO  struPtzInfo;//ptz
    DWORD   dwPicLen;//Picture Len
    DWORD   dwThermalPicLen;//Thermal Picture Len
    DWORD   dwThermalInfoLen;//Thermal Info Len
    char*   pPicBuff;//Picture
    char*   pThermalPicBuff;//Thermal Picture
    char*   pThermalInfoBuff;//Thermal Info
    BYTE    byThermometryUnit;//Thermometry Unit: 0-(),1-(H),2-(K)
    BYTE    byPicTransType;        //Image data transmission: 0-binary; 1-url
    BYTE    byRes1[2];
    float   fToleranceTemperature;//
    DWORD   dwAlarmFilteringTime;//
    DWORD   dwVisibleChannel; 
    BYTE    byRes[48];
}NET_DVR_THERMOMETRY_DIFF_ALARM, *LPNET_DVR_THERMOMETRY_DIFF_ALARM;

typedef  struct  //Conditions of structure 
{
    DWORD   dwSize;
    DWORD  dwChannel;//Channel number (front-end default is 1) 
    BYTE   byRes[128];
}NET_DVR_SHIPSCOUNT_COND, *LPNET_DVR_SHIPSCOUNT_COND;


//get ships counting information structure 
typedef struct tagNET_DVR_SHIPSCOUNT_CFG
{
    DWORD dwSize;
    DWORD dwUpShipsCount; //Number of uplink ships 
    DWORD dwDownShipsCount; //Number of downward ships
    DWORD dwLeftShipsCount; //Number of ships left 
    DWORD dwRightShipsCount; //Another ship number 
    DWORD dwTotalCount;//The relative timing counting equipment side began to count 
    DWORD dwRelativeTime; //Relative Time
    DWORD dwAbsTime; //Counting equipment side began to count the absolute time scale 
    BYTE   byDataType;//State of data types: 0 - tests, 1 -, 2 - end 
    BYTE   byRes[255];
}NET_DVR_SHIPSCOUNT_CFG, *LPNET_DVR_SHIPSCOUNT_CFG;


//Ships Info
typedef struct tagNET_DVR_SHIPSINFO
{
    float     fShipsLength; //Ships Length
    float     fShipsHeight; //Ships Height
    float     fShipsWidth;  //Ships Width
    float     fShipsSpeed;  //Ships Speed
    BYTE      byShipsDirection;//Ships Direction
    BYTE      byShipsDetState;//Ship detection; 0~ across the detection line, 1~the bow, 2~ the stern
    BYTE      byTriggerLineID;// ID
    BYTE      byRes[61];
    NET_VCA_POLYGON  struShipsRect; //Ships Rect
} NET_DVR_SHIPSINFO, *LPNET_DVR_SHIPSINFO;

//Ships Capture Info
typedef struct tagNET_DVR_SHIPIMAGE_INFO
{
    DWORD   dwShipImageLen;//Ships Capture Binary Data Length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*   pXmlBuf;  //Ships Capture Binary Data Pointer
#else
    char*   pXmlBuf;  //Ships Capture Binary Data Pointer
    BYTE    byRes[4];
#endif
}NET_DVR_SHIPIMAGE_INFO, *LPNET_DVR_SHIPIMAGE_INFO;

//Ships Dectction Alarm
typedef struct tagNET_DVR_SHIPSDETECTION_ALARM
{
    DWORD   dwSize;
    NET_VCA_DEV_INFO  struDevInfo;   //Device Info
    DWORD   dwRelativeTime; //Relative Time
    DWORD   dwAbsTime; //Abs Time
    BYTE    byShipsNum; //Ships Num
    BYTE    byShipsNumHead;//Ships Num;(The bow number of detected ships)
    BYTE    byShipsNumEnd; //Ships Num;(The stern number of detected ships)
    BYTE    byPicTransType;        //Image data transmission: 0-binary; 1-url
    NET_DVR_SHIPSINFO struShipInfo[MAX_SHIPS_NUM/*20*/];//Ship Info
    DWORD   dwPicLen;//Picture Length
    DWORD   dwThermalPicLen;//Thermal Picture Length
    BYTE*   pPicBuffer;    //Picture Buffer
    BYTE*   pThermalPicBuffer;          //Thermal Picture Buffer
    WORD    wDevInfoIvmsChannelEx;      //NET_VCA_DEV_INFO->byIvmsChannel
    BYTE    byTimeDiffFlag;      /*Time difference is valid or not 0-invalid 1-valid */
    char    cTimeDifferenceH;         /*Time difference(HOUR) from UTC */
    char    cTimeDifferenceM;      	/*Time difference(MINUTE) from UTC*/
    BYTE    bySID;//Scenario ID
    BYTE    byRes1[2];
    char    szSceneName[NAME_LEN];//Scenario name, no more than 32 characters
    BYTE    byRes[132];
    DWORD   dwXmlLen;//XML data length, The EventNotificationAlert XML Block data length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*   pXmlBuf; // XML alarm info pointer, EventNotificationAlert XML Block
#else
    char*   pXmlBuf; // XML alarm info pointer, EventNotificationAlert XML Block
    BYTE    byRes2[4];
#endif
    NET_DVR_SHIPIMAGE_INFO  struShipImageInfo[MAX_SHIPIMAGE_NUM/*6*/];// Array of Ships capture image info, no more than 6 image
}NET_DVR_SHIPSDETECTION_ALARM, *LPNET_DVR_SHIPSDETECTION_ALARM;

typedef    struct tagNET_DVR_RULESLINE_CFG
{
    NET_DVR_RGB_COLOR struRGB;// RGB parameters: R (red), G (green) and B (blue) range of 0-255 
    BYTE      byRes[128];
}NET_DVR_RULESLINE_CFG, *LPNET_DVR_RULESLINE_CFG;

typedef    struct tagNET_DVR_THERMAL_INTELRULE_DISPLAY
{
    DWORD       dwSize;
    BYTE      byFontSizeType;//font size ratio index
    BYTE      byRes1[3];
    NET_DVR_RULESLINE_CFG struNormalRulesLineCfg;//Normal rules line correlation property parameters 
    NET_DVR_RULESLINE_CFG struAlertRulesLineCfg;//Early warning rules line correlation property parameter 
    NET_DVR_RULESLINE_CFG struAlarmRulesLineCfg;//Alarm rules line correlation property parameters 
    BYTE      byRes[640];
}NET_DVR_THERMAL_INTELRULE_DISPLAY, *LPNET_DVR_THERMAL_INTELRULE_DISPLAY;

typedef    struct tagNET_DVR_THERMAL_PIP
{
    DWORD     dwSize;
    BYTE      byEnable;
    BYTE      byPipMode;//Picture in picture mode, 0 ~ superposition model, 1 ~ fusion model 2-normal model 
    BYTE      byOverlapType;/*Superposition type, Choose picture in picture come into force after the overlay mode.
                            0 ~visible light overlay thermal imaging picture, 1 ~thermal imaging superposition visible light images*/
    BYTE      byTransparency;//Transparency, 0 ~ 100 
    NET_VCA_POLYGON struPipRegion;//Picture in picture area
    BYTE      byImageFusionRatio;// dep on fusion mode, range 0-100 default 75
    BYTE      byBorderFusionRatio;//dep on fusion mode, range 0-100 default 100
    BYTE      byRes1[2];
    float     fDistance;//Fusion Distance,Fusion Mode Effective, Range 0.1-4.0 M
    BYTE      byRes[632];
}NET_DVR_THERMAL_PIP, *LPNET_DVR_THERMAL_PIP;

typedef struct tagNET_DVR_BAREDATAOVERLAY_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//Enable
    BYTE    byIntervalTime;// Interval Time
    BYTE    byRes[258];
}NET_DVR_BAREDATAOVERLAY_CFG, *LPNET_DVR_BAREDATAOVERLAY_CFG;

//Thermometry Trigger Cond
typedef    struct tagNET_DVR_THERMOMETRY_TRIGGER_COND
{
    DWORD    dwSize;
    DWORD    dwChan;//Channel
    DWORD    dwPreset;//Preset(currently does not support) 
    BYTE     byRes[256];
}NET_DVR_THERMOMETRY_TRIGGER_COND, *LPNET_DVR_THERMOMETRY_TRIGGER_COND;

//terminal register GK info
typedef struct tagNET_DVR_TERMINAL_GK_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //enable
    BYTE  byRegisterState;    //register status,0-not,1-yes,readly only
    BYTE  byRes1[2];
    NET_DVR_IPADDR struGKIP; //GK IP
    WORD wGKPort; //GK port
    BYTE byRes2[2];
    BYTE byRegisterName[REGISTER_NAME_LEN]; //terminal register gk name
    BYTE byPassword[PASSWD_LEN];    //terminal password
    BYTE byRes3[16];
}NET_DVR_TERMINAL_GK_CFG, *LPNET_DVR_TERMINAL_GK_CFG;


typedef    struct tagNET_DVR_MANUALDEICING_CFG
{
    DWORD        dwSize;
    BYTE        byEnabled; //Manual Deicing
    BYTE        byRes[127];
}NET_DVR_MANUALDEICING_CFG, *LPNET_DVR_MANUALDEICING_CFG;
typedef struct tagNET_DVR_POS_HIDDEN_INFORMATION
{
    char szKeyWord[KEY_WORD_NUM/*3*/][KEY_WORD_LEN/*128*/];
    BYTE    byRes[128];
}NET_DVR_POS_HIDDEN_INFORMATION, *LPNET_DVR_POS_HIDDEN_INFORMATION;

typedef struct tagNET_DVR_HIDDEN_INFORMATION_CFG
{
    DWORD  dwSize;
    BYTE   byFuncType;//0-Pos
    BYTE   Res1[3];
    NET_DVR_POS_HIDDEN_INFORMATION struPosInfo;
    BYTE    byRes[1024];
}NET_DVR_HIDDEN_INFORMATION_CFG, *LPNET_DVR_HIDDEN_INFORMATION_CFG;

//led controler
typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_COND
{
    DWORD    dwSize;
    DWORD    dwInputSourceNo;
    DWORD    dwTextNo;
    BYTE    byRes[32];
}NET_DVR_INPUT_SOURCE_TEXT_COND, *LPNET_DVR_INPUT_SOURCE_TEXT_COND;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT
{
    DWORD        dwSize;
    DWORD        dwTextNo;
    BYTE        byEnable;        
    BYTE        byFontSize;        
    BYTE        byBkGroudMode;        
    BYTE        byRes[1];
    DWORD        dwXPosition;        
    DWORD        dwYPosition;        
    NET_DVR_RGB_COLOR struForegroudColor;
    NET_DVR_RGB_COLOR struBackgroudColor; 
    BYTE        byTextContent[MAX_LEN_TEXT_CONTENT];    
    BYTE        byRes1[64];
}NET_DVR_INPUT_SOURCE_TEXT, *LPNET_DVR_INPUT_SOURCE_TEXT;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_SOURCE_TEXT struTextList[MAX_NUM_INPUT_SOURCE_TEXT];
    BYTE    byRes[64];
}NET_DVR_INPUT_SOURCE_TEXT_LIST, *LPNET_DVR_INPUT_SOURCE_TEXT_LIST;

typedef struct  tagNET_DVR_INPUT_SOURCE_RESOLUTION
{
    DWORD  dwSize;
    DWORD  dwInputSignalNo;
    BYTE  byEnabled;
    BYTE  byRes;
    WORD  wImageWidth;    
    WORD  wImageHeight;    
    WORD  wRefreshRate;
    BYTE  byColorDepth;    
    BYTE  byScanType;
    BYTE  byRes1[62];
}NET_DVR_INPUT_SOURCE_RESOLUTION, *LPNET_DVR_INPUT_SOURCE_RESOLUTION;

typedef struct tagNET_DVR_INPUT_SOURCE_RESOLUTION_LIST
{
    DWORD  dwSize;
    DWORD  dwInputSignalCnt;
    LPNET_DVR_INPUT_SOURCE_RESOLUTION  lpstruBuffer;
    DWORD  dwBufferSize;
    BYTE   byRes[32];
}NET_DVR_INPUT_SOURCE_RESOLUTION_LIST, *LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

typedef struct tagNET_DVR_LED_AREA_COND
{
    DWORD dwSize;
    DWORD dwVideoWallNo; 
    DWORD dwLEDAreaNo; 
    BYTE   byRes[32];
}NET_DVR_LED_AREA_COND, *LPNET_DVR_LED_AREA_COND;

typedef struct tagNET_DVR_LED_AREA_INFO
{
    DWORD dwSize;
    DWORD dwLEDAreaNo; 
    NET_DVR_RECTCFG_EX struRect; 
    DWORD dwaOutputNo[MAX_NUM_OUTPUT_CHANNEL];
    BYTE  byAreaType;
    BYTE  byRes[31];
}NET_DVR_LED_AREA_INFO, *LPNET_DVR_LED_AREA_INFO;

typedef struct tagNET_DVR_LED_AREA_INFO_LIST
{
    DWORD dwSize;
    DWORD dwLEDAreaNum; 
    LPNET_DVR_LED_AREA_INFO lpstruBuffer; 
    DWORD dwBufferSize; 
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO_LIST, *LPNET_DVR_LED_AREA_INFO_LIST;

//call waiting struct
typedef struct tagNET_DVR_CALL_WAITTING_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable,1--enable
    BYTE    byRes1;
    WORD    wWaitTime;//wait time(s)
    WORD    wCalledWaitTime;//called wait time(s)
    BYTE    byRes[510];
}NET_DVR_CALL_WAITTING_CFG, *LPNET_DVR_CALL_WAITTING_CFG;

//alarm lamp struct
typedef struct tagNET_DVR_ALARM_LAMP_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable,1--enable
    BYTE    byRes1;
    WORD   wFlashDuration;//flash duration time(s)
    WORD   wFlashIntervalTime;//flash interval time(s)
    BYTE    byRes[510];
}NET_DVR_ALARM_LAMP_CFG, *LPNET_DVR_ALARM_LAMP_CFG;

//voice promption struct
typedef struct tagNET_DVR_VOICE_PROMPTION_CFG
{
    DWORD   dwSize;    //struct size
    BYTE    byEnable;    //0--disable,1--enable
    BYTE    byRes1[3];
    BYTE    byCenterBusyFile[NAME_LEN];//center busy file name
    BYTE    byRefusedFile[NAME_LEN];//refused file name
    BYTE    byHangUpFile[NAME_LEN];//hang up file name
    BYTE    byCallWaittingFile[NAME_LEN];//call waitting file name
    BYTE    byConsultWaittingFile[NAME_LEN];//Consult waitting file name
    BYTE    byWelcomeFile[NAME_LEN];//welcome file name
    BYTE    byFarewellFile[NAME_LEN];//farewell file name
    BYTE    byCalledVoicePromptName[NAME_LEN];//called voice prompt name
    BYTE    byRes[384];
}NET_DVR_VOICE_PROMPTION_CFG, *LPNET_DVR_VOICE_PROMPTION_CFG;

//emergence alarm rsp configure
typedef struct tagNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG
{
    DWORD   dwSize;        //struct size
    BYTE    byCommand;    //command,0--centerbusy,1--refuse
    BYTE    byType;        //0--emergency call help,1--consult
    BYTE    byRes[510];
}NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG, *LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

///////////*net parameter config_V50/////////////
typedef struct _tagNET_DVR_ALARMHOST_NETPARAM_V50
{
    DWORD     dwSize;
    NET_DVR_IPADDR  struIP;
    WORD     wPort;
    BYTE    byAddressType;
    BYTE    byEnable; //0-not use,1-use
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/];
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/];
    BYTE    byProtocolVersion;       //EHome protocol version,0-invalid,1-v2.0,2-v4.0,3-v5.0
    BYTE    byRes1[3];
    BYTE    byEHomeKey[NET_SDK_EHOME_KEY_LEN];            //EHome Key
    BYTE    byRes2[28];
} NET_DVR_ALARMHOST_NETPARAM_V50, *LPNET_DVR_ALARMHOST_NETPARAM_V50;

typedef struct _tagNET_DVR_ALARMHOST_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM_V50   struNetCenter[MAX_CENTERNUM];
    BYTE        byRes1[128];
} NET_DVR_ALARMHOST_NETCFG_V50, *LPNET_DVR_ALARMHOST_NETCFG_V50;
//system pack type    
typedef enum tagSTREAM_TYPE{
    STREAM_PS = 0x1,   //PS pack
    STREAM_3GPP = 0x2,   //3GP pack
}STREAM_TYPE;
typedef enum tagNET_SDK_INIT_CFG_TYPE
{
    NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0,
    NET_SDK_INIT_CFG_ABILITY = 1,
    NET_SDK_INIT_CFG_SDK_PATH = 2,  //HCNetSDK path
	NET_SDK_INIT_CFG_LIBEAY_PATH = 3, //libeay32.dll/libcrypto.so/libcrypto.dylib path
    NET_SDK_INIT_CFG_SSLEAY_PATH = 4  //ssleay32.dll/libssl.so/libssl.dylib path
}NET_SDK_INIT_CFG_TYPE;


typedef struct tagNET_DVR_INIT_CHECK_MODULE_COM
{
    BYTE byEnable;
    BYTE byRes[255];
}NET_DVR_INIT_CHECK_MODULE_COM, *LPNET_DVR_INIT_CHECK_MODULE_COM;
typedef enum _INIT_CFG_MAX_NUM
{
    INIT_CFG_NUM_2048 = 2048,   // 2048
    INIT_CFG_NUM_5120 = 5120,   //5120
    INIT_CFG_NUM_10240 = 10240,   // 10240
    INIT_CFG_NUM_15360 = 15360,   // 15360
    INIT_CFG_NUM_20480 = 20480,   // 20480
}INIT_CFG_MAX_NUM;

typedef struct tagNET_DVR_INIT_CFG_ABILITY
{
    INIT_CFG_MAX_NUM    enumMaxLoginUsersNum;                
    INIT_CFG_MAX_NUM   enumMaxAlarmNum;                      
    BYTE    byRes[64];
}NET_DVR_INIT_CFG_ABILITY, *LPNET_DVR_INIT_CFG_ABILITY;

typedef struct tagNET_DVR_LOCAL_SDK_PATH
{
    char sPath[NET_SDK_MAX_FILE_PATH];//sdk path
    BYTE byRes[128];
}NET_DVR_LOCAL_SDK_PATH, *LPNET_DVR_LOCAL_SDK_PATH;

typedef struct tagNET_DVR_SDKMEMPOOL_CFG
{
    BYTE byRes[256];
}NET_DVR_SDKMEMPOOL_CFG, *LPNET_DVR_SDKMEMPOOL_CFG;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/];
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST, *LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource;
    DWORD  dwChannel;
    NET_DVR_IPADDR  struIP;
    WORD  wPort;
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO, *LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;
    NET_DVR_IPADDR struIP;
    WORD  wPort;
    BYTE  byRes1[2];
    DWORD dwDecChan;
    BYTE  sUserName[NAME_LEN];
    BYTE  sPassword[PASSWD_LEN];
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO, *LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum;
    DWORD dwDecChan;
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND, *LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[3];
    DWORD dwYUVAddress[3];
    WORD  wWidth;
    WORD  wHeight;
    BYTE  byEnableAudio;
    BYTE  byRes2[3];
    DWORD dwAudioAddr;
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG, *LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
    DWORD   dwSize;
    DWORD   dwVideoMangeNo;
    BYTE    byVideoType;
    BYTE    byRes1[3];
    BYTE    sVideoName[NAME_LEN]; 
    NET_DVR_TIME_V30 struTime;
    BYTE     byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
    DWORD   dwSize;
    BYTE    sFileName[NAME_LEN];
    DWORD    dwManageNo;
    NET_DVR_TIME_EX  struTime;
    BYTE    byUsed;
    BYTE    byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
    DWORD    dwSize;
    BYTE    byItemType;
    BYTE    byRes[3];
    DWORD    dwPlayManageNo;
    DWORD    dwPlayPicTime;
    BYTE    byRes2[64];
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM;

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byPlayType;
    BYTE    byVaildItemNum;
    BYTE    byRes[1];
    NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM];
    BYTE     byPlaylistName[PLAYLIST_NAME_LEN];
    DWORD   dwPlaylistNo;
    BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;
typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
    DWORD    dwSize;
    BYTE    byCtrlType;
    BYTE    byPlayIndex;
    NET_DVR_PLAY_ITEM struPlayItem;
    BYTE   byNewPlayIndex;
    BYTE   byRes[63];
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL;

typedef struct tagNET_DVR_PLAN_ITEM
{
    NET_DVR_PLAY_ITEM struPlanPlayItem;   
    NET_DVR_TIME_SEGMENT struTimeSegment;
    BYTE  byRes[16];
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byPlanMode;
    BYTE    byRes[2];
    NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwPlayPlanNo;
    BYTE    byPlayPlanName[NAME_LEN];
    BYTE    byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;
typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;
    BYTE byRes[3];
    DWORD dwPlayPlanNo;
    BYTE byRes2[32];
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG;

typedef struct tagNET_DVR_DEV_PLAYCTRL
{
    DWORD   dwSize;
    BYTE    byControlType; 
    BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;

typedef union tagNET_DVR_PLAYITEM_INFO
{
    struct
    {
        DWORD  dwPlayItem; 
        BYTE    byPlayItemName[NAME_LEN];
        BYTE    byRes2[8];
    } struPlayItem;
    struct
    {
        DWORD  dwPlaylistNo;
        BYTE    byPlaylistName[NAME_LEN];
        WORD   wPlayIndex;
        BYTE    byPlayType;  
        BYTE    byRes[3];
        DWORD  dwPlayItem;   
        BYTE    byPlayItemName[NAME_LEN];
        BYTE    byRes2[16];
    } struPlaylistItem;
    struct
    {
        DWORD  dwPlayPlanNo;
        NET_DVR_TIME_SEGMENT struTime;
        BYTE    byPlayType;
        BYTE    byRes[3];
        DWORD  dwPlaylistNo;
        BYTE    byPlaylistName[NAME_LEN];
        DWORD  dwPlayItem;
        BYTE    byPlayItemName[NAME_LEN];
        WORD   wPlayIndex;
        BYTE    byRes2[18];
    } struPlayPlanItem;
}NET_DVR_PLAYITEM_INFO, *LPNET_DVR_PLAYITEM_INFO;
typedef struct tagNET_DVR_PLAYING_INFO
{
    DWORD    dwSize;
    BYTE    byPlayWay;
    BYTE    byCurPlayType;
    BYTE    byPlayState;
    BYTE    byAudioState;
    NET_DVR_PLAYITEM_INFO  struPlayItemInfo; 
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;
    WORD wHeight;
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;
    BYTE byUseHistoryMap;
    BYTE byRes[30];
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_MULTIFUNCTION_SERIALCFG
{
    DWORD dwSize;
    BYTE  byVariable;  //serial port: 1-invariable  2-variable
    BYTE  bySerialWorkMode;   //work mode: 1-RS485, 2-RS232
    BYTE  byFunType;   //type: 1-keyboard control, 2-screen control, 3-transparent channel mode,  4-PTZ control,  5-matrix control, 6-console
    BYTE byDataBit;// data bit:  05bit, 16bit, 27bit, 38bit
    BYTE byStopBit;// stop bit:  01bit, 12bit
    BYTE byParity;// 0no check, 1odd check, 2parity check
    BYTE byFlowcontrol;// 0no, 1soft flow control, 2-hard flow control
    BYTE byRes1;
    DWORD dwBaudRate;//baud rate: 050, 175, 2110, 3150, 4300, 5600, 61200, 72400, 84800, 99600, 1019200, 1138400, 1257600, 1376800, 14115.2k   
    WORD wProtocol;   
    BYTE byRes[34];
}NET_DVR_MULTIFUNCTION_SERIALCFG, *LPNET_DVR_MULTIFUNCTION_SERIALCFG;

typedef struct tagNET_DVR_DISPINPUT_CFG_LIST
{
    DWORD  dwSize;
    DWORD  dwDispInputNum;
    LPNET_DVR_DISPINPUT_CFG lpstruBuffer;
    DWORD  dwBufferSize;
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG_LIST, *LPNET_DVR_DISPINPUT_CFG_LIST;

typedef struct tagNET_DVR_RES_INFO
{
    DWORD dwImageWidth;
    DWORD dwImageHeight;
}NET_DVR_RES_INFO, *LPNET_DVR_RES_INFO;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    DWORD dwResNums;
    NET_DVR_RES_INFO struResList[MAX_RES_NUM_ONE_VS_INPUT_CHAN];
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT, *LPNET_DVR_VS_INPUT_CHAN_INIT;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT_LIST
{
    DWORD dwSize;
    NET_DVR_VS_INPUT_CHAN_INIT struChanList[MAX_VS_INPUT_CHAN_NUM];
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT_LIST, *LPNET_DVR_VS_INPUT_CHAN_INIT_LIST;

typedef struct tagNET_DVR_VS_INPUT_CHAN_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    NET_DVR_RES_INFO struResolutin;
    BYTE byRes[64];
}NET_DVR_VS_INPUT_CHAN_CFG, *LPNET_DVR_VS_INPUT_CHAN_CFG;

typedef struct tagNET_DVR_VS_NETSRC_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan;
    BYTE byDispUrl[MAX_URL_LEN];
    BYTE byEnabled; 
    BYTE byRes[127];
}NET_DVR_VS_NETSRC_CFG, *LPNET_DVR_VS_NETSRC_CFG;

typedef struct tagNET_DVR_EDID_FILE_INFO
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNo;
    BYTE    byFileName[FILE_NAME_LEN];
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO, *LPNET_DVR_EDID_FILE_INFO;

typedef struct tagNET_DVR_EDID_FILE_INFO_LIST
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNum;
    LPNET_DVR_EDID_FILE_INFO lpstruBuffer;
    DWORD   dwBufferSize;
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO_LIST, *LPNET_DVR_EDID_FILE_INFO_LIST;

typedef struct tagNET_DVR_OSD_INFO
{
    BYTE byEnabled;
    BYTE byEnabledFlash;
    BYTE byFontSize;
    BYTE byTransparent;
    NET_DVR_RGB_COLOR struColor;
    WORD wCoordinateX;
    WORD wCoordinateY;
    BYTE byContent[MAX_LEN_OSD_CONTENT];
    BYTE byRes[32];
}NET_DVR_OSD_INFO, *LPNET_DVR_OSD_INFO;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD
{
    DWORD dwSize;
    DWORD dwSubWndNo;
    DWORD dwOSDNums;
    NET_DVR_OSD_INFO struOSDList[MAX_NUM_OSD_ONE_SUBWND];
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD, *LPNET_DVR_SUBWND_DECODE_OSD;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD_LIST
{
    DWORD dwSize;
    NET_DVR_SUBWND_DECODE_OSD struSubWndList[MAX_NUM_SPLIT_WND];
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD_LIST, *LPNET_DVR_SUBWND_DECODE_OSD_LIST;

typedef struct tagNET_DVR_DECODE_CHANNEL_OSD
{
    DWORD dwSize;
    NET_DVR_OSD_INFO struOSDInfo[MAX_NUM_OSD];
    BYTE byRes[32];
}NET_DVR_DECODE_CHANNEL_OSD, *LPNET_DVR_DECODE_CHANNEL_OSD;

typedef    struct tagNET_DVR_THERMINTELL_PARAM
{
    DWORD   dwSize;
    BYTE    byIntellType;  //Intell Type, 0~thermometryAndSmart, 1~shipsDetection, 2~fireDetection,3~PIP,4-face thermintell,5-thermometryAndSmokeFireDetection,6-thermometryAndFireDetection  7-behavior 8-thermometry
    BYTE    byRes[127];
}NET_DVR_THERMINTELL_PARAM, *LPNET_DVR_THERMINTELL_PARAM;

typedef struct tagNET_DVR_FACE_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//channel id
    BYTE    byRuleID;//rule ID 1-40
    BYTE    byRes1[3];
    BYTE    byRuleName[NAME_LEN];    //rule name
    DWORD   dwRelativeTime; //relative time
    DWORD   dwAbsTime; //abs time
    BYTE    byFaceDetectionState;//face detect state  0-no face 1-had face
    BYTE    byThermometryUnit;//unit 0-c 1-f 2-K
    BYTE    byAlarmRule;//alarmrule:0-high 1-low
    BYTE    byRes2[1];
    float   fAlarmTemperature;//alarm temp
    float   fRuleTemperature;// rule temp
    DWORD   dwVisibleLightImageLen;// Visible Light Image Len
    BYTE    *pVisibleLightImage;  //Visible Light Image buffer
    DWORD   dwFaceImageLen;// 
    BYTE     *pFaceImage;  //
    NET_VCA_RECT  struFaceRegion;//
    float         fMinTemperature;
    float         fAverageTemperature;
    NET_VCA_POINT struMinTemperaturePoint;
    NET_VCA_POINT struMaxTemperaturePoint;
    BYTE     byRes[720];
}NET_DVR_FACE_THERMOMETRY_ALARM, *LPNET_DVR_FACE_THERMOMETRY_ALARM;

//Export GUID File
typedef struct tagNET_DVR_GUID_FILE_EXPORT
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //user login password
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_EXPORT, *LPNET_DVR_GUID_FILE_EXPORT;

//user login password check
typedef struct tagNET_DVR_LOGIN_PASSWORDCFG
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //user login password
    BYTE    byRes[256];
}NET_DVR_LOGIN_PASSWORDCFG, *LPNET_DVR_LOGIN_PASSWORDCFG;

//single security question config
typedef struct tagNET_DVR_SINGLE_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    DWORD   dwId;//index
    char    sAnswer[NET_SDK_MAX_ANSWER_LEN/*256*/];//answer
    BYTE    byMark;//mark  0-no 1-yes
    BYTE    byRes[127];
}NET_DVR_SINGLE_SECURITY_QUESTION_CFG, *LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG;

//security question config
typedef struct tagNET_DVR_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    NET_DVR_SINGLE_SECURITY_QUESTION_CFG  struSecurityQuestion[NET_SDK_MAX_QUESTION_LIST_LEN/*32*/];//security question list
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];//admin passwd
    BYTE    byRes[512];
}NET_DVR_SECURITY_QUESTION_CFG, *LPNET_DVR_SECURITY_QUESTION_CFG;

//alarm in trigger
typedef    struct tagNET_DVR_ALARMIN_TRIGGER_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //channel ,start from 1
    DWORD   dwAlarmInNo;//alarm in number from 0
    BYTE    byRes[256];
}NET_DVR_ALARMIN_TRIGGER_COND, *LPNET_DVR_ALARMIN_TRIGGER_COND;

typedef    struct tagNET_DVR_FACELIB_GUARD_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //channnel num
    char    szFDID[68];//face lib ID
    BYTE    byRes[128];
}NET_DVR_FACELIB_GUARD_COND, *LPNET_DVR_FACELIB_GUARD_COND;

typedef struct tagNET_DVR_GUID_FILE_STATUS_INFO
{
    DWORD   dwSize;
    BYTE    byLockStatus;
    BYTE    byPasswd;
    BYTE    byRetryNum;
    BYTE    byRes1;
    DWORD   dwLockTime;
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_STATUS_INFO, *LPNET_DVR_GUID_FILE_STATUS_INFO;


//Thermometry Mode
typedef    struct tagNET_DVR_THERMOMETRY_MODE
{
    DWORD     dwSize;
    BYTE      byMode;//Mode, 0~normal, 1~expert
    BYTE      byThermometryROIEnabled; //0-res 1-close 2-open
    BYTE      byRes[62];
}NET_DVR_THERMOMETRY_MODE, *LPNET_DVR_THERMOMETRY_MODE;


//Get thermal Algorithm library Version
typedef    struct tagNET_DVR_THERMAL_ALGINFO
{
    DWORD     dwSize;
    char      sThermometryAlgName[NET_SDK_MAX_THERMOMETRYALGNAME/*128*/];//Thermometry Algorithm library Name
    char      sShipsAlgName[NET_SDK_MAX_SHIPSALGNAME /*128*/];//Ships Algorithm library Name
    char      sFireAlgName[NET_SDK_MAX_FIRESALGNAME /*128*/];//Fire Algorithm library Name
    BYTE      byRes[768];
}NET_DVR_THERMAL_ALGINFO, *LPNET_DVR_THERMAL_ALGINFO;

//Current lock
typedef    struct tagNET_DVR_CURRENT_LOCK
{
    DWORD     dwSize;
    BYTE      byCurrentLock;//current Lock
    BYTE      byRes[255];
}NET_DVR_CURRENT_LOCK, *LPNET_DVR_CURRENT_LOCK;

typedef struct tagNET_VCA_FACESNAP_RAWDATA_ALARM_
{
    DWORD  dwSize;
    DWORD  dwRelativeTime;       // Relative Time
    DWORD  dwAbsTime;            // Abs Time
    NET_VCA_DEV_INFO struDevInfo;  //Device Info
    DWORD  dwJsonDataLen;        //json Data Len
    BYTE*  pJsonBuff;// json Data
    BYTE   byRes[256];
}NET_VCA_FACESNAP_RAWDATA_ALARM, *LPNET_VCA_FACESNAP_RAWDATA_ALARM;

typedef struct tagNET_DVR_ADVANCE_SCREEN_CHECK_PARAM
{
    BYTE byDelFullScreenGamut;	//valid only when byOperateType is 3,  0-no  1-yes
    BYTE byDelLightPanelGamut;	//valid only when byOperateType is 3,  0-no  1-yes
    BYTE byDelLightPanelWhiteBalance;	//valid only when byOperateType is 3,  0-no  1-yes
    BYTE byRes[13];
}NET_DVR_ADVANCE_SCREEN_CHECK_PARAM, *LPNET_DVR_ADVANCE_SCREEN_CHECK_PARAM;

typedef struct tagNET_SDK_LED_SCREEN_CHECK_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;
    BYTE byIsRGBSynChk;
    BYTE byScreenCheckType;
    BYTE byRes1;
    WORD wRgbPermil;  
    WORD wRedPermil;   
    WORD wGreenPermil; 
    WORD wBluePermil; 
    DWORD dwRectCount;  
    NET_DVR_RECTCFG_EX struRectList[MAX_SCREEN_AREA_NUM];  
    NET_DVR_ADVANCE_SCREEN_CHECK_PARAM struAdvanceScreenCheckParam;//valid only when byScreenCheckType is 1
    BYTE byRes2[48];
}NET_SDK_LED_SCREEN_CHECK_PARAM, *LPNET_SDK_LED_SCREEN_CHECK_PARAM;

typedef struct tagNET_SDK_SCREEN_CHECK_RESPONSE_DATA
{
    DWORD dwSize;
    BYTE byDataType;             
    BYTE byOperateType;        
    BYTE byProgress;              
    BYTE byStatus;                 
    NET_DVR_RECTCFG_EX struRect;
    BYTE byRes[64];
}NET_SDK_SCREEN_CHECK_RESPONSE_DATA, *LPNET_SDK_SCREEN_CHECK_RESPONSE_DATA;


#define MAX_MATRIX_SUBBOARD_NUM      16   //max matrix subboard num
#define MAX_MATRIX_SUBBOARD_NUM_V51  32  //max matrix subboard num
#define MAX_BOARD_SUBSYSTEM_NUM      12   //max board subsystem num
typedef  struct  tagNET_DVR_SUBSYSTEM_STATUS
{
    BYTE    bySubSystemType;
    BYTE    bySubSystemNo;   //sub system no
    BYTE    byOnlineStatus;  //online status 1-online 2-offline
    BYTE    byRes[49]; 
}NET_DVR_SUBSYSTEM_STATUS, *LPNET_DVR_SUBSYSTEM_STATUS;


typedef  struct  tagNET_DVR_MATRIX_SUBBOARD
{
    BYTE  byBoardNo;                //sub board no
    BYTE  byPcieConnectStatus;        //pcie connect status ,1-connected,2-disconnect
    BYTE  byRes[2];
    DWORD dwHardwareVersion;       //hardware version
    DWORD dwPcieBandwidth;        //pcie Link band width
    DWORD dwTemperature;          //subboard temperature
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //system status
    BYTE  byRes2[16];
}NET_DVR_MATRIX_SUBBOARD, *LPNET_DVR_MATRIX_SUBBOARD;
typedef struct  tagNET_DVR_MATRIX_STATUS
{
    DWORD dwSize;
    BYTE  byMainFrameType;  
    BYTE  bySoltNum;  
    BYTE  byBoardNum;   
    BYTE  byRes;
    NET_DVR_MATRIX_SUBBOARD struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    BYTE  byRes2[48];
}NET_DVR_MATRIX_STATUS, *LPNET_DVR_MATRIX_STATUS;


typedef  struct  tagNET_DVR_MATRIX_SUBBOARD_V50
{
    BYTE  byBoardNo;            
    BYTE  byPcieConnectStatus; 
    BYTE  byRes;
    BYTE  byTemperatureAlarm;  
    DWORD dwHardwareVersion;  
    DWORD dwPcieBandwidth;    
    DWORD dwTemperature;       
    NET_DVR_SUBSYSTEM_STATUS struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM];
    BYTE  bySubboardModel[32];
    BYTE  byRes1[32];
}NET_DVR_MATRIX_SUBBOARD_V50, *LPNET_DVR_MATRIX_SUBBOARD_V50;

typedef struct  tagNET_DVR_MATRIX_STATUS_V50
{
    DWORD dwSize;
    BYTE  byMainFrameType;
    BYTE  bySoltNum; 
    BYTE  byBoardNum; 
    BYTE  byLCDPanelStatus; 
    NET_DVR_MATRIX_SUBBOARD_V50 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    DWORD dwFanSequence; 
    DWORD dwFanConnectStatus;
    DWORD dwFanOperationStatus; 
    BYTE  byDeviceModel[32]; 
    BYTE  byPowerNums; 
    BYTE  byMainBoardNums; 
	BYTE  byHotStandbyMode;
    BYTE  byRes[29];
}NET_DVR_MATRIX_STATUS_V50, *LPNET_DVR_MATRIX_STATUS_V50;
typedef struct tagNET_DVR_MATRIX_SUBBOARD_V51
{
    BYTE    byBoardNo; 
    BYTE    byPcieConnectStatus; 
    BYTE    byRes1;
    BYTE    byTemperatureAlarm; 
    DWORD   dwHardwareVersion; 
    DWORD dwPcieBandwidth; 
    DWORD dwTemperature; 
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; 
    BYTE    bySubboardModel[32]; 
    BYTE    byRes2[128];
}NET_DVR_MATRIX_SUBBOARD_V51, *LPNET_DVR_MATRIX_SUBBOARD_V51;

typedef struct tagNET_DVR_MATRIX_STATUS_V51
{
    DWORD   dwSize;
    BYTE    byMainFrameType; 
    BYTE    bySoltNum; 
    BYTE    byBoardNum; 
    BYTE    byLCDPanelStatus; 
    NET_DVR_MATRIX_SUBBOARD_V51 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM_V51];
    DWORD  dwFanSequence;
    DWORD dwFanConnectStatus; 
    DWORD dwFanOperationStatus; 
    BYTE   byDeviceModel[32];
    BYTE    byFanSpeed[32]; 
    BYTE   byMainMemUsed;
    BYTE    byMainCpuUsed;
    BYTE    byNetwordUsed;
    BYTE   byRes1;
    DWORD   dwMainSoftwareVer; 
    BYTE  byPowerNums; 
    BYTE  byMainBoardNums; 
    BYTE  byHotStandbyMode;
    BYTE     byRes2[125];
}NET_DVR_MATRIX_STATUS_V51, *LPNET_DVR_MATRIX_STATUS_V51;

typedef struct _NET_DVR_SUBWIND_INFO
{
	DWORD dwSize;
    DWORD dwSubWndNo; //sub window no
	BYTE	byRes[8];
} NET_DVR_SUBWIND_INFO, *LPNET_DVR_SUBWIND_INFO;

#define NET_SDK_MAX_INDENTITY_KEY_LEN 64 //Identity Key length

//Face lib Cond
typedef struct tagNET_DVR_FACELIB_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];//FDID
    BYTE        byConcurrent;//Concurrent
    BYTE        byCover;//cover enable 0-n,1-y
    BYTE        byCustomFaceLibID;//Custom Face Lib ID: 0-n,1-y
    BYTE        byPictureSaveMode;//picture save mode,0-y,1-n
    BYTE        byIdentityKey[NET_SDK_MAX_INDENTITY_KEY_LEN /*64*/];//Identity Key
    BYTE        byRes[60];
}NET_DVR_FACELIB_COND, *LPNET_DVR_FACELIB_COND;

//Human lib Cond
typedef struct tagNET_DVR_HBDLIB_COND
{
    DWORD       dwSize;
    char        szHBDID[NET_SDK_MAX_HBDID_LEN/*256*/];//HBDID
    BYTE        byConcurrent;//Concurrent
    BYTE        byCover;//cover enable 0-n,1-y
    BYTE        byCustomHBDID;// HBDID: 0-n,1-y
    BYTE        byRes[125];
}NET_DVR_HBDLIB_COND, *LPNET_DVR_HBDLIB_COND;

typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_COND
{
    DWORD dwSize;
    DWORD  dwAudioChannel;//Voice intercom channel number 
    BYTE   byRes[128];
}NET_DVR_GBT28181_AUDIO_OUTPUT_COND, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_COND;

//GBT28181 Voice output channel configuration 
typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_CFG
{
    DWORD                   dwSize;
    char    szAudioOutNumID[MAX_COMPRESSIONID_LEN];//Voice output coding ID 
    BYTE             byRes[256];
}NET_DVR_GBT28181_AUDIO_OUTPUT_CFG, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_CFG;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA
{
    DWORD dwSize;
    DWORD dwFileSize;
    BYTE  byNoticeNumber[MAX_NOTICE_NUMBER_LEN];
    BYTE  byRes[2016];
}NET_DVR_NOTICE_VIDEO_DATA, *LPNET_DVR_NOTICE_VIDEO_DATA;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_COND
{
    DWORD       dwSize;
    BYTE  byRes[256];
}NET_DVR_NOTICE_VIDEO_DATA_COND, *LPNET_DVR_NOTICE_VIDEO_DATA_COND;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_CFG
{
    DWORD    dwSize;
    DWORD dwDataLen;     //Data Len
    char*  pDataBuffer;  //Data Buffer
    BYTE  byDataType;    //Data Type:0-invalid,1-struct data(NET_DVR_NOTICE_VIDEO_DATA),2-video data
    BYTE  byRes[63];
}NET_DVR_NOTICE_VIDEO_DATA_CFG, *LPNET_DVR_NOTICE_VIDEO_DATA_CFG;

typedef struct tagNET_DVR_UPGRADE_FIRMWARE_INFO
{
    DWORD dwMagicNumber;
    DWORD dwCheckSum;
    DWORD dwHeadLen;
    DWORD dwFileNums;
    DWORD dwLanguage;
    DWORD dwDeviceClassID;
    DWORD dwOemCode;
    BYTE  byUpgradeVersion;
    BYTE  byResFeature[15];
    BYTE  byFlashSize;
    BYTE  byRamSize;
    BYTE  byDspRamSize;
    BYTE  byRes[17];
}NET_DVR_UPGRADE_FIRMWARE_INFO, *LPNET_DVR_UPGRADE_FIRMWARE_INFO;
typedef  struct  tagNET_DVR_EXPORT_PUBLISH_SCHEDULE
{
    DWORD       dwScheduleID;// schedule ID
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //callback
    void*   pUser;    
    BYTE    byRes[32];
}NET_DVR_EXPORT_PUBLISH_SCHEDULE, *LPNET_DVR_EXPORT_PUBLISH_SCHEDULE;

typedef struct tagNET_DVR_SCHEDULE_FILE_RET
{
    DWORD   dwSize;
    char   szFileName[32];    //file name
    DWORD   dwFileLen;  //file size
    BYTE    byRes[64];
}NET_DVR_SCHEDULE_FILE_RET, *LPNET_DVR_SCHEDULE_FILE_RET;

#define NET_SDK_MAX_EXAM_ROUND_NO       64  //max exam round no
#define NET_SDK_MAX_EXAM_NO             64  //max exam no
#define NET_SDK_MAX_EXAM_SUBJECT        64  //max exam subject
#define NET_SDK_MAX_TEACHER_NO          64  //max teacher no
#define NET_SDK_MAX_TEACHER_NAME        64  //max teacher name
#define NET_SDK_MAX_EXAMINEE_NO         64  //max examinee no
#define NET_SDK_MAX_ADMISSION_TICKET    64  //max admission 

typedef struct tagNET_DVR_EXAM_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamNumber; //exam number
    BYTE  byRes[128];
}NET_DVR_EXAM_INFO_COND, *LPNET_DVR_EXAM_INFO_COND;

typedef struct tagNET_DVR_EXAM_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //exam no
    BYTE  byExamSubject[NET_SDK_MAX_EXAM_SUBJECT/*64*/]; //exam subject
    BYTE  byTeacherNo[NET_SDK_MAX_TEACHER_NO/*64*/]; //teacher no
    BYTE  byTeacherName[NET_SDK_MAX_TEACHER_NAME/*64*/]; //teacher name
    NET_DVR_TIME    struStartTime; //exam start time
    NET_DVR_TIME    struEndTime; //exam end time
    BYTE  byExamInfoValid; //exam info valid:0-invalid,1-valid
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_CFG, *LPNET_DVR_EXAM_INFO_CFG;

typedef struct tagNET_DVR_EXAM_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byStatus;  //status:0-invalid,1-failed,2-success
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_STATUS, *LPNET_DVR_EXAM_INFO_STATUS;

typedef struct tagNET_DVR_EXAMINEE_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamineeNumber; //examinee number
    BYTE  byRes[128];
}NET_DVR_EXAMINEE_INFO_COND, *LPNET_DVR_EXAMINEE_INFO_COND;

typedef struct tagNET_DVR_EXAMINEE_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //examinee no
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //admission ticket
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byName[NAME_LEN/*32*/]; //name
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  bySex; //sex:0-invalid,1-male,2-female
    BYTE  byExamineeInfoValid; //examinee info valid:0-invalid,1-valid
    BYTE  byRes[126];
}NET_DVR_EXAMINEE_INFO_CFG, *LPNET_DVR_EXAMINEE_INFO_CFG;

typedef struct tagNET_DVR_EXAMINEE_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //examinee no
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byStatus;  //status:0-invalid,1-failed,2-success
    BYTE  byRes[127];
}NET_DVR_EXAMINEE_INFO_STATUS, *LPNET_DVR_EXAMINEE_INFO_STATUS;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_COND
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //exam no
    NET_DVR_TIME    struStartTime; //exam start time
    NET_DVR_TIME    struEndTime; //exam end time
    BYTE  byRes[512];
}NET_DVR_EXAM_COMPARE_RESULT_COND, *LPNET_DVR_EXAM_COMPARE_RESULT_COND;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_CFG
{
    DWORD dwSize;
    NET_DVR_TIME    struTime; //time
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //examinee no
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //admission ticket
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //exam no
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //exam round no
    BYTE  byName[NAME_LEN/*32*/]; //name
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    DWORD dwPicDataLen; //pic data len
    char  *pPicData; //pic data
    BYTE  byRes[256];
}NET_DVR_EXAM_COMPARE_RESULT_CFG, *LPNET_DVR_EXAM_COMPARE_RESULT_CFG;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //number of picture 
    BYTE  byRes[128];
}NET_DVR_BLOCKLIST_PICTURE_COND, *LPNET_DVR_BLOCKLIST_PICTURE_COND;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //card no.
    BYTE  byStatus; //status:0-invalid,1-processing,2-failed,3-success
    BYTE  byRes[63];
}NET_DVR_BLOCKLIST_PICTURE_STATUS, *LPNET_DVR_BLOCKLIST_PICTURE_STATUS;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //card no.
    BYTE  byName[NAME_LEN/*32*/]; //name
    BYTE  bySex; //:0-invalid,1-male,2-female
    BYTE  byPictureValid; //0-following invalid,1- valid
    BYTE  byRes1[2];
    DWORD dwPictureLen;
    char*  pPictureBuffer;
    BYTE  byRes[128];
}NET_DVR_BLOCKLIST_PICTURE_CFG, *LPNET_DVR_BLOCKLIST_PICTURE_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_COND
{
    DWORD       dwSize;
    DWORD       dwBlockListNum; //number of blocklist 
    BYTE  byRes[128];
}NET_DVR_UPLOAD_ID_BLOCKLIST_COND, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_COND;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_CFG
{
    DWORD       dwSize;
    NET_DVR_ID_CARD_INFO  struIDCardCfg;//ID information
    BYTE  byBlockListValid;
    BYTE  byRes[127];
}NET_DVR_UPLOAD_ID_BLOCKLIST_CFG, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_STATUS
{
    DWORD       dwSize;
    BYTE  byIDNum[MAX_ID_NUM_LEN];  //certificate ID
    BYTE  byStatus;  //status:0-invalid,1-processing,2-failed,3-success
    BYTE  byRes[63];
}NET_DVR_UPLOAD_ID_BLOCKLIST_STATUS, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_STATUS;

typedef struct tagNET_DVR_ALARM_ISAPI_INFO
{
    char *pAlarmData;
    DWORD dwAlarmDataLen;
    BYTE byDataType;        // 0-invalid,1-xml,2-json
    BYTE byPicturesNumber; 
    BYTE byRes[2];
    void *pPicPackData; 
    BYTE byRes1[32];
}NET_DVR_ALARM_ISAPI_INFO, *LPNET_DVR_ALARM_ISAPI_INFO;

typedef struct tagNET_DVR_ALARM_ISAPI_PICDATA
{
    DWORD dwPicLen;
    BYTE byPicType;  //Picture type: 1- jpg
    BYTE byRes[3];
    char szFilename[MAX_FILE_PATH_LEN];
    BYTE *pPicData;
}NET_DVR_ALARM_ISAPI_PICDATA, *LPNET_DVR_ALARM_ISAPI_PICDATA;
typedef struct tagNET_DVR_PLAY_BY_NAME_PARA
{
    char szFileName[100]; //file name
    BYTE byDownload;    //Download 0- no, 1- yes.
    BYTE byRes1[127];
    HWND hWnd;  //handle to play
    NET_DVR_ADDRESS struAddr; //CS address info,get with find files
    //NULL represent local IP
    BYTE byRes2[256];
}NET_DVR_PLAY_BY_NAME_PARA, *LPNET_DVR_PLAY_BY_NAME_PARA;

typedef struct tagNET_DVR_PLAYBCK_BYTIME_COND_PCNVR
{
    DWORD           dwSize;
    NET_DVR_IPADDR  struIpAddr;
    WORD            wIpPort;
    BYTE            byRes[2];
    char            sDomainName[MAX_DOMAIN_NAME];
    char            sSerial[SERIALNO_LEN];
    LONG            iChannel;
    NET_DVR_TIME    struStartTime;
    NET_DVR_TIME    struStopTime;
    HWND            hWnd;
}NET_DVR_PLAYBCK_BYTIME_COND_PCNVR, *LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR;

typedef struct tagNET_DVR_DOWNLOAD_BY_NAME_COND
{
    char *pFileName;
    char *pSavedFileName;
    NET_DVR_ADDRESS struAddr;
    BYTE byRes[256];
}NET_DVR_DOWNLOAD_BY_NAME_COND, *LPNET_DVR_DOWNLOAD_BY_NAME_COND;

typedef struct    tagNET_DVR_PIC_PARAM
{
    char *pDVRFileName;
    char *pSavedFileBuf;
    DWORD dwBufLen;
    DWORD *lpdwRetLen;
    NET_DVR_ADDRESS struAddr;
    BYTE    byRes[256];
}NET_DVR_PIC_PARAM, *LPNET_DVR_PIC_PARAM;

typedef struct tagNET_DVR_FORMAT_HDD
{
    DWORD dwSize;
    DWORD dwDiskNo;
    NET_DVR_IPADDR struLocateIP;
    BYTE byRes[16];
}NET_DVR_FORMAT_HDD, *LPNET_DVR_FORMAT_HDD;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //picture num
    BYTE  byCheckTemplate; //0-check face picture,1-check face match with template or not
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_COND, *LPNET_DVR_CHECK_FACE_PICTURE_COND;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_CFG
{
    DWORD       dwSize;
    DWORD dwPictureNo; //picture No
    DWORD dwPictureLen; //picture length(<=200K)
    char*  pPictureBuffer; //pointer to buffer
    DWORD dwFaceTemplateLen;  //template len
    char*  pFaceTemplateBuffer; //template buffer
    BYTE  byRes[248];
}NET_DVR_CHECK_FACE_PICTURE_CFG, *LPNET_DVR_CHECK_FACE_PICTURE_CFG;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_STATUS
{
    DWORD       dwSize;
    DWORD dwPictureNo; //picture no
    BYTE  byCheckStatus; //check result:0-invalid,1-mode success,2-mode failed,3-communicate exception,4-no face,5-face up,6-face down,7-face left,8-face right
    //,9-face roll right ,10-face roll left,11-eyes interval small ,12-face and template match,13-face and template no match,14-wrong data
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_STATUS, *LPNET_DVR_CHECK_FACE_PICTURE_STATUS;

typedef struct tagNET_SDK_NPQ_STATE_SINGLE
{
    DWORD  dwRttUs;
    DWORD  dwRealRttUs;
    DWORD  dwBitRate;
    BYTE   byLossFraction;
    BYTE   byLossFraction2;
    BYTE   byRes[126];
}NET_SDK_NPQ_STATE_SINGLE, *LPNET_SDK_NPQ_STATE_SINGLE;


typedef struct tagNET_SDK_NPQ_STATE
{
    DWORD                       dwSize;
    NET_SDK_NPQ_STATE_SINGLE    struAudioState;
    NET_SDK_NPQ_STATE_SINGLE    struVideoState;
    BYTE                        byRes[256];
}NET_SDK_NPQ_STATE, *LPNET_SDK_NPQ_STATE;

typedef struct tagNET_SDK_NPQ_NOTIFY_PARAM
{
    LONG   iVersion;				
    DWORD dwBitRate;
    BOOL   bHaveBitrate;			
    BOOL   bHaveForceIframe;		
    BOOL   bForceIframe;			
    BOOL   bHaveScale;			   
    float  fScale;				
    BYTE   res[240];
}NET_SDK_NPQ_NOTIFY_PARAM, *LPNET_SDK_NPQ_NOTIFY_PARAM;

typedef	struct tagNET_DVR_ALARM_SEARCH_COND
{
    DWORD                       dwSize;
    NET_DVR_TIME_SEARCH_COND    strStartTime;  //start time
    NET_DVR_TIME_SEARCH_COND    strStopTime;   //stop time
    DWORD                       dwAlarmComm;   // alarm command
    char                        sAlarmUID[64]; //alarm UID
    WORD                       wEventType;//Event type, only dwAlarmComm COMM_VCA_ALARM 0x4993 smart detection alarm is valid, 0- means all events,1- mixedTargetDetection, 2- radarVideoDetection
    WORD                       wSubEventType;//The subevent type, 0- represents all the subevents, and the remaining values vary according to the value of wEventType, see the capability set for details.
    BYTE                       bySupport; //reserve
    BYTE                       byNoBoundary; //remove boundary0-no1-yesonly dwAlarmComm COMM_VCA_ALARM 0x4993 smart detection alarm is valid
    BYTE                       byRes[122];    //reserve
}NET_DVR_ALARM_SEARCH_COND, *LPNET_DVR_ALARM_SEARCH_COND;
//alarm search result struct
typedef	struct tagNET_DVR_ALARM_SEARCH_RESULT
{
    DWORD                   dwSize;
    DWORD                   dwAlarmComm;
    DWORD                   dwAlarmLen;
    char                    *pAlarmInfo;
    NET_DVR_ALARMER         struAlarmer;
    BYTE                    byRes[128];
}NET_DVR_ALARM_SEARCH_RESULT, *LPNET_DVR_ALARM_SEARCH_RESULT;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    DWORD dwFaceNum;
    BYTE  byRes[128];          //reserve
}NET_DVR_FACE_AND_TEMPLATE_COND, *LPNET_DVR_FACE_AND_TEMPLATE_COND;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    DWORD dwFaceLen;  //face picture len
    char*  pFaceBuffer;   //buffer
    DWORD dwFaceTemplateLen;  //template len
    char*  pFaceTemplateBuffer;   //template buffer
    BYTE  byRes[116];
}NET_DVR_FACE_AND_TEMPLATE_CFG, *LPNET_DVR_FACE_AND_TEMPLATE_CFG;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_STATUS
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //card no
    BYTE  byRecvStatus;//0-failed,1-success,2-full
    BYTE  byRes[131];
}NET_DVR_FACE_AND_TEMPLATE_STATUS, *LPNET_DVR_FACE_AND_TEMPLATE_STATUS;

typedef struct tagNET_DVR_SINGLE_HEATMAP_RESULT_PDC
{
    DWORD  dwMaxHeatMapValue;//max heat map value
    DWORD  dwMinHeatMapValue;//min heat map value
    DWORD  dwTimeHeatMapValue;// time heat map value
    WORD   wArrayLine;//image array line
    WORD   wArrayColumn;//image array column
    BYTE*  pBuffer;  //image information pointer
    BYTE   byRes[32];
}NET_DVR_SINGLE_HEATMAP_RESULT_PDC, *LPNET_DVR_SINGLE_HEATMAP_RESULT_PDC;

//HeatMap PDC
typedef struct tagNET_DVR_HEATMAP_RESULT_PDC
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;//start time 
    NET_DVR_TIME_EX   struEndTime;//end time
    NET_VCA_DEV_INFO  struDevInfo;//device information
    WORD   wDevInfoIvmsChannelEx;
    BYTE   byBrokenNetHttp;     //broken net,0-not, 1-yes
    BYTE   byArrayUnitType;//1-byte,2-short,4- int
    /*
    struSingleHeatMap[0]:stay heat map
    struSingleHeatMap[1]:leave heat map
    */
    NET_DVR_SINGLE_HEATMAP_RESULT_PDC struSingleHeatMap[2];
    WORD   wCurNumber;//current number
    WORD   wLeaveNumber;//leave number
    #if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char*   pEventNotificationAlertBuff; //EventNotificationAlert JSON Block("eventType":  "heatmap")
#else
    char*   pEventNotificationAlertBuff; //EventNotificationAlert JSON Block("eventType":  "heatmap")
    BYTE    byRes2[4];
#endif
    DWORD   dwEventNotificationAlertLen;//length of (EventNotificationAlert JSON Block("eventType":  "heatmap")
    BYTE    byRes1[48];
}NET_DVR_HEATMAP_RESULT_PDC, *LPNET_DVR_HEATMAP_RESULT_PDC;


//AIOP Video
typedef struct _NET_AIOP_VIDEO_HEAD_
{
    DWORD dwSize;
    DWORD dwChannel;       //Channel
    NET_DVR_SYSTEM_TIME     struTime;   //Time
    char  szTaskID[64];    //Task ID
    DWORD dwAIOPDataSize;   //AIOP data size
    DWORD dwPictureSize;    //Picture Size
    char szMPID[64]; //model ID; form  URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json),get label and description of model;
    BYTE *pBufferAIOPData;//AIOPD data
    BYTE *pBufferPicture;//picture data
    BYTE  byPictureMode;//Picture data transmission mode is 0-binary, 1-Wuhan cloud storage, pBuffer Picture is binary when byPicture Mode is 0, pBuffer Picture is Wuhan cloud URL when byPicture Mode is 1.
    BYTE  byRes2[3];//
    DWORD dwPresetIndex; //
    DWORD dwAddInfoPictureSize;	//
    BYTE *pAddInfoPictureBuffer;//
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char* pFacePicBuff; //Face image pointer
#else
    char* pFacePicBuff; //Face image pointer
    BYTE  byRes3[4];
#endif
    DWORD dwFacePicBuffLen;//The length of the data indicated by pFacePicBuff
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    char* pComparisonPicBuff; //Base image pointer
#else
    char* pComparisonPicBuff; //Base image pointer
    BYTE  byRes4[4];
#endif
    DWORD dwComparisonPicBuffLen;//The length of the data indicated by pComparisonPicBuff
    BYTE  byRes[144];
}NET_AIOP_VIDEO_HEAD, *LPNET_AIOP_VIDEO_HEAD;

//AIOP Picture
typedef struct _NET_AIOP_PICTURE_HEAD_
{
    DWORD dwSize;   
    NET_DVR_SYSTEM_TIME    struTime;    //Time
    char  szPID[64];            //PID
    DWORD dwAIOPDataSize;       //AIOP data size
    BYTE byStatus;              //Status
    BYTE  byPictureMode;//Picture data transmission mode(vaild when dwPictureSize>0) is 0-binary, 1-Wuhan cloud storage, pBuffer Picture is binary when byPicture Mode is 0, pBuffer Picture is Wuhan cloud URL when byPicture Mode is 1.
    BYTE byRes1[2];
    char szMPID[64]; //model ID
    BYTE *pBufferAIOPData;//AIOPD data
    DWORD dwPresetIndex; //
    DWORD dwPictureSize;   //picture or url length
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))
    BYTE *pBufferPicture;//picture buffer or url
#else
    BYTE *pBufferPicture;//picture buffer or url
    BYTE  byRes2[4];
#endif
    char szTaskID[64]; //taskID
    BYTE byRes[104];
}NET_AIOP_PICTURE_HEAD, *LPNET_AIOP_PICTURE_HEAD;

#define MAX_FILE_NAME_LEN		100     //max file name len
typedef struct tagNET_DVR_DOOR_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;     //file size
    BYTE  byFileName[MAX_FILE_NAME_LEN]; //file name
    BYTE  byRes1[256];
}NET_DVR_DOOR_FILE_UPLOAD_PARAM, *LPNET_DVR_DOOR_FILE_UPLOAD_PARAM;

#define AUDIO_FILE_NAME_LEN  32
//upload audio control file
typedef struct tagNET_DVR_TRANS_AUDIO_INFO
{
    DWORD  dwSize;                        //size
    char   sAudioName[AUDIO_FILE_NAME_LEN];  //audio file name
    BYTE   byAudioFormat;	               //audio format: 0-wav
    BYTE   byRes[127];
}NET_DVR_TRANS_AUDIO_INFO, *LPNET_DVR_TRANS_AUDIO_INFO;

typedef struct _NET_AIOP_POLLING_VIDEO_HEAD_
{
    DWORD dwSize;          //dwSize = sizeof(NET_AIOP_POLLING_VIDEO_HEAD)		
    DWORD dwChannel;      //
    NET_DVR_SYSTEM_TIME     struTime;//
    char  szTaskID[64];    //
    DWORD dwAIOPDataSize;	//AIOP data size
    DWORD dwPictureSize;
    char szMPID[64]; //model ID
    BYTE *pBufferAIOPData;//AIOPDdata
    BYTE *pBufferPicture;//picture data
    BYTE  byPictureMode;//Picture data transmission mode is 0-binary, 1-Wuhan cloud storage, pBuffer Picture is binary when byPicture Mode is 0, pBuffer Picture is Wuhan cloud URL when byPicture Mode is 1.
    BYTE  byRes2[3];//
    DWORD dwPresetIndex; //
    BYTE byRes[176];
} NET_AIOP_POLLING_VIDEO_HEAD, *LPNET_AIOP_POLLING_VIDEO_HEAD;

typedef struct _NET_AIOP_HISTORY_VIDEO_HEAD_
{
	DWORD dwSize;			//dwSize = sizeof(_NET_AIOP_HISTORY_VIDEO_HEAD_)		
	DWORD dwChannel;      //Channel number of device analysis channel (follow SDK protocol);
	NET_DVR_SYSTEM_TIME     struTime; 	//time
	char  szTaskID[64];    //Historical video task ID, from video task dispatch
	DWORD dwAIOPDataSize;	//AIOP data size
	DWORD dwPictureSize;	//Correspondence analysis image length
	char szMPID[64]; /*The ID of the detection model package is used to match the detection data analysis of aiop;
					 the label description information of the model package loaded by the current device can be obtained through the
					 URI (get / ISAPI / intelligent / aiopenplatform / algorithmmodel / management? Format = JSON);*/
	BYTE *pBufferAIOPData;//AIOPDdata
	BYTE *pBufferPicture;//Correspondence analysis image data
	BYTE  byPictureMode;/*Picture data transmission mode 0-binary, 1-wuhan cloud storage. When bypicturemode is 0,
						pbufferpicture is binary data, when bypicturemode is 1, pbufferpicture is Wuhan cloud URL*/
	BYTE  byRes[183];
}NET_AIOP_HISTORY_VIDEO_HEAD, *LPNET_AIOP_HISTORY_VIDEO_HEAD;

typedef struct _NET_AIOP_POLLING_SNAP_HEAD_
{
    DWORD dwSize;        //dwSize = sizeof(NET_AIOP_POLLING_SNAP_HEAD)		
    DWORD dwChannel;      //
    NET_DVR_SYSTEM_TIME     struTime;//
    char  szTaskID[64];    //
    DWORD dwAIOPDataSize;  //AIOP data size
    DWORD dwPictureSize;  //
    char szMPID[64]; //model ID
    BYTE *pBufferAIOPData;//AIOPDdata
    BYTE *pBufferPicture;//Picture size
    BYTE  byPictureMode;//Picture data transmission mode is 0-binary, 1-Wuhan cloud storage, pBuffer Picture is binary when byPicture Mode is 0, pBuffer Picture is Wuhan cloud URL when byPicture Mode is 1.
    BYTE  byRes2[3];//
    DWORD dwPresetIndex; //
	DWORD dwAddInfoPictureSize;	//
	BYTE *pAddInfoPictureBuffer;//
	BYTE  byRes[168];
} NET_AIOP_POLLING_SNAP_HEAD, *LPNET_AIOP_POLLING_SNAP_HEAD;

typedef struct tagNET_DVR_AI_ALGORITHM_MODEL
{
    DWORD dwSize;
    DWORD dwDescribeLength;  //{AlgorithmModel}file length
    char* pDescribeBuffer; //{AlgorithmModel}file
    BYTE byRes1[3];//res
    DWORD dwLicenseKeyLength; //licenseKey file length
    char* pLicenseKeyBuffer;  //licenseKey file
    BYTE byRes[120];
}NET_DVR_AI_ALGORITHM_MODEL, *LPNET_DVR_AI_ALGORITHM_MODEL;

typedef struct tagNET_DVR_AI_PICTUR_UPLOAD
{
    DWORD       dwSize;
    char         szTaskID[64];   //Task id, strlen. max = 64, unified maintenance and management of business platform
    char         szPID[64];   //Picture id, strlen. max = 64, unified maintenance and management of business platform
    BYTE        byRes[128];
}NET_DVR_AI_PICTUR_UPLOAD, *LPNET_DVR_AI_PICTUR_UPLOAD;

typedef struct _NET_DVR_CARD_RECORD
{
    DWORD                      dwSize;
    BYTE                        byCardNo[ACS_CARD_NO_LEN];
    BYTE                        byCardType;
    BYTE                        byLeaderCard;
    BYTE                        byUserType;
    BYTE                        byRes1;
    BYTE                        byDoorRight[MAX_DOOR_NUM_256];
    NET_DVR_VALID_PERIOD_CFG    struValid;
    BYTE                        byBelongGroup[MAX_GROUP_NUM_128];
    BYTE                        byCardPassword[CARD_PASSWORD_LEN];
    WORD                        wCardRightPlan[MAX_DOOR_NUM_256];
    DWORD                       dwMaxSwipeTimes;
    DWORD                       dwSwipeTimes;
    DWORD                       dwEmployeeNo;
    BYTE                        byName[NAME_LEN];
    DWORD                      dwCardRight;
    BYTE                       byRes[256];
}NET_DVR_CARD_RECORD, *LPNET_DVR_CARD_RECORD;

typedef struct _NET_DVR_CARD_COND
{
    DWORD dwSize;
    DWORD dwCardNum;
    BYTE  byRes[64];
}NET_DVR_CARD_COND, *LPNET_DVR_CARD_COND;

typedef struct _NET_DVR_CARD_SEND_DATA
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byRes[16];
}NET_DVR_CARD_SEND_DATA, *LPNET_DVR_CARD_SEND_DATA;

typedef struct _NET_DVR_CARD_STATUS
{
    DWORD   dwSize;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwErrorCode;
    BYTE    byStatus; //0-failed 1-success
    BYTE    byRes[23];
}NET_DVR_CARD_STATUS, *LPNET_DVR_CARD_STATUS;

typedef struct  _NET_DVR_FACE_RECORD
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    DWORD dwFaceLen;
    BYTE* pFaceBuffer;
    BYTE  byRes[128];
}NET_DVR_FACE_RECORD, *LPNET_DVR_FACE_RECORD;

typedef struct _NET_DVR_FACE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byErrorMsg[ERROR_MSG_LEN];
    DWORD  dwReaderNo;
    BYTE  byRecvStatus;  
    BYTE  byRes[131];
}NET_DVR_FACE_STATUS, *LPNET_DVR_FACE_STATUS;

typedef struct _NET_DVR_FACE_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    DWORD dwFaceNum;   
    DWORD dwEnableReaderNo;
    BYTE  byRes[124];
}NET_DVR_FACE_COND, *LPNET_DVR_FACE_COND;

typedef struct _NET_DVR_FINGERPRINT_RECORD
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    DWORD dwFingerPrintLen;
    DWORD  dwEnableReaderNo;
    BYTE  byFingerPrintID;
    BYTE  byFingerType;
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];
    BYTE  byRes[96];
}NET_DVR_FINGERPRINT_RECORD, *LPNET_DVR_FINGERPRINT_RECORD;

typedef struct _NET_DVR_FINGERPRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];
    BYTE  byCardReaderRecvStatus;
    BYTE  byFingerPrintID;
    BYTE  byFingerType;
    BYTE  byRecvStatus;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; 
    DWORD dwCardReaderNo;   
    BYTE  byRes[20];
}NET_DVR_FINGERPRINT_STATUS, *LPNET_DVR_FINGERPRINT_STATUS;

typedef struct tagNET_DVR_FINGERPRINT_COND
{
    DWORD   dwSize;
    DWORD   dwFingerprintNum;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwEnableReaderNo;
    BYTE    byFingerPrintID;
    BYTE    byRes[131];
}NET_DVR_FINGERPRINT_COND, *LPNET_DVR_FINGERPRINT_COND;

#define EZVIZ_CLASSSESSION_LEN  64
#define EZVIZ_DEVICEID_LEN      32
typedef struct  tagNET_DVR_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];  
    WORD wPort;       
    BYTE byLogin;
    BYTE byRes1[1];
    char sClassSession[EZVIZ_CLASSSESSION_LEN];  
    char sDeviceID[EZVIZ_DEVICEID_LEN];               
    BYTE byRes2[128];
}NET_DVR_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_EZVIZ_USER_LOGIN_INFO;

#define EZVIZ_REQURL_LEN        64
#define EZVIZ_ACCESSTOKEN_LEN   128
#define EZVIZ_CLIENTTYPE_LEN    32
#define EZVIZ_FEATURECODE_LEN   64
#define EZVIZ_OSVERSION_LEN     32
#define EZVIZ_NETTYPE_LEN       32
#define EZVIZ_SDKVERSION_LEN    32
#define EZVIZ_APPID_LEN         64
typedef struct  tagNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN]; 
    BYTE byRes1[3];
    WORD wPort;
    BYTE byRes2[2];
    char sUrl[EZVIZ_REQURL_LEN];
    char sAccessToken[EZVIZ_ACCESSTOKEN_LEN];   
    char sDeviceID[EZVIZ_DEVICEID_LEN];          
    char sClientType[EZVIZ_CLIENTTYPE_LEN];        
    char sFeatureCode[EZVIZ_FEATURECODE_LEN]; 
    char sOsVersion[EZVIZ_OSVERSION_LEN];       
    char sNetType[EZVIZ_NETTYPE_LEN];          
    char sSdkVersion[EZVIZ_SDKVERSION_LEN];       
    char sAppID[EZVIZ_APPID_LEN];                
    BYTE byRes3[512];
}NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO;

#define MAX_ERROR_MSG_LEN                  256  

typedef enum tagALARM_EXCEPTION_ERROR_ENUM
{    
    ENUM_AEE_PARAM_ERROR        = 1,   
    ENUM_AEE_LENS_ERROR         = 2,   
    ENUM_AEE_PIC_LENS_ERROR     = 3,  
    ENUM_AEE_DEVID_LENS_ERROR   = 4,   
    ENUM_AEE_NEW_ALLOC_ERROR    = 5,   
    ENUM_AEE_JSON_FORMAT_ERROR  = 6,   
    ENUM_AEE_XML_FORMAT_ERROR   = 7,  
    ENUM_AEE_BINARY_PIC_ERROR   = 8,   
    ENUM_AEE_PIC_NUM_ERROR      = 9,  
    ENUM_AEE_GET_BOUNDARY_ERROR = 10,  
    ENUM_AEE_BOUNDARY_NUM_ERROR = 11,  
}ALARM_EXCEPTION_ERROR_ENUM;

typedef struct tagNET_ALARM_EXCEPTION
{
    DWORD dwAlarmType;                    
    BYTE byExceptionType;                 
    BYTE byRes[3];                        
    char szErrMsg[MAX_ERROR_MSG_LEN];     
    BYTE byRes1[248];                    
}NET_ALARM_EXCEPTION, *LPNET_ALARM_EXCEPTION;

enum ADDITIONAL_LIB 
{
    PLAYCTRL = 0,  
    DSSDK,        
    STREAMCONVERT,  
    STREAMTRANS,   
    QOSSDK,     
    DLL_PATH_AUDIO,  
    EZVIZ_SSL_SDK, 
    ANALYZE_DATA_LIB,
    DLL_LIBICONV,   
    SSLEAY32_SDK, 
    LIBEAY32_SDK,
    HCNETUTILS_SDK, 
    NPQ_LIB,  
    LOAD_DLL_COUNT,  
};

typedef struct tagNET_DVR_AUTOTEST_CFG_HEAD
{
    DWORD   dwSize;
    DWORD   dwInfoType;          //1-Video3-Audio
    DWORD   dwRetResult;
    DWORD   dwDataBodySize;     //Structure address size followed 
    void*   lpDataBody;         //Structure address followed 
    BYTE    byRes[32];
}NET_DVR_AUTOTEST_CFG_HEAD,*LPNET_DVR_AUTOTEST_CFG_HEAD;

//Video
typedef struct tagNET_DVR_AUTOTEST_VIDEO_CFG
{
    DWORD  dwSplitScreenNums;   //Number of split screens, support 1,4,9
    DWORD  dwVoCh;
    DWORD  dwInterface;         //1-CVBS,2-HDMI,3-VGA,4-Auxiliary port HDMI
}NET_DVR_AUTOTEST_VIDEO_CFG,*LPNET_DVR_AUTOTEST_VIDEO_CFG;

//Audio
typedef struct tagNET_DVR_AUTOTEST_AUDIO_CFG
{
    DWORD  dwVoCh;
    DWORD  dwOpen;             //1-enable0-disable
}NET_DVR_AUTOTEST_AUDIO_CFG, *LPNET_DVR_AUTOTEST_AUDIO_CFG;

#if ((defined __linux__) || (defined _WIN64))
typedef struct _NET_DVR_AUDIOENCInfo  
{
    DWORD            in_frame_size;        
    int            reserved[16];              
} NET_DVR_AUDIOENC_INFO;

typedef enum _ENUM_AUDIO_ENC_MODE
{
    AMR_MR475_ = 0,        /* 4.75 kb/s */
    AMR_MR515_,          /* 5.15 kb/s */
    AMR_MR59_,            /* 5.90 kb/s */
    AMR_MR67_,            /* 6.70 kb/s */
    AMR_MR74_,            /* 7.40 kb/s */
    AMR_MR795_,            /* 7.95 kb/s */
    AMR_MR102_,            /* 10.2 kb/s */
    AMR_MR122_,          /* 12.2 kb/s */

    AMR_MRDTX_,       
    AMR_N_MODES_
}ENUM_AUDIO_ENC_MODE;

typedef struct _NET_DVR_AUDIOENC_PROCESS_PARAM_
{
    unsigned char		*in_buf;                
    unsigned char		*out_buf;                
    DWORD			out_frame_size;       

    int				g726enc_reset;     
    int				g711_type;      
    ENUM_AUDIO_ENC_MODE	enc_mode;                    
    int				reserved[16];                 
}NET_DVR_AUDIOENC_PROCESS_PARAM;

typedef struct _NET_DVR_AUDIODECInfo                    
{
    int            nchans;                        
    int            sample_rate;                  
    int            aacdec_profile;              
    int            reserved[16];                
} NET_DVR_AUDIODEC_INFO;

typedef struct _NET_DVR_AUDIODEC_PROCESS_PARAM
{
    unsigned char		*in_buf;                 
    unsigned char		*out_buf;                   
    DWORD			in_data_size;                
    DWORD			proc_data_size;               
    DWORD			out_frame_size;               
    NET_DVR_AUDIODEC_INFO		dec_info;                     

    int				g726dec_reset;                
    int				g711_type;                    
    int				reserved[16];                
} NET_DVR_AUDIODEC_PROCESS_PARAM;
const unsigned int G726_EBCIN_DECOUT_SIZE = 640; 
#if (defined __x86_64__)
const unsigned int G726_ENC_OUT_SIZE = 160; 
const unsigned int G726_DEC_IN_SIZE = 200; 
#else // if (defined __i386__)
const unsigned int G726_ENC_OUT_SIZE = 80; 
const unsigned int G726_DEC_IN_SIZE = 80; 
#endif // (defined __x86_64__)
#endif // (defined __linux__)

NET_DVR_API BOOL __stdcall NET_DVR_Init();
NET_DVR_API BOOL __stdcall NET_DVR_Cleanup();

//NET_DVR_SetDVRMessage extension
#ifdef _WIN32
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessage(UINT nMessage,HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT nMessage, HWND hWnd, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
#elif defined(__linux__) || defined(__APPLE__)
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT reserved1, void* reserved2, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
/*Linux*/
#if defined(__linux__)
NET_DVR_API BOOL NET_DVR_DrawAreaInit(INITINFO InitInfo, DWORD iUseSDL = 1);
NET_DVR_API BOOL NET_DVR_DrawAreaRelease();
#endif
#endif

NET_DVR_API BOOL __stdcall NET_DVR_LoadAllCom();
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack(BOOL (CALLBACK *fMessCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_EX(BOOL (CALLBACK *fMessCallBack_EX)(LONG lCommand,LONG lUserID,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_NEW(BOOL (CALLBACK *fMessCallBack_NEW)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, WORD dwLinkDVRPort));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack(BOOL (CALLBACK *fMessageCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, DWORD dwUser), DWORD dwUser);
typedef void (CALLBACK *MSGCallBack)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V30(MSGCallBack fMessageCallBack, void* pUser);
typedef BOOL(CALLBACK *MSGCallBack_V31)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V31(MSGCallBack_V31 fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V50(int iIndex, MSGCallBack fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V51(int iIndex, MSGCallBack fMsgCallBack, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetConnectTime(DWORD dwWaitTime = 3000, DWORD dwTryTimes = 3);
NET_DVR_API BOOL __stdcall NET_DVR_SetReconnect(DWORD dwInterval = 30000, BOOL bEnableRecon = TRUE);
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKVersion();
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKBuildVersion();
NET_DVR_API int __stdcall NET_DVR_IsSupport();
NET_DVR_API BOOL __stdcall NET_DVR_StartListen(char *sLocalIP,WORD wLocalPort);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen();

NET_DVR_API LONG __stdcall NET_DVR_StartListen_V30(char *sLocalIP, WORD wLocalPort, MSGCallBack DataCallback, void* pUserData = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen_V30(LONG lListenHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartServer(char *sLocalIP, WORD wLocalPort, BYTE byMode);
NET_DVR_API BOOL __stdcall NET_DVR_StopServer(LONG lServerHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartRecvNakedDataListen(NAKED_DATA_TYPE type, LPNET_DVR_NAKED_DATA_PARAM pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopRecvNakedDataListen(LONG lNakedDataRecvHandle);          
typedef void(CALLBACK * NAKEDDAtACALLBACK)(DWORD typeInfo, char *pInfo, DWORD dwInfoLen,DWORD dwIPLen, void* pUser);
NET_DVR_API BOOL __stdcall  NET_DVR_SetNakedDataRecvCallBack(LONG lNakedDataRecvHandle, void(CALLBACK *fNakedDataCallBack)(DWORD dwTypeInfo, NET_DVR_NAKED_DATA_INFO *pStruNakedDataInfo, char *pInfo, DWORD dwInfoLen, void* pUser), void* pUser);


NET_DVR_API LONG __stdcall NET_DVR_Login(char *sDVRIP,WORD wDVRPort,char *sUserName,char *sPassword,LPNET_DVR_DEVICEINFO lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V30(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V40(LPNET_DVR_USER_LOGIN_INFO pLoginInfo,LPNET_DVR_DEVICEINFO_V40 lpDeviceInfo);

NET_DVR_API BOOL __stdcall NET_DVR_Login_Check(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Logout(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Logout_V30(LONG lUserID);
NET_DVR_API DWORD __stdcall NET_DVR_GetLastError();
NET_DVR_API void __stdcall NET_DVR_GetLastErrorModelCode(DWORD *pModelCode, DWORD *pMErrDevSelfEx);
NET_DVR_API char* __stdcall NET_DVR_GetErrorMsg(LONG *pErrorNo = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_SetShowMode(DWORD dwShowType,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRIPByResolveSvr(char *sServerIP, WORD wServerPort, BYTE *sDVRName,WORD wDVRNameLen,BYTE *sDVRSerialNumber,WORD wDVRSerialLen,char* sGetIP);
NET_DVR_API BOOL  __stdcall NET_DVR_GetDVRIPByResolveSvr_EX(char *sServerIP, WORD wServerPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP, DWORD *dwPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRNAMEByResolveSvr(char const *sServerIP, WORD wServerPort, char const *sIP, char *sDVRName);

//Preview releated interface
typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);
NET_DVR_API LONG __stdcall NET_DVR_PlayDirect(char *sDVRIP, char *sUserName, char *sPassword, \
                                              LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay(LONG lUserID,LPNET_DVR_CLIENTINFO lpClientInfo);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V30(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V40(LONG lUserID, LPNET_DVR_PREVIEWINFO lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);
NET_DVR_API LONG __stdcall NET_DVR_RealPlaySpecial(LONG lUserID, LPNET_DVR_PREVIEWINFO_SPECIAL lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_GetLinkAddr(LONG lLinkHandle, NET_DVR_LINK_KIND enumLinkKind, LPNET_DVR_LINK_ADDR lpLinkAddr);

NET_DVR_API BOOL __stdcall NET_DVR_StopRealPlay(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayDirect(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RigisterDrawFun(LONG lRealHandle,void (CALLBACK* fDrawFun)(LONG lRealHandle,HDC hDc,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayerBufNumber(LONG lRealHandle,DWORD dwBufNum);
NET_DVR_API BOOL __stdcall NET_DVR_ThrowBFrame(LONG lRealHandle,DWORD dwNum);
NET_DVR_API BOOL __stdcall NET_DVR_SetAudioMode(DWORD dwMode);
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_Volume(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData(LONG lRealHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopSaveRealData(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBack(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBackEx(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBack(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBackEx(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentDataCallBack(LONG lRealHandle, void(CALLBACK *fTpDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture(LONG lRealHandle,char *sPicFileName);//bmp
NET_DVR_API BOOL __stdcall NET_DVR_SetCapturePictureMode(DWORD dwCaptureMode);


//Make I frame
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrame(LONG lUserID, LONG lChannel);//main stream
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrameSub(LONG lUserID, LONG lChannel);//sub stream

//PTZ control releated interface
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_Other(LONG lUserID,LONG lChannel,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_Other(LONG lUserID,LONG lChannel,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_EX(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_EX(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_EX(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_EX(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_Other(LONG lUserID, LONG lChannel, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_EX(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_Other(LONG lUserID, LONG lChannel, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_EX(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCruise(LONG lUserID,LONG lChannel,LONG lCruiseRoute, LPNET_DVR_CRUISE_RET lpCruiseRet);


//File search and playback
NET_DVR_API LONG __stdcall NET_DVR_FindFile(LONG lUserID,LONG lChannel,DWORD dwFileType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile(LONG lFindHandle,LPNET_DVR_FIND_DATA lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_Card(LONG lFindHandle, LPNET_DVR_FINDDATA_CARD lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V30(LONG lFindHandle, LPNET_DVR_FINDDATA_V30 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V40(LONG lFindHandle, LPNET_DVR_FINDDATA_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V50(LONG lFindHandle, LPNET_DVR_FINDDATA_V50 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V30(LONG lUserID, LPNET_DVR_FILECOND pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V50(LONG lUserID, LPNET_DVR_FILECOND_V50 pFindCond);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_V30(LONG lFindHandle);

NET_DVR_API BOOL __stdcall NET_DVR_LockFileByName(LONG lUserID, char *sLockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByName(LONG lUserID, char *sUnlockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByNameV40(LONG lUserID, BOOL bLock, const NET_DVR_LOCK_FILE_BY_NAME_PARA *lpLockFilePara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName(LONG lUserID,char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName_V50(LONG lUserID, LPNET_DVR_PLAY_BY_NAME_PARA pParam);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName_V50(LONG lUserID, LPNET_DVR_PLAY_BY_NAME_PARA pParam);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_PCNVR(LONG lUserID, NET_DVR_PLAYBCK_BYTIME_COND_PCNVR const *pPlaybackParams);

NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl(LONG lPlayHandle,DWORD dwControlCode,DWORD dwInValue,DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBack(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayBackESCallBack(LONG lPlayHandle, void (CALLBACK *fPlayESCallBack)(LONG lPlayHandle, NET_DVR_PACKET_INFO_EX *struPackInfo,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack_V40(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack_V40) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackSaveData(LONG lPlayHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBackSave(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlayBackOsdTime(LONG lPlayHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackCaptureFile(LONG lPlayHandle,char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName(LONG lUserID,char *sDVRFileName,char *sSavedFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName_V50(LONG lUserID, LPNET_DVR_DOWNLOAD_BY_NAME_COND pParam);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetFile(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadPos(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPlayBackPos(LONG lPlayHandle);

//Upgrade
NET_DVR_API LONG __stdcall NET_DVR_AdapterUpgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_VcalibUpgrade(LONG lUserID, LONG lChannel, char const *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeState(LONG lUpgradeHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeProgress(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseUpgradeHandle(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetNetworkEnvironment(DWORD dwEnvironmentLevel);
//Remote format disk
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk(LONG lUserID,LONG lDiskNumber);
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk_V50(LONG lUserID, NET_DVR_FORMAT_HDD *lpStruHddFormatCond);
NET_DVR_API BOOL __stdcall NET_DVR_GetFormatProgress(LONG lFormatHandle, LONG *pCurrentFormatDisk,LONG *pCurrentDiskPos,LONG *pFormatStatic);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFormatHandle(LONG lFormatHandle);
//Alarm
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan(LONG lAlarmHandle);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V30(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan_V30(LONG lAlarmHandle);
//Voice talk
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_V30(LONG lUserID, DWORD dwVoiceChan, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceComClientVolume(LONG lVoiceComHandle, WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_StopVoiceCom(LONG lVoiceComHandle);
//Forward Voice
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR_V30(LONG lUserID, DWORD dwVoiceChan, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceComSendData(LONG lVoiceComHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress(LONG lUserID, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress_V50(LONG lUserID, LPNET_DVR_AUDIO_CHANNEL lpAudioChannel, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);

//Voice broadcast
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart();
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart_V30(void(CALLBACK *fVoiceDataCallBack)(char *pRecvDataBuffer, DWORD dwBufSize, void * pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStop();
NET_DVR_API BOOL __stdcall NET_DVR_AddDVR(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_AddDVR_V30(LONG lUserID, DWORD dwVoiceChan);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR_V30(LONG lVoiceHandle);
////////////////////////////////////////////////////////////
//Transparent Channel
NET_DVR_API LONG __stdcall NET_DVR_SerialStart(LONG lUserID,LONG lSerialPort,void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle,char *pRecvDataBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
//If RS485 is used as transparent channel,  please specify the channel No. And different channels can have different RS485 parameters
NET_DVR_API LONG __stdcall NET_DVR_SerialStart_V40(LONG lUserID,void* lpInBuffer, LONG dwInBufferSize, void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle, LONG lCHannel, char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SerialSend(LONG lSerialHandle, LONG lChannel, char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SerialStop(LONG lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SendTo232Port(LONG lUserID, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SendToSerialPort(LONG lUserID, DWORD dwSerialPort, DWORD dwSerialIndex, char *pSendBuf, DWORD dwBufSize);

#if (!defined __linux__) && (!defined _WIN64)
//Decoding nBitrate = 16000
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder(int nBitrate = 16000);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *pDecHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
#elif ((defined __linux__) || (defined _WIN64))
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder();
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *handle, NET_DVR_AUDIODEC_PROCESS_PARAM * param);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder(NET_DVR_AUDIOENC_INFO* enc_info);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *handle, NET_DVR_AUDIOENC_PROCESS_PARAM* param);
#endif // _WIN32
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Decoder(void *pDecHandle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);

//Decoding
NET_DVR_API void* __stdcall NET_DVR_InitG726Decoder(void** pDecMoudle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG726Frame(void *pDecMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG726Encoder(void** pEncMoudle);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG726Frame(void *pEncMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Encoder(void *pEncHandle);

//Control the local preview remotely
NET_DVR_API BOOL __stdcall NET_DVR_ClickKey(LONG lUserID, LONG lKeyIndex);
NET_DVR_API BOOL __stdcall NET_DVR_DoorBellControl(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Preview(LONG lUserID, LONG lPicNum);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewOne(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackByNameLocDisplay(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackByTimeLocDisplay(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpStartTime, NET_DVR_TIME const *lpStopTime);
NET_DVR_API BOOL __stdcall NET_DVR_StopLocDisplayPlay(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_PlayControlLocDisplay(LONG lUserID, DWORD dwControlCode);
//Control the manual record remotely
NET_DVR_API BOOL __stdcall NET_DVR_StartDVRRecord(LONG lUserID,LONG lChannel,LONG lRecordType);
NET_DVR_API BOOL __stdcall NET_DVR_StopDVRRecord(LONG lUserID,LONG lChannel);
//Decoding Card
NET_DVR_API BOOL __stdcall NET_DVR_InitDevice_Card(long *pDeviceTotalChan);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDevice_Card();
NET_DVR_API BOOL __stdcall NET_DVR_InitDDraw_Card(HWND hParent,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDraw_Card();
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card_V30(LONG lUserID, NET_DVR_CARDINFO const *lpCardInfo, LONG lChannelNum, DWORD dwMode, BOOL bBlock, REALDATACALLBACK fRealDataCallBack_V30, void* pUser);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card(LONG lUserID,LPNET_DVR_CARDINFO lpCardInfo,long lChannelNum);
NET_DVR_API BOOL __stdcall NET_DVR_ResetPara_Card(LONG lRealHandle,LPNET_DVR_DISPLAY_PARA lpDisplayPara);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_ClearSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_RestoreSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetVolume_Card(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_AudioPreview_Card(LONG lRealHandle,BOOL bEnable);
NET_DVR_API LONG __stdcall NET_DVR_GetCardLastError_Card();
NET_DVR_API BOOL __stdcall NET_DVR_SetDspErrMsg_Card(DWORD dwMessage, HANDLE hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_ResetDSP_Card(LONG iChannelNum);
NET_DVR_API HANDLE __stdcall NET_DVR_GetChanHandle_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_Card(LONG lRealHandle, char *sPicFileName);
//NET_DVR_GetSerialNum_Card is invalid,  Call GetBoardDetail instead.
NET_DVR_API BOOL __stdcall NET_DVR_GetSerialNum_Card(long lChannelNum,DWORD *pDeviceSerialNo);
//Log
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog(LONG lLogHandle, LPNET_DVR_LOG lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V30(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, BOOL bOnlySmart = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V30(LONG lLogHandle, LPNET_DVR_LOG_V30 lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V50(LONG lUserID, LPNET_DVR_FIND_LOG_COND pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V50(LONG lLogHandle, LPNET_DVR_LOG_V50 lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose_V30(LONG lLogHandle);

NET_DVR_API LONG __stdcall NET_DVR_FindFile_PCNVR(LONG lUserID, LPNET_DVR_FILE_COND_PCNVR const pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_PCNVR(LONG lFindHandle, LPNET_DVR_FINDDATA_PCNVR lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_PCNVR(LONG lFindHandle);
// Alarmhost log
NET_DVR_API LONG __stdcall NET_DVR_FindAlarmHostLog(LONG lUserID, LONG lSelectMode, NET_DVR_ALARMHOST_SEARCH_LOG_PARAM *lpSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextAlarmHostLog(LONG lFindHandle, NET_DVR_ALARMHOST_LOG_RET *lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindAlarmHostLogClose(LONG lFindHandle);
//ATM DVR
NET_DVR_API LONG __stdcall NET_DVR_FindFileByCard(LONG lUserID,LONG lChannel,DWORD dwFileType, int nFindType, BYTE *sCardNumber, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

//Encoding
// NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
// NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
// NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);
//2005-09-15
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sPicFileName);
//Grab JPEG and save to RAM
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_NEW(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sJpegPicBuffer, DWORD dwPicSize,  LPDWORD lpSizeReturned);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_V50(LONG lUserID, LONG lChannel, LPNET_DVR_PICPARAM_V50  lpPicParam, char *sPicBuffer, DWORD dwPicSize, LPDWORD lpSizeReturned);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_WithAppendData(LONG lUserID, LONG lChannel, NET_DVR_JPEGPICTURE_WITH_APPENDDATA *lpJpegWithAppend);

NET_DVR_API BOOL __stdcall NET_DVR_GetRealPlayOsdTime(LONG iRealHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_RealPlayPause(LONG iRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RealPlayRestart(LONG iRealHandle, HWND hPlayWnd);

//2006-02-16
NET_DVR_API LONG __stdcall NET_DVR_GetRealPlayerIndex(LONG lRealHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPlayBackPlayerIndex(LONG lPlayHandle);

//2006-08-28 704-640 Scale
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG(LONG lUserID, DWORD dwScale);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG(LONG lUserID, DWORD *lpOutScale);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
//2006- 08- 28 Port of ATM
NET_DVR_API BOOL __stdcall NET_DVR_SetATMPortCFG(LONG lUserID, WORD wATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetATMPortCFG(LONG lUserID, WORD *LPOutATMPort);

//2006- 11- 10 Display on Multi displayer
NET_DVR_API BOOL __stdcall NET_DVR_InitDDrawDevice();
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDrawDevice();
NET_DVR_API LONG __stdcall NET_DVR_GetDDrawDeviceTotalNums();
NET_DVR_API BOOL __stdcall NET_DVR_SetDDrawDevice(LONG lPlayPort, DWORD nDeviceNum);

NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn(LONG lRealHandle, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn_EX(LONG lUserID, LONG lChannel, LPNET_DVR_POINT_FRAME pStruPointFrame);
//Decoder DS- 6001D/DS- 6001F
NET_DVR_API BOOL __stdcall NET_DVR_StartDecode(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERINFO lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecode(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecoderState(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERSTATE lpDecoderState);
//2005-08-01
NET_DVR_API BOOL __stdcall NET_DVR_SetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_DecPlayBackCtrl(LONG lUserID, LONG lChannel, DWORD dwControlCode, DWORD dwInValue,DWORD *LPOutValue, LPNET_DVR_PLAYREMOTEFILE lpRemoteFileInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlDec(LONG lUserID, LONG lChannel, DWORD dwControlCode);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlScreen(LONG lUserID, LONG lChannel, DWORD dwControl);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecCurLinkStatus(LONG lUserID, LONG lChannel, LPNET_DVR_DECSTATUS lpDecStatus);

//Multi- channel decoder
//2007- 11- 30 V211 support the API below //11
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DYNAMIC_DEC lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopDynamic(LONG lUserID, DWORD dwDecChanNum); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecEnable(LONG lUserID, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_STATUS lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetVideoStandard(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwVideoStandard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetVideoStandard(LONG lUserID, DWORD dwDecChanNum, DWORD dwVideoStandard);

//2007-12-22 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlayControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwControlCode, DWORD dwInValue, DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetRemotePlayStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS lpOuter);
//2009-4-13 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);

NET_DVR_API LONG __stdcall NET_DVR_MatrixStartPassiveDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_PASSIVEMODE lpPassiveMode /*, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser*/);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSendData(LONG lPassiveHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopPassiveDecode(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_DISP_LOGOCFG lpDispLogoCfg, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo_NEW(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadLogo(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer, DWORD dwLogoBufferSize);
#define    NET_DVR_SHOWLOGO            1        /*Show LOGO*/
#define    NET_DVR_HIDELOGO            2        /*Hide LOGO*/  
NET_DVR_API BOOL __stdcall NET_DVR_LogoSwitch(LONG lUserID, DWORD dwDecChan, DWORD dwLogoSwitch);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus(LONG lUserID,  LPNET_DVR_DECODER_WORK_STATUS lpDecoderCfg);

#define    DISP_CMD_ENLARGE_WINDOW                1    /*Enlarge some region*/
#define    DISP_CMD_RENEW_WINDOW                2    /*Restore the region*/
#define    DISP_CMD_OPENAUDIO                    3    /*Open audio*/
#define    DISP_CMD_CLOSEAUDIO                    4    /*close audio*/




NET_DVR_API BOOL __stdcall NET_DVR_MatrixDiaplayControl(LONG lUserID, DWORD dwDispChanNum, DWORD dwDispChanCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPassiveDecodeControl(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PASSIVEDECODE_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_MatrixGetPassiveDecodeStatus(LONG lPassiveHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_NEW(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpStartTime, NET_DVR_TIME const *lpStopTime, LONG lLongitude, LONG lLatitude, HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshPlay(LONG lPlayHandle);
//Restore default configuration
NET_DVR_API BOOL __stdcall NET_DVR_RestoreConfig(LONG lUserID);
//Save configuration
NET_DVR_API BOOL __stdcall NET_DVR_SaveConfig(LONG lUserID);
//Reboot
NET_DVR_API BOOL __stdcall NET_DVR_RebootDVR(LONG lUserID);
//Shutdown DVR
NET_DVR_API BOOL __stdcall NET_DVR_ShutDownDVR(LONG lUserID);

//config parameter begin
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState_V30(LONG lUserID, LPNET_DVR_WORKSTATE_V30 lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState(LONG lUserID, LPNET_DVR_WORKSTATE lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_SetVideoEffect(LONG lUserID, LONG lChannel, DWORD dwBrightValue, DWORD dwContrastValue, DWORD dwSaturationValue, DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetVideoEffect(LONG lUserID, LONG lChannel, DWORD *pBrightValue, DWORD *pContrastValue, DWORD *pSaturationValue, DWORD *pHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat_V30(LONG lUserID, LPNET_DVR_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat_V30(LONG lUserID, LPNET_DVR_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_SetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmProtocol(LONG lUserID, LPNET_DVR_ATM_PROTOCOL lpAtmProtocol);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut_V30(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS_V30 lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmOut(LONG lUserID, LONG lAlarmOutPort,LONG lAlarmOutStatic);

//Adjust video parameters
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetVideoEffect(LONG lRealHandle,DWORD dwBrightValue,DWORD dwContrastValue, DWORD dwSaturationValue,DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetVideoEffect(LONG lRealHandle,DWORD *pBrightValue,DWORD *pContrastValue, DWORD *pSaturationValue,DWORD *pHueValue);

//Configuration File
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_V30(LONG lUserID, char *sOutBuffer, DWORD dwOutSize, DWORD *pReturnSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_EX(LONG lUserID, char *sOutBuffer, DWORD dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile_EX(LONG lUserID, char *sInBuffer, DWORD dwInSize);

//write log file
NET_DVR_API BOOL __stdcall NET_DVR_SetLogToFile(DWORD nLogLevel = 0, char * strLogDir = NULL, BOOL bAutoDel = TRUE);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKState(LPNET_DVR_SDKSTATE pSDKState);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKAbility(LPNET_DVR_SDKABL pSDKAbl);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol(LONG lUserID, NET_DVR_PTZCFG *pPtzcfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCtrl_Other(LONG iUserID, LONG iChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCtrl(LONG iRealHandle);
//Lock Front Panel
NET_DVR_API BOOL __stdcall NET_DVR_LockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_UnLockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StartPanelKey(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopPanelKey(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_SetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpOutBuffer, DWORD dwOutBufferSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceAbility(LONG lUserID, DWORD dwAbilityType, char* pInBuf, DWORD dwInLength, char* pOutBuf, DWORD dwOutLength);
NET_DVR_API BOOL __stdcall NET_DVR_SetSimAbilityPath(char * szSimAbilityPath, char *szSDCard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);

// set/get vca behavior param key
NET_DVR_API BOOL __stdcall NET_DVR_SetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int nValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int *pValue);

//add target API for Get/SetVCA
NET_DVR_API BOOL __stdcall NET_DVR_GetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);
NET_DVR_API BOOL __stdcall NET_DVR_SetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);

//Track mode configuration interface
NET_DVR_API BOOL __stdcall NET_DVR_SetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);

//Restart VCA Lib
NET_DVR_API BOOL __stdcall NET_VCA_RestartLib(LONG lUserID, LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData_V30(LONG lRealHandle, DWORD dwTransType, char *sFileName);

#if ((!defined __linux__) && (!defined _WIN64))
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
#elif ((defined __linux__) || (defined _WIN64))
//NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(LPVOID handle, DWORD iType, BYTE* pInBuffer, BYTE* pOutBuffer, DWORD *dwOutSize);
//NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(LPVOIDInitG722Encoder handle, DWORD iType, BYTE* pInBuffer, BYTE* pOutBuffer, DWORD *dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(LPVOID handle, NET_DVR_AUDIOENC_PROCESS_PARAM *p_enc_proc_param);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(LPVOID handle, NET_DVR_AUDIODEC_PROCESS_PARAM *p_dec_proc_param);
NET_DVR_API LPVOID __stdcall NET_DVR_InitG711Decoder();
NET_DVR_API LPVOID __stdcall NET_DVR_InitG711Encoder(NET_DVR_AUDIOENC_INFO * enc_info);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseG711Encoder(LPVOID pEncodeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseG711Decoder(LPVOID pDecHandle);
#endif //(defined _WIN32)
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V40(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V40  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V50(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V50 lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V40(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET_V40 lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V50(LONG lFindHandle, LPNET_DVR_SEARCH_EVENT_RET_V50 lpSearchEventRet);

//NET_DVR_FindClose is invalid

NET_DVR_API LONG __stdcall NET_DVR_FindPDCInfo(LONG lUserID, LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPDCInfo(LONG lFindHandle,LPNET_DVR_PDC_QUERY lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindPDCClose(LONG lFindHandle);

//Calibration 
#define NET_DVR_PDC_VERIFY_CALIBRATION          1  
#define NET_DVR_VERIFY_BEHAVIOR_CALIBRATION     2    
#define NET_DVR_VERIFY_ITS_CALIBRATION            3     
#define NET_DVR_VERIFY_BV_CALIBRATION            5    

NET_DVR_API BOOL __stdcall  NET_DVR_VerifyCalibration(LONG lUserID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOuterBuffer, DWORD dwOuterBufferSize);
NET_DVR_API BOOL __stdcall  NET_DVR_ResetCounter(LONG lUserID,LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_MATRIX(LONG lLogHandle, LPNET_DVR_LOG_MATRIX lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_Matrix(LONG lUserID, LONG lSelectMode, DWORD dwMajorType, DWORD dwMinorType, LPNET_DVR_VEDIOPLATLOG lpVedioPlatLog, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

NET_DVR_API BOOL __stdcall NET_DVR_ManualSnap(LONG lUserID, NET_DVR_MANUALSNAP const* lpInter, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol_Ex(LONG lUserID, LONG lChannel, NET_DVR_PTZCFG *pPtzcfg);

NET_DVR_API LONG __stdcall NET_DVR_StartEmailTest(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopEmailTest(LONG lEmailTestHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetEmailTestProgress(LONG lEmailTestHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST lpProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList_V41(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST_V41 lpProtoList);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch_V40(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM_V40 lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SearchNextInfo(LONG lSearchHandle, LPNET_DVR_SMART_SEARCH_RET lpSmartSearchRet);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearch(LONG lSearchHandle);

// IP San Directory search
NET_DVR_API LONG __stdcall NET_DVR_FindIpSanDirectory(LONG lUserID, LPNET_DVR_IPSAN_SERACH_PARAM lpIpsanSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDirectory(LONG lFindHandle, LPNET_DVR_IPSAN_SERACH_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindDirectoryClose(LONG lFindHandle);

NET_DVR_API LONG __stdcall NET_DVR_ZeroStartPlay(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL, BOOL bBlocked = TRUE);

NET_DVR_API BOOL __stdcall NET_DVR_ZeroStopPlay(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroMakeKeyFrame(LONG lUserID, LONG lZeroChan);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl_V40(LONG lPlayHandle,DWORD dwControlCode, LPVOID lpInBuffer = NULL, DWORD dwInLen = 0, LPVOID lpOutBuffer = NULL, DWORD *lpOutLen = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroTurnOver(LONG lUserID, LONG lChannel, BOOL bNextPreview);

NET_DVR_API BOOL __stdcall NET_DVR_GetDiskList(LONG lUserID, LPNET_DVR_DISKABILITY_LIST lpDiskList);
NET_DVR_API LONG __stdcall NET_DVR_Backup(LONG lUserID, DWORD dwBackupType, LPVOID lpBackupBuff, DWORD dwBackupBuffSize);
NET_DVR_API LONG __stdcall NET_DVR_BackupByName(LONG lUserID, LPNET_DVR_BACKUP_NAME_PARAM lpBackupByName);
NET_DVR_API LONG __stdcall NET_DVR_BackupByTime(LONG lUserID, LPNET_DVR_BACKUP_TIME_PARAM lpBackupBytime);
NET_DVR_API BOOL __stdcall NET_DVR_GetBackupProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopBackup(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_GetSadpInfoList(LONG lUserID, LPNET_DVR_SADPINFO_LIST lpSadpInfoList);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateSadpInfo(LONG lUserID, LPNET_DVR_SADP_VERIFY lpSadpVerify, LPNET_DVR_SADPINFO lpSadpInfo);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_SetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestDeleteFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCDWByFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpCdrwFile);
NET_DVR_API LONG __stdcall NET_DVR_InquestUploadFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_InquestUploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_InquestGetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStartCDW( LONG lUserID, BOOL bPause);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStopCDW(LONG lUserID, BOOL bCancelWrite);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDWState(LONG lUserID, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCheckSecretKey(LONG lUserID, BOOL *bSecretSet);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetSecretKey(LONG lUserID, LPNET_DVR_INQUEST_SECRET_INFO pSecretInfo);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStreamEncrypt(LONG lUserID, LONG lChannel, BOOL bEncrypt);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetEncryptState(LONG  lUserID, LONG lChannel, BOOL *bEncrypt);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindFile(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindNextFile(LONG lFindHandle, LPNET_DVR_INQUEST_FILEINFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_InquestFindClose(LONG lFindHandle);

// 9000RH
NET_DVR_API LONG __stdcall NET_DVR_RaidFastConfig(LONG lUserID, char *sName);
NET_DVR_API BOOL __stdcall NET_DVR_FastConfigProcess(LONG lHandle, DWORD *pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFastConfig(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetArraySpaceAlloc(LONG lUserID, DWORD dwSlot, LPNET_DVR_ARRAY_SPACE_ALLOC_INFO lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DelArray(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_CreateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CalcArraySize(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam, UINT64* lpArraySize);
NET_DVR_API BOOL __stdcall NET_DVR_MigrateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_RebuildArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVD(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM lpVDParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVDEx(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM_EX lpVDParamEx);
NET_DVR_API BOOL __stdcall NET_DVR_DelVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_RepairVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_SetSpareDisk(LONG lUserID, LPNET_DVR_SPARE_DISK_PARAM lpSpareDisk);
NET_DVR_API BOOL __stdcall NET_DVR_GetPDList(LONG lUserID,  LPNET_DVR_PHY_DISK_LIST lpPDList);
NET_DVR_API BOOL __stdcall NET_DVR_GetArrayList(LONG lUserID, LPNET_DVR_ARRAY_LIST lpArrayList);
NET_DVR_API BOOL __stdcall NET_DVR_GetVDList(LONG lUserID, LPNET_DVR_VD_LIST lpVDList);
NET_DVR_API LONG __stdcall NET_DVR_ExpandDisk(LONG    lUserID,DWORD dwVDSLot);
NET_DVR_API BOOL __stdcall NET_DVR_GetExpandProgress(LONG lExpandHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseExpandHandle(LONG lExpandHandle);
NET_DVR_API LONG __stdcall NET_DVR_AlgoDebugStart(LONG lUserID, LONG lCHannel, void(CALLBACK *fAlgoLibInfoCallBack)(LONG lHandle, LONG lChannel,char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugSend(LONG lHandle, LONG lChannel, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugStop(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrint(BOOL bLogPrint);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrintAction(DWORD nLogLevel, DWORD nToDevice, BOOL bEnable, int Reserve1, int Reserve2);

NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_SetSceneMode(LONG  lUserID, LONG lChannel, DWORD dwSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetSceneMode(LONG lUserID, LONG lChannel, DWORD  *pSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetVCAVersion(LONG lUserID, LONG lChannel, LPNET_DVR_VCA_VERSION lpVersion);
   
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPicAdjust(LONG lUserID, DWORD dwDispChan, DWORD dwPicAdjust, DWORD dwCmdParam); 
NET_DVR_API BOOL __stdcall NET_DVR_AlarmJoinedRecord(LONG lUserID, DWORD dwChan, DWORD dwAlarmSeq, DWORD dwRecordTime, DWORD dwRes);

typedef LONG(CALLBACK * ALARMSETUPRESPONSECallBack)(LONG lUserID, LONG lAlarmHandle, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSetupResponseCallBack(ALARMSETUPRESPONSECallBack fAlarmSetupResponseCallBack, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SpringJPEGPicture(LONG lUserID, LONG lChannel, NET_DVR_PUSHJPEGPARA const *lpJpegPara);
NET_DVR_API BOOL __stdcall NET_DVR_SetPushModeParam(LPNET_DVR_PUSHMODEPARAM pPushParam);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetupAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostCloseAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_BypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_UnBypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostAssistantControl(LONG lUserID, DWORD dwType, DWORD dwNumber, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceTypeList(LONG lUserID, NET_DVR_DEVICE_TYPE_LIST *lpDeviceTypeList);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceProtoList(LONG lUserID, LONG lDeviceType, NET_DVR_DEVICE_PROTO_LIST *lpDeviceProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetBatteryVoltage(LONG lUserID, float *pVoltage);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_ControlGateway(LONG lUserID, LONG lGatewayIndex, DWORD dwStaic);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmHostOut(LONG lUserID, LONG lAlarmOutPort, LONG lAlarmOutStatic);
typedef void(CALLBACK *fAlarmHostSerialDataCallBack)
(LONG lSerialHandle, LONG lPort, LONG lDateType, char *pRecvDataBuffer, DWORD  dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_AlarmHostSerialStart(LONG lUserID, LONG lSerialType, fAlarmHostSerialDataCallBack cbSerialDataCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialSend(LONG lSerialHandle,LONG lPort,char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialStop(LONG  lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmOffMonitor(LONG lUserID, DWORD dwMonID, DWORD dwCamID);
NET_DVR_API BOOL __stdcall NET_DVR_GetGlobalNum(LONG lUserID, DWORD *dwCamNum, DWORD *dwMonNum); 
NET_DVR_API BOOL __stdcall NET_DVR_GetCameraListInfo(LONG lUserID, DWORD dwCamNum, DWORD dwStartCam, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetMonitorListInfo(LONG lUserID, DWORD dwMonNum, DWORD dwStartMon, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);

typedef void (CALLBACK *FLOWTESTCALLBACK)(LONG lFlowHandle, LPNET_DVR_FLOW_INFO pFlowInfo, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartNetworkFlowTest(LONG lUserID, NET_DVR_FLOW_TEST_PARAM* pFlowTest,  FLOWTESTCALLBACK fFlowTestCallback, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_StopNetworkFlowTest(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindRecordLabel(LONG lUserID, LPNET_DVR_FIND_LABEL lpFindLabel);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLabel(LONG lFindHandle, LPNET_DVR_FINDLABEL_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_StopFindLabel(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_InsertRecordLabel(LONG lPlayHandle, NET_DVR_RECORD_LABEL* lpRecordLabel, NET_DVR_LABEL_IDENTIFY *lpLableIdentify);
NET_DVR_API BOOL __stdcall NET_DVR_DelRecordLabel(LONG lUserID, NET_DVR_DEL_LABEL_PARAM* lpDelLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_ModifyRecordLabel(LONG lUserID, NET_DVR_MOD_LABEL_PARAM * lpModLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock(LONG lPlayHandle, char *sPicFileName, DWORD dwTimeOut);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock_New(LONG lPlayHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);
NET_DVR_API LONG __stdcall NET_DVR_FindPicture(LONG lUserID, NET_DVR_FIND_PICTURE_PARAM* pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture(LONG lFindHandle,LPNET_DVR_FIND_PICTURE lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V40(LONG lFindHandle,LPNET_DVR_FIND_PICTURE_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V50(LONG lFindHandle, LPNET_DVR_FIND_PICTURE_V50 lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFindPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture(LONG lUserID,char *sDVRFileName,const char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V30(LONG lUserID, char *sDVRFileName, char *sSavedFileBuf, DWORD dwBufLen, DWORD *lpdwRetLen);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V50(LONG lUserID, LPNET_DVR_PIC_PARAM lpPicParam);
NET_DVR_API LONG __stdcall NET_DVR_BackupPicture(LONG lUserID, NET_DVR_BACKUP_PICTURE_PARAM *lpBackupPicture);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeStep(LONG lUpgradeHandle, LONG *pSubProgress);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetEncodeJoint(LONG lUserID, LONG lChannel, LPNET_DVR_ENCODE_JOINT_PARAM lpEncodeJoint);
NET_DVR_API BOOL  __stdcall NET_DVR_GetLocalIP(char strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL  __stdcall NET_DVR_SetValidIP(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetLocalIPv6(BYTE strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_SetValidIPv6(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetVcaDevWorkState(LONG lUserID, LPNET_DVR_VCA_DEV_WORKSTATUS lpWorkState);
NET_DVR_API BOOL  __stdcall NET_DVR_SetRecvTimeOut(DWORD nRecvTimeOut = 5000); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);              
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_ShutterCompensation(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CorrectDeadPixel(LONG lUserID, LONG lChannel, LPNET_DVR_CORRECT_DEADPIXEL_PARAM lpInParam);
NET_DVR_API BOOL __stdcall NET_DVR_CustomConfig(LONG lUserID, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricDataInfo(LONG lUserID, LONG lChannel, LPNET_DVR_HISTORICDATACFG lpHisData);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricData(LONG lUserID, LONG lChannel, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ClearHistoricData(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_VPD_SetShutter(LONG lUserID, LONG lChannel, LPNET_VPD_SHUTTER lpShutter);
NET_DVR_API BOOL __stdcall NET_VPD_SendPicture(LONG lUserID, DWORD dwFields, BYTE const *sImageBuffer, DWORD dwWidth, DWORD dwHeight);
NET_DVR_API LONG  __stdcall NET_DVR_InquestUploadFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom,  char *sFileName);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestDeleteFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSendMessage(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_MESSAGE lpInquestMessage);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStartCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bNotBurn);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bCancelWrite);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetCDWState_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API LONG  __stdcall NET_DVR_InquestResumeEvent(LONG lUserID, LPNET_DVR_INQUEST_RESUME_EVENT lpResumeEvent);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetResumeProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopResume(LONG lHandle);
NET_DVR_API LONG  __stdcall NET_DVR_InquestFindFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM pInquestRoom);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetDeviceVersion(LONG lUserID, LPNET_DVR_INQUEST_DEVICE_VERSION lpVersionInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_SetSDKSecretKey(LONG lUserID, char *sSecretKey);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenZoomIn(LONG lUserID, LPNET_DVR_SCREENZOOM pStruScreen);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllCameraInfo(LONG lUserID, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleCameraInfo(LONG lUserID, DWORD dwCameraId, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddCamera(LONG lUserID, DWORD dwCameraNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModCameraInfo(LONG lUserID, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelCamera(LONG lUserID, DWORD dwCameraId);

NET_DVR_API BOOL __stdcall NET_DVR_DetectImage_V50(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT_V50 lpOutBuf);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddMonitor(LONG lUserID, DWORD dwMonitorNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModMonitorInfo(LONG lUserID, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelMonitor(LONG lUserID, DWORD dwMonitorId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMonitorInfo(LONG lUserID, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleMonitorInfo(LONG lUserID, DWORD dwMonitorId, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMatrixInfo(LONG lUserID, LPNET_DVR_MATRIXLIST lpMatrixListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSingleMatrixInfo(LONG lUserID, DWORD dwMatrixId, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AddMatrix(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_ModMatrixInfo(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelMatrix(LONG lUserID, DWORD dwMatrixId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSeNET_DVR_MatrixGetUserInfotUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUser(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUser(LONG lUserID, DWORD dwUserNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUserGroup (LONG lUserID, DWORD dwUserGroupNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllTrunkInfo(LONG lUserID, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTrunkInfo(LONG lUserID, DWORD dwTrunkNum, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddTrunk(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModTrunkInfo(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkCtrl(LONG lUserID, DWORD dwTrunkNum, BYTE byCtrlMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkStatusQuery(LONG lUserID, DWORD dwTrunkNum, BYTE *byTrunkStatus);

NET_DVR_API BOOL __stdcall NET_DVR_FindBackgroundPic(LONG lUserID, DWORD dwPicID, BYTE *pPicBuffer, DWORD *lpPicLen);
NET_DVR_API BOOL __stdcall NET_DVR_DetectImage(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_GetPictureModel(LONG lUserID, LPNET_VCA_REGISTER_PIC lpInBuf, LPNET_VCA_PICMODEL_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_AddBlockList(LONG lUserID,LONG lChannel,LPNET_VCA_BLOCKLIST_PARA lpInter);
NET_DVR_API LONG __stdcall NET_DVR_FindBlockList(LONG lUserID, LPNET_VCA_BLOCKLIST_COND lpBlockListCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextBlockList(LONG lFindHandle,LPNET_VCA_BLOCKLIST_INFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindBlockListClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetBlockListPicture(LONG lUserID, DWORD dwRegisterID, LPNET_VCA_BLOCKLIST_PIC lpOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateBlockList(LONG lUserID,LONG lChannel, LPNET_VCA_BLOCKLIST_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelBlockList(LONG lUserID,LONG lChannel, DWORD dwRegisterID);
NET_DVR_API LONG __stdcall NET_DVR_FindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSnapPic(LONG lFindHandle,LPNET_VCA_SUB_SNAPPIC_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindSnapPicClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_AdvanceFindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND_ADVANCE lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFaceMatchAlarm(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFaceMatchAlarm(LONG lFindHandle, LPNET_VCA_FACESNAP_MATCH_ALARM_LOG lpFaceMatchAlarmLog);
NET_DVR_API BOOL __stdcall NET_DVR_FindFaceMatchAlarmClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetFaceMatchPic(LONG lUserID, LPNET_VCA_FACEMATCH_PICCOND lpMatchCond, LPNET_VCA_FACEMATCH_PICTURE lpMatchPic);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddBlockList(LONG lUserID,LONG lChannel,LPNET_VCA_BLOCKLIST_FASTREGISTER_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpVoutCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus_V41(LONG lUserID, LPNET_DVR_DECODER_WORK_STATUS_V41 lpDecoderCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSceneControl(LONG lUserID, DWORD dwSceneNum, DWORD dwCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCurrentSceneMode(LONG lUserID, DWORD *dwSceneNum);
NET_DVR_API BOOL __stdcall NET_DVR_GetAllValidWinInfo(LONG lUserID, LPNET_DVR_WINLIST lpWinListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenWinCtrl(LONG lUserID, DWORD dwWinIndex, DWORD dwCommand, LPNET_DVR_SCREEN_WINCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenInputStatus(LONG lUserID, LPNET_DVR_SCREENINPUTSTATUS lpStatus);
NET_DVR_API LONG __stdcall NET_DVR_PicUpload(LONG lUserID, char const *sFileName, LPNET_DVR_PICTURECFG lpPictureCfg);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadProgress(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall  NET_DVR_CloseUploadHandle(LONG lUploadHandle);        
NET_DVR_API BOOL __stdcall NET_DVR_PicControl(LONG lUserID, BYTE byUseType, BYTE byPicIndex, BYTE byCtrlCmd);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadState(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenCtrl(LONG lUserID, DWORD dwDeviceNum, LPNET_DVR_SCREEN_CONTROL lpStruScreenCtrl);
typedef void (CALLBACK *SCREENPICDATACB)(LONG nScreenPicHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartScreenPic(LONG nUserID, DWORD nInputNum, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopScreenPic(LONG nScreenPicHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FocusOnePush(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_ResetLens(LONG lUserID, LONG lChannel);

typedef void(CALLBACK *fRemoteConfigCallback)(DWORD dwType, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_StartRemoteConfig(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferLen, fRemoteConfigCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopRemoteConfig(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetNextRemoteConfig(LONG lHandle, void* lpOutBuff, DWORD dwOutBuffSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRemoteConfigState(LONG lHandle, void *pState);
NET_DVR_API BOOL __stdcall NET_DVR_SendRemoteConfig(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API LONG __stdcall NET_DVR_SendWithRecvRemoteConfig(LONG lHandle, void* lpInBuff, DWORD dwInBuffSize, void* lpOutBuff, DWORD dwOutBuffSize, DWORD *dwOutDataLen);

typedef void(CALLBACK *fLongCfgStateCallback)(LONG lHandle,  DWORD dwState, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseLongCfgHandle(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_RaidPullDiskStart(LONG lUserID, LONG lRaidID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_ScanRaidStart(LONG lUserID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_SetAccessCameraInfo(LONG lUserID, DWORD dwChannel, LPNET_DVR_ACCESS_CAMERA_INFO lpCameraInfo, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);

NET_DVR_API BOOL __stdcall NET_DVR_InquiryRecordTimeSpan(LONG lUserID, DWORD dwChannel,  NET_DVR_RECORD_TIME_SPAN_INQUIRY const *lpInquiry, LPNET_DVR_RECORD_TIME_SPAN lpResult);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateRecordIndex(LONG lUserID, DWORD dwChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetUpnpNatState(LONG lUserID, LPNET_DVR_UPNP_NAT_STATE lpState);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopPlanArray(LONG lUserID, DWORD dwArrayNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopPlanArray(LONG lUserID, DWORD dwArrayNum, NET_DVR_MATRIX_LOOP_DECINFO_V30 const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAlarmShowMode(LONG lUserID, LPNET_DVR_ALARMMODECFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetAlarmShowMode(LONG lUserID, NET_DVR_ALARMMODECFG const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamicAssociateDecode(LONG lUserID, DWORD dwDecChanNum, NET_DVR_DYNAMICDECODE const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmTurn(LONG lUserID, DWORD dwDecChanNum, DWORD dwTurnParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmShowControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwShowMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetPlanDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PLANDECODE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetPlanDecode(LONG lUserID, DWORD dwDecChanNum, NET_DVR_PLANDECODE const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_EX lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrunkListInfo(LONG lUserID, DWORD dwTrunkNum, DWORD dwStartTrunk, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo, DWORD *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemSetupAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemCloseAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostClearAlarm(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypass(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypassResume (LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetReportMode(LONG lUserID, LONG lCenterNum, LPVOID lpInputBuf, DWORD dwInputBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostGetReportMode(LONG lUserID, LPVOID lpOutputBuf, DWORD dwOutputBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadAudio(LONG lUserID, DWORD dwAudioNum, DWORD dwAudioType, char const *sAudioFileName);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadAudio(LONG lUserID, DWORD dwAudioNum, char const *sAudioFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopAudioOperate(LONG lAudioHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetAudioProgress(LONG lAudioHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AudioCtrl(LONG lUserID, DWORD dwAudioNum, DWORD dwCtrlParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpInParamBuffer, DWORD dwInParamBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_LockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_StartManualRecord(LONG lUserID, LPNET_DVR_MANUAL_RECORD_PARA lpManualRecPara);
NET_DVR_API BOOL __stdcall NET_DVR_StopManualRecord(LONG lUserID, LPNET_DVR_STREAM_INFO pIDInfo);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V40(LONG lUserID, NET_DVR_VOD_PARA const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V50(LONG lUserID, NET_DVR_VOD_PARA_V50 const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByTime_V40(LONG lUserID, HWND hWnd, LPNET_DVR_PLAYCOND pPlayCond);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime_V40(LONG lUserID, char *sSavedFileName, LPNET_DVR_PLAYCOND  pDownloadCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V40(LONG lUserID, LPNET_DVR_FILECOND_V40 pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V41(LONG lUserID, LPNET_DVR_SETUPALARM_PARAM lpSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_AddDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindDataBase(LONG lUserID, LPNET_VCA_FIND_DATABASE_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDataBase(LONG lFindHandle, LPNET_VCA_DATABASE_PARAM lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FindDataBaseClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteDataBase(LONG lUserID, LPNET_VCA_DELETE_DATABASE_COND lpCond);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_InquireSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_INQUIRE_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireSnapDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_SNAPRECORD_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_SearchSnapDB(LONG lUserID, LPNET_VCA_SEARCH_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchSnapDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_AddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_FAST_DATARECORD_INFO lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_InquireFaceDBRecord(LONG lUserID, LPNET_VCA_DATARECORD_COND lpInBuf,fSearchDBCallBack cbInquireDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireFaceDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_RECORD_COND lpInBuf);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lSearchHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_SearchFaceDB(LONG lUserID, LPNET_VCA_SEARCH_FACEDB_COND lpInBuf,fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchFaceDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearchDB(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FindMatchPicture(LONG lUserID, LPNET_VCA_FIND_MATCHPIC_COND lpFindCond, LPNET_VCA_FIND_MATCHPIC_RESULT lpFindResult);
NET_DVR_API BOOL __stdcall NET_DVR_RemoteControl(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetBMPByTime(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpTime, char const *sFilename);
NET_DVR_API BOOL __stdcall NET_DVR_CommandDevice(LONG lUserID, DWORD dwOutCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_TestDVRAlive(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_PicViewRequest(LONG lUserID, NET_DVR_PIC_VIEW_PARAM *lpPicViewParam);
typedef LONG (CALLBACK *PicViewCallBack)(LPNET_DVR_PICVIEW_CALLBACKPARAM pStruPicViewParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewResponseCallBack(PicViewCallBack fPicViewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewDataCallBack(LONG lPicViewHandle, SCREENPICDATACB fPicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDevList(LONG lUserID, LPNET_DVR_DEVLIST lpDevListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenList(LONG lUserID, LPNET_DVR_SCREENLIST lpScreenListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetScreenRelation(LONG lUserID, NET_DVR_DISP_SCREEN const* lpScreenInfo);
NET_DVR_API BOOL __stdcall NET_DVR_TextShowCtrl(LONG lUserID, DWORD dwDeviceIndex, LPNET_DVR_TEXTSHOW lpText);
typedef void (CALLBACK *DVCS_UPGRADESTATE_CB)(LONG nUpgradeHandle, BYTE *pBuffer, DWORD dwBufSize, void* pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, DVCS_UPGRADESTATE_CB UpgradeStateCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AddNetSignal(LONG lUserID, LPNET_DVR_NETSIGNAL_INFO lpStruSignal, void* lpOutBuf , DWORD dwBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartPicPreview(LONG lUserID, NET_DVR_START_PIC_VIEW_INFO const* lpStruStartPicView, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceStatus(LONG iUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlanList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_PLAN_LIST lpPlanList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList_V40(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);

NET_DVR_API LONG __stdcall NET_DVR_UploadFile(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char* sFileName);
NET_DVR_API LONG __stdcall NET_DVR_UploadFile_V40(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char const * sFileName, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetUploadResult(LONG lUploadHandle, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_UploadClose(LONG lUploadHandle);

NET_DVR_API LONG __stdcall NET_DVR_StartUploadFile(LONG lUserID, LPNET_DVR_UPLOAD_PARAM  lpStruUploadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopUploadFile (LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadFile(LONG lUserID, LPNET_DVR_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownloadFile (LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadControl(LONG lDownloadHandle, NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM enumDownloadType, void* lpInBuffer, DWORD dwInBufferLen, void* lpOutBuffer, DWORD dwOutBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_UploadSend(LONG lUploadHandle, const NET_DVR_SEND_PARAM_IN *pstruSendParamIN, void* lpOutBuffer);


NET_DVR_API BOOL __stdcall NET_DVR_GetMobileDevStatus(LONG lUserID, DWORD dwStatusType, LPNET_DVR_MB_MOBILEDEV_STATUS lpstruMobileDevStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceDataCallBack(LONG lVoiceComHandle, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize, char *sOutBuffer, DWORD dwOutSize);

NET_DVR_API LONG __stdcall NET_DVR_OpticalUpgrade(LONG lUserID, char const *sFileName, LPNET_DVR_OPTICAL_INFO lpOpticalInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, const void *lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, void* lpOutBuff);

typedef void(CALLBACK *fGPSDataCallback)(LONG nHandle, DWORD dwState, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_GetVehicleGpsInfo(LONG nUserID, LPNET_DVR_GET_GPS_DATA_PARAM lpGPSDataParam, fGPSDataCallback cbGPSDataCallback, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePreview(LONG lUserID, DWORD nSessionID);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePlayBack(LONG lUserID, DWORD nSessionID);

NET_DVR_API LONG __stdcall NET_DVR_StartDownload(LONG lUserID, DWORD dwDownloadType, LPVOID lpInBuffer, DWORD dwInBufferSize, const char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadState(LONG lDownloadHandle, LPDWORD pProgress);
NET_DVR_API int  __stdcall NET_DVR_GetDownloadStateInfo(LONG lDownloadHandle, void* pStatusInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownload(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_V41 lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 lpOuter);    

NET_DVR_API LONG __stdcall NET_DVR_StartT1Test(LONG lUserID, LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API BOOL __stdcall NET_DVR_StopTT1Test(BOOL lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetT1TestStatus(LONG lHandle, LONG *pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SendT1TestData(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwSendBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo_NEW(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer);
NET_DVR_API LONG __stdcall NET_DVR_StartPassiveTransCode(LONG lUserID, NET_DVR_STREAM_INFO const *pStreamInfo, NET_DVR_COMPRESSIONCFG_V30 const *pDstTransInfo, NET_DVR_PASSIVETRANSINFO const *pPassiveTransInfo, void(CALLBACK *fTransCodeDataCallBack) (LONG lPassiveHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_TransCodeInputData(LONG lPassiveHandle, BYTE *pBuffer, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_StopPassiveTransCode(LONG lPassiveHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPassiveTransChanNum(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfigEx(LONG iUserID, DWORD dwCommand, DWORD dwCount, NET_DVR_IN_PARAM *lpInParam, NET_DVR_OUT_PARAM *lpOutParam);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSpanSwitch(LONG lUserID, BYTE nSwitchMode, LPNET_DVR_MATRIXSWITCH lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartSwitch(LONG lUserID, LPNET_DVR_MATRIXSWITCHCTRL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char  *sOutBuffer, DWORD   dwOutSize, DWORD   *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V40(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSTDAbility(LONG lUserID, DWORD dwAbilityType, LPNET_DVR_STD_ABILITY  lpAbilityParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDControl(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONTROL lpControlParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V40(DWORD lUserID, DWORD dwUpgradeType, char const *sFileName, void *pInbuffer, DWORD dwBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V50(DWORD lUserID, LPNET_DVR_UPGRADE_PARAM lpUpgradeParam);

NET_DVR_API BOOL __stdcall NET_DVR_GetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_UNITEDMATRIXINFO lpInter);
typedef LONG(CALLBACK * REGCallBack)(LONG lUserID, LPNET_DVR_REGCALLBACKPARAM pRegCallbackParam, LPNET_DVR_LOGONREPONSEPARAM pInterParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRegisterCallBack(REGCallBack fRegCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewRequest(LONG lUserID, LONG lChannel, LPNET_DVR_PREVIEWPARAM lpPreviewParam, LPNET_DVR_DEVICENATINFO lpOuter);
typedef LONG(CALLBACK * PREVIEWRESPONSECallBack)(LONG lUserID, LONG lStreamHandle, LPNET_DVR_PREVIEWCALLBACKPARAM pPewviewCallbackParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPreviewResponseCallBack(PREVIEWRESPONSECallBack fPreviewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlaybackRequest(LONG lUserID, LPNET_DVR_PLAYBACKREQUESTPARAM lpPlayBackRequestParam);
typedef LONG(CALLBACK * PLAYBACKRESPONSECallBack)(LONG lUserID, LONG lPlaybackHandle, LPNET_DVR_PLAYBACKCALLBACKPARAM lpPlaybackParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlaybackResponseCallBack(PLAYBACKRESPONSECallBack fPlaybackResponseCallBack, void *pUser);
typedef LONG(CALLBACK * VOICERESPONSECallBack)(LONG lUserID, LONG lVoiceHandle, LONG lVoiceChannel, BYTE nAudioType, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceResponseCallBack(VOICERESPONSECallBack fVoiceResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceRequest(LONG lUserID, LPNET_DVR_VOICEREQUESTPARAM lpVoiceParam);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmSetupRequest(LONG lUserID, LPNET_DVR_ALARMSETUPREQUESTPARAM lpAlarmSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);                      
NET_DVR_API BOOL __stdcall NET_DVR_SetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsListInfo(LONG lUserID, LPNET_DVR_TIME_EX lpStartTime, LPNET_DVR_TIME_EX lpStopTime, LPNET_DVR_SMSLISTINFO lpSmsListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SendSms(LONG lUserID, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsContent(LONG lUserID, DWORD dwSmsIndex, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearchPicture(LONG lUserID, NET_DVR_SMART_SEARCH_PIC_PARA * pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSmartPicture(LONG lFindHandle,LPNET_DVR_SMART_SEARCH_PIC_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSmartSearchPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_SetESCallBack(LONG iRealHandle, void (__stdcall *fnESCallback)(LONG lPreviewHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetESRealPlayCallBack(LONG iRealHandle, void(__stdcall *fPlayESCallBack)(LONG lPreviewHandle, NET_DVR_PACKET_INFO_EX *pstruPackInfo, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ActivateDevice(char* sDVRIP, WORD wDVRPort, LPNET_DVR_ACTIVATECFG    lpActivateCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetAddrInfoByServer(DWORD     dwQueryType, void* pInBuf, DWORD dwInBufLen, void* pOutBuf, DWORD dwOutBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_StartGetDevState(LPNET_DVR_CHECK_DEV_STATE pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetDevState();
NET_DVR_API BOOL __stdcall NET_DVR_RigisterPlayBackDrawFun(LONG lPlayHandle, void (__stdcall *fDrawFun)(LONG lPlayHandle, HDC hDc, DWORD dwUser), DWORD dwUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKInitCfg(NET_SDK_INIT_CFG_TYPE enumType, void* const lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseSDKMemPool(LPNET_DVR_SDKMEMPOOL_CFG lpSdkMemPoolCfg);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock(LONG iRealHandle, char const *sPicFileName, DWORD dwTimeOut);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock_New(LONG iRealHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);

NET_DVR_API BOOL __stdcall NET_DVR_ChangeWndResolution(LONG iRealHandle);

NET_DVR_API LONG __stdcall  NET_DVR_SDKChannelToISAPI(LONG lUserID, LONG lInChannel, BOOL bSDKToISAPI);

NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig_Conv(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);

NET_DVR_API BOOL __stdcall NET_DVR_SetDevXmlLen(LONG lUserID, const WORD wDevXmlLen);

NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V50(LONG iUserID, LPNET_DVR_SETUPALARM_PARAM_V50 lpSetupParam, char *pSub, DWORD dwSubSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmSubscribe(LONG lAlarmHandle, char *pData, DWORD dwDataLen);

NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSubscribe(LONG lAlarmHandle, char *pData, DWORD dwDataLen);

NET_DVR_API BOOL __stdcall NET_DVR_GetNPQStat(LONG lHandle, NET_SDK_NPQ_STATE* pStruStat);

NET_DVR_API BOOL __stdcall NET_DVR_SetNPQNotifyParam(LONG lHandle, NET_SDK_NPQ_NOTIFY_PARAM* pNotifyParam);

NET_DVR_API BOOL __stdcall NET_DVR_PlaybackGetNPQStat(LONG lHandle, NET_SDK_NPQ_STATE* pStruStat);
NET_DVR_API BOOL __stdcall NET_DVR_RenderPrivateData(LONG lRealHandle, int iIntelType,BOOL bTrue);
NET_DVR_API BOOL __stdcall NET_DVR_RenderPrivateDataEx(LONG lRealHandle, int iIntelType, int iSubType, BOOL bTrue);

NET_DVR_API BOOL __stdcall NET_DVR_PlaybackSetNPQNotifyParam(LONG lHandle, NET_SDK_NPQ_NOTIFY_PARAM* pNotifyParam);

NET_DVR_API BOOL __stdcall NET_DVR_EnableRelogon(BOOL bEnable, DWORD dwReserved);

NET_DVR_API LONG __stdcall NET_DVR_CreateEzvizUser(LPNET_DVR_EZVIZ_USER_LOGIN_INFO pLoginInfo, LPNET_DVR_DEVICEINFO_V30 pDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteEzvizUser(LONG iUserID);

NET_DVR_API LONG __stdcall NET_DVR_CreateOpenEzvizUser(LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO pLoginInfo, LPNET_DVR_DEVICEINFO_V40 pDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteOpenEzvizUser(LONG iUserID);

NET_DVR_API BOOL __stdcall NET_DVR_LoadAdditionalLib(ADDITIONAL_LIB libType, char const *sDllName);

#endif //

